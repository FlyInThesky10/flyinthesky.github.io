<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Codeforces 1151E (简单图连通块转化)]]></title>
    <url>%2FCodeforces1151E%2F</url>
    <content type="text"><![CDATA[Codeforces 1151E题意：求$$\sum_{i=1}^n\sum_{j=i}^nf(i,j)$$其中$f(i,j)$表示只保留权值在$[i,j]$之间的点形成的连通块数量。 一看连通块，就考虑转化，连通块数量=点数-边数。 然后考虑每个点和每条边对答案的贡献，用点个数减掉边个数即可。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;queue&gt; #include&lt;string&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { int n, a[100000 + 5]; void clean() {} int solve() { clean(); cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i]); LL ans = 0; for (int i = 1; i &lt;= n; ++i) ans += 1ll * a[i] * (n - a[i] + 1); for (int i = 1; i &lt; n; ++i) { ans -= 1ll * min(a[i], a[i + 1]) * (n - max(a[i], a[i + 1]) + 1); } cout &lt;&lt; ans; return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Loj 2478」「九省联考 2018」林克卡特树 (树形DP + 带权二分)]]></title>
    <url>%2Floj2478%2F</url>
    <content type="text"><![CDATA[Loj 2478题意：给定一棵 $n$ 个点的树，边权有正有负，要求在树上选出 $k+1$ 条链，使得其权值之和最大。 考虑DP。设$dp(i,j,0/1/2)$分别为$i$点子树$j$条完整链，当前 $i$ 节点的度数为 $0/1/2$ 的最大价值。度数为 $0$ 时，这个点没有链的连边。度数为 $1$ 时，这个点拖着一条未完成的链，而这条链不计入 $j$ 。度数为 $2$ 时，这个点被一条连接两个不同子树的链穿过，计入$j$。 转移见代码，状态非常经典重要。 考虑带权二分优化DP，即我们发现这个答案是关于$k, ans$的上凸函数，所以我们可以二分斜率切这个上凸函数，然后计算$k,ans$，每个物品都要减去二分的斜率值，然后直到找到极值才输出，注意上凸函数切点越左斜率越大 知识点： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;queue&gt; #include&lt;string&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 300000 + 5; struct data { LL v; int k; data(LL x = 0, LL y = 0) : v(x), k(y) {} data operator + (const data &amp;rhs) const {return data(v + rhs.v, k + rhs.k);} data operator += (const data &amp;rhs) {return *this = data(v + rhs.v, k + rhs.k);} data operator + (const int &amp;rhs) const {return data(v + rhs, k);} data operator += (const int &amp;rhs) {return *this = data(v + rhs, k);} bool operator &lt; (const data &amp;rhs) const {return v == rhs.v ? k &gt; rhs.k : v &lt; rhs.v;} } g; int n, k; data dp[MAXN][3]; vector&lt;int &gt; G[MAXN], c[MAXN]; void dfs(int u, int fa) { dp[u][0] = dp[u][1] = data(); dp[u][2] = g; for (int i = 0; i &lt; (int)G[u].size(); ++i) { int v = G[u][i], ci = c[u][i]; if (v != fa) { dfs(v, u); dp[u][2] = max(dp[u][2], max(dp[u][2] + dp[v][0], dp[u][1] + dp[v][1] + g + ci)); dp[u][1] = max(dp[u][1], max(dp[u][1] + dp[v][0], dp[u][0] + dp[v][1] + ci)); dp[u][0] = max(dp[u][0], dp[u][0] + dp[v][0]); } } dp[u][0] = max(dp[u][0], max(dp[u][1] + g, dp[u][2])); } void clean() { } int solve() { clean(); cin &gt;&gt; n &gt;&gt; k; ++k; for (int x, y, w, i = 1; i &lt; n; ++i) { scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;w); G[x].push_back(y), G[y].push_back(x); c[x].push_back(w), c[y].push_back(w); } LL l = -1e12, r = 1e12; while (l &lt; r) { LL mid = (db)(l + r) / 2.0 - 0.5; g = data(-mid, 1); dfs(1, 0); if (dp[1][0].k == k) { return printf(&quot;%lld\n&quot;, dp[1][0].v + mid * k), 0; } if (dp[1][0].k &lt; k) r = mid; else l = mid + 1; } g = data(-l, 1), dfs(1, 0); printf(&quot;%lld\n&quot;, dp[1][0].v + l * k); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Loj</category>
      </categories>
      <tags>
        <tag>树形DP</tag>
        <tag>Loj</tag>
        <tag>带权二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「agc 038C」 LCMs (数论)]]></title>
    <url>%2Fagc038C%2F</url>
    <content type="text"><![CDATA[agc 038C题意：给定$n$长序列$A_i$，求$$\sum_{i=0}^{N-2} \sum_{j=i+1}^{N-1} \mathrm{lcm}(A_i,A_j)$$看起来很像莫反我们推下式子$$\begin{align}\mathrm{Ans}&amp;=\sum_{i=1}^{N-1} \sum_{j=i+1}^{N} \mathrm{lcm}(A_i,A_j) \\&amp;=\sum_{i=1}^{N-1} \sum_{j=i+1}^{N} \frac{A_iA_j}{\gcd(A_i,A_j)} \\\end{align}$$设$\sum\limits_{d|n} w(d)= \frac 1n$，则有$$\sum_{i=1}^{N-1} \sum_{j=i+1}^{N} A_iA_j \sum_{d|A_i,d|A_j} w(d) \\$$交换一下顺序，得$$\sum_{d=1}^{V} w(d) \sum_{d|A_i,d|A_j,i \leq j,i \not=j} A_iA_j \\$$ $w$很容易算，即$w(n)=\frac 1n - \sum\limits_{d|n, d \not= n} w(d)$，调和级数筛一下即可 考虑后面的怎么计算，因为权值范围$V$比较小，我们只需要统计每个权值出现几次即可。 对每个$d$，我们统计答案，即调和级数筛一下获得$A_i$中是$d$倍数$x$的数的和，然后将和自乘就是不考虑$i \leq j,i \not=j$的答案，考虑这个的话我们就在筛的时候顺便记录$x^2$的和，减去即可，然后除以二，但是要注意有重复数字，重复数字要再多乘一个数字出现次数。 放一个修改后更好理解的标程 #include &lt;bits/stdc++.h&gt; using namespace std; using ll=long long; #define int ll #define rng(i,a,b) for(int i=int(a);i&lt;int(b);i++) #define rep(i,b) rng(i,0,b) #define gnr(i,a,b) for(int i=int(b)-1;i&gt;=int(a);i--) #define per(i,b) gnr(i,0,b) #define pb push_back #define eb emplace_back #define a first #define b second #define bg begin() #define ed end() #define all(x) x.bg,x.ed #ifdef LOCAL #define dmp(x) cerr&lt;&lt;__LINE__&lt;&lt;&quot; &quot;&lt;&lt;#x&lt;&lt;&quot; &quot;&lt;&lt;x&lt;&lt;endl #else #define dmp(x) void(0) #endif template&lt;class t,class u&gt; void chmax(t&amp;a,u b){if(a&lt;b)a=b;} template&lt;class t,class u&gt; void chmin(t&amp;a,u b){if(b&lt;a)a=b;} template&lt;class t&gt; using vc=vector&lt;t&gt;; template&lt;class t&gt; using vvc=vc&lt;vc&lt;t&gt;&gt;; using pi=pair&lt;int,int&gt;; using vi=vc&lt;int&gt;; template&lt;class t,class u&gt; ostream&amp; operator&lt;&lt;(ostream&amp; os,const pair&lt;t,u&gt;&amp; p){ return os&lt;&lt;&quot;{&quot;&lt;&lt;p.a&lt;&lt;&quot;,&quot;&lt;&lt;p.b&lt;&lt;&quot;}&quot;; } template&lt;class t&gt; ostream&amp; operator&lt;&lt;(ostream&amp; os,const vc&lt;t&gt;&amp; v){ os&lt;&lt;&quot;{&quot;; for(auto e:v)os&lt;&lt;e&lt;&lt;&quot;,&quot;; return os&lt;&lt;&quot;}&quot;; } using uint=unsigned; using ull=unsigned long long; const uint mod=998244353; struct mint{ uint v; mint(ll vv=0){s(vv%mod+mod);} mint&amp; s(uint vv){ v=vv&lt;mod?vv:vv-mod; return *this; } mint operator-()const{return mint()-*this;} mint&amp; operator+=(const mint&amp;rhs){return s(v+rhs.v);} mint&amp;operator-=(const mint&amp;rhs){return s(v+mod-rhs.v);} mint&amp;operator*=(const mint&amp;rhs){ v=ull(v)*rhs.v%mod; return *this; } mint&amp;operator/=(const mint&amp;rhs){return *this*=rhs.inv();} mint operator+(const mint&amp;rhs)const{return mint(*this)+=rhs;} mint operator-(const mint&amp;rhs)const{return mint(*this)-=rhs;} mint operator*(const mint&amp;rhs)const{return mint(*this)*=rhs;} mint operator/(const mint&amp;rhs)const{return mint(*this)/=rhs;} mint pow(int n)const{ mint res(1),x(*this); while(n){ if(n&amp;1)res*=x; x*=x; n&gt;&gt;=1; } return res; } mint inv()const{return pow(mod-2);} friend ostream&amp; operator&lt;&lt;(ostream&amp;os,const mint&amp;m){ return os&lt;&lt;m.v; } bool operator&lt;(const mint&amp;r)const{return v&lt;r.v;} bool operator==(const mint&amp;r)const{return v==r.v;} }; const int vmax=(1&lt;&lt;21)+10; mint fact[vmax],finv[vmax],invs[vmax]; void initfact(){ fact[0]=1; rng(i,1,vmax){ fact[i]=fact[i-1]*i; } finv[vmax-1]=fact[vmax-1].inv(); for(int i=vmax-2;i&gt;=0;i--){ finv[i]=finv[i+1]*(i+1); } for(int i=vmax-1;i&gt;=1;i--){ invs[i]=finv[i]*fact[i-1]; } } mint choose(int n,int k){ return fact[n]*finv[n-k]*finv[k]; } mint binom(int a,int b){ return fact[a+b]*finv[a]*finv[b]; } mint catalan(int n){ return binom(n,n)-(n-1&gt;=0?binom(n-1,n+1):0); } signed main(){ cin.tie(0); ios::sync_with_stdio(0); cout&lt;&lt;fixed&lt;&lt;setprecision(20); initfact(); const int v=1000010; vc&lt;mint&gt; w(v); rng(i,1,v){ w[i]+=invs[i]; for(int j=i*2;j&lt;v;j+=i) w[j]-=w[i]; } int n;cin&gt;&gt;n; mint ans=0; vc&lt;mint&gt; s(v); rep(i,n){ int a;cin&gt;&gt;a; s[a]+=a; } rng(i,1,v){ mint x=0,gg=0; for(int j=i;j&lt;v;j+=i)x+=s[j],gg+=s[j].v*j; ans+=(x*x-gg)/2*w[i]; } cout&lt;&lt;ans&lt;&lt;endl; }]]></content>
      <categories>
        <category>Atcoder</category>
      </categories>
      <tags>
        <tag>Atcoder</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 4197」「NOI2015」寿司晚宴 (状压DP + 质因数分解)]]></title>
    <url>%2Fbzoj4197%2F</url>
    <content type="text"><![CDATA[BZOJ 4197题意：给定$n$，求出选择两个不相交集合$A,B$，不存在$d$使得$d|(x\in A), d|(y\in B)$的方案。 我们发现$n=500$以内质数小于$\sqrt n$的只有$8$个，我们考虑状压小质数当做背包容量，然后再用大质数(每个数只有最多一个)来分组做分组背包。 设$dp(S,T)$为选的集合分别是$S,T$的方案 每次大质数相同的一起转移，考虑转移时设$f(S,T,0/1)$表示大质数放$S$还是$T$的方案。 然后分别转移即可，$dp(S,T)=f(S,T,0)+f(S,T,1)-dp(S, T)$ 没有大质数的可以处理完马上转移，具体看代码实现，比较简单 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;queue&gt; #include&lt;string&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { LL MO, dp[260][260], f[2][260][260]; int n; int pri[10] = {2, 3, 5, 7, 11, 13, 17, 19}; struct data {int st, pri;} a[505]; bool cmp(data a, data b) {return a.pri &lt; b.pri;} void clean() { } int solve() { clean(); cin &gt;&gt; n &gt;&gt; MO; for (int i = 1; i &lt; n; ++i) { int tmp = i + 1; for (int j = 2; j * j &lt;= tmp; ++j) { if (tmp % j == 0) { for (int k = 0; k &lt; 8; ++k) if (j == pri[k]) a[i].st |= (1 &lt;&lt; k); while (tmp % j == 0) tmp /= j; } } if (tmp != 1) { if (tmp &gt; 19) a[i].pri = tmp; else { for (int k = 0; k &lt; 8; ++k) if (tmp == pri[k]) a[i].st |= (1 &lt;&lt; k); } } } sort(a + 1, a + n, cmp); dp[0][0] = 1; for (int i = 1; i &lt; n; ++i) { if (i == 1 || a[i].pri != a[i - 1].pri || a[i].pri == 0) memcpy(f[0], dp, sizeof dp), memcpy(f[1], dp, sizeof dp); for (int S1 = 255; ~S1; --S1) { for (int S2 = 255; ~S2; --S2) { if (S1 &amp; S2) continue ; if (!(a[i].st &amp; S2)) (f[0][S1 | a[i].st][S2] += f[0][S1][S2]) %= MO; if (!(a[i].st &amp; S1)) (f[1][S1][S2 | a[i].st] += f[1][S1][S2]) %= MO; } } if (i == n - 1 || a[i].pri != a[i + 1].pri || a[i].pri == 0) { for (int S1 = 255; ~S1; --S1) { for (int S2 = 255; ~S2; --S2) { if (S1 &amp; S2) continue ; dp[S1][S2] = ((f[0][S1][S2] + f[1][S1][S2] - dp[S1][S2]) % MO + MO) % MO; } } } } LL ans = 0; for (int S1 = 0; S1 &lt;= 255; ++S1) { for (int S2 = 0; S2 &lt;= 255; ++S2) { if (S1 &amp; S2) continue ; (ans += dp[S1][S2]) %= MO; } } cout &lt;&lt; ans; return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>状压DP</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 4538」「HNOI2016」网络 (树链剖分 + 线段树 + 堆)]]></title>
    <url>%2Fbzoj4538%2F</url>
    <content type="text"><![CDATA[BZOJ 4538题意：见上。 直接树剖剖成序列问题，然后每次修改取反修改区间即可，维护线段树的每个节点上都开个堆存最大重要值，再开一个堆代表删除节点堆，取顶时两个堆对比一下就行了。 知识点：1、灵活运用树剖模板，线段树上维护堆 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;queue&gt; #include&lt;string&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 200000 + 5; int n, Q, tot, ai[MAXN], bi[MAXN], vi[MAXN]; vector&lt;int &gt; G[MAXN]; int siz[MAXN], dep[MAXN], son[MAXN], top[MAXN], p[MAXN], fa[MAXN], idx; struct node { priority_queue&lt;int &gt; q, qd; int top() { int ret = -1; while (!qd.empty() &amp;&amp; q.top() == qd.top()) q.pop(), qd.pop(); if (!q.empty()) ret = q.top(); return ret; } void push(int x) {q.push(x);} void pushd(int x) {qd.push(x);} } node[MAXN * 4]; struct qj {int l, r;} B[MAXN * 4]; bool cmp(qj a, qj b) {return a.l &lt; b.l;} void dfs_pre(int u, int pa) { son[u] = -1, siz[u] = 1, dep[u] = dep[pa] + 1, fa[u] = pa; for (int i = 0; i &lt; (int)G[u].size(); ++i) { int v = G[u][i]; if (v != pa) { dfs_pre(v, u); son[u] = son[u] == -1 ? v : (siz[v] &gt; siz[son[u]] ? v : son[u]); siz[u] += siz[v]; } } } void dfs_top(int u, int cha) { top[u] = cha; p[u] = ++idx; if (son[u] != -1) dfs_top(son[u], cha); for (int i = 0; i &lt; (int)G[u].size(); ++i) { int v = G[u][i]; if (v != fa[u] &amp;&amp; v != son[u]) dfs_top(v, v); } } #define M ((l + r) &gt;&gt; 1) #define lc (o &lt;&lt; 1) #define rc (o &lt;&lt; 1 | 1) #define ls lc, l, M #define rs rc, M + 1, r void update(int o, int l, int r, int x, int y, int opt, int w) { if (x &lt;= l &amp;&amp; r &lt;= y) { if (opt == 0) node[o].push(w); if (opt == 1) node[o].pushd(w); return ; } if (x &lt;= M) update(ls, x, y, opt, w); if (M &lt; y) update(rs, x, y, opt, w); } int query(int o, int l, int r, int x) { int ret = -1; if (l &lt;= x &amp;&amp; x &lt;= r) ret = node[o].top(); if(l == r) return ret; if (x &lt;= M) ret = max(ret, query(ls, x)); else ret = max(ret, query(rs, x)); return ret; } void change(int u, int v, int opt, int w) { int x = top[u], y = top[v], tot = 0; while (x != y) { if (dep[x] &lt; dep[y]) swap(x, y), swap(u, v); B[++tot] = (qj){p[x], p[u]}; u = fa[x], x = top[u]; } if (dep[u] &lt; dep[v]) swap(u, v); B[++tot] = (qj){p[v], p[u]}; sort(B + 1, B + 1 + tot, cmp); int lst = 0; for (int i = 1; i &lt;= tot; ++i) { if (lst + 1 &lt;= B[i].l - 1) update(1, 1, n, lst + 1, B[i].l - 1, opt, w); lst = B[i].r; } if (lst + 1 &lt;= n) update(1, 1, n, lst + 1, n, opt, w); } void clean() { } int solve() { clean(); cin &gt;&gt; n &gt;&gt; Q; for (int u, v, i = 1; i &lt; n; ++i) { scanf(&quot;%d%d&quot;, &amp;u, &amp;v); G[u].push_back(v), G[v].push_back(u); } dfs_pre(1, 0); dfs_top(1, 1); while (Q--) { ++tot; int ty; scanf(&quot;%d&quot;, &amp;ty); if (ty == 0) { scanf(&quot;%d%d%d&quot;, &amp;ai[tot], &amp;bi[tot], &amp;vi[tot]); change(ai[tot], bi[tot], 0, vi[tot]); } else if (ty == 1) { int t; scanf(&quot;%d&quot;, &amp;t); change(ai[t], bi[t], 1, vi[t]); } else if (ty == 2) { int x; scanf(&quot;%d&quot;, &amp;x); printf(&quot;%d\n&quot;, query(1, 1, n, p[x])); } } return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>堆</tag>
        <tag>Bzoj</tag>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1132」「POI2008」Tro (计算几何, 叉积求三角形面积+极角排序)]]></title>
    <url>%2Fbzoj1132%2F</url>
    <content type="text"><![CDATA[Bzoj 1132题意：平面上有$N$个点. 求出所有以这$N$个点为顶点的三角形的面积和 已知平面3点$A,B,C$, 求三角形面积：$S=|(y_b-y_a)(x_c-x_a)-(y_c-y_a)(x_b-x_a)|$ 我们可以让$A$变为坐标原点，那么$S=|y_bx_c-y_cx_b|$ 那么我们可以把点按$x$坐标排序，然后枚举点$i$, 考虑$i$右边的点对答案贡献 我们发现上式像叉积并且三角形面积有向性，我们可以把右边点极角排序，然后就能确定符号了，那么直接倒序枚举$j \in (i, n]$，用个前缀和处理$k$即可 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;queue&gt; #include&lt;string&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 5000 + 5; struct point { int x, y; point operator - (const point &amp;rhs) const {return (point){x - rhs.x, y - rhs.y};} bool operator &lt; (const point &amp;rhs) const {return x == rhs.x ? y &lt; rhs.y : x &lt; rhs.x;} }a[MAXN], b[MAXN]; bool cmp(point a, point b) {return b.x * a.y &lt; b.y * a.x;} int n; LL ans; void clean() { } int solve() { clean(); cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d%d&quot;, &amp;a[i].x, &amp;a[i].y); sort(a + 1, a + 1 + n); for (int i = 1; i &lt;= n; ++i) { int tot = 0; for (int j = i + 1; j &lt;= n; ++j) b[j] = a[j] - a[i]; sort(b + 1 + i, b + 1 + n, cmp); LL sx = 0, sy = 0; for (int j = n; j &gt; i; --j) { ans += b[j].x * sy - b[j].y * sx; sx += b[j].x, sy += b[j].y; } } printf(&quot;%lld.%lld\n&quot;, ans / 2ll, ans % 2ll * 5ll); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>极角排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 2115」「Wc2011」Xor (线性基 + DFS)]]></title>
    <url>%2Fbzoj2115%2F</url>
    <content type="text"><![CDATA[Bzoj 2115题意：给定一张无向图带边权图，求图上一条$1 \rightarrow n$路径的异或和最大值。 路径不要求简单路径，那么这个路径就是一条链+一些环我们随便找一条$1 \rightarrow n$的链，然后考虑在其中加上环如果环和链有交，那么直接异或环的异或和是对的如果没有交，我们要走过去再走回来，连接路径抵消了，也是对的 为什么我们可以随便选链呢，因为$1 \rightarrow n$的任意两条链一定可以构成环然后就是上面的问题 所以我们随便选个链，再把所有环的异或和丢进线性基 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;queue&gt; #include&lt;string&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 50000 + 5; int vis[MAXN], n, m; LL dis[MAXN], a[105]; vector&lt;int &gt; G[MAXN]; vector&lt;LL &gt; val[MAXN]; void ins(LL t) { if (t) for (LL i = 63; ~i; --i) { if (!((t &gt;&gt; i) &amp; 1ll)) continue ; if (a[i]) t ^= a[i]; else { for (LL j = 0; j &lt; i; ++j) if ((t &gt;&gt; j) &amp; 1ll) t ^= a[j]; for (LL j = i + 1; j &lt;= 63; ++j) if ((a[j] &gt;&gt; i) &amp; 1ll) a[j] ^= t; a[i] = t; break ; } } } void dfs(int u, LL D) { dis[u] = D; vis[u] = 1; for (int i = 0; i &lt; (int)G[u].size(); ++i) { int v = G[u][i]; LL w = val[u][i]; if (dis[v] &gt;= 0) ins(dis[v] ^ w ^ dis[u]); if (!vis[v]) dfs(v, D ^ w); } } void clean() { ms(dis, -1); } int solve() { clean(); cin &gt;&gt; n &gt;&gt; m; LL w; for (int x, y, i = 1; i &lt;= m; ++i) { scanf(&quot;%d%d%lld&quot;, &amp;x, &amp;y, &amp;w); G[x].push_back(y), val[x].push_back(w); G[y].push_back(x), val[y].push_back(w); } dfs(1, 0); LL ans = dis[n]; for (int i = 0; i &lt;= 63; ++i) if ((ans ^ a[i]) &gt; ans) ans ^= a[i]; cout &lt;&lt; ans; return 0; } } int main() { flyinthesky::solve(); return 0; } /* */]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>DFS</tag>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF 1059E / CF 1039D / CF 1042F / NOIP2018 赛道修建]]></title>
    <url>%2FCodeforces1059E%2F</url>
    <content type="text"><![CDATA[Codeforces 1059E题意：现有$n$个点组成一棵以$1$为根的有根树，第$i$个点的点权为$w_i$,需将其分成若干条垂直路径使得每一个点当且仅当被一条垂直路径覆盖，同时，每条垂直路径长度不能超过$L$,点权和不能超过$S$，求最少需要几条垂直路径才能满足要求。特别地，无解输出$-1$。一条垂直路径是一条不在树中弯曲的路径。Codeforces 1039D题意：有一棵$n$个节点的树，其中一个简单路径的集合被称为$k$合法当且仅当：树的每个节点至多属于其中一条路径，且每条路径恰好包含$k$个点对于$k∈[1,n]$，求出k合法路径集合的最多路径数即：设k合法路径集合为$S$，求最大的$|S|$Codeforces 1042F题意：无向无根树$n$个点，要将树叶分成集合，使得每个集合中任意两个叶子距离小于等于$k$，问能最少分成几个集合？NOIP2018 赛道修建题意：一颗树$n$个点，将树分成$m$条路径，使得 $m$ 条赛道中长度最小的赛道长度最大 这4题都是树上贪心的题，基本上都是树上分路径的问题。 CF1059E 直接记录每个点向上最远到哪 (因为垂直路径)，然后就子树DP，记录最长链返回父亲，最后统计条数即可 CF1039D 就直接从下往上能合并就合并，不能合并就传最长链回父亲，这是朴素做法，我们可以发现$k \leq \sqrt{n}$时直接暴力，$k \geq \sqrt{n}$时最多会有$\sqrt{n}$种答案，而且答案单调。二分就行了。 CF1042F 具体看另一博客，主要是记录最长链返回父亲 NOIP2019 就将子树所有最长链存在multiset，然后合并路径，主要是记录最长链返回父亲 所以这类问题就是一般是树上路径划分，一般用记录最长链返回和贪心合并为主。]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 446C (线段树维护斐波那契数列)]]></title>
    <url>%2FCodeforces446C%2F</url>
    <content type="text"><![CDATA[Codeforces 446C题意：给出一个数列，每次可以选取一个区间，按顺序加上第$i$个斐波那契数进行更新，也可以查询某一个区间的总和。 性质一 $\sum_{i=1}^n f_i = f_{n+2} - f_2$ 证明即累加$f_1=f_3-f_2$ 性质二 两个斐波那契数列相加仍然是斐波那契数列，只是前两项不一样，并且可以通过$f$求出这个数列，即$g_i=a \times f_{n-2} + b \times f_{n-1}$ 计算方法通过累加很容易发现。 那么这里就可以线段树维护了，线段树维护每个区间的前两项和区间和，因为性质二所以区间信息可以方便pushdown 顺便提一下pushup：显然区间和信息可合并pushdown：性质二query：性质二update：性质二 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;queue&gt; #include&lt;string&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 300000 + 5; const LL MO = 1e9 + 9; #define lc (o &lt;&lt; 1) #define rc (o &lt;&lt; 1 | 1) #define M ((l + r) &gt;&gt; 1) #define ls lc, l, M #define rs rc, M + 1, r int n, Q, a[MAXN]; LL f[MAXN * 4], sumv[MAXN * 4], f1[MAXN * 4], f2[MAXN * 4]; LL g(LL a, LL b, LL n) { if (n == 1) return a; if (n == 2) return b; return (f[n - 2] * a % MO + f[n - 1] * b % MO) % MO; } LL sum(LL a, LL b, LL n) { if (n == 1) return a; if (n == 2) return a + b; return ((g(a, b, n + 2) - b) % MO + MO) % MO; } void pushup(int o) {(sumv[o] = sumv[lc] + sumv[rc]) %= MO;} void pushdown(int o, int l, int r) { if (f1[o]) { int len = r - l + 1; (f1[lc] += f1[o]) %= MO; (f2[lc] += f2[o]) %= MO; (sumv[lc] += sum(f1[o], f2[o], len - len / 2)) %= MO; (f1[rc] += g(f1[o], f2[o], len - len / 2 + 1)) %= MO; (f2[rc] += g(f1[o], f2[o], len - len / 2 + 2)) %= MO; (sumv[rc] += sum(g(f1[o], f2[o], len - len / 2 + 1), g(f1[o], f2[o], len - len / 2 + 2), len / 2)) %= MO; f1[o] = f2[o] = 0; } } void build(int o, int l, int r) { if (l == r) return sumv[o] = a[l], void(); build(ls), build(rs); pushup(o); } void update(int o, int l, int r, int x, int y) { if (l != r) pushdown(o, l, r); if (x &lt;= l &amp;&amp; r &lt;= y) { (f1[o] += f[l - x + 1]) %= MO, (f2[o] += f[l - x + 2]) %= MO; (sumv[o] += sum(f[l - x + 1], f[l - x + 2], r - l + 1)) %= MO; return ; } if (x &lt;= M) update(ls, x, y); if (M &lt; y) update(rs, x, y); pushup(o); } LL query(int o, int l, int r, int x, int y) { if (l != r) pushdown(o, l, r); if (x &lt;= l &amp;&amp; r &lt;= y) return sumv[o]; LL ret = 0; if (x &lt;= M) (ret += query(ls, x, y)) %= MO; if (M &lt; y) (ret += query(rs, x, y)) %= MO; return ret; } void clean() { } int solve() { cin &gt;&gt; n &gt;&gt; Q; for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i]); f[1] = f[2] = 1; for (int i = 3; i &lt;= n + 2; ++i) (f[i] += f[i - 1] + f[i - 2]) %= MO; build(1, 1, n); while (Q--) { int ty, l, r; scanf(&quot;%d%d%d&quot;, &amp;ty, &amp;l, &amp;r); if (ty == 1) { update(1, 1, n, l, r); } else { printf(&quot;%lld\n&quot;, query(1, 1, n, l, r)); } } return 0; } } int main() { flyinthesky::solve(); return 0; } /* 10 100 0 0 0 0 0 0 0 0 0 0 1 1 10 2 9 9 5 100 0 0 0 0 0 1 1 5 2 5 5 4 400 1 2 3 4 1 1 4 2 1 4 1 2 4 2 1 3 */]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>Codeforces</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 718D (线段树维护矩阵)]]></title>
    <url>%2FCodeforces718C%2F</url>
    <content type="text"><![CDATA[Codeforces 718D题意：给出一个$n$长序列$a_i$，维护以下操作1、1 l r x，将$a_{i \in [l,r]}$加上$x$2、2 l r，求$\sum\limits_{i=l}^r F(a_i)$，$F(a_i)$为斐波那契的第$x$项 斐波那契数列考虑矩阵，那么这里我们可以用线段树维护矩阵 (矩阵满足结合律，则可以轻松合并信息) 区间加一个数相当于矩阵乘多少次转移矩阵，最后答案乘上起始矩阵即可。 线段树维护$lazy$表示当前的标记 (是一个矩阵)，$sum$表示当前区间的和 (矩阵和) #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;queue&gt; #include&lt;string&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 100000 + 5; const LL MO = 1e9 + 7; int n, Q; struct matrix { LL a[2][2]; matrix() {ms(a, 0);} void init() {for (int i = 0; i &lt; 2; ++i) a[i][i] = 1;} } f, tr; matrix mul(matrix a, matrix b) { matrix ret; for (int i = 0; i &lt; 2; ++i) for (int j = 0; j &lt; 2; ++j) for (int k = 0; k &lt; 2; ++k) (ret.a[i][j] += a.a[i][k] * b.a[k][j] % MO) %= MO; return ret; } matrix ksm(matrix a, int b) { matrix ans, bs = a; ans.init(); while (b) { if (b &amp; 1) ans = mul(ans, bs); bs = mul(bs, bs); b &gt;&gt;= 1; } return ans; } matrix add(matrix a, matrix b) { matrix ret; for (int i = 0; i &lt; 2; ++i) for (int j = 0; j &lt; 2; ++j) (ret.a[i][j] += a.a[i][j] + b.a[i][j]) %= MO; return ret; } #define lc (o &lt;&lt; 1) #define rc (o &lt;&lt; 1 | 1) #define M ((l + r) &gt;&gt; 1) #define ls lc, l, M #define rs rc, M + 1, r matrix sum[MAXN * 4], lazy[MAXN * 4]; void pushup(int o) { sum[o] = sum[lc]; sum[o] = add(sum[o], sum[rc]); } void pushdown(int o) { sum[lc] = mul(sum[lc], lazy[o]); sum[rc] = mul(sum[rc], lazy[o]); lazy[lc] = mul(lazy[lc], lazy[o]); lazy[rc] = mul(lazy[rc], lazy[o]); lazy[o] = matrix(), lazy[o].init(); } void build(int o, int l, int r) { lazy[o].init(), sum[o].init(); if (l == r) return ; build(ls), build(rs); pushup(o); } void update(int o, int l, int r, int x, int y, matrix p) { if (!(l == r)) pushdown(o); if (x &lt;= l &amp;&amp; r &lt;= y) { sum[o] = mul(sum[o], p); lazy[o] = mul(lazy[o], p); return ; } if (x &lt;= M) update(ls, x, y, p); if (M &lt; y) update(rs, x, y, p); pushup(o); } matrix query(int o, int l, int r, int x, int y) { if (!(l == r)) pushdown(o); if (x &lt;= l &amp;&amp; r &lt;= y) { return sum[o]; } matrix ret; if (x &lt;= M) ret = add(ret, query(ls, x, y)); if (M &lt; y) ret = add(ret, query(rs, x, y)); return ret; } void clean() { } int solve() { tr.a[0][0] = 0, tr.a[0][1] = 1; tr.a[1][0] = 1, tr.a[1][1] = 1; f.a[0][0] = 0, f.a[0][1] = 1; clean(); cin &gt;&gt; n &gt;&gt; Q; build(1, 1, n); for (int c, i = 1; i &lt;= n; ++i) { scanf(&quot;%d&quot;, &amp;c); update(1, 1, n, i, i, ksm(tr, c - 1)); } while (Q--) { int tp, l, r, c; scanf(&quot;%d%d%d&quot;, &amp;tp, &amp;l, &amp;r); if (tp == 1) { scanf(&quot;%d&quot;, &amp;c); update(1, 1, n, l, r, ksm(tr, c)); } else { printf(&quot;%lld\n&quot;, mul(f, query(1, 1, n, l, r)).a[0][1]); } } return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>Codeforces</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「uoj 192」「UR 14」最强跳蚤 (异或性质，Hash，数论，拆路径)]]></title>
    <url>%2Fuoj192%2F</url>
    <content type="text"><![CDATA[uoj 192题意：给出一个带边权树，求出树上所有路径积为完全平方数的条数。 我们考虑完全平方数的条件，则它的每个质因数出现偶数次那么我们联想到异或，我们可以记录路径异或值，然后问题转化为多少条路径异或和为0这里我们可以对每个质因数指定一个Hash值，然后异或起来就行注意根据生日攻击的原理，权值范围要远大于$n^2$，那么我们$\text{rand}$一个long long 范围的数具体有一个近似的公式$$\sqrt{\frac \pi 2 n}$$那么我们预处理$\sqrt{w}$以内的质数，每次枚举质数分解质因数即可，注意数本身是个大质数的情况然后就可以求多少条路径异或和为0了，这是经典问题，即拆分路径以后做 1、异或–两两消除2、Hash–暴力不行时想想 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;queue&gt; #include&lt;string&gt; #include&lt;ctime&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { int n, en, hd[100000 + 5], vis[10000 + 5], pri[10000 + 5], tot, cnt; LL dis[100000 + 5]; map&lt;int, LL &gt; hsh; struct edge {int v; LL w; int nxt;} ed[200000 + 5]; void ins(int x, int y, LL w) {ed[++en] = (edge){y, w, hd[x]}, hd[x] = en;} void dfs(int u, int fa, LL D) { dis[++cnt] = D; for (int i = hd[u]; i &gt;= 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (e.v != fa) dfs(e.v, u, D ^ e.w); } } void clean() { en = -1, ms(hd, -1); } int solve() { srand((int)time(0)); clean(); for (int i = 2; i &lt;= 10000; ++i) { if (!vis[i]) pri[++tot] = i; for (int j = 1; j &lt;= tot &amp;&amp; pri[j] * i &lt;= 10000; ++j) { vis[pri[j] * i] = 1; if (i % pri[j] == 0) break ; } } scanf(&quot;%d&quot;, &amp;n); for (int x, y, w, i = 1; i &lt; n; ++i) { scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;w); LL hh = 0; for (int j = 1; j &lt;= tot; ++j) { if (w % pri[j] == 0) { if (hsh.find(pri[j]) == hsh.end()) hsh[pri[j]] = (LL)rand() &lt;&lt; 31ll | (LL)rand(); while (w % pri[j] == 0) w /= pri[j], hh ^= hsh[pri[j]]; } } if (w != 1) { if (hsh.find(w) == hsh.end()) hsh[w] = (LL)rand() &lt;&lt; 31ll | (LL)rand(); hh ^= hsh[w]; } ins(x, y, hh), ins(y, x, hh); } dfs(1, 0, 0); sort(dis + 1, dis + 1 + cnt); LL ans = 0; int j; for (int i = 1; i &lt;= cnt; i = j) { j = i + 1; while (j &lt;= cnt &amp;&amp; dis[j] == dis[i]) ++j; ans += 1ll * (j - i) * (j - i - 1ll); } cout &lt;&lt; ans; return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>uoj</category>
      </categories>
      <tags>
        <tag>Hash</tag>
        <tag>Xor</tag>
        <tag>数论</tag>
        <tag>uoj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带权二分 学习笔记]]></title>
    <url>%2Fsz%E5%B8%A6%E6%9D%83%E4%BA%8C%E5%88%86%2F</url>
    <content type="text"><![CDATA[模板及讲解什么时候用带权二分它的作用就是题目给了一个选物品的限制条件，要求刚好选$m$个，让你最大化（最小化）权值，然后其特点就是当选的物品越多的时候权值越大（越小）。 算法分析我们先不考虑物品限制条件，假定我们要最大化权值。然后其中我们二分一个$C$，表示选一次物品的附加权值，如果我们$C$越大，我们选的物品个数越多，权值越大，于是当选的物品个数大于$m$时，减小$C$，否则增大$C$，最后计算答案的时候去掉$C$值的影响即可。 例题：Bzoj 2654 给你一个无向带权连通图，每条边是黑色或白色。让你求一棵最小权的恰好有$K$条白色边的生成树。题目保证有解。 https://loj.ac/article/872二分$x \in [-\text{MaxC}, \text{MaxC}]$, 每条边权加上$x$, 做最小生成树，权值相同优先选，判断选的白边数量与$K$的关系 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;queue&gt; #include&lt;string&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { int n, m, K, f[100000 + 5]; struct edge { int u, v, w, c; bool operator &lt; (const edge &amp;rhs) const {return w == rhs.w ? c &lt; rhs.c : w &lt; rhs.w;} } ed[100000 + 5]; int find(int x) {return x == f[x] ? x : f[x] = find(f[x]);} pair&lt;int, LL &gt; chk(int x) { for (int i = 1; i &lt;= m; ++i) if (ed[i].c == 0) ed[i].w += x; sort(ed + 1, ed + 1 + m); for (int i = 1; i &lt;= n; ++i) f[i] = i; int cnt = 0; LL sum = 0; for (int i = 1; i &lt;= m; ++i) { int a = find(ed[i].u), b = find(ed[i].v); if (a != b) { f[a] = b; if (ed[i].c == 0) ++cnt; sum += ed[i].w; } } for (int i = 1; i &lt;= m; ++i) if (ed[i].c == 0) ed[i].w -= x; return make_pair(cnt, sum); } void clean() { } int solve() { clean(); cin &gt;&gt; n &gt;&gt; m &gt;&gt; K; for (int i = 1; i &lt;= m; ++i) scanf(&quot;%d%d%d%d&quot;, &amp;ed[i].u, &amp;ed[i].v, &amp;ed[i].w, &amp;ed[i].c), ++ed[i].u, ++ed[i].v; int l = -110, r = 110; LL ans = 0; while (l &lt;= r) { int mid = (l + r) &gt;&gt; 1; pair&lt;int, LL &gt; tmp = chk(mid); int d = tmp.first; LL sum = tmp.second; if (d &gt;= K) l = mid + 1, ans = sum - 1ll * K * mid; else r = mid - 1; } printf(&quot;%lld\n&quot;, ans); return 0; } } int main() { flyinthesky::solve(); return 0; } /* 4 5 2 0 1 5 1 0 3 4 1 0 2 5 1 0 1 100 0 1 3 4 0 */]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>带权二分</tag>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 5369」「PKUSC2018」最大前缀和 (状压DP)]]></title>
    <url>%2Fbzoj5369%2F</url>
    <content type="text"><![CDATA[BZOJ 5369题意：给定$n$长序列$a_i$，求任意该序列排列最大前缀和的和。 我们考虑状压。 最大前缀和性质即我们可以找到一个位置 $p$ ，使得在这之前的 $ i $ 都满足 $\text{sum} (i) \leq \text{sum} (p)$，在这之后的 $i$ 都满足 $\text{sum} (i) \geq \text{sum} (p)$ 考虑集合 $S$ 的数组成最大前缀和的方案数，那么计算就是一个求贡献那么设 $g(S)$ 为 $S$ 集合组成序列最大前缀和是 $\text{sum}(S)$ 的方案数$f(S)$ 为 $S$ 集合组成序列的任意最大前缀和都小于 $0$ 的方案数。则$g(S + i)=\sum g(S), f(S)=\sum f(S-i)$那么最后答案就是$\sum f(S)g(C_US)\text{sum}(S)$ #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;queue&gt; #include&lt;string&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL MO = 998244353; LL n, maxd, a[25], sum[(1 &lt;&lt; 21) + 5], f[(1 &lt;&lt; 21) + 5], g[(1 &lt;&lt; 21) + 5]; void clean() { } int solve() { clean(); cin &gt;&gt; n; maxd = (1 &lt;&lt; n) - 1; for (LL i = 1; i &lt;= n; ++i) scanf(&quot;%lld&quot;, &amp;a[i]), g[(1 &lt;&lt; (i - 1))] = 1; for (LL S = 0; S &lt;= maxd; ++S) { for (LL i = 1; i &lt;= n; ++i) if (S &amp; (1 &lt;&lt; (i - 1))) sum[S] = sum[S ^ (1 &lt;&lt; (i - 1))] + a[i]; } f[0] = 1; for (LL S = 0; S &lt;= maxd; ++S) { if (sum[S] &gt;= 0) { for (LL i = 1; i &lt;= n; ++i) { if (!(S &amp; (1 &lt;&lt; (i - 1)))) (g[S | (1 &lt;&lt; (i - 1))] += g[S]) %= MO; } } else { for (LL i = 1; i &lt;= n; ++i) { if (S &amp; (1 &lt;&lt; (i - 1))) (f[S] += f[S ^ (1 &lt;&lt; (i - 1))]) %= MO; } } } LL ans = 0; for (LL S = 0; S &lt;= maxd; ++S) (ans += (sum[S] + MO) * g[S] % MO * f[(~S) &amp; maxd] % MO) %= MO; cout &lt;&lt; ans; return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1097D (期望DP + 积性函数 + 质因子独立)]]></title>
    <url>%2FCodeforces1097D%2F</url>
    <content type="text"><![CDATA[Codeforces 1097D题意：给定 $n,k$，一共会进行 $k$ 次操作，每次操作会把 $n$ 等概率的变成 $n$ 的某个约数求操作 $k$ 次后 $n$ 的期望是多少 考虑到质因子的概率是独立的，那么我们只需要解出$n=p^k$的期望即可。考虑设$dp(i, j)$为$p^i$操作$j$次的期望，那么$$dp(i,j)=\sum_{k=0}^i\frac{1}{i+1} dp(k,j-1)$$然后分解质因数乘起来即可。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;queue&gt; #include&lt;string&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL MO = 1e9 + 7; LL n, k, ans = 1, dp[60][10000 + 5]; LL ksm(LL a, LL b) { LL ans = 1, bs = a % MO; while (b) { if (b &amp; 1) ans = ans * bs % MO; bs = bs * bs % MO; b &gt;&gt;= 1; } return ans; } LL dfs(LL &amp;a, LL i, LL j) { if (i == 0) return dp[i][j] = 1; if (j == 0) return dp[i][j] = ksm(a, i); if (dp[i][j] &gt;= 0) return dp[i][j]; LL ret = 0; for (LL k = 0; k &lt;= i; ++k) (ret += dfs(a, k, j - 1)) %= MO; return dp[i][j] = ret * ksm(i + 1, MO - 2) % MO; } void clean() { } int solve() { clean(); cin &gt;&gt; n &gt;&gt; k; for (LL i = 2; i * i &lt;= n; ++i) { if (n % i == 0) { LL cnt = 0; while (n % i == 0) n /= i, ++cnt; ms(dp, -1); ans = ans * dfs(i, cnt, k) % MO; } } ms(dp, -1); if (n != 1) ans = ans * dfs(n, 1, k) % MO; cout &lt;&lt; ans; return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>概率DP</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1191F (树状数组 / 线段树 + 扫描线)]]></title>
    <url>%2FCodeforces1191F%2F</url>
    <content type="text"><![CDATA[Codeforces 1191F题意：给定平面上$n$个点，每次可以用$x\in [l,r],y \in [a,+\infty)$作为限制条件来得到一个点集。求能得到多少种不同的点集。 很显然要扫描线。 发现$y \in [a,+\infty)$，那么从上往下即可。 考虑从上往下，从左到右加点，然后统计新加的点的答案。 可能一开始会想到一个找这个点的左上角的所有点乘上右上角所有点，但是有重复。 考虑缩小右上角点的范围，那么我们只需要统计矩形$([x_i,x_{i+1}], y_i), y_i=y_{i+1}$的点的个数作为右上角点的范围即可。 注意这里每列的赋值只能最多一，那么我们能想到用线段树维护，但是这里由于只是单点修改，我们完全可以开一个树状数组和一个vis数组来判断某个地方加了1没有即可完成。 坐标数据大离散化即可。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;queue&gt; #include&lt;string&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { struct data { int ox, oy; int x, y; } pos[200000 + 5]; int n, tax[400000 + 5], tot = 0; LL sumv[400000 * 4 + 5]; #define lc (o &lt;&lt; 1) #define rc (o &lt;&lt; 1 | 1) #define M ((l + r) &gt;&gt; 1) bool cmp(data a, data b) {return a.y == b.y ? a.x &lt; b.x : a.y &gt; b.y;} void pushup(int o) {sumv[o] = sumv[lc] + sumv[rc];} void add(int o, int l, int r, int p) { if (l == r) {sumv[o] = 1; return ;} if (p &lt;= M) add(lc, l, M, p); else if (p &gt; M) add(rc, M + 1, r, p); pushup(o); } LL query(int o, int l, int r, int x, int y) { if (x &lt;= l &amp;&amp; r &lt;= y) { return sumv[o]; } LL ret = 0; if (x &lt;= M) ret += query(lc, l, M, x, y); if (M &lt; y) ret += query(rc, M + 1, r, x, y); return ret; } void clean() { } int solve() { clean(); cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) { scanf(&quot;%d%d&quot;, &amp;pos[i].ox, &amp;pos[i].oy); tax[++tot] = pos[i].ox; tax[++tot] = pos[i].oy; } sort(tax + 1, tax + 1 + tot); tot = unique(tax + 1, tax + 1 + tot) - tax - 1; for (int i = 1; i &lt;= n; ++i) { pos[i].x = lower_bound(tax + 1, tax + 1 + tot, pos[i].ox) - tax; pos[i].y = lower_bound(tax + 1, tax + 1 + tot, pos[i].oy) - tax; } sort(pos + 1, pos + 1 + n, cmp); LL ans = 0, lst = 1; while (lst &lt;= n) { LL now = lst + 1; while (now &lt;= n &amp;&amp; pos[now].y == pos[now - 1].y) ++now; now--; for (LL i = lst; i &lt;= now; ++i) add(1, 1, tot, pos[i].x); for (LL i = lst; i &lt;= now; ++i) { LL l = query(1, 1, tot, 1, pos[i].x); LL gg = pos[i + 1].x - 1; if (i == now) gg = tot; LL r = query(1, 1, tot, pos[i].x, gg); ans += l * r; } lst = now + 1; } cout &lt;&lt; ans; return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>树状数组</tag>
        <tag>Codeforces</tag>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「poj 2311」Cutting Game (博弈论，SG函数)]]></title>
    <url>%2Fpoj2311%2F</url>
    <content type="text"><![CDATA[poj 2311题意：有一张$n \times m$的格子，两个玩家轮流每次可以剪下一行/一列，第一个剪下$1\times 1$的玩家获胜。两个玩家都采用最优决策，求先手是否必胜。 考虑将一张格子定义为一个有向图游戏，最终游戏的$\text{SG}$值即为所有有向图游戏的异或和考虑这个$1\times 1$获胜不符合我们有向图游戏的定义，我们做一些转化。考虑到我们剪下$1 \times x, x \times 1$会使得当前的玩家必败。那么我们可以将局面$(2,3), (3,2), (2,2)$设为必败局面，然后$$\text{SG}(x,y)=\text{mex}(\text{SG}(x - i,y) ⊕ \text{SG}(i,y) \cup \text{SG}(x ,y- i) ⊕ \text{SG}(x,i))$$ 注意多组询问完全可以将之前的$\text{SG}$函数值保留。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;queue&gt; #include&lt;string&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { int w, h, sg[205][205]; int dfs(int x, int y) { if (sg[x][y] &gt;= 0) return sg[x][y]; int mex[205]; ms(mex, 0); for (int i = 2; i &lt;= x - 2; ++i) mex[dfs(i, y) ^ dfs(x - i, y)] = 1; for (int i = 2; i &lt;= y - 2; ++i) mex[dfs(x, i) ^ dfs(x, y - i)] = 1; for (int i = 0; ; ++i) if (!mex[i]) return sg[x][y] = i; } void clean() { } int solve() { clean(); if (dfs(w, h) == 0) puts(&quot;LOSE&quot;); else puts(&quot;WIN&quot;); return 0; } } using flyinthesky::sg; using flyinthesky::w; using flyinthesky::h; int main() { ms(sg, -1); sg[2][2] = 0, sg[2][3] = 0, sg[3][2] = 0; while (scanf(&quot;%d%d&quot;, &amp;w, &amp;h) == 2) flyinthesky::solve(); return 0; } /* */]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1563」「NOI2009」诗人小G (DP + 决策单调性 + 四边形不等式)]]></title>
    <url>%2Fbzoj1563%2F</url>
    <content type="text"><![CDATA[BZOJ 1563题意：有一个长度为 $n$ 的序列 $A$ 和常数 $L,P$ ，你需要将它分成若干段，每一段的代价为 $|\sum A_i−L|^P$ ，求最小代价的划分方案。 易得暴力DP$$dp(i) = \min_{j = 0} ^ {i - 1} (|\text{sum}(i) - \text{sum}(j) - L|^P + dp(j))$$ 发现这个$dp$满足决策单调性，即如果我们把每个位置$i$由哪个位置转移而来记为$g(i)$，则$g(i)$为单调不减的 这个可以数学证明也可以打表验证 然后我们就可以通过一个队列来完成优化，即我们队列存的是三元组$(l,r,j)$表示$[l,r]$区间的$dp$值的最优决策为$j$ 那么我们每次在队头删掉$r$小于当前枚举的$i$的三元组然后就就可以取队头元素来计数$dp(i)$然后我们在队尾处理，如果当前有决策$i$, 队尾三元组$(l_t,r_t,j_t)$，则如果$\text{val}(i, l_t) \leq \text{val}(l_j, l_t)$，那么删掉队尾三元组然后我们尝试插入当前的$i$，我们在当前$[l_t,r_t]$中二分一个位置$pos$，使得$j_t$是$[l_t,pos-1]$的最优决策，$i$是$[pos, r_t]$的最优决策 最后注意开 long double 来判断是否大于$10^{18}$ 知识点打表验证决策单调性 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;queue&gt; #include&lt;string&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long double #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { struct node {int l, r, j;} q[100000 + 5]; int n, L, P, fr[100000 + 5], l, r, stk[100000 + 5], top; LL dp[100000 + 5], sum[100000 + 5]; char s[100000 + 5][35]; LL calc(int j, int i) { LL gg = sum[i] - sum[j] - L + i - j - 1, ret = 1; if (gg &lt; 0) gg = -gg; for (int i = 1; i &lt;= P; ++i) ret *= gg; return dp[j] + ret; } int find(node a, int y) { int l = a.l, r = a.r; while (l &lt;= r) { int mid = (l + r) &gt;&gt; 1; if (calc(a.j, mid) &lt; calc(y, mid)) l = mid + 1; else r = mid - 1; } return l; } void clean() { } int solve() { clean(); cin &gt;&gt; n &gt;&gt; L &gt;&gt; P; for (int i = 1; i &lt;= n; ++i) scanf(&quot;%s&quot;, s[i]), sum[i] = sum[i - 1] + strlen(s[i]); q[l = r = 1] = (node){1, n, 0}; for (int i = 1; i &lt;= n; ++i) { while (l &lt; r &amp;&amp; q[l].r &lt; i) ++l; dp[i] = calc(q[l].j, i), fr[i] = q[l].j; while (l &lt;= r &amp;&amp; calc(i, q[r].l) &lt;= calc(q[r].j, q[r].l)) --r; if (l &gt; r) q[++r] = (node){i, n, i}; else if (calc(i, n) &lt;= calc(q[r].j, n)) { // 二分找得到这样的 pos 吗? int pos = find(q[r], i); q[r].r = pos - 1, q[++r] = (node){pos, n, i}; } } if (dp[n] &gt; 1e18) puts(&quot;Too hard to arrange&quot;); else { printf(&quot;%lld\n&quot;, (long long)dp[n]); int now = n; top = 0; while (now) stk[++top] = now, now = fr[now]; for (int lst = 0, i = top; i; --i) { for (int j = lst + 1; j &lt;= stk[i]; ++j) printf(&quot;%s%c&quot;, s[j], j == stk[i] ? &#39;\n&#39; : &#39; &#39;); lst = stk[i]; } } puts(&quot;--------------------&quot;); return 0; } } int main() { int T; cin &gt;&gt; T; while (T--) flyinthesky::solve(); return 0; } /* */]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>Bzoj</tag>
        <tag>决策单调性</tag>
        <tag>四边形不等式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博弈论 学习笔记]]></title>
    <url>%2Fsz%E5%8D%9A%E5%BC%88%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[讲解基本概念局面：游戏过程中面临的状态先手：整局游戏第一个行动的后手：整局游戏第二个行动的必败局面：在某一局面下无论采取什么行动都会输必胜局面：在某一局面存在某行动能够使对手面临必败局面 公平组合游戏 ICG1、两名玩家交替行动2、可执行的合法行动与轮到谁无关3、不能行动判负 $\text{SG}$ 函数$\text{Mex}$运算设$S$表示一个非负整数集合，则$$\text{Mex}(S)=\min_{x \in \mathbb{N}, x \notin S} (x)$$ $\text{SG}$ 函数$$\text{SG}(x)=\operatorname{Mex}\limits_{i=1}^k(\text{SG}(y_i))$$ 一个有向图$$\text{SG}(G)=\text{SG}(s)$$ $$\text{SG}(G)=\text{SG}(G_1) \text{xor} \text{SG}(G_2) \text{xor} … \text{xor} \text{SG}(G_m)$$ 局面必胜：$SG &gt; 0$局面必败：$SG=0$]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 4870」「六省联考2017」组合数问题 (组合数+矩阵快速幂)]]></title>
    <url>%2Fbzoj4870%2F</url>
    <content type="text"><![CDATA[BZOJ 4870题意：给定$n,p,k,r$，求$$\sum_{i=0}^{∞} C_{nk}^{ik+r}$$ 注意到$ik+r \mod k=r$，则我们考虑组合数的组合意义 从$nk$个物品中选 $\mod k=r$ 的个数的物品的方案数 那么设$dp(i,j)$为前 $i$ 个物品选择 $\mod k$ 为 $j$ 的方案数.转移即$$dp(i,j)=dp(i-1,j)+dp(i-1,(j-1+k)\mod k)$$ 矩阵快速幂优化即可。]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>Bzoj</tag>
        <tag>组合数学</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 4818」「SDOI2017」序列计数 (DP + 矩阵快速幂优化)]]></title>
    <url>%2Fbzoj4818%2F</url>
    <content type="text"><![CDATA[BZOJ 4818题意：求$n$长序列值域$[1,m]$，求序列和是$p$倍数并且序列至少有一个质数的序列个数。 转化题意，则$\text{ans}=$满足和为$p$的倍数的方案数$−$满足和为$p$的倍数且不含质数的方案数 那么我们先考虑满足和为$p$的倍数的方案数怎么算，显然我们可以设$dp(i,j)$为前$i$个和模$p=j$的方案，然后可以这样转移 $$dp(i,j)=\sum_{k=1}^m dp(i-1,(j-k) \mod p)$$ 考虑优化，我们想办法让它与$m$复杂度无关，我们发现$i$位填$u$和填$u+pv$效果是一样的，所以我们直接记$cnt_i$表示$1∼m$中$\mod p$为$i$的个数，那么转移为 $$dp(i,j)=\sum_{k=0}^{p-1} dp(i-1,(j-k) \mod p) \times cnt_k$$ 那么现在复杂度为$O(np^2)$ 发现$n$很大，考虑矩阵优化到$O(\log n \times p^3)$ 矩阵构造就循环一下构造就行，然后就是常规的优化方法 注意vis数组要开成bool #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;queue&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL MO = 20170408; LL n, m, p; LL tot, pri[1400000 + 2]; bool vis[20000000 + 2]; LL gg1[100 + 2], gg2[100 + 2]; struct matrix { LL a[100 + 2][100 + 2]; matrix() {for (int i = 0; i &lt;= 100; ++i) for (int j = 0; j &lt;= 100; ++j) a[i][j] = 0;} void init() {for (int i = 0; i &lt;= 100; ++i) a[i][i] = 1;} void clean() {for (int i = 0; i &lt;= 100; ++i) for (int j = 0; j &lt;= 100; ++j) a[i][j] = 0;} }f, ma1, ma2, orz1, orz2; void mul(matrix &amp;a, matrix &amp;b, matrix &amp;ret) { ret.clean(); for (LL i = 0; i &lt;= p; ++i) { for (LL j = 0; j &lt;= p; ++j) { for (LL k = 0; k &lt;= p; ++k) { (ret.a[i][j] += a.a[i][k] * b.a[k][j] % MO) %= MO; } } } } matrix ksm(matrix &amp;a, LL b) { matrix ans, bs = a, tmp; ans.init(); int fl = 0; while (b) { if (b &amp; 1) { if (!fl) fl = 1, ans = bs; else mul(ans, bs, tmp), ans = tmp; } mul(bs, bs, tmp), bs = tmp; b &gt;&gt;= 1; } return ans; } void clean() { } int solve() { clean(); cin &gt;&gt; n &gt;&gt; m &gt;&gt; p; vis[1] = 1; for (int i = 2; i &lt;= m; ++i) { if (!vis[i]) pri[++tot] = i; for (int j = 1; j &lt;= tot &amp;&amp; pri[j] * i &lt;= m; ++j) { vis[pri[j] * i] = 1; if (i % pri[j] == 0) { break ; } } } gg1[0] = m / p; for (int i = 1; i &lt; p; ++i) gg1[i] = m / p + (m % p &gt;= i); for (int i = 1; i &lt;= m; ++i) if (vis[i]) gg2[i % p]++; f.a[0][0] = 1; for (int i = 0; i &lt; p; ++i) { for (int j = 0; j &lt; p; ++j) { ma1.a[j][i] = gg1[((p + i - j) % p + p) % p]; ma2.a[j][i] = gg2[((p + i - j) % p + p) % p]; } } ma1 = ksm(ma1, n); ma2 = ksm(ma2, n); mul(f, ma1, orz1), mul(f, ma2, orz2); cout &lt;&lt; ((orz1.a[0][0] - orz2.a[0][0]) % MO + MO) % MO; return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>Bzoj</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客Wannafly挑战赛19 C多彩的树 (状压 + DFS + 容斥)]]></title>
    <url>%2F%E7%89%9B%E5%AE%A2Wannafly%E6%8C%91%E6%88%98%E8%B5%9B19-C%2F</url>
    <content type="text"><![CDATA[牛客Wannafly挑战赛19 C多彩的树题意：有一棵树包含 $N$ 个节点。节点总共有 $K$ 种颜色。第 $i$ 个节点的颜色为 $A_i$。求恰好包含 $i$ 种颜色的路径数量 $F_i$。 这个恰好我们可以用容斥来做。考虑一条条路径不方便处理，我们考虑路径就是两个块之间的任意连线。那么我们发现颜色数小，可以状压，我们每次枚举一个集合表示当前许可进入的颜色，然后在树中DFS，DFS到的一个块里面的路径都是符合当前许可进入的颜色的，然后我们只需要进行容斥就可以计算出在某个连通块中出现恰好包含 $i$ 种颜色的路径数量。]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>状压DP</tag>
        <tag>组合数学</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客国庆集训派对Day2 E数据排序 (状压DP + lowbit/最高位转移)]]></title>
    <url>%2F%E7%89%9B%E5%AE%A2%E5%9B%BD%E5%BA%86%E9%9B%86%E8%AE%AD%E6%B4%BE%E5%AF%B9Day2-E%2F</url>
    <content type="text"><![CDATA[牛客国庆集训派对Day2 E数据排序题意：见上。 这种题一般都是按从小到大赋值$c$。我们可以设$dp(S)$为前面已经赋值的最小值。 然后我们就可以枚举剩下元素的子集来加入，这个子集所有元素都是一个值，且大于之前所有的值。 那么我们可以预处理出来前面一个求和，后面的求和也可以预处理。 前面的求和先预处理出一个点对一个集合的，再在DP过程中从小到大去转移集合对集合的。用最高位转移。这样可以免去枚举一个$n$，具体可以看代码中的$p$ 知识点：1、状态设计方法2、lowbit/最高位转移 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;queue&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL MAXN = 15 + 1; LL n, g[MAXN][MAXN], high[(1 &lt;&lt; 15) + 1]; LL val[MAXN][(1 &lt;&lt; 15) + 1], gg[(1 &lt;&lt; 15) + 1], p[(1 &lt;&lt; 15) + 1]; LL dp[(1 &lt;&lt; 15) + 1], st[(1 &lt;&lt; 15) + 1], top; LL abss(LL x) {return x &gt; 0 ? x : -x;} void clean() { } int solve() { clean(); cin &gt;&gt; n; for (LL x, y, i = 1; i &lt;= 2ll * n * (n - 1); ++i) scanf(&quot;%lld%lld&quot;, &amp;x, &amp;y), ++g[x][y]; for (LL S = 0; S &lt; (1 &lt;&lt; n); ++S) { for (LL i = 1; i &lt;= n; ++i) if (S &amp; (1 &lt;&lt; (i - 1))) { for (LL j = i + 1; j &lt;= n; ++j) if ((S &amp; (1 &lt;&lt; (j - 1)))) { gg[S] += abss(g[i][j] - g[j][i]); } } } for (LL i = 1; i &lt;= n; ++i) { for (LL S = 0; S &lt; (1 &lt;&lt; n); ++S) if (!(S &amp; (1 &lt;&lt; (i - 1)))) { for (LL j = 1; j &lt;= n; ++j) if (S &amp; (1 &lt;&lt; (j - 1))) val[i][S] += g[j][i]; // i &gt; j } } for (LL S = 1; S &lt; (1 &lt;&lt; n); ++S) for (LL i = 1; i &lt;= n; ++i) if (S &amp; (1 &lt;&lt; (i - 1))) high[S] = i; ms(dp, 0x3f); dp[0] = 0; for (LL i = 1; i &lt;= n; ++i) dp[1 &lt;&lt; (i - 1)] = 0; for (LL S = 0; S &lt; (1 &lt;&lt; n); ++S) { LL C = ((1 &lt;&lt; n) - 1) &amp; (~S); top = 0; for (LL T = C; T; T = (T - 1) &amp; C) st[++top] = T; while (top) { LL T = st[top--]; p[T] = p[T ^ (1 &lt;&lt; (high[T] - 1))] + val[high[T]][S]; dp[S ^ T] = min(dp[S ^ T], dp[S] + gg[T] + p[T]); } } printf(&quot;%lld\n&quot;, dp[(1 &lt;&lt; n) - 1]); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客练习赛27-F 计数 (状压DP + 矩阵快速幂)]]></title>
    <url>%2F%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B27-F%2F</url>
    <content type="text"><![CDATA[牛客练习赛27-F题意：见上。$m$小考虑状压，$n$大考虑矩阵优化$dp(i,j)$为合法$i$转移到合法$j$状态的方案数，其中状态是当前位置为$i$, 区间$[i-m+1,i]$填$3, 7$情况，判断一下就可以构造转移矩阵，然后发现转移可以看做Floyd的联通矩阵，题面就要求某个点开始的环的个数。那么矩阵快速幂一下，再加上对角线的值即可(加上每个点出发环的个数) 另外可以用常规DP方法做，快速幂次数就进行$n-m$次，之后将末尾和前面check一下即可 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;queue&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL MO = 998244353; LL n, m, p; struct mat { LL a[32][32]; mat() {ms(a, 0);} } f, tr; mat mul(mat a, mat b) { mat ret; for (LL i = 0; i &lt;= p; ++i) { for (LL j = 0; j &lt;= p; ++j) { for (LL k = 0; k &lt;= p; ++k) { (ret.a[i][j] += a.a[i][k] * b.a[k][j] % MO) %= MO; } } } return ret; } mat ksm(mat a, LL b) { int fl = 0; mat bs = a, ans; while (b) { if (b &amp; 1) { if (!fl) fl = 1, ans = bs; else ans = mul(ans, bs); } bs = mul(bs, bs); b &gt;&gt;= 1; } return ans; } LL get(LL x) {LL ret = 0; while (x) ++ret, x &amp;= (x - 1); return ret;} void clean() { } int solve() { clean(); cin &gt;&gt; n &gt;&gt; m; p = (1 &lt;&lt; m) - 1; for (LL S = 0; S &lt;= p; ++S) if (get(S) &lt;= m / 2) { tr.a[S][((S &lt;&lt; 1) &amp; p)] = 1; if (get(((S &lt;&lt; 1) &amp; p) | 1) &lt;= m / 2) tr.a[S][((S &lt;&lt; 1) &amp; p) | 1] = 1; } tr = ksm(tr, n); LL ans = 0; for (LL S = 0; S &lt;= p; ++S) (ans += tr.a[S][S]) %= MO; cout &lt;&lt; ans; return 0; } } int main() { flyinthesky::solve(); return 0; } /* 2 2 3 3 4 3 */]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>状压DP</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 3294」「CQOI2011」放棋子 (组合计数DP)]]></title>
    <url>%2Fbzoj3294%2F</url>
    <content type="text"><![CDATA[BZOJ 3294题意：在一个$n$行$m$列的棋盘里放$c$种不同色的棋子（每种有$c_i$个），使得每个格子最多放一个棋子，且不同颜色的棋子不能在同一行或者同一列。有多少种方法？ 本题发现其实列或者行交换不影响答案，那么我们可以设个$dp(i,j,k)$为前$k$个颜色占据了$i$行$j$列的方案。那么可以转移$$dp(i,j,k)=\sum_{x=1}^i \sum_{y=1}^j dp(x,y,k-1) \times C^{i-x}_{n-x} \times C^{j-y}_{m-y} \times g(i-x,j-y,a_k)$$其中$a_k$为第$k$种颜色有几个棋子，$g(i,j,k)$为$k$个相同棋子占据了$i$行$j$列的方案。考虑如何计算$g$，我们只用将不符合条件(即不占据$i$行$j$列时已经用完棋子)的情况减去即可，容易得总情况数目为$C_{ij}^n$那么转移$$g(i,j,k)=C^{k}_{ij} - \sum_{x=1}^i \sum_{y=1}^j g(x,y,k) \times C^x_i \times C^y_j$$那么就可以递推求解了。 知识点：1、容斥2、dp的辅助dp数组 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;queue&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL MO = 1000000009; LL n, m, c, jc[50000 + 5], jc_inv[50000 + 5]; LL g[35][35], dp[35][35][15]; LL ksm(LL a, LL b) { LL bs = a, ans = 1; while (b) { if (b &amp; 1) ans = ans * bs % MO; bs = bs * bs % MO; b &gt;&gt;= 1; } return ans; } LL C(LL n, LL m) { if (n &lt; m) return 0; return jc[n] * jc_inv[m] % MO * jc_inv[n - m] % MO; } void clean() { ms(dp, 0); } int solve() { clean(); jc[0] = 1; for (LL i = 1; i &lt;= 50000; ++i) jc[i] = jc[i - 1] * i % MO; for (LL i = 0; i &lt;= 50000; ++i) jc_inv[i] = ksm(jc[i], MO - 2); cin &gt;&gt; n &gt;&gt; m &gt;&gt; c; dp[0][0][0] = 1; for (LL ak, o = 1; o &lt;= c; ++o) { scanf(&quot;%lld&quot;, &amp;ak); ms(g, 0); for (LL i = 1; i &lt;= n; ++i) { for (LL j = 1; j &lt;= m; ++j) { g[i][j] = C(i * j, ak); for (LL x = 0; x &lt;= i; ++x) { for (LL y = 0; y &lt;= j; ++y) { if (x == i &amp;&amp; y == j) continue ; LL tmp = g[x][y] * C(i, x) % MO * C(j, y) % MO; g[i][j] = ((g[i][j] - tmp) % MO + MO) % MO; } } } } for (LL i = 1; i &lt;= n; ++i) { for (LL j = 1; j &lt;= m; ++j) { for (LL x = 0; x &lt;= i; ++x) { for (LL y = 0; y &lt;= j; ++y) { if (x == i &amp;&amp; y == j) continue ; LL tmp = dp[x][y][o - 1] * C(n - x, i - x) % MO * C(m - y, j - y) % MO * g[i - x][j - y] % MO; (dp[i][j][o] += tmp) %= MO; } } } } } /*for (LL i = 1; i &lt;= n; ++i) for (LL j = 1; j &lt;= m; ++j) for (LL k = 1; k &lt;= c; ++k) printf(&quot;i=%lld, j=%lld, k=%lld, dp=%lld\n&quot;, i, j, k, dp[i][j][k]);*/ LL ans = 0; for (LL i = 1; i &lt;= n; ++i) for (LL j = 1; j &lt;= m; ++j) (ans += dp[i][j][c]) %= MO; cout &lt;&lt; ans; return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>计数DP</tag>
        <tag>Bzoj</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 5314」「Jsoi2018」潜入行动 (树形DP)]]></title>
    <url>%2Fbzoj5314%2F</url>
    <content type="text"><![CDATA[BZOJ 5314题意：见上。 设$dp(u,j,0/1,0/1)$为$u$子树放了$j$个，$u$放不放，$u$有没有信号的方案。 然后按照树形背包DP的方法转移即可，注意要用$dp[u][i+j][][] \Leftarrow dp[u][i][][], dp[v][j][][]$来保证复杂度。 这种树形背包dp就是形如$dp[x][j+k]=\sum dp[x][j] \times dp[y][k]$的 这里有对这样的树形背包dp复杂度为$O(nk)$的证明。证明用了一个基本性质即在$\text{LCA}$上算贡献，可以将复杂度$O(n^3)$分析到$O(n^2)$ #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;queue&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 100000 + 5; const LL MO = 1000000007; int n, m, dp[MAXN][102][2][2], gg[102][2][2], siz[MAXN]; vector&lt;int &gt; G[MAXN]; void dfs(int u, int fa) { siz[u] = 1; dp[u][0][0][0] = 1, dp[u][1][1][0] = 1; for (int o = 0; o &lt; (int)G[u].size(); ++o) { int v = G[u][o]; if (v != fa) { dfs(v, u); LL t = 0; memcpy(gg, dp[u], sizeof dp[u]), ms(dp[u], 0); for (int i = 0; i &lt;= min(siz[v], m); ++i) { for (int k = 0; k &lt;= min(siz[u], m) &amp;&amp; i + k &lt;= m; ++k) { int j = i + k; t = 1ll * gg[k][0][0] * dp[v][j - k][0][1] % MO; dp[u][j][0][0] = 1ll * (1ll * dp[u][j][0][0] + t) % MO; t = 1ll * gg[k][0][1] * ((dp[v][j - k][0][1] + dp[v][j - k][1][1]) % MO) % MO; t = (t + 1ll * gg[k][0][0] * dp[v][j - k][1][1]) % MO; dp[u][j][0][1] = 1ll * (1ll * dp[u][j][0][1] + t) % MO; t = 1ll * gg[k][1][0] * ((dp[v][j - k][0][0] + dp[v][j - k][0][1]) % MO) % MO; dp[u][j][1][0] = 1ll * (1ll * dp[u][j][1][0] + t) % MO; LL gg1 = (1ll * dp[v][j - k][0][0] + 1ll * dp[v][j - k][0][1] + 1ll * dp[v][j - k][1][0] + 1ll * dp[v][j - k][1][1]) % MO; LL gg2 = (1ll * dp[v][j - k][1][0] + 1ll * dp[v][j - k][1][1]) % MO; t = 1ll * gg[k][1][1] * gg1 % MO; t = (t + 1ll * gg[k][1][0] * gg2 % MO) % MO; dp[u][j][1][1] = 1ll * (1ll * dp[u][j][1][1] + t) % MO; } } siz[u] += siz[v]; } } } void clean() { ms(gg, 0); } int solve() { clean(); cin &gt;&gt; n &gt;&gt; m; for (int x, y, i = 1; i &lt; n; ++i) { scanf(&quot;%d%d&quot;, &amp;x, &amp;y); G[x].push_back(y); G[y].push_back(x); } dfs(1, 0); LL ans = dp[1][m][0][1] + dp[1][m][1][1]; ans %= MO; printf(&quot;%lld\n&quot;, ans); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1140F (可撤销并查集+线段树分治)]]></title>
    <url>%2FCodeforces1040F%2F</url>
    <content type="text"><![CDATA[Codeforces 1140F题意：$S$一开始是$∅$, 现在支持插入一个数/删除一个点，并且这个点一定只会插入一次删除一次，求每次操作完后集合$\text{E}(S)$的大小。$\text{E}(S)$集合一开始是当前的$S$, 如果$(x_1,y_1) \in \text{E}(S), (x_1,y_2) \in \text{E}(S), (x_2,y_1) \in \text{E}(S), (x_2,y_2) \notin \text{E}(S)$，那么$(x_2,y_2)$被加入到$\text{E}(S)$中，一直操作直到没有为止。 这题类似 CF 某场 EJOI 的题，我们发现将$(x,y)$看做连边，则答案就是一个联通块的$x,y$值域之积。 然后我们就可以维护并查集，但是这里有删除，我们联想到可撤销并查集 但是并不好用，因为一个数对有效范围是一个区间。 所以我们想到用线段树来优化($\log$级优化)，类比于线段树优化连边 即我们开一棵线段树，把每个数对有效区间在线段树上打好标记，然后我们可以按$\text{dfs}$序来遍历线段树，每次遍历到线段树的一个区间，暴力插入当前区间上所有有标记的数对，然后之后退出这个点再暴力删掉。由于线段树上一个大区间会被分成$\log$级别的小区间，然后每个修改最多操作$\log n$次，那么就符合时间复杂度了。 这种线段树优化的方法很好，以后一些整区间的优化可以联想到线段树划分区间来优化，其实和线段树优化连边思路有相似点，都是利用线段树上一个大区间会被分成$\log$级别的小区间来优化复杂度。]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>Codeforces</tag>
        <tag>线段树分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斐波那契数列 学习笔记]]></title>
    <url>%2FszFibonacci%2F</url>
    <content type="text"><![CDATA[模板及讲解通项公式$$F(n)=\frac{1}{\sqrt 5}\left[\left(\frac{1+\sqrt 5}{2}\right)^n - \left(\frac{1-\sqrt 5}{2}\right)^n\right]$$ 技巧1、斐波那契数列增长快2、与斐波那契数列相关的大数据递推，可以用矩阵优化 恒等式(前缀和) 1、$f(1)+f(2)+f(3)+ \dots +f(n)=f(n+2)-1$(平方前缀和) 2、$f(1)^2+f(2)^2+f(3)^2+ \dots +f(n)^2=f(n)f(n+1)$(奇数项) 3、$f(1)+f(3)+f(5)+ \dots +f(2n-1)=f(2n)$(偶数项) 4、$f(2)+f(4)+f(6)+ \dots +f(2n)=f(2n+1)-1$5、$f(m)f(n-m+1)+f(m-1)f(n-m)=f(n), n \leq m$6、$f(n-1)f(n+1)=f(n)^2+(-1)^n$ 性质1、$\gcd(f(n), f(m))=f(\gcd(n, m))$2、$n | m \Leftrightarrow f(n) | f(m)$3、类斐波那契数列 $h(n)=a \times f(n-2) + b \times f(n-1)，a=h(1), b=h(2)$ 例题P1306 斐波那契公约数 运用$\gcd(f(n), f(m))=f(\gcd(n, m))$缩小范围再矩阵快速幂优化。]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1167E (双指针+单调性)]]></title>
    <url>%2FCodeforces1167E%2F</url>
    <content type="text"><![CDATA[Codeforces 1167E题意：给定一个序列$a_i$，求有多少种在$a$中取$a_i \in (-∞, l] \cup [r, +∞)$的方案使得取出来的数是增序排序的。 我们考虑分开两边处理，发现左边如果使$l$单调递增，那么右边的$r$也是单调递增的。 所以我们可以考虑双指针来做。 $l$增加的过程中，不能存在$a_i \in (-∞, l]$不有序的情况。$r$即为满足$a_i \in (-∞, l] \cup [r, +∞)$的最小$r$ 那么我们这样就可以算方案了。 判断加进来的数能不能有序，就每个数记录一个最大出现位置和最小出现位置，判断一下大小关系即可。 知识点程序出错的原因1、大思路就出错了 —— 重构2、程序上有bug —— 检查程序3、思维上有bug —— 出数据，想特殊情况一般情况下，错误先看程序上是否写错，然后再看思维上是否有漏洞，否则就考虑一下是否大思路是有误 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;queue&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL MAXN = 1000000 + 5; LL n, x, a[MAXN]; LL maxd[MAXN], mind[MAXN]; LL pre[MAXN], suf[MAXN]; void clean() { ms(maxd, 0), ms(mind, 0x3f); ms(pre, 0), ms(suf, 0x3f); } int solve() { clean(); cin &gt;&gt; n &gt;&gt; x; for (LL i = 1; i &lt;= n; ++i) { scanf(&quot;%lld&quot;, &amp;a[i]); maxd[a[i]] = max(maxd[a[i]], i); mind[a[i]] = min(mind[a[i]], i); } for (LL i = 1; i &lt;= x; ++i) { pre[i] = max(maxd[i], pre[i - 1]); } for (LL i = x; i; --i) { suf[i] = min(mind[i], suf[i + 1]); } LL r = 1, ans = 0, lstL = 0; for (LL i = x - 1; i; --i) { if (maxd[i] &gt; suf[i + 1]) { r = i + 1; break ; } } for (LL l = 0; l &lt;= x; ++l) { if (l &amp;&amp; mind[l] &lt; pre[l - 1]) break ; while (r &lt;= x &amp;&amp; suf[r] &lt; maxd[l]) ++r; LL L = l + 1ll, R = r - 1ll; ans += (L - lstL) * (x - max(L, R) + 1ll); lstL = L; } cout &lt;&lt; ans; return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 3622」已经没有什么好害怕的了 (容斥DP + 二项式反演)]]></title>
    <url>%2Fbzoj3622%2F</url>
    <content type="text"><![CDATA[BZOJ 3622题意：给出 $n$ 个数 $a_i$，以及 $n$ 个数 $b_i$，要求两两配对使得 a &gt; b 的对数减去 a &lt; b 的对数等于 $k$ 。保证 $a,b$ 无相同元素。 我们可以计算出a &gt; b的对数，我们可以算出他是$\frac{k+n}{2}$，方便起见我们让$k=\frac{k+n}{2}$ 如果前面的式子不能整除则无解 然后我们考虑容斥，将$a,b$从小到大排序，我们可以设$f(i,j)$为前$i$个位置有$j$对a &gt; b，其他的没有考虑的方案数。 注意这里$f(n,k)$不是答案，因为没有考虑其他的位置 设$l_i$ 为$a_i \geq b_j$的最大$j$，则有转移方程$$f(i,j)=f(i-1,j)+f(i-1,j-1)\times (l_i-j+1)$$$l_i$相当于当前$i$的所有决策点，这些点一定包括之前的$i$的所有决策点，所以减去$j-1$就可以保证不重复。 然后我们将其他位置安排下来，设$F(i)=f(n, i) \times (n-i)!$ 设最后的答案为$g(i)$，则$g(i)$对每个小于$i$的$F$有贡献。 则$$F(i)= \sum \limits_{j=i}^{n} C^{i}_{j} \times g(j)$$ 根据二项式反演，则有$$g(i)= \sum \limits_{j=i}^{n} (-1)^{j-i} \times C^{i}_{j} \times F(j)$$ //==========================Head files========================== #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;map&gt; #define LL long long #define db double #define mp make_pair #define pr pair&lt;int, int&gt; #define fir first #define sec second #define pb push_back #define ms(i, j) memset(i, j, sizeof i) using namespace std; //==========================Templates========================== inline int read() { int x = 0, f = 1; char c = getchar(); while(c &lt; &#39;0&#39; || c &gt; &#39;9&#39;){if (c == &#39;-&#39;) f = -1; c = getchar();} while(c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;){x = x * 10 + c - &#39;0&#39;; c = getchar();} return x * f; } inline LL readl() { LL x = 0, f = 1; char c = getchar(); while(c &lt; &#39;0&#39; || c &gt; &#39;9&#39;){if (c == &#39;-&#39;) f = -1; c = getchar();} while(c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;){x = x * 10 + c - &#39;0&#39;; c = getchar();} return x * f; } int power(int a, int b) { int ans = 1; while (b) { if(b &amp; 1) ans = ans * a; b &gt;&gt;= 1; a = a * a; } return ans; } int power_mod(int a, int b, int mod) { a %= mod; int ans = 1; while (b) { if(b &amp; 1) ans = (ans * a) % mod; b &gt;&gt;= 1, a = (a * a) % mod; } return ans; } LL powerl(LL a, LL b) { LL ans = 1ll; while (b) { if(b &amp; 1ll) ans = ans * a; b &gt;&gt;= 1ll;a = a * a; } return ans; } LL power_modl(LL a, LL b, LL mod) { a %= mod; LL ans = 1ll; while (b) { if(b &amp; 1ll) ans = (ans * a) % mod; b &gt;&gt;= 1ll, a = (a * a) % mod; } return ans; } LL gcdl(LL a, LL b) {return b == 0 ? a : gcdl(b, a % b);} LL abssl(LL a) {return a &gt; 0 ? a : -a;} int gcd(int a, int b) {return b == 0 ? a : gcd(b, a % b);} int abss(int a) {return a &gt; 0 ? a : -a;} //==========================Main body========================== #define LD &quot;%I64d&quot; #define D &quot;%d&quot; #define pt printf #define sn scanf #define pty printf(&quot;YES\n&quot;) #define ptn printf(&quot;NO\n&quot;) //==========================Code here========================== const LL MAXN = 2000 + 5; const LL MO = 1e9 + 9; LL n, k, jc[MAXN], jc_inv[MAXN]; LL a[MAXN], b[MAXN], f[MAXN][MAXN], F[MAXN], g[MAXN]; LL C(LL n, LL m) { if (m &gt; n) return 0; return jc[n] * jc_inv[m] % MO * jc_inv[n - m] % MO; } int main() { cin &gt;&gt; n &gt;&gt; k; if ((n + k) % 2 == 1) return puts(&quot;0&quot;), 0; k = (n + k) &gt;&gt; 1; for (LL i = 1; i &lt;= n; ++i) scanf(&quot;%lld&quot;, &amp;a[i]); for (LL i = 1; i &lt;= n; ++i) scanf(&quot;%lld&quot;, &amp;b[i]); sort(a + 1, a + 1 + n), sort(b + 1, b + 1 + n); jc[0] = 1; for (LL i = 1; i &lt;= n; ++i) jc[i] = jc[i - 1] * i % MO; jc_inv[0] = 1; for (LL i = 1; i &lt;= n; ++i) jc_inv[i] = power_modl(jc[i], MO - 2, MO); ms(f, 0); f[0][0] = 1; for (LL i = 1; i &lt;= n; ++i) { for (LL j = 0; j &lt;= i; ++j) { LL li = lower_bound(b + 1, b + 1 + n, a[i]) - b - 1; if (j != 0) f[i][j] = (f[i][j] + f[i - 1][j - 1] * (li - j + 1) % MO) % MO; f[i][j] = (f[i][j] + f[i - 1][j]) % MO; } } for (LL i = 1; i &lt;= n; ++i) F[i] = f[n][i] * jc[n - i] % MO; LL ans = 0, gg = 1; for (LL i = k; i &lt;= n; ++i) { ans = (ans + gg * C(i, k) % MO * F[i] % MO) % MO; gg = (gg * -1) % MO; gg = (gg + MO) % MO; } cout &lt;&lt; ans; return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>Bzoj</tag>
        <tag>组合数学</tag>
        <tag>二项式反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1174D (构造+Xor)]]></title>
    <url>%2FCodeforces1174D%2F</url>
    <content type="text"><![CDATA[Codeforces 1174D题意：给两个数$n$和$x$，构造一个满足以下条件的序列：对任何$a_i, 1 \leq a_i \leq 2^n-1$, 序列中没有非空连续子序列异或和为$0$或$x$序列长度$l$应该最大 其实发现对于子序列来说这题会很好做 然而我们可以构造这题的前缀和，然后就转化成子序列问题 然后依次填即可。 知识点：1、构造一个数列，可以构造他的前缀和 (升次) #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;queue&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 1000000 + 5, len = 20; int sz, ans, n, S[MAXN], a[MAXN], vis[MAXN]; vector&lt;int &gt; vec; void add(int t, int op) { int oo = t; for (int i = len; i &gt;= 0; --i) { if (!(t &gt;&gt; i &amp; 1)) continue ; if (a[i]) t ^= a[i]; else { for (int j = 0; j &lt; i; ++j) if (t &gt;&gt; i &amp; 1) t ^= a[j]; for (int j = i + 1; j &lt;= len; ++j) if (a[j] &gt;&gt; i &amp; 1) a[j] ^= t; a[i] = t, ++sz; if (op) vec.push_back(oo); break ; } } } void dfs(int x, int num) { printf(&quot;%d &quot;, x); if (num == (1 &lt;&lt; ans) - 1) return ; for (int i = 0; i &lt; (int)vec.size(); ++i) { int val = vec[i]; if (!vis[x ^ val]) { vis[x ^ val] = 1; dfs(x ^ val, num + 1); } } } void clean() { } int solve() { clean(); cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;S[i]); sort(S + 1, S + 1 + n); int p = 1; for (int i = 1; i &lt;= len; ++i) { while (p &lt;= n &amp;&amp; S[p] &lt; (1 &lt;&lt; i)) add(S[p], 0), ++p; if (sz == i) ans = i; } printf(&quot;%d\n&quot;, ans); ms(a, 0); for (int i = 1; i &lt;= n &amp;&amp; S[i] &lt; (1 &lt;&lt; ans); ++i) add(S[i], 1); vis[0] = 1, dfs(0, 0); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>构造</tag>
        <tag>Xor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1175E (倍增)]]></title>
    <url>%2FCodeforces1175E%2F</url>
    <content type="text"><![CDATA[Codeforces 1163E题意：给定$n$个区间$[l_i, r_i]$，$m$次询问用最小的区间覆盖$[x,y]$ 发现对于一个点，所有包含他的区间只有$r$最远区间的有用，因为直接选这个区间一定最优所以我们可以用并查集或者线段树预处理每个点所有包含他的区间最远的$r$，然后我们就可以一步步的跳然后找到答案。这里一步步跳，我们联想到倍增优化，那么预处理一下倍增即可。但是这里还要考虑一下不存在方案的情况。那么对区间在轴上区间增加，如果一个地方的值等于0说明这中间断开了，处理一下即可。更好的实现我们考虑一个区间，所有和他相交区间只有$r$最远区间的有用，按照上面的方法处理一下即可。 知识点：1、需要跳的题面可以考虑倍增优化 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;queue&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 500000 + 5, LOGS = 20; int n, m, c[MAXN], tax[MAXN], pre[MAXN][LOGS + 2]; struct data { int l, r; } qj[200000 + 5]; bool cmp (data a, data b) { if (a.l == b.l) return a.r &gt; b.r; return a.l &lt; b.l; } void clean() { } int solve() { clean(); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d%d&quot;, &amp;qj[i].l, &amp;qj[i].r), qj[i].r--; sort(qj + 1, qj + 1 + n, cmp); int tmp = n; n = 1; c[qj[1].l]++, c[qj[1].r + 1]--; for (int i = 2; i &lt;= tmp; ++i) if (qj[i].r &gt; qj[n].r) qj[++n] = qj[i], c[qj[n].l]++, c[qj[n].r + 1]--; if (!c[0]) tax[0] = 1; for (int i = 1; i &lt;= 500000; ++i) { c[i] += c[i - 1]; if (!c[i]) tax[i] = 1; tax[i] += tax[i - 1]; } int j = 2; for (int i = 1; i &lt;= n; ++i) { j = max(j, i + 1); while (j &lt;= n &amp;&amp; qj[j].l &lt;= qj[i].r + 1) ++j; if (i != j - 1) pre[i][0] = j - 1; } for (int j = 1; j &lt;= LOGS; ++j) { for (int i = 1; i &lt;= n; ++i) { pre[i][j] = pre[pre[i][j - 1]][j - 1]; } } while (m--) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y), --y; int cnt = tax[y]; if (x) cnt -= tax[x - 1]; if (cnt) printf(&quot;-1\n&quot;); else { int p = lower_bound(qj + 1, qj + 1 + n, (data){x + 1, (int)1e9}, cmp) - qj - 1; if (qj[p].r &gt;= y) { printf(&quot;1\n&quot;); continue ; } else { int ans = 0; for (int i = LOGS; i &gt;= 0; --i) { if (qj[pre[p][i]].r &lt; y &amp;&amp; pre[p][i]) { p = pre[p][i]; ans += 1 &lt;&lt; i; } } printf(&quot;%d\n&quot;, ans + 2); } } } return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1181D (树状数组)]]></title>
    <url>%2FCodeforces1181D%2F</url>
    <content type="text"><![CDATA[Codeforces 1181D题意： 考虑将每个国家的举行次数排序，然后按顺序离线去做即可，可以看代码注释方法。注意要求$k$大，可以Splay，但是可以更方便的用树状数组来求 知识点：1、思维要清晰 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;queue&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL MAXN = 500000 + 5; LL n, m, q; LL qID[MAXN], k[MAXN]; LL H[MAXN], Hid[MAXN]; LL ans[MAXN], C[MAXN]; LL cmpH(LL a, LL b) {return H[a] &lt; H[b];} LL cmpq(LL a, LL b) {return k[a] &lt; k[b];} void update(LL x) {while (x &lt;= m) C[x]++, x += x &amp; (-x);} LL query(LL x) { LL p = 0; for (LL i = 20; ~i; --i) { if (p + (1 &lt;&lt; i) &lt;= m &amp;&amp; C[p + (1 &lt;&lt; i)] &lt;= x) x -= C[p + (1 &lt;&lt; i)], p += (1 &lt;&lt; i); } return p; } void clean() { } int solve() { clean(); cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; for (LL x, i = 1; i &lt;= n; ++i) scanf(&quot;%lld&quot;, &amp;x), ++H[x]; for (LL i = 1; i &lt;= m; ++i) Hid[i] = i; sort(Hid + 1, Hid + 1 + m, cmpH); for (LL i = 1; i &lt;= q; ++i) scanf(&quot;%lld&quot;, &amp;k[i]), k[i] -= n, qID[i] = i; sort(qID + 1, qID + 1 + q, cmpq); LL now = 1, gg = 0; // gg 为当前累加值 update(Hid[1]); for (LL i = 1; i &lt;= q; ++i) { LL v = k[qID[i]]; while (now &lt; m &amp;&amp; gg + now * (H[Hid[now + 1]] - H[Hid[now]]) &lt; k[qID[i]]) gg += now * (H[Hid[now + 1]] - H[Hid[now]]), update(Hid[++now]); v -= gg + 1; v %= now; ans[qID[i]] = query(v) + 1; } for (LL i = 1; i &lt;= q; ++i) printf(&quot;%lld\n&quot;, ans[i]); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 4665」小w的喜糖 (容斥DP)]]></title>
    <url>%2Fbzoj4665%2F</url>
    <content type="text"><![CDATA[BZOJ 4665题意：求有重复元素排列的错排。 考虑将所有元素都看成不同的(重复元素也看做)，然后最后再除以各自的个数消序即可。 然后我们考虑设$F(i)$为至少有$i$个位置上是原来的数，那么我们可以利用这个来容斥，即$$\text{ans}=\sum_{i=0}^n F(i) \cdot (-1)^i$$ 我们考虑怎么求这个$F(i)$，设$dp(i,j)$为前$i$个值全部考虑完，至少有$j$个位置上是原来的数的方案，那么 $$dp(i,j)=\sum_{k=0}^{min(j,cnt[i])}dp(i-1,j-k) \cdot C_{cnt[i]}^{k} \cdot \prod_{p=cnt[i]-k+1}^{cnt[i]}p$$ 其中$cnt[i]$为值$i$的元素个数。那么我们可以得到$$F(i)=dp(n,i)\cdot (n-i)!$$那么就能容斥了。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;queue&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL MO = 1000000009, MAXN = 2000 + 5; LL n, cnt[MAXN], jc[MAXN], jc_inv[MAXN], dp[MAXN][MAXN], f[MAXN]; LL ksm(LL a, LL b) { LL bs = a, ans = 1; while (b) { if (b &amp; 1) ans = ans * bs % MO; bs = bs * bs % MO; b &gt;&gt;= 1; } return ans; } LL C(LL n, LL m) { if (m &gt; n) return 0; return jc[n] * jc_inv[m] % MO * jc_inv[n - m] % MO; } void clean() { } int solve() { clean(); cin &gt;&gt; n; jc[0] = 1, jc_inv[0] = 1; for (LL i = 1; i &lt;= n; ++i) jc[i] = jc[i - 1] * i % MO, jc_inv[i] = ksm(jc[i], MO - 2); for (LL x, i = 1; i &lt;= n; ++i) scanf(&quot;%lld&quot;, &amp;x), ++cnt[x]; dp[0][0] = 1; for (LL i = 1; i &lt;= n; ++i) { for (LL j = 0; j &lt;= n; ++j) { for (LL k = 0; k &lt;= min(j, cnt[i]); ++k) { dp[i][j] = (dp[i][j] + dp[i - 1][j - k] * C(cnt[i], k) % MO * jc[cnt[i]] % MO * jc_inv[cnt[i] - k] % MO) % MO; } } } for (LL i = 0; i &lt;= n; ++i) f[i] = dp[n][i] * jc[n - i] % MO; LL ans = 0, hh = 1; for (LL i = 0; i &lt;= n; ++i) { ans = (ans + hh * f[i] % MO) % MO; hh = (hh * -1 + MO) % MO; } for (LL i = 1; i &lt;= n; ++i) ans = (ans * jc_inv[cnt[i]]) % MO; cout &lt;&lt; ans; return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>计数DP</tag>
        <tag>Bzoj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 2111」「ZJOI2010」排列计数 (树形计数DP)]]></title>
    <url>%2Fbzoj2111%2F</url>
    <content type="text"><![CDATA[BZOJ 2111题意：称一个$1,2,…,N​$的排列$P_1,P_2…,P_n​$是$\text{Magic}​$的，当且仅当$2 \leq i \leq N​$时，$P_i &gt; P_{\frac i2}​$. 计算$1，2，…N​$的排列中有多少是$\text{Magic}​$的，答案可能很大，只能输出模$P​$以后的值 容易转化为即求小根堆的方案数。那么我们可以用树形DP方法来做，设$dp(i)$为以$i$为根($P$的下标$i$)的方案数。那么这个树的左右子树大小是定的，那么就有$$dp(i)=C^{s-1}_{n-i} dp(ls) \cdot dp(rs)$$其中$ls, rs$为左右子树大小，$s$为$i$子树大小即$i$子树候选集合大小为$n-i$，从候选集合选出$s-1$个来当$i$的子树，然后分别乘上左儿子右儿子的方案即可。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;queue&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL MAXN = 2000000 + 5; LL n, p, dp[MAXN], jc[MAXN], jc_inv[MAXN], s[MAXN]; LL ksm(LL a, LL b) { LL ans = 1, bs = a; while (b) { if (b &amp; 1) ans = ans * bs % p; bs = bs * bs % p; b &gt;&gt;= 1; } return ans; } LL C(LL n, LL m) { if (m &gt; n) return 0; return jc[n] * jc_inv[n - m] % p * jc_inv[m] % p; } LL lucas(LL n, LL m) { if (m == 0) return 1; return lucas(n / p, m / p) * C(n % p, m % p) % p; } void dfs_siz(LL u) { if (u &gt; n) return ; s[u] = 1; dfs_siz(u * 2), dfs_siz(u * 2 + 1); s[u] += s[u * 2] + s[u * 2 + 1]; } void dfs(LL u) { if (u * 2 &gt; n) return dp[u] = 1, void(); dfs(u * 2), dfs(u * 2 + 1); LL t1 = dp[u * 2], t2 = dp[u * 2 + 1]; if (t1 == 0) t1 = 1; if (t2 == 0) t2 = 1; dp[u] = lucas(s[u] - 1, s[u * 2]) * t1 % p * t2 % p; } void clean() { } int solve() { clean(); cin &gt;&gt; n &gt;&gt; p; jc[0] = jc_inv[0] = 1; for (LL i = 1; i &lt;= 1000000; ++i) jc[i] = jc[i - 1] * i % p, jc_inv[i] = ksm(jc[i], p - 2); dfs_siz(1); dfs(1); printf(&quot;%lld\n&quot;, dp[1]); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>计数DP</tag>
        <tag>Bzoj</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Loj 6185」烷基计数 (计数DP，无标号有根树统计)]]></title>
    <url>%2Floj6185%2F</url>
    <content type="text"><![CDATA[Loj 6185题意：求$n$个点的每个点度数不超过$4$且根的度数不超过$3$的有根树的数目。 显然有一个暴力DP方法，复杂度取决于根度数 考虑$dp$一颗一颗子树加进去方案，从小到大加可以不重不漏。这里我们设$dp(s,i,j)$为当前添加的子树大小不超过$s$，有$i$个节点，根节点$j$度的方案数。 考虑枚举添加的子树个数$k$，那么这$k$个$s$大小的子树占用了$ks$个节点和$k$度，那么可以从$dp(s-1,i-ks,j-k)$转移过来。然后考虑将$k$棵子树乘上他们的方案。 设$a_i=\sum\limits_{g=0}^{m-1} dp(s-1, i, g)$，那么$a_s$就是$s$大小子树的方案‘考虑将$k$棵子树分成$a_s$份(可以留空)，方案数为$C^{a_s-1}_{a_s+k-1}$ 那么得到转移方程$$dp(s,i,j)=\sum_{k=0}^{k \leq j, ks - 1 \leq i} dp(s-1,i-ks,j-k) \cdot C^{k}_{a_s+k-1}$$ 由于$a_s-1$较大，而$k \leq m=3$, 则转化一下方便求组合数。注意到第一维可以不需要存储，类似背包滚动数组的方法，所以$i$要倒序 时间复杂度$O \left( n^2 m \log m \right)$。 知识点：1、计数DP要按顺序加才能不重不漏2、有根树统计可以用加子树的顺序 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;queue&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL MAXN = 405, MO = 1e9 + 7; LL n, m = 4, dp[MAXN][7], inv2 = 500000004, inv6 = 166666668; LL C(LL n, LL m) { if (m &gt; n) return 0; if (m == 0) return 1; if (m == 1) return n; if (m == 2) return n * (n - 1ll) % MO * inv2 % MO; if (m == 3) return n * (n - 1ll) % MO * (n - 2ll) % MO * inv6 % MO; return 0; } void clean() { } int solve() { clean(); cin &gt;&gt; n; dp[1][0] = 1; for (int s = 1; s &lt; n; ++s) { LL a = 0; for (int g = 0; g &lt; m; ++g) a = (a + dp[s][g]) % MO; for (int i = n; i ; --i) { for (int j = 1; j &lt; m; ++j) { for (int k = 1; k &lt;= j &amp;&amp; k * s &lt; i; ++k) { dp[i][j] = (dp[i][j] + dp[i - k * s][j - k] * C(a + k - 1, k) % MO) % MO; } } } } LL ans = 0; for (LL i = 0; i &lt;= m; ++i) ans = (ans + dp[n][i]) % MO; cout &lt;&lt; ans; return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Loj</category>
      </categories>
      <tags>
        <tag>计数DP</tag>
        <tag>Loj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1163E (线性基)]]></title>
    <url>%2FCodeforces1165E%2F</url>
    <content type="text"><![CDATA[Codeforces 1163E题意：给定集合$S$, 求出一个$x$最大的$[0, 2^x-1]$排列，使得任意两个相邻元素异或值在$S$中。 设$S$的线性基为$T$1、$[0, 2^x-1]$可以被构造出来当且仅当$[0, 2^x-1]$中的数可以被小于$2^x-1$的$T$中的元素表示出来 证明：排列中一定有$0$, $0$周围两个数$i,j$肯定$i,j \in S$，那么之后的数都可以类推然后发现就是能被$S$表示既可以，否则不行。那么只需要$T$能表示即可。 运用这个结论，边求出线性基，边计算最大满足条件的$x$ 2、构造的排列相邻的两个元素在$T$中映射的bitset相差$1$位 证明：结果比较显然，不相差$1$位就不能从其他位异或一个$S$得到这个数。 那么直接DFS从0开始构造序列即可。 知识点：1、异或题的0 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;queue&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 1000000 + 5, len = 20; int sz, ans, n, S[MAXN], a[MAXN], vis[MAXN]; vector&lt;int &gt; vec; void add(int t, int op) { int oo = t; for (int i = len; i &gt;= 0; --i) { if (!(t &gt;&gt; i &amp; 1)) continue ; if (a[i]) t ^= a[i]; else { for (int j = 0; j &lt; i; ++j) if (t &gt;&gt; i &amp; 1) t ^= a[j]; for (int j = i + 1; j &lt;= len; ++j) if (a[j] &gt;&gt; i &amp; 1) a[j] ^= t; a[i] = t, ++sz; if (op) vec.push_back(oo); break ; } } } void dfs(int x, int num) { printf(&quot;%d &quot;, x); if (num == (1 &lt;&lt; ans) - 1) return ; for (int i = 0; i &lt; (int)vec.size(); ++i) { int val = vec[i]; if (!vis[x ^ val]) { vis[x ^ val] = 1; dfs(x ^ val, num + 1); } } } void clean() { } int solve() { clean(); cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;S[i]); sort(S + 1, S + 1 + n); int p = 1; for (int i = 1; i &lt;= len; ++i) { while (p &lt;= n &amp;&amp; S[p] &lt; (1 &lt;&lt; i)) add(S[p], 0), ++p; if (sz == i) ans = i; } printf(&quot;%d\n&quot;, ans); ms(a, 0); for (int i = 1; i &lt;= n &amp;&amp; S[i] &lt; (1 &lt;&lt; ans); ++i) add(S[i], 1); vis[0] = 1, dfs(0, 0); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1156F (概率DP)]]></title>
    <url>%2FCodeforces1156F%2F</url>
    <content type="text"><![CDATA[Codeforces 1156F题意：包里面有$n$个数，每次取一个数，当前取出的数为$x$，前一个取出的数为$y$,则：若x &gt; y，游戏继续若x = y，游戏结束并且玩家赢若x &lt; y，游戏结束并且玩家输问玩家赢的概率 容易发现必须从小取到大。设$dp(i,j)$为删了$i$个卡牌，最大删到$j$值卡牌获胜的概率。那么考虑取出相同值或者大于$j$值卡牌的情况，两者概率相加。具体转移方程可以看代码。代码实现中加入一个$0$必选，不影响答案，可以方便求出答案，答案为$dp[0][0]$ #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;queue&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL MO = 998244353; LL ksm(LL a, LL b) { LL ret = 1, bs = a; while (b) { if (b &amp; 1) ret = (ret * bs) % MO; bs = (bs * bs) % MO; b &gt;&gt;= 1; } return ret; } LL n, a[5005], dp[5005][5005], b[5005], tax[5005], ni[5005]; void clean() { } int solve() { clean(); cin &gt;&gt; n; for (LL i = 1; i &lt;= n; ++i) ni[i] = ksm(i, MO - 2); for (LL i = 1; i &lt;= n; ++i) scanf(&quot;%lld&quot;, &amp;a[i]), ++tax[a[i]]; LL ans = 0; tax[0] = 1; for (LL i = n; i &gt;= 0; --i) { for (LL j = n; j &gt;= 0; --j) if (tax[j]) { dp[i][j] = (ni[n - i] * b[j + 1] % MO + (tax[j] - 1) * ni[n - i] % MO) % MO; ans = (ans + dp[i][j]) % MO; } for (LL j = 1; j &lt;= n; ++j) b[j] = dp[i][j] * tax[j] % MO; for (LL j = n; j &gt;= 1; --j) b[j] = (b[j] + b[j + 1]) % MO; } cout &lt;&lt; dp[0][0]; return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>概率DP</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 5299」「CQOI2018」解锁屏幕 (状压DP)]]></title>
    <url>%2Fbzoj5299%2F</url>
    <content type="text"><![CDATA[BZOJ 5299题意：见上。 可以用连接个数来划分阶段。那么我们设$dp(S,i)$为已经连过的点的集合，最后一次连在$i$点的方案数。然后转移即可。复杂度$O(2^n n^2)$，复杂度跑不满可以过然后我们还要满足两个点之间的连线不能「跨过」另一个点，那么我们预处理出来两个点之间点的集合，转移时判断即可。 这个集合可以$O(n^3)$来做，就是枚举两个点$i,j$求他们的之间点集合$S_{i,j}$那么我们再枚举一个$k$点，判下斜率相等即可确定 还可以$O(nx)$做。先求出$\Delta x = b_x - a_x, \Delta y = b_y - a_y$，我们发现整点数只会在$(a_x + \frac{\Delta x}{\gcd (\Delta x, \Delta y)}, a_y + \frac{\Delta y}{\gcd (\Delta x, \Delta y)})$，直接找坐标是否存在给定点即可，这里用了map，其实可以用桶。可以发现这个步数不超过$\max(x,y)$ 最后统计答案统计$S$二进制下$1$个数大于等于$4$的 知识点：1、状压的空间预留不要开太大，特别是尾数 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;queue&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MO = 100000007, MAXN = 20 + 1; int gcd(int a, int b) {return b != 0 ? gcd(b, a % b) : a;} int n, dp[(1 &lt;&lt; 20) + 2][MAXN], s[MAXN][MAXN]; struct pos { int x, y; bool operator &lt; (const pos &amp;rhs) const { return x == rhs.x ? y &lt; rhs.y : x &lt; rhs.x; } } p[MAXN]; map&lt;pos, int &gt; ma; void clean() { ms(dp, 0), ms(s, 0); } int solve() { clean(); cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d%d&quot;, &amp;p[i].x, &amp;p[i].y), ma[p[i]] = i; for (int u = 1; u &lt;= n; ++u) { for (int v = 1; v &lt;= n; ++v) if (u != v) { int dx = p[v].x - p[u].x; int dy = p[v].y - p[u].y; int g = gcd(dx, dy); g = (g &lt; 0 ? -g : g); if (g != 0) dx /= g, dy /= g; int nowx = p[u].x, nowy = p[u].y; while (!(nowx == p[v].x &amp;&amp; nowy == p[v].y)) { if (ma[(pos){nowx, nowy}]) s[u][v] |= (1 &lt;&lt; (ma[(pos){nowx, nowy}] - 1)); nowx += dx, nowy += dy; } s[u][v] |= (1 &lt;&lt; (u - 1)); s[u][v] |= (1 &lt;&lt; (v - 1)); } } for (int i = 1; i &lt;= n; ++i) dp[(1 &lt;&lt; (i - 1))][i] = 1; for (int S = 0; S &lt; (1 &lt;&lt; n); ++S) { for (int i = 1; i &lt;= n; ++i) if (S &amp; (1 &lt;&lt; (i - 1))) { for (int v = 1; v &lt;= n; ++v) if (i != v &amp;&amp; (S &amp; (1 &lt;&lt; (v - 1)))) { if ((S &amp; s[i][v]) == s[i][v]) dp[S][i] = (dp[S ^ (1 &lt;&lt; (i - 1))][v] + dp[S][i]) % MO; } } } int ans = 0; for (int S = 0; S &lt; (1 &lt;&lt; n); ++S) { int tmp = S, cnt = 0; do {++cnt, tmp &amp;= (tmp - 1);} while (tmp); if (cnt &lt; 4) continue ; for (int i = 1; i &lt;= n; ++i) ans = (ans + dp[S][i]) % MO; } cout &lt;&lt; ans; return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 4571」「SCOI2016」美味 (主席树 + 按位贪心)]]></title>
    <url>%2Fbzoj4571%2F</url>
    <content type="text"><![CDATA[BZOJ 4571题意：给定$a_i​$，询问$m​$次$b,x,l, r​$, 求$\max(b \text{xor} (a_i+x))​$, $i \in [l, r]​$ 这里有加法就不能用01Trie的方法了。然而我们还是可以按位贪心。考虑贪心到第$i$位，当前已经贪了的$\text{ans}=a_i+x$，那么之后如果第$i$位填上了$1$，则答案范围为$[\text{ans} + 2^{i}, \text{ans} + 2^{i+1}-1]$$0$同理为答案范围为$[\text{ans}, \text{ans} + 2^{i}-1]$然后我们只需要看有没有$a_i$在这个范围即可判断能不能填了。因为区间，所以用主席树来做。 注意主席树值域要开$2 \times 10^5$ 知识点1、异或的按位贪心。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;queue&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 500000 + 5, MV = 300000 + 5; #define M ((l + r) &gt;&gt; 1) int n, m; int sz, rt[MAXN], lc[MAXN * 20], rc[MAXN * 20], sumv[MAXN * 20]; void update(int pre, int &amp;now, int l, int r, int p) { if (!now) now = ++sz, sumv[now] = 0; sumv[now] = sumv[pre] + 1; if (l == r) return ; if (p &lt;= M) rc[now] = rc[pre], update(lc[pre], lc[now], l, M, p); else if (M &lt; p) lc[now] = lc[pre], update(rc[pre], rc[now], M + 1, r, p); } int query(int x, int y, int l, int r, int u, int v) { if (u &lt;= l &amp;&amp; r &lt;= v) return sumv[y] - sumv[x]; int ans = 0; if (u &lt;= M) ans += query(lc[x], lc[y], l, M, u, v); if (M &lt; v) ans += query(rc[x], rc[y], M + 1, r, u, v); return ans; } void clean() { sz = 0; } int solve() { clean(); cin &gt;&gt; n &gt;&gt; m; for (int x, i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;x), update(rt[i - 1], rt[i], 0, MV, x); for (int b, x, l, r, i = 1; i &lt;= m; ++i) { scanf(&quot;%d%d%d%d&quot;, &amp;b, &amp;x, &amp;l, &amp;r); int ans = 0; for (int j = 18; j &gt;= 0; --j) { int op = ((b &gt;&gt; j) &amp; 1); int tl, tr; if (!op) tl = ans + (1 &lt;&lt; j), tr = tl + (1 &lt;&lt; j) - 1; else tl = ans, tr = tl + (1 &lt;&lt; j) - 1; if (tr &lt; 0 || tl &gt; MV) { ans |= (op &lt;&lt; j); continue ; } tl = max(0, tl - x), tr = min(MV, tr - x); if (tl &gt; tr) { ans |= (op &lt;&lt; j); continue ; } if (query(rt[l - 1], rt[r], 0, MV, tl, tr)) ans |= ((op ^ 1) &lt;&lt; j); else ans |= (op &lt;&lt; j); } printf(&quot;%d\n&quot;, ans ^ b); } return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>Bzoj</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 4571」「SDOI2016」排列计数 (错位排列)]]></title>
    <url>%2Fbzoj4517%2F</url>
    <content type="text"><![CDATA[BZOJ 4571题意：求有多少种长度为 $n$ 的序列 $A$，满足以下条件：$[1, n]$ 这 $n$ 个数在序列中各出现了一次若第 $i$ 个数 $A_i$ 的值为 $i$，则称 $i$ 是稳定的。序列恰好有 $m$ 个数是稳定的满足条件的序列可能很多，序列数对 $10^9+7$ 取模。 我们可以$C^m_n$选出$m$个人来稳定，然后其他就是错位排列。错位排列可以递推出来，设$n$个数的错位排列是$D(n)$，则有$$D(n)=(n-1)(D(n-1)+D(n-2))$$证明：考虑$n$这个数放到了$k$位置，有$n-1$种情况。然后考虑$k$这个数放在哪1、$k$这个数放在$n$位置，那么显然$n,k$全部被排完，变成了$D(n-2)$的局面2、$k$这个数不放在$n$位置，那么现在先不放$k$，然后现在我们已经少了一个$n$数和$k$位置，那么其实$k$数等价于现在的$n$数，变成了$D(n-1)$的局面 这里还有一个通项式子$$D(n) = n! \left( 1 - \frac{1}{1!} + \frac{1}{2!} - \frac{1}{3!} \cdots + (-1)^n \frac{1}{n!} \right)$$证明即使用容斥原理。 ps：不要忘了预处理阶乘逆元的方法求组合数。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;queue&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL MAXN = 1000000 + 5, MO = 1e9 + 7; LL T, n, m, D[MAXN], jc[MAXN], jc_inv[MAXN]; LL ksm(LL a, LL b) { LL ans = 1, bs = a; while (b) { if (b &amp; 1) ans = (ans * bs) % MO; bs = (bs * bs) % MO; b &gt;&gt;= 1; } return ans; } LL C(LL n, LL m) { if (m &gt; n) return 0; return jc[n] * jc_inv[m] % MO * jc_inv[n - m] % MO; } void clean() { } int solve() { clean(); D[0] = D[2] = 1; for (LL i = 3; i &lt;= 1000000; ++i) D[i] = (i - 1) * (D[i - 1] + D[i - 2]) % MO; jc[0] = 1, jc_inv[0] = 1; for (LL i = 1; i &lt;= 1000000; ++i) jc[i] = jc[i - 1] * i % MO, jc_inv[i] = ksm(jc[i], MO - 2); cin &gt;&gt; T; while (T--) { scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m); printf(&quot;%lld\n&quot;, C(n, m) * D[n - m] % MO); } return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 5495」「十二省联考2019」异或粽子 (可持久化01Trie + 堆)]]></title>
    <url>%2Fbzoj5495%2F</url>
    <content type="text"><![CDATA[BZOJ 5495题意：求异或和前$k$大的区间的和。 类似超级钢琴做法，见bzoj 5495那题查询最大值用的st表，这里是异或区间最大所以想到可持久化01Trie维护即可。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;queue&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 500000 + 5, LEN = 34; int n, k; LL a[MAXN], s[MAXN]; int rt[MAXN], ch[MAXN * 40][2], end[MAXN * 40], sz; int gg[40], hh[40]; struct data { int l, r, x, y; bool operator &lt; (const data &amp;rhs) const { return (s[r] ^ s[l - 1]) &lt; (s[rhs.r] ^ s[rhs.l - 1]); } }; priority_queue&lt;data &gt; q; void fj(LL v) { int len = 0; LL tmp = v; ms(gg, 0); do {gg[++len] = tmp &amp; 1, tmp &gt;&gt;= 1;} while (tmp); } void ins(int pre, int now, int i, int ith) { if (i == 0) {end[now] = ith; return ;} int c = gg[i]; ch[now][c] = ++sz, ch[now][c ^ 1] = ch[pre][c ^ 1]; ins(ch[pre][c], ch[now][c], i - 1, ith); end[now] = max(max(end[now], end[ch[now][0]]), end[ch[now][1]]); } int query(int now, int l) { for (int i = LEN; i; --i) { int c = gg[i]; if (end[ch[now][c ^ 1]] &gt;= l &amp;&amp; ch[now][c ^ 1]) { hh[i] = 1, now = ch[now][c ^ 1]; } else hh[i] = 0, now = ch[now][c]; } return end[now]; } void clean() { sz = 0, ms(rt, 0), ms(ch, 0), ms(end, 0); } int solve() { clean(); cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; ++i) { scanf(&quot;%lld&quot;, &amp;a[i]); s[i] = s[i - 1] ^ a[i]; fj(s[i]), ins(rt[i - 1], rt[i] = ++sz, LEN, i); } for (int l = 1; l &lt;= n; ++l) { fj(s[l - 1]); int id = query(rt[n], l); LL bs = 1, res = 0; for (int i = 1; i &lt;= LEN; ++i) res += bs * hh[i], bs *= 2ll; q.push((data){l, id, l, n}); } LL ans = 0; for (int i = 1; i &lt;= k; ++i) { data p = q.top(); q.pop(); ans += (s[p.l - 1] ^ s[p.r]); if (p.x &lt;= p.r - 1) { fj(s[p.l - 1]); int id = query(rt[p.r - 1], p.x); LL bs = 1, res = 0; for (int j = 1; j &lt;= LEN; ++j) res += bs * hh[j], bs *= 2ll; q.push((data){p.l, id, p.x, p.r - 1}); } if (p.r + 1 &lt;= p.y) { fj(s[p.l - 1]); int id = query(rt[p.y], p.r + 1); LL bs = 1, res = 0; for (int j = 1; j &lt;= LEN; ++j) res += bs * hh[j], bs *= 2ll; q.push((data){p.l, id, p.r + 1, p.y}); } } cout &lt;&lt; ans; return 0; } } int main() { flyinthesky::solve(); return 0; } /* 5 3 5 4 2 3 1 */]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>堆</tag>
        <tag>Bzoj</tag>
        <tag>可持久化Trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 3167」「HEOI2013」SAO (树形DP + 组合计数DP)]]></title>
    <url>%2Fbzoj3167%2F</url>
    <content type="text"><![CDATA[bzoj 3170题意：给定一个树形图，求他的拓扑序个数。 如果看成拓扑图做那就凉了…据说拓扑图的拓扑序个数是NP的我们发现这里是一个树形图，那么我们考虑分类讨论边的方向，树形DPDP是合并思想，最暴力的想法就是，每个点存下一个序列，然后在父亲$u$合并儿子的答案。具体就是$dp(u) \Leftarrow dp’(u), dp(v)$ ($dp’(u)$为只考虑当前枚举的$v$前的子树，类似DP求树直径方法)但是显然不能记录那么多，我们考虑设$dp(u, i)$为$u$子树形成的拓扑序，$u$在$i$位置的方案数。这个状态可以让我们知道$u$前有几个数，$u$后有几个数。(以上思想是思考DP不要拘束于状态，而是去想怎么方便怎么做，之后再来看怎么压状态)考虑$dp(u, i) \Leftarrow dp’(u, j), dp(v, k)$那么先给出式子(先考虑$u$在$v$前的情况)$$dp(u,i)=\sum_{j=1}^{\min(\text{sz}[i], i)} C^{j-1}_{i-1} \cdot C^{\text{sz}[u]-j}_{\text{sz}[u]+\text{sz}[v]-i} \cdot dp’(u,j) \cdot \sum_{k=i-j+1}^{\text{sz}[v]}dp(v, k)$$这里是$dp(u, i) \Leftarrow dp’(u, j), dp(v, k)$，即一个序列合并的情况。前$3$项是说，在$u$的前面的$i-1$个位置，选择$j-1$个位置出来，然后在$u$后面$\text{sz}[u]+\text{sz}[v]-i$个位置选$\text{sz}[u]-j$个位置出来，这些选的位置只有$dp’(u,j)$种填法(保证顺序)。然后其他空位置只能有$dp(v, k)$种填法。注意对于$v$合并后必须到$u$后面，所以对$k$有约束。然后对于$u$在$v$后，就是$k$的约束不同。然后就可以DP了。对于复杂度，我们先发现后面$v,k$的东西可以单独前缀和处理，然后前面的$i,j$在$\text{LCA}$处计算复杂度，是$O(n^2)$的。具体就是，这里相当于枚举$v$前子树和$v$子树的节点，设这一对点为$(a,b)$，这对点当且仅当在$\text{LCA}$处被枚举，所以不会重复枚举，点对个数为$n^2$，类似此题分析的还有很多树形DP题。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #include&lt;vector&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; int T; namespace flyinthesky { const int MAXN = 1000 + 5; const LL MO = 1000000007; int n, en, hd[MAXN], sz[MAXN]; struct edge {int u, v, d, nxt;} ed[MAXN * 2]; // d = 0, u &lt; v LL C[MAXN][MAXN], dp[MAXN][MAXN], pre[MAXN][MAXN], suf[MAXN][MAXN]; void ins(int u, int v, int d) {ed[++en] = (edge){u, v, d, hd[u]}, hd[u] = en;} void dfs(int u, int fa) { sz[u] = 1; dp[u][1] = 1; for (int o = hd[u]; o &gt;= 0; o = ed[o].nxt) { edge &amp;e = ed[o]; if (e.v != fa) { dfs(e.v, u); if (ed[o].d == 0) { for (int i = sz[u] + sz[e.v]; i; --i) { LL sum = 0; for (int j = 1; j &lt;= min(sz[u], i); ++j) { sum = (sum + C[i - 1][j - 1] * dp[u][j] % MO * C[sz[u] + sz[e.v] - i][sz[u] - j] % MO * suf[e.v][i - j + 1] % MO) % MO; } dp[u][i] = sum; } } else { for (int i = sz[u] + sz[e.v]; i; --i) { LL sum = 0; for (int j = 1; j &lt;= min(sz[u], i); ++j) { sum = (sum + C[i - 1][j - 1] * dp[u][j] % MO * C[sz[u] + sz[e.v] - i][sz[u] - j] % MO * pre[e.v][i - j] % MO) % MO; } dp[u][i] = sum; } } sz[u] += sz[e.v]; } } for (int i = 1; i &lt;= sz[u]; ++i) pre[u][i] = (dp[u][i] + pre[u][i - 1]) % MO; for (int i = sz[u]; i; --i) suf[u][i] = (dp[u][i] + suf[u][i + 1]) % MO; } void clean() { en = -1, ms(hd, -1), ms(sz, 0), ms(dp, 0), ms(pre, 0), ms(suf, 0); } int solve() { clean(); scanf(&quot;%d&quot;, &amp;n); for (int u, v, i = 1; i &lt; n; ++i) { char c; scanf(&quot;%d %c %d&quot;, &amp;u, &amp;c, &amp;v), ++u, ++v; if (c == &#39;&lt;&#39;) ins(u, v, 0), ins(v, u, 1); else ins(u, v, 1), ins(v, u, 0); } dfs(1, 0); LL ans = 0; for (LL i = 1; i &lt;= n; ++i) ans = (ans + dp[1][i]) % MO; printf(&quot;%lld\n&quot;, ans); return 0; } } int main() { for (int i = 0; i &lt;= 1000; ++i) flyinthesky::C[i][0] = flyinthesky::C[i][i] = 1; for (int i = 1; i &lt;= 1000; ++i) for (int j = 1; j &lt; i; ++j) flyinthesky::C[i][j] = (flyinthesky::C[i - 1][j] + flyinthesky::C[i - 1][j - 1]) % flyinthesky::MO; cin &gt;&gt; T; while (T--) flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>计数DP</tag>
        <tag>Bzoj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 2143」「国家集训队」飞飞侠 (线段树优化连边 + 最短路)]]></title>
    <url>%2Fbzoj2143%2F</url>
    <content type="text"><![CDATA[Bzoj 2143题意：见上。 这题暴力就是直接连边跑。然而我们发现这里连边都是向一个区间连边，那么我们可以考虑线段树优化连边对每行建线段树，线段树内部父亲连孩子一条边边权为0，然后要连边的话就递归下去找到几个区间连对应边权的边即可。 这题也可以DP。可以将每一步拆开来，设$dp(i,j,k)$为在$i,j$还能免费走$k$步的最小距离。这里免费是之前交过费以后，类似CF某题 注意本题数组要开够，可以开到$10^7$ 知识点1、线段树优化连边2、数组大小要算不要偷懒 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #include&lt;vector&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 155; const LL INF = 0x3f3f3f3f3f3f3f3f; int n, m, A[MAXN][MAXN], B[MAXN][MAXN], en, hd[3000000 + 5], p[MAXN][MAXN], gg[3000000 + 5]; LL dis[3][3000000 + 5], vis[3000000 + 5]; struct edge {int v, w, nxt;} ed[8000000 + 5]; struct data { int u; LL dis; bool operator &lt; (const data &amp;rhs) const {return dis &gt; rhs.dis;} }; priority_queue&lt;data &gt; q; void ins(int u, int v, int w) {ed[++en] = (edge){v, w, hd[u]}, hd[u] = en;} #define M ((l + r) &gt;&gt; 1) int sz, lc[3000000 + 5], rc[3000000 + 5]; void build(int o, int l, int r, int ln) { if (l == r) p[ln][l] = o; else { build(lc[o] = ++sz, l, M, ln), ins(o, lc[o], 0); build(rc[o] = ++sz, M + 1, r, ln), ins(o, rc[o], 0); } } void lb(int o, int l, int r, int x, int y, int hh, int w) { if (x &lt;= l &amp;&amp; r &lt;= y) ins(hh, o, w); else { if (x &lt;= M) lb(lc[o], l, M, x, y, hh, w); if (M &lt; y) lb(rc[o], M + 1, r, x, y, hh, w); } } void dij(int st, int nmsl) { ms(dis[nmsl], 0x3f), ms(vis, 0); dis[nmsl][st] = 0, q.push((data){st, 0}); while (!q.empty()) { data p = q.top(); q.pop(); if (vis[p.u]) continue ; vis[p.u] = 1; for (int i = hd[p.u]; i &gt;= 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (dis[nmsl][e.v] &gt; dis[nmsl][p.u] + e.w) { dis[nmsl][e.v] = dis[nmsl][p.u] + e.w; q.push((data){e.v, dis[nmsl][e.v]}); } } } } void clean() { en = -1, ms(hd, -1), ms(p, 0), sz = 0; } int solve() { clean(); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) scanf(&quot;%d&quot;, &amp;B[i][j]); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) scanf(&quot;%d&quot;, &amp;A[i][j]); for (int i = 1; i &lt;= n; ++i) build(gg[i] = ++sz, 1, m, i); for (int x = 1; x &lt;= n; ++x) { for (int y = 1; y &lt;= m; ++y) { lb(gg[x], 1, m, max(0, y - B[x][y]), min(m, y + B[x][y]), p[x][y], A[x][y]); for (int i = 1; i &lt;= B[x][y]; ++i) { if (x + i &lt;= n) lb(gg[x + i], 1, m, max(0, y - B[x][y] + i), min(m, y + B[x][y] - i), p[x][y], A[x][y]); if (x - i &gt;= 1) lb(gg[x - i], 1, m, max(0, y - B[x][y] + i), min(m, y + B[x][y] - i), p[x][y], A[x][y]); if (x + i &gt; n &amp;&amp; x - i &lt; 1) break; } } } LL ans = INF; int x_u, y_u, up; int x_v, y_v, vp; int x_w, y_w, wp; scanf(&quot;%d%d%d%d%d%d&quot;, &amp;x_u, &amp;y_u, &amp;x_v, &amp;y_v, &amp;x_w, &amp;y_w); up = p[x_u][y_u], vp = p[x_v][y_v], wp = p[x_w][y_w]; int fl = -1; dij(up, 0); dij(vp, 1); dij(wp, 2); if (dis[0][up] + dis[1][up] + dis[2][up] &lt; ans) ans = dis[0][up] + dis[1][up] + dis[2][up], fl = 0; if (dis[0][vp] + dis[1][vp] + dis[2][vp] &lt; ans) ans = dis[0][vp] + dis[1][vp] + dis[2][vp], fl = 1; if (dis[0][wp] + dis[1][wp] + dis[2][wp] &lt; ans) ans = dis[0][wp] + dis[1][wp] + dis[2][wp], fl = 2; if (ans == INF) return printf(&quot;NO\n&quot;), 0; printf(&quot;%c\n%lld\n&quot;, fl + &#39;X&#39;, ans); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>线段树</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 2118」「国家集训队」墨墨的等式 (同余最短路)]]></title>
    <url>%2Fbzoj2118%2F</url>
    <content type="text"><![CDATA[Bzoj 2118 orz MashiroSky 这题我们设$\text{min}a_i=T$, 则我们只需要去考虑用$n$个数能够组成的数对$T$的模的情况。其他可以用$T$累加倍数得到。因为$T$的灵活性最高。那么设$dis(i)$表示构成的一个数$k$，满足$k \mod T = i$, 且$k$是最小的满足这个条件的数。那么对于询问$x$能否组成，进行分讨$dis(i) \leq x$时，可以拼成而反之则不能。那么我们求出$dis(i)$的值就能解决这题了。考虑最短路模型，设$[0,T)$为点，每个点$i$连到$(i + a_j) \mod T$, 边权为$a_j$，最短路一遍即为答案。对于区间$[\text{Bmin}, \text{Bmax}]$的数，公式求一下即可 知识点：1、同余最短路模型2、最小数的运用 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #include&lt;vector&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL MAXN = 500000 + 5; LL n, bmin, bmax, a[20], T, dis[MAXN], vis[MAXN]; LL en, hd[MAXN]; struct edge {LL v, w, nxt;} ed[MAXN * 20]; struct data { LL u, dis; bool operator &lt; (const data &amp;rhs) const {return dis &gt; rhs.dis;} }; priority_queue&lt;data &gt; q; void ins(LL u, LL v, LL w) {ed[++en] = (edge){v, w, hd[u]}, hd[u] = en;} void clean() { en = -1, ms(hd, -1), ms(dis, 0x3f), ms(vis, 0); } int solve() { clean(); cin &gt;&gt; n &gt;&gt; bmin &gt;&gt; bmax; for (LL i = 1; i &lt;= n; ++i) scanf(&quot;%lld&quot;, &amp;a[i]); sort(a + 1, a + 1 + n), T = a[1]; for (LL i = 0; i &lt; T; ++i) { for (LL j = 1; j &lt;= n; ++j) { ins(i, (i + a[j]) % T, a[j]); } } dis[0] = 0, q.push((data){0, 0}); while (!q.empty()) { data p = q.top(); q.pop(); if (vis[p.u]) continue ; vis[p.u] = 1; for (LL i = hd[p.u]; i &gt;= 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (dis[e.v] &gt; dis[p.u] + e.w) { dis[e.v] = dis[p.u] + e.w; q.push((data){e.v, dis[e.v]}); } } } LL ans = 0; for (LL i = 0; i &lt; T; ++i) { if (dis[i] &gt; bmax) continue ; if (dis[i] &lt; bmin) { LL t = dis[i] + ((bmin - dis[i]) / T + (bool)((bmin - dis[i]) % T)) * T; ans += max(0ll, (bmax - t) / T + 1); } else { ans += max(0ll, (bmax - dis[i]) / T + 1); } } cout &lt;&lt; ans; return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Loj 2652」「Code+1」大吉大利，晚上吃鸡！ (最短路+最短路图DP+Bitset)]]></title>
    <url>%2Floj6252%2F</url>
    <content type="text"><![CDATA[Loj 2652题意：见上。 设$g(i,j)$为$i \to j$的路径条数，那么设$F(i)=g(S,i) \cdot g(i,T)$可以发现第一个条件等价于$F(A)+F(B)=F(T)$的$A,B$第二个条件即$A,B$不为前驱后缀关系 那么第一个条件用一个map优化，第二个条件我们可以求出最短路图，然后传递闭包，bitset优化 第一个条件和第二个条件的可能点的交集即为答案。 知识点：1、Bitset空间 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #include&lt;bitset&gt; #include&lt;map&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 50000 + 5; const LL INF = 0x3f3f3f3f3f3f3f3f; int n, m, S, T; int en_o, hd_o[MAXN], vis_o[MAXN]; int en_z, hd_z[MAXN]; int en_f, hd_f[MAXN]; LL dis[MAXN][2], g[MAXN][2], f[MAXN]; bitset&lt;50001 &gt; bs[50001][2]; map&lt;LL, bitset&lt;50001 &gt; &gt; ma; struct edge {int v, w, nxt;} ed_o[MAXN * 2], ed_z[MAXN * 2], ed_f[MAXN * 2]; struct data { int u; LL dis; bool operator &lt; (const data &amp;rhs) const { return dis &gt; rhs.dis; } }; priority_queue&lt;data &gt; q; void ins_o(int u, int v, int w) {ed_o[++en_o] = (edge){v, w, hd_o[u]}, hd_o[u] = en_o;} void ins_z(int u, int v, int w) {ed_z[++en_z] = (edge){v, w, hd_z[u]}, hd_z[u] = en_z;} void ins_f(int u, int v, int w) {ed_f[++en_f] = (edge){v, w, hd_f[u]}, hd_f[u] = en_f;} void prbs(bitset&lt;50001 &gt; b) {for (int i = 0; i &lt; n; ++i) printf(&quot;%d &quot;, (int)b[i]); puts(&quot;\n&quot;);} void dij(int op) { ms(vis_o, 0); if (op == 0) q.push((data){S, 0}), dis[S][op] = 0, g[S][op] = 1; else q.push((data){T, 0}), dis[T][op] = 0, g[T][op] = 1; while (!q.empty()) { data p = q.top(); q.pop(); if (vis_o[p.u]) continue ; vis_o[p.u] = 1; for (int i = hd_o[p.u]; i &gt;= 0; i = ed_o[i].nxt) { edge &amp;e = ed_o[i]; if (dis[e.v][op] &gt; dis[p.u][op] + e.w) { dis[e.v][op] = dis[p.u][op] + e.w; g[e.v][op] = 1; q.push((data){e.v, dis[e.v][op]}); } else if (dis[e.v][op] == dis[p.u][op] + e.w) g[e.v][op] += g[p.u][op]; } } } void csdag(int u) { for (int i = hd_o[u]; i &gt;= 0; i = ed_o[i].nxt) { edge &amp;e = ed_o[i]; if (dis[e.v][0] == dis[u][0] + e.w) { if (dis[e.v][0] + dis[e.v][1] == dis[T][0]) { ins_z(u, e.v, e.w); ins_f(e.v, u, e.w); vis_o[e.v] = 1; csdag(e.v); } } } } void dp_z(int u) { if (vis_o[u]) return ; vis_o[u] = 1; for (int i = hd_z[u]; i &gt;= 0; i = ed_z[i].nxt) { edge &amp;e = ed_z[i]; dp_z(e.v); bs[u][0] |= bs[e.v][0]; } } void dp_f(int u) { if (vis_o[u]) return ; vis_o[u] = 1; for (int i = hd_f[u]; i &gt;= 0; i = ed_f[i].nxt) { edge &amp;e = ed_f[i]; dp_f(e.v); bs[u][1] |= bs[e.v][1]; } } void clean() { ms(hd_o, -1), en_o = -1; ms(hd_z, -1), en_z = -1; ms(hd_f, -1), en_f = -1; ms(dis, 0x3f), ms(g, 0); } int solve() { clean(); cin &gt;&gt; n &gt;&gt; m &gt;&gt; S &gt;&gt; T; for (int u, v, w, i = 1; i &lt;= m; ++i) { scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); ins_o(u, v, w), ins_o(v, u, w); } dij(0), dij(1); if (dis[T][0] == INF) { return printf(&quot;%lld\n&quot;, 1ll * n * (n - 1) / 2); } vis_o[S] = 1, ms(vis_o, 0); csdag(S); /*for (int u = 1; u &lt;= n; ++u) {printf(&quot;u=%d\n&quot;, u);for (int i = hd_z[u]; i &gt;= 0; i = ed_z[i].nxt) {printf(&quot;%d &quot;, ed_z[i].v);}}*/ for (int u = 0; u &lt; n; ++u) bs[u + 1][0][u] = bs[u + 1][1][u] = 1; ms(vis_o, 0); dp_z(S); ms(vis_o, 0); dp_f(T); for (int u = 1; u &lt;= n; ++u) { if (dis[u][0] + dis[u][1] == dis[T][0]) f[u] = g[u][0] * g[u][1]; ma[f[u]].set(u - 1); } LL ans = 0; for (int u = 1; u &lt;= n; ++u) { //if (dis[u][0] + dis[u][1] != dis[T][0]) continue ; /*printf(&quot;u=%d\n&quot;, u); puts(&quot;fir&quot;); prbs(ma[f[T] - f[u]]); puts(&quot;sec&quot;); prbs(~bs[u][0]); puts(&quot;third&quot;); prbs(~bs[u][1]);*/ ans += (ma[f[T] - f[u]] &amp; (~bs[u][0]) &amp; (~bs[u][1])).count(); } cout &lt;&lt; ans / 2; return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Loj</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>bitset</tag>
        <tag>最短路</tag>
        <tag>Loj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 24D(期望DP + 高斯消元)]]></title>
    <url>%2FCodeforces24D%2F</url>
    <content type="text"><![CDATA[Codeforces 24D给你一个$n×m$的棋盘，你初始在$(x,y)$，每一步等概率不动、向左、向下或向右走（如果向左走会越界则该步等概率不动、向右、向下走，向右会越界同理, 走到最后一行就结束, 问从开始到结束的期望步数 很容易设出方程$f[i][j]$表示从$(i,j)$走到最后一行的期望步数 $$\begin{align}f[i][1]&amp;=\frac{1}{3}(f[i][1]+f[i][2]+f[i+1][1])+1, j=1\\f[i][m]&amp;=\frac{1}{3}(f[i][m]+f[i][m-1]+f[i+1][m])+1, j=m \\f[i][j]&amp;=\frac{1}{4}(f[i][j]+f[i][j-1]+f[i][j+1]+f[i+1][j])+1, 2 \leq j \leq n - 1\\\end{align}$$ 初始化$f[n][j]=0$ 那么我们发现这个方程是有后效性的。 其实行与行之间还是有无后效性的，但是列之间不满足。 考虑整理化简。我们将$f[i+1][]$看作常数，那么可以列一个方程组解出所有的$f[i][]$ 即化成$a \cdot f[i][j] +b \cdot f[i][j - 1] + c \cdot f[i][j +1]=d+e \cdot f[i + 1][]$的形式 那么我们可以高斯消元解出来。 我们发现这里的每列最多三个有值，那么我们可以用特殊方法来求值，这里用倒三角的矩阵好做点，比直接求出简化阶梯矩阵好求，具体看代码 然后注意特判$m=1$即可，也可以直接输出$2n-1$，具体可以从高斯消元来推导，然后递推式转成封闭形式 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;map&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 1000 + 5; db dp[MAXN][MAXN], M[MAXN][MAXN]; int n, m, x, y; void gauss() { for (int i = 1; i &lt;= m; ++i) { // M[][m+1] 是常数项 db tmp = 1.0 / M[i][i]; M[i][i] *= tmp, M[i][m + 1] *= tmp; if (i == m) break ; M[i][i + 1] *= tmp; tmp = M[i + 1][i] / M[i][i]; M[i + 1][i] -= tmp * M[i][i], M[i + 1][i + 1] -= tmp * M[i][i + 1], M[i + 1][m + 1] -= tmp * M[i][m + 1]; // 倒三角矩阵 } for (int i = m - 1; i &gt; 0; --i) M[i][m + 1] -= M[i + 1][m + 1] * M[i][i + 1]; // 逐一将后面的回代 } void clean() { } int solve() { clean(); cin &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y; for (int i = n - 1; i &gt;= x; --i) { M[1][1] = -2.0 / 3.0; M[1][2] = 1.0 / 3.0; M[1][m + 1] = -1.0 - 1.0 / 3.0 * dp[i + 1][1]; M[m][m] = -2.0 / 3.0; M[m][m - 1] = 1.0 / 3.0; M[m][m + 1] = -1.0 - 1.0 / 3.0 * dp[i + 1][m]; for (int j = 2; j &lt; m; ++j) { M[j][j - 1] = M[j][j + 1] = 1.0 / 4.0; M[j][j] = -3.0 / 4.0; M[j][m + 1] = -1.0 / 4.0 * dp[i + 1][j] - 1.0; } if (m == 1) { M[1][1] = -1.0 / 2.0; M[1][m + 1] = -1.0 / 2.0 * dp[i + 1][1] - 1; } gauss(); for (int j = 1; j &lt;= m; ++j) dp[i][j] = M[j][m + 1]; //for (int j = 1; j &lt;= m; ++j, puts(&quot;&quot;)) //for (int k = 1; k &lt;= m; ++k) printf(&quot;%.2f &quot;, M[j][k]); } printf(&quot;%.8f\n&quot;, dp[x][y]); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>概率DP</tag>
        <tag>Codeforces</tag>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 5290」「Hnoi2018」道路 (树形DP+卡空间)]]></title>
    <url>%2Fbzoj5290%2F</url>
    <content type="text"><![CDATA[BZOJ 5290题意：见上。一开始没看见必须选边…然后发现是树形DP然后打……之后发现我写假了我们直接设$dp(u,i,j)$为$u$到根经过$i$条绿边，$j$条红边的最小代价那么转移即$$dp[u][i][j] = \min(dp[lc[u]][i][j] + dp[rc[u]][i][ + 1], dp[lc[u]][i + 1][j] + dp[rc[u]][i][j])$$ 然后这题一个精髓是卡空间方法，我们维护一个dfn，然后每次存两个孩子的值即可，具体可看代码。 知识点1、dfn卡空间方法 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;map&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL MAXN = 40000 + 5, INF = 1e16; LL grn[MAXN], red[MAXN], dp[105][55][55]; LL n, dfn[MAXN]; LL a[MAXN], b[MAXN], c[MAXN]; void dfs(LL u, LL now) { dfn[u] = now; // 卡空间 if (u &gt; n - 1) { for (LL i = 0; i &lt;= 41; ++i) for (LL j = 0; j &lt;= 41; ++j) dp[dfn[u]][i][j] = c[u] * (a[u] + i) * (b[u] + j); return ; } dfs(red[u], now + 1), dfs(grn[u], now + 2); // 卡空间 for (LL i = 0; i &lt;= 41; ++i) for (LL j = 0; j &lt;= 41; ++j) { dp[dfn[u]][i][j] = min(dp[dfn[grn[u]]][i][j] + dp[dfn[red[u]]][i][j + 1], dp[dfn[grn[u]]][i + 1][j] + dp[dfn[red[u]]][i][j]); } } void clean() { ms(red, 0), ms(grn, 0); for (int i = 0; i &lt;= 101; ++i) for (int j = 0; j &lt;= 51; ++j) for (int k = 0; k &lt;= 51; ++k) dp[i][j][k] = INF; } int solve() { clean(); cin &gt;&gt; n; for (LL s, t, i = 1; i &lt; n; ++i) { scanf(&quot;%lld%lld&quot;, &amp;s, &amp;t); if (s &lt; 0) s = -s + n - 1; if (t &lt; 0) t = -t + n - 1; grn[i] = s, red[i] = t; } for (LL i = 1; i &lt;= n; ++i) scanf(&quot;%lld%lld%lld&quot;, &amp;a[i + n - 1], &amp;b[i + n - 1], &amp;c[i + n - 1]); dfs(1, 1); LL ans = INF; for (LL i = 0; i &lt;= 41; ++i) for (LL j = 0; j &lt;= 41; ++j) ans = min(ans, dp[dfn[1]][i][j]); cout &lt;&lt; ans; return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spoj GSS - Can you answer these queries]]></title>
    <url>%2Fspoj-GSS%2F</url>
    <content type="text"><![CDATA[Spoj GSS 系列…. GSS 1线段树最长字段和裸题 GSS 2题意：给出$n$个数，$q$次询问求$[l,r]$最大子段和，相同的数只算一次。 线段树离线好题考虑这题相同的数只算一次，也就是颜色问题，我们可以从颜色思考，可以发现能离线。我们将询问按右端点排序，然后从左到右扫描到$i​$，然后线段树每个节点$j​$记录$\text{sum}(j)=\sum\limits_{j + 1 \leq k \leq i} a_k​$，即我们维护的线段树每个节点都是区间$[j+1,i]​$的值，我们维护的线段树实际上是区间套上了区间。 先不考虑颜色不同的情况，我们每次扫描到$i$更新，相当于是在线段树上$[1,i]$更新，然后处理$r=i$的询问，答案显然是$\max\limits_{l \leq j \leq r} (\text{sum}(j))$，但是好像不太正确，因为不一定右端点在$r$最优。所以我们要记录整个过程中的最大值 (历史最大值)。 考虑维护 max_now, 当前区间$\max \text{sum}(j)$ lazy_now,当前区间更新标记 max_old, 当前区间历史最大值 lazy_old,当前区间历史最大更新标记 now的就按照常规线段树维护最大值的方法来更新 然后update时 lazy_now[o] += v; max_now[o] += v; // now 按照常规线段树维护最大值的方法来更新 chkmax(lazy_old[o], lazy_now[o]); chkmax(max_old[o], max_now[o]); // 更新历史最优值 pushdown时 chkmax(max_old[lc], max_now[lc] + lazy_old[o]); chkmax(max_old[rc], max_now[rc] + lazy_old[o]); chkmax(lazy_old[lc], lazy_now[lc] + lazy_old[o]); chkmax(lazy_old[rc], lazy_now[rc] + lazy_old[o]); // 更新历史最优值 max_now[lc] += lazy_now[o]; max_now[rc] += lazy_now[o]; lazy_now[lc] += lazy_now[o]; lazy_now[rc] += lazy_now[o]; // now 按照常规线段树维护最大值的方法来更新 lazy_now[o] = lazy_old[o] = 0; 值得注意的是，为什么我们用lazy_now[rc] + lazy_old[o], max_now[rc] + lazy_old[o]而不是都用old。因为这样会导致最大字段和不连续。 比如说有$4$个数是2 -1 -3 1执行这个命令就相当于把$2$加进去的时候lazy_old[1]=2,然后加$-1$和$-3$的时候lazy_old[1]不会更新，把$1$加进去的时候又会更新lazy_old[1]=2+1=3，此时，就相当于把$2$和$1$加起来了而没有加上$-1$和$-3$，不再是一个连续的区间！ 如果考虑去重的话，那么每个数字记录他前一个出现在$\text{pre}_i$，然后每次更新$[\text{pre}_i + 1, i]$即可 知识点 1、线段树记得开4倍空间2、离线1、右端点排序、2、记录前驱颜色3、线段树叶子节点记录位置$\to$当前扫描位置的值4、历史最优值的记录 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #include&lt;vector&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL MAXN = 100000 + 5, BS = 100000; LL chkmax(LL &amp;x, LL y) {return x = (x &gt; y) ? x : y;} LL chkmin(LL &amp;x, LL y) {return x = (x &lt; y) ? x : y;} LL n, Q, a[MAXN], tax[MAXN * 2], pre[MAXN], ans[MAXN]; struct qry { LL l, r, id; bool operator &lt; (const qry &amp;rhs) const {return r &lt; rhs.r;} } xw[MAXN]; #define M ((l + r) &gt;&gt; 1) #define lc (o &lt;&lt; 1) #define rc (o &lt;&lt; 1 | 1) #define ls lc, l, M #define rs rc, M + 1, r LL max_now[MAXN * 4], lazy_now[MAXN * 4], max_old[MAXN * 4], lazy_old[MAXN * 4]; void pushup(LL o) { max_now[o] = max(max_now[lc], max_now[rc]); max_old[o] = max(max_old[lc], max_old[rc]); } void pushdown(LL o) { chkmax(max_old[lc], max_now[lc] + lazy_old[o]); chkmax(max_old[rc], max_now[rc] + lazy_old[o]); chkmax(lazy_old[lc], lazy_now[lc] + lazy_old[o]); chkmax(lazy_old[rc], lazy_now[rc] + lazy_old[o]); // 更新历史最优值 max_now[lc] += lazy_now[o]; max_now[rc] += lazy_now[o]; lazy_now[lc] += lazy_now[o]; lazy_now[rc] += lazy_now[o]; // now 按照常规线段树维护最大值的方法来更新 lazy_now[o] = lazy_old[o] = 0; } void update(LL o, LL l, LL r, LL x, LL y, LL v) { if (x &lt;= l &amp;&amp; r &lt;= y) { lazy_now[o] += v; max_now[o] += v; // now 按照常规线段树维护最大值的方法来更新 chkmax(lazy_old[o], lazy_now[o]); chkmax(max_old[o], max_now[o]); // 更新历史最优值 return ; } pushdown(o); if (x &lt;= M) update(ls, x, y, v); if (M &lt; y) update(rs, x, y, v); pushup(o); } LL query(LL o, LL l, LL r, LL x, LL y) { if (x &lt;= l &amp;&amp; r &lt;= y) return max_old[o]; pushdown(o); LL ret = 0; if (x &lt;= M) chkmax(ret, query(ls, x, y)); if (M &lt; y) chkmax(ret, query(rs, x, y)); return ret; } void clean() { } int solve() { clean(); cin &gt;&gt; n; for (LL i = 1; i &lt;= n; ++i) { scanf(&quot;%lld&quot;, &amp;a[i]); pre[i] = tax[a[i] + BS], tax[a[i] + BS] = i; } cin &gt;&gt; Q; for (LL i = 1; i &lt;= Q; ++i) scanf(&quot;%lld%lld&quot;, &amp;xw[i].l, &amp;xw[i].r), xw[i].id = i; sort(xw + 1, xw + 1 + Q); LL j = 1; for (LL i = 1; i &lt;= n; ++i) { update(1, 1, n, pre[i] + 1, i, a[i]); while (j &lt;= Q &amp;&amp; xw[j].r &lt;= i) ans[xw[j].id] = query(1, 1, n, xw[j].l, xw[j].r), ++j; } for (LL i = 1; i &lt;= Q; ++i) printf(&quot;%lld\n&quot;, ans[i]); return 0; } } int main() { flyinthesky::solve(); return 0; } GSS 3同 GSS 1 GSS 4同 Bzoj 3211 GSS 5GSS 6GSS 7GSS 8]]></content>
      <categories>
        <category>spoj</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>spoj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1492」「NOI2006」货币兑换 (斜率优化DP+CDQ分治维护凸包)]]></title>
    <url>%2Fbzoj1492%2F</url>
    <content type="text"><![CDATA[BZOJ 1492题意：金券交易所可以对$A 、B$两种金券进行交易。接下来的$N$天内，第$i$天$A、B$分别具有单位价值$A_i,B_i$,每一天用户进行若干次如下操作:1、卖出所有的金券2、用所有的钱买入等价值的金券，买入的$A、 B$两种金券的比例为$\text{Rate}_i$初始时用户拥有$S$元钱，问$N$天后用户最多拥有多少钱? 可以证明每次一定全卖或者全买，不严谨证明是有利可图就尽量做，否则就不做。 具体证明即设有$S$元钱，我们设卖出单位收益为$p$, 不卖单位收益为$q$，卖出比例$x$, 则收益为$S \cdot x \cdot p + S \cdot (1 - x) \cdot q=S(x(p-q)+ q)​$当$p-q \geq 0$时，取$x=1$有最大值当$p-q \leq 0$时，取$x=0$有最大值所以得证。 那么设$f(i)$为前$i$天的最大收益。则$$f(i)=\max_\limits{1 \leq j \leq i-1}(f(i-1),A_ix_j+B_iy_j)$$其中$x_j, y_j$为最多能买到的$A,B$劵数量。由$$\begin{cases}f(j)=x_iA_j+y_iB_j \\\frac{x_j}{y_j}=\text{Rate}_j\end{cases}$$可算出$x_i, y_j$的值。那么考虑斜率优化，我们可以得到$$y_j=-\frac{A_i}{B_i}x_j+\frac{f(i)}{B_i}$$但是这里$x​$和斜率都不单调怎么办？考虑动态维护上凸包。可以用平衡树来维护，即每次插入一个决策点，如果这个决策点和它$x​$最近两个点连后形成下凸，则不用加这个决策点，否则向左找到一个最远的能形成凸包的，右边同理，然后将这两个点之间所有决策点删除，插入这个决策点，形成新的上凸包。可以用Splay来维护，也可以用Set 因为一个位置的决策集合是它前面的点，所以我们可以考虑CDQ分治。具体步骤为 若$l=r$则返回。把左区间按编号把$≤mid$的分到左边，大于$mid$的分到右边。分治左区间CDQ(l,mid)。此时左区间横坐标有序，右区间斜率有序，所以用单调队列斜率优化DP。分治右区间CDQ(mid+1,r)。按$x$归并排序。 即左边构造好上凸包，用来更新右边的答案 有序情况具体情况如下 进入 CDQ(l, M) CDQ(M + 1, r) 合并 左区间 $k$ $x$ $x$ $x$ 右区间 $k$ $k$ $x$ $x$ 所有 $k$ 无 无 $x$ 1、注意斜率不存在时INF的正负。2、注意CDQ分治时q[i].id与i的区别 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #include&lt;vector&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 100000 + 5; const db eps = 1e-10, INF = 1e17; int n, st[MAXN], top; db dp[MAXN]; struct data { int id; db a, b, r, k, x, y; bool operator &lt; (const data &amp;rhs) const { return k &lt; rhs.k; } } q[MAXN], tmp[MAXN]; db getK(int a, int b) {return fabs(q[a].x - q[b].x) &lt;= eps ? (q[a].y &lt; q[b].y ? -INF : INF) : (q[a].y - q[b].y) / (q[a].x - q[b].x);} void CDQ(int l, int r) { if (l == r) { // [1, l - 1]处理完毕 dp[l] = max(dp[l], dp[l - 1]); q[l].y = dp[l] / (q[l].a * q[l].r + q[l].b); q[l].x = q[l].y * q[l].r; return ; } int mid = (l + r) &gt;&gt; 1; int t1 = l, t2 = mid + 1; for (int i = l; i &lt;= r; ++i) { // 分区间 if (q[i].id &lt;= mid) { tmp[t1++] = q[i]; } else tmp[t2++] = q[i]; } for (int i = l; i &lt;= r; ++i) q[i] = tmp[i]; CDQ(l, mid); top = 0; for (int i = l; i &lt;= mid; ++i) { // 构造上凸包 while (top &gt;= 2 &amp;&amp; getK(i, st[top]) - getK(st[top], st[top - 1]) &gt;= eps) --top; st[++top] = i; } for (int i = mid + 1; i &lt;= r; ++i) { // 求值 while (top &gt;= 2 &amp;&amp; getK(st[top], st[top - 1]) - q[i].k &lt;= eps) --top; int j = st[top]; dp[q[i].id] = max(dp[q[i].id], q[i].a * q[j].x + q[i].b * q[j].y); } CDQ(mid + 1, r); t1 = l, t2 = mid + 1; int cnt = 0; while (t1 &lt;= mid || t2 &lt;= r) { // 按x归并 if (t2 &gt; r || (t1 &lt;= mid &amp;&amp; q[t1].x &lt;= q[t2].x)) { tmp[++cnt] = q[t1++]; } else { tmp[++cnt] = q[t2++]; } } for (int i = l; i &lt;= r; ++i) q[i] = tmp[i - l + 1]; } void clean() { } int solve() { clean(); scanf(&quot;%d%lf&quot;, &amp;n, &amp;dp[0]); for (int i = 1; i &lt;= n; ++i) { scanf(&quot;%lf%lf%lf&quot;, &amp;q[i].a, &amp;q[i].b, &amp;q[i].r); q[i].k = -q[i].a / q[i].b, q[i].id = i; } sort(q + 1, q + 1 + n); CDQ(1, n); printf(&quot;%.7f\n&quot;, dp[n]); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>斜率优化</tag>
        <tag>CDQ分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[prufer序列 学习笔记]]></title>
    <url>%2FszPrufer%2F</url>
    <content type="text"><![CDATA[模板及讲解定义$Prufer$数列是无根树的一种数列。在组合数学中，$Prufer$数列由有一个对于顶点标过号的树转化来的数列，点数为n的树转化来的$Prufer$数列长度为$n-2$。它可以通过简单的迭代方法计算出来。 将树转换为$prufer$序列总体的思路是迭代删点，直到原图中只剩下两个点。对于一棵树$T$,我们已经将每次找到树中标号最小的叶子结点，将这个叶子结点以及与它相邻的边删去，将与叶子结点相连的点加入数列中。重复上一步，直到原图中只剩下两个点。 将$prufer$序列转换为树将结点列一个集合$A=(1，2，\dots ,n)$在集合$A$中找出一个没有在$prufer$数列中出现的最小的值，将这个值在集合$A$中删去，并且将这个值和$prufer$数列中的第一个数连起一条边，并划去$prufer$数列中的第一个值，重复此步，直到集合$A$中只剩下两个数字，将以这两个数字为编号的结点连起一条边。 应用1、无根树和$prufer$数列是唯一对应的2、一个点的度数为$d$，那么这个点在$prufer$序列中的出现次数为$d−1$, bzoj 12113、一个完全图$K_n$有$n^{n-2}$棵生成树，换句话说$n$个节点的带标号的无根树有$n^{n-2}$个。(Cayley公式, bzoj 1430) 对3的证明，显然一个$n-2$长的$prufer$序列对应唯一一棵无根树，那么所有$prufer$序列的个数是$n^{n-2}$]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>算法笔记</tag>
        <tag>prufer序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 2006」「Noi2010」超级钢琴 (堆 / 主席树+堆)]]></title>
    <url>%2Fbzoj2006%2F</url>
    <content type="text"><![CDATA[BZOJ 2006题意：求序列区间和前$k$大的和。 我题意转化得不好。。我转化成求序列$k$个可重区间和的和，没有体现出本题的贪心思想然后我们可以发现固定了区间的左端点，那么他的右端点是有固定取值集合的，即$[i+L-1, \min(i+R-1, n)], i+L-1 \leq n$那么我们先把所有左端点的右端点取值集合弄出来，用ST表维护最大的右端点前缀和，那么这个区间就是最大值的候选答案，加到堆里然后每次从堆中取出一个区间，加上和以后，删掉这个最优的右端点，继续放进堆作候选答案 当然也可以主席树来做，即每次更新就将那颗树的右端点位置赋值为无穷大，然后这个点不会再影响答案，线段树维护区间最大值即可。或者直接查询$k$大 知识点1、左端点的取值集合运用2、区间和——前缀和 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #include&lt;vector&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL MAXN = 500000 + 5; const LL LOGS = 20; LL n, k, L, R, a[MAXN], st[MAXN][LOGS + 1]; LL mymin(LL x, LL y) {return a[x] &gt; a[y] ? x : y;} LL query(LL l, LL r) { LL k = log2(r - l + 1); return mymin(st[l][k], st[r - (1 &lt;&lt; k) + 1][k]); } struct data { LL l, r, u, v; data(LL xl, LL xr, LL xu) { l = xl, r = xr, u = xu, v = query(l, r); } bool operator &lt; (const data &amp;rhs) const {return a[v] - a[u] &lt; a[rhs.v] - a[rhs.u];} }; priority_queue&lt;data &gt; q; void clean() { } int solve() { clean(); cin &gt;&gt; n &gt;&gt; k &gt;&gt; L &gt;&gt; R; for (LL i = 1; i &lt;= n; ++i) scanf(&quot;%lld&quot;, &amp;a[i]), a[i] += a[i - 1], st[i][0] = i; for (LL j = 1; (1 &lt;&lt; j) &lt;= n; ++j) { for (LL i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i) { st[i][j] = mymin(st[i][j - 1], st[i + (1 &lt;&lt; (j - 1))][j - 1]); } } for (LL l = 1; l &lt;= n; ++l) if (l + L - 1 &lt;= n) { data p(l + L - 1, min(l + R - 1, n), l - 1); q.push(p); } LL ans = 0; for (LL i = 1; i &lt;= k; ++i) { data u = q.top(); q.pop(); ans += a[u.v] - a[u.u]; data p1(u.l, u.v - 1, u.u); data p2(u.v + 1, u.r, u.u); if (u.l &lt;= u.v - 1) q.push(p1); if (u.v + 1 &lt;= u.r) q.push(p2); } cout &lt;&lt; ans; return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>堆</tag>
        <tag>Bzoj</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 4542」「HNOI2016」大数 (莫队 + 前缀和技巧)]]></title>
    <url>%2Fbzoj4542%2F</url>
    <content type="text"><![CDATA[BZOJ 4542题意：给定一个数字串，询问一些区间组成的数(可含前导零)是否是给定$p​$的倍数。 显然前缀和取余来做。然后刚开始我是想莫队+map，即存前缀和，用公式算出个数，但是这非常麻烦。。我们可以发现前缀和取余以后，前缀和余数相同，则之间的区间和是模数的倍数那么我们直接维护前缀和序列的相同数对个数即可，莫队裸题。。具体证明我们可以设$\text{sum}(i)$为后缀和($[i,n]$表示数)，那么数字即为$\frac{\text{sum}(i) - \text{sum}(j+1)}{10^{n-i}}$设$[l,r]$表示的数为$\text{num}(l,r)≡\frac{\text{sum}(l)-\text{sum}(r+1)}{10^{r-l+1}}\pmod p$区间能够被$p$整除当且仅当$\frac{\text{sum}(i) - \text{sum}(j+1)}{10^{n-i}} \equiv \text{num}(l,r)\pmod p $即$\text{sum}(i) - \text{sum}(j+1) \equiv \text{num}(l,r) \cdot 10^{n-i}\pmod p $ 显然$10^{n-i}$与$p$互质，那么这个当$\text{sum}(i)=\text{sum}(j+1)$时，可以确定他们同余 满足条件是$\gcd(p, 10)=1$，所以要特判$p=2,p=5$的情况，具体可以看代码的方法。 注意$r+1$取值为0，要把0加入离散化 知识点1、前缀和余数相同，则之间的区间和是模数的倍数 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #include&lt;vector&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL MAXN = 100000 + 5; LL p, n, m, blolen, bl[MAXN], s[MAXN], ls[MAXN], nl, nr, nans, ans[MAXN], pre[MAXN], qwq[MAXN]; char ch[MAXN]; struct qry { LL l, r, id; bool operator &lt; (const qry &amp;rhs) const { return bl[l] == bl[rhs.l] ? r &lt; rhs.r : bl[l] &lt; bl[rhs.l]; } } xw[MAXN]; LL tax[MAXN]; void update(int x, int v) { nans -= tax[s[x]] * (tax[s[x]] - 1) / 2; tax[s[x]] += v; nans += tax[s[x]] * (tax[s[x]] - 1) / 2; } void clean() { } int solve() { clean(); cin &gt;&gt; p; scanf(&quot;%s&quot;, ch + 1); n = strlen(ch + 1); blolen = (LL)sqrt(n); for (LL i = 1; i &lt;= n; ++i) bl[i] = (i - 1) / blolen + 1; LL tmp = 1; for (LL i = n; i &gt;= 1; --i) { s[i] = (s[i + 1] + tmp * (ch[i] - &#39;0&#39;) % p) % p, ls[i] = s[i]; tmp = (tmp * 10) % p; } ls[n + 1] = 0; sort(ls + 1, ls + 1 + n + 1); tmp = unique(ls + 1, ls + 1 + n + 1) - ls - 1; for (LL i = 1; i &lt;= n + 1; ++i) s[i] = lower_bound(ls + 1, ls + 1 + tmp, s[i]) - ls; cin &gt;&gt; m; for (LL i = 1; i &lt;= m; ++i) scanf(&quot;%lld%lld&quot;, &amp;xw[i].l, &amp;xw[i].r), xw[i].id = i; if (p == 2 || p == 5) { for (LL i = 1; i &lt;= n; ++i) { pre[i] = pre[i - 1], qwq[i] = qwq[i - 1]; if ((ch[i] - &#39;0&#39;) % p == 0) pre[i] += i, qwq[i]++; } for (LL i = 1; i &lt;= m; ++i) printf(&quot;%lld\n&quot;, pre[xw[i].r] - pre[xw[i].l - 1] - (qwq[xw[i].r] - qwq[xw[i].l - 1]) * (xw[i].l - 1)); return 0; } for (LL i = 1; i &lt;= m; ++i) ++xw[i].r; sort(xw + 1, xw + 1 + m); nl = 1, nr = 0, nans = 0; for (LL i = 1; i &lt;= m; ++i) { while (nl &gt; xw[i].l) update(nl - 1, 1), --nl; while (nr &lt; xw[i].r) update(nr + 1, 1), ++nr; while (nl &lt; xw[i].l) update(nl, -1), ++nl; while (nr &gt; xw[i].r) update(nr, -1), --nr; ans[xw[i].id] = nans; } for (LL i = 1; i &lt;= m; ++i) printf(&quot;%lld\n&quot;, ans[i]); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>前缀和</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 4552」「HEOI2016/TJOI2016」排序 (线段树合并分裂 + Set / 二分 + 线段树)]]></title>
    <url>%2Fbzoj4552%2F</url>
    <content type="text"><![CDATA[BZOJ 4552题意：给出一个$1$到$n$的全排列，现在对这个全排列序列进行$m$次局部排序，排序分为两种：$1:(0,l,r)$表示将区间$[l,r]$的数字升序排序$2:(1,l,r)$表示将区间$[l,r]$的数字降序排序最后询问第$q$位置上的数字。 方法一只有一个位置，我们可以二分这个上面的数是多少。考虑将数的排序转化为二进制数$01$的排序。因为二进制数$01$的排序只需要升序将所有$0$放在$1$前，降序反之。那么我们怎么将数转化成这个呢，我们考虑大于二分值的数赋值为$1$, 否则为$0$，对询问离线，线段树辅助$01$数排序，求出最后的结果，然后如果$q$上是$1$，说明当前二分值小了，否则大了。线段树排序$01$数即查询区间$01$个数，再区间修改本方法难想但是代码好写。 方法二考虑直接模拟题目的过程，我们可以将原来的每个数变成孤立的每个点，那么每次排序都会合并一系列点，并且此时还可能需要分裂。我们考虑一个支持合并、按前$k$大分裂的权值线段树。用一个$\text{Set}(l,r,nd,op)$来维护区间合并情况，即记录$[l,r]$的根在$nd$, 是升序还是降序，然后分裂时二分找出来后处理即可。具体可以看代码实现。这里体现了数据结构互相辅助的优势。本方法好想，但是代码难写。本题为了训练线段树分裂，我写了方法二的代码。 本文借鉴于 HEOI2016/TJOI2016 排序 解题报告（二分答案/线段树分裂合并+set） - 星星之火OIer - 博客园 知识点1、将数的排序转化为二进制数$01$的排序的方法 (用于二分)。2、数据结构互相辅助的优势。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #include&lt;vector&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 100000 + 5; int n, m, a[MAXN]; struct data { // set 记录节点 int l, r, nd, op; // 区间，根，是降序还是升序 bool operator &lt; (const data &amp;rhs) const {return r == rhs.r ? l &lt; rhs.l : r &lt; rhs.r;} }; namespace seg { #define M ((l + r) &gt;&gt; 1) int sz, lc[MAXN * 60], rc[MAXN * 60], sumv[MAXN * 60]; void update(int l, int r, int &amp;now, int x) { // 加一个值 if (!now) now = ++sz; ++sumv[now]; if (l == r) return ; if (x &lt;= M) update(l, M, lc[now], x); else update(M + 1, r, rc[now], x); } int kth(int l, int r, int now, int k) { // 找 k 大 if (l == r) return l; int whw = sumv[lc[now]]; if (k &lt;= whw) return kth(l, M, lc[now], k); else return kth(M + 1, r, rc[now], k - whw); } void split(int l, int r, int now, int &amp;res, int k) { // 按 k 大将小于等于 k 的分到 res 里，其他留在 now 里 if (!now) return ; if (!res) res = ++sz; if (l == r) {sumv[now] -= k, sumv[res] += k; return ;} int whw = sumv[lc[now]]; if (whw &gt; k) split(l, M, lc[now], lc[res], k); else if (whw == k) lc[res] = lc[now], lc[now] = 0; else if (whw &lt; k) { lc[res] = lc[now], lc[now] = 0; split(M + 1, r, rc[now], rc[res], k - whw); } // 和 kth 差不多 sumv[now] = sumv[lc[now]] + sumv[rc[now]]; sumv[res] = sumv[lc[res]] + sumv[rc[res]]; // pushup } int merge(int &amp;x, int y) { // 合并两个线段树 if (x == 0) return x = y; if (y == 0) return 0; sumv[x] += sumv[y]; return merge(lc[x], lc[y]), merge(rc[x], rc[y]); } } namespace S { set&lt;data &gt; s; int split(int l, int r) { // 将 [l, r] 分出来使得 set 里有这个区间，返回这个区间的根 set&lt;data &gt;::iterator it = s.lower_bound((data){0, l, 0, 0}); if (it-&gt;l != l) { // l 在 *it 区间里 data whw = *it; s.erase(it); int gg = 0; if (whw.op == 1) { // 降序 seg::split(1, n, whw.nd, gg, whw.r - l + 1); s.insert((data){whw.l, l - 1, whw.nd, 1}); s.insert((data){l, whw.r, gg, 1}); } else { // 增序 seg::split(1, n, whw.nd, gg, l - whw.l); s.insert((data){whw.l, l - 1, gg, 0}); s.insert((data){l, whw.r, whw.nd, 0}); } } it = s.lower_bound((data){0, r, 0, 0}); if (it-&gt;r != r) { // r 在 *it 区间里 data whw = *it; s.erase(it); int gg = 0; if (whw.op == 1) { // 降序 seg::split(1, n, whw.nd, gg, whw.r - r); s.insert((data){whw.l, r, whw.nd, 1}); s.insert((data){r + 1, whw.r, gg, 1}); } else { // 增序 seg::split(1, n, whw.nd, gg, r - whw.l + 1); s.insert((data){whw.l, r, gg, 0}); s.insert((data){r + 1, whw.r, whw.nd, 0}); } } int ret = 0; while (1) { // 将刚刚分出来的区间合成一个 it = s.lower_bound((data){0, l, 0, 0}); if (it == s.end() || it-&gt;r &gt; r) break ; // seg::merge(ret, it-&gt;nd); s.erase(it); } return ret; } } void clean() { } int solve() { clean(); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) { scanf(&quot;%d&quot;, &amp;a[i]); int x = 0; seg::update(1, n, x, a[i]); S::s.insert((data){i, i, x, 0}); } for (int op, l, r, i = 1; i &lt;= m; ++i) { scanf(&quot;%d%d%d&quot;, &amp;op, &amp;l, &amp;r); int x = S::split(l, r); S::s.insert((data){l, r, x, op}); // 记得将整个区间加到 set 里 } int p; scanf(&quot;%d&quot;, &amp;p); int x = S::split(p, p); printf(&quot;%d\n&quot;, seg::kth(1, n, x, 1)); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>线段树</tag>
        <tag>STL</tag>
        <tag>二分</tag>
        <tag>线段树合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 4540」「HNOI2016」序列 (莫队 / 扫描线)]]></title>
    <url>%2Fbzoj4540%2F</url>
    <content type="text"><![CDATA[BZOJ 4540题意：$m$ 组询问区间$[L,R]$的所有子区间的最小值的和。 第一种思路是用莫队，考虑加入后加入位置对当前答案贡献设$s_i$表示所有以$i$为右端点的答案具体方法见其他题解 第二种方法就是考虑将一个位置$i$左边第一个小于$i$记为$L_i$，右边第一个小于$i$记为$R_i$那么左端点在$[L_i+1,i]$，右端点在$[i, R_i-1]$的区间最小值都是$a_i$我们将左端点右端点分别映射到二维平面的横坐标纵坐标，那么这个贡献就可以在矩形中加上贡献，询问同样，就是询问矩形的和那么我们这里可以直接二维数据结构维护，但是常数大不能过我们考虑离线扫描线降维，用一个树状数组维护差分序列即可。 知识点：1、区间$[l,r]$看做二维平面上的点$(l,r)$，则方便用区间操作处理一下区间2、记录左右离$i$最近的比$i$小的数，思路类似上一个颜色在哪]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>树状数组</tag>
        <tag>扫描线</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 4827」「AH2017/HNOI2017」礼物 (FFT)]]></title>
    <url>%2Fbzoj4827%2F</url>
    <content type="text"><![CDATA[BZOJ 4827题意：给定数列$a,b, b$可以循环移动，选择整数$c$，求$$\min\sum\limits_{i=1}^n(a_i-b_i+c)^2$$ 化简式子，可得$$\sum_{i=1}^na_i^2+\sum_{i=1}^nb_i^2-2\sum_{i=1}^na_ib_i+nc^2+2c\sum_{i=1}^n(a_i-b_i)$$前面两项是定值，后面两项可以看作一个关于$c$的二次函数，显然有最小值，求最近对称轴$\frac{\sum\limits_{i=1}^n (a_i - b_i)}{n}$的两个点的最小值加入答案。 现在问题变为求$\min\sum\limits_{i=1}^na_ib_i$ 我们将环断为链，复制一份在后面考虑平移的情况$$\min\sum\limits_{i=1}^na_{i}b_{i+k}$$我们可以转化一下，翻转$a$数组，得$$\sum\limits_{i=1}^na_{n-i+1}b_{i+k}$$那么两项下标为常数，是卷积的形式，FFT求卷积即可，最后扫描一遍求最大值，答案减去这个最大值。 知识点1、FFT 套路：翻转数组形成卷积 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;complex&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL MAXN = 200000 + 5; const db PI = acos(-1); LL ans = 0, n, m, a[MAXN], b[MAXN], r[MAXN], ret[MAXN]; complex&lt;db &gt; f[MAXN], g[MAXN]; void FFT(complex&lt;db &gt; *a, int op) { for (int i = 0; i &lt; n; ++i) if (i &lt; r[i]) swap(a[i], a[r[i]]); for (int i = 1; i &lt; n; i *= 2) { complex&lt;db &gt; Wn(cos(PI / i), sin(PI / i) * op); for (int j = 0; j &lt; n; j += i * 2) { complex&lt;db &gt; w(1, 0), *a0 = a + j, *a1 = a0 + i; for (int k = 0; k &lt; i; ++k) { complex&lt;db &gt; t = *a1 * w; *a1 = *a0 - t, *a0 += t; w *= Wn, ++a0, ++a1; } } } } void clean() { } int solve() { clean(); cin &gt;&gt; n &gt;&gt; m; for (LL i = 1; i &lt;= n; ++i) scanf(&quot;%lld&quot;, &amp;a[i]), ans += a[i] * a[i]; for (LL i = 1; i &lt;= n; ++i) scanf(&quot;%lld&quot;, &amp;b[i]), ans += b[i] * b[i]; LL t = 0; for (LL i = 1; i &lt;= n; ++i) t += a[i] - b[i]; LL c1 = (LL)floor(-(db)t / (db)n), c2 = (LL)ceil(-(db)t / (db)n); ans += min(n * c1 * c1 + 2ll * c1 * t, n * c2 * c2 + 2ll * c2 * t); reverse(a + 1, a + 1 + n); for (LL i = 1; i &lt;= n; ++i) b[n + i] = b[i]; for (LL i = 1; i &lt;= n; ++i) f[i] = (db)a[i]; for (LL i = 1; i &lt;= 2 * n; ++i) g[i] = (db)b[i]; int l = 0; for (m = n * 2, n = 1; n &lt;= m; ++l, n &lt;&lt;= 1); for (LL i = 1; i &lt;= n; ++i) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (l - 1)); FFT(f, 1), FFT(g, 1); for (LL i = 0; i &lt; n; ++i) f[i] *= g[i]; FFT(f, -1); for (LL i = 0; i &lt; n; ++i) ret[i] = (int)(fabs(f[i].real()) / (db)n + 0.5); LL whw = 0; for (LL i = 0; i &lt; m / 2; ++i) whw = max(whw, ret[m / 2 + i + 1]); printf(&quot;%lld\n&quot;, ans - 2ll * whw); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1926」「SDOI2010」粟粟的书架 (二分+主席树/二维前缀和)]]></title>
    <url>%2Fbzoj1926%2F</url>
    <content type="text"><![CDATA[BZOJ 1926题意：见上本题显然是两个题。首先考虑$n,m \leq 200$的，二维前缀和记录矩形大于某数个数和和，二分查找即可考虑$r=1$的，即用类似的方法，二分+主席树即可。 知识点1、主席树节点数和操作次数有关，与值域无关2、主席树边更新边合并和更新完合并两种写法不要写混 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #include&lt;vector&gt; #include&lt;string&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { int r, c, Q; namespace task1 { const int MAXN = 200 + 5; int a[MAXN][MAXN], qzh_num[MAXN][MAXN][1000 + 5], qzh_he[MAXN][MAXN][1000 + 5]; int getNum(int x1, int y1, int x2, int y2, int k) {return qzh_num[x2][y2][k] - qzh_num[x2][y1 - 1][k] - qzh_num[x1 - 1][y2][k] + qzh_num[x1 - 1][y1 - 1][k];} int getHe(int x1, int y1, int x2, int y2, int k) {return qzh_he[x2][y2][k] - qzh_he[x2][y1 - 1][k] - qzh_he[x1 - 1][y2][k] + qzh_he[x1 - 1][y1 - 1][k];} int solve() { for (int i = 1; i &lt;= r; ++i) for (int j = 1; j &lt;= c; ++j) scanf(&quot;%d&quot;, &amp;a[i][j]); for (int i = 1; i &lt;= r; ++i) for (int j = 1; j &lt;= c; ++j) qzh_num[i][j][a[i][j]] = 1; for (int i = 1; i &lt;= r; ++i) for (int j = 1; j &lt;= c; ++j) qzh_he[i][j][a[i][j]] = a[i][j]; for (int k = 1000 - 1; k; --k) for (int i = 1; i &lt;= r; ++i) for (int j = 1; j &lt;= c; ++j) qzh_num[i][j][k] += qzh_num[i][j][k + 1]; for (int k = 1000 - 1; k; --k) for (int i = 1; i &lt;= r; ++i) for (int j = 1; j &lt;= c; ++j) qzh_he[i][j][k] += qzh_he[i][j][k + 1]; for (int k = 1000; k; --k) for (int i = 1; i &lt;= r; ++i) for (int j = 1; j &lt;= c; ++j) qzh_num[i][j][k] += qzh_num[i - 1][j][k] + qzh_num[i][j - 1][k] - qzh_num[i - 1][j - 1][k]; for (int k = 1000; k; --k) for (int i = 1; i &lt;= r; ++i) for (int j = 1; j &lt;= c; ++j) qzh_he[i][j][k] += qzh_he[i - 1][j][k] + qzh_he[i][j - 1][k] - qzh_he[i - 1][j - 1][k]; while (Q--) { int x1, y1, x2, y2, h; scanf(&quot;%d%d%d%d%d&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2, &amp;h); int l = 1, r = 1000 + 1, ans = -1; while (l &lt;= r) { int mid = (l + r) &gt;&gt; 1; if (getHe(x1, y1, x2, y2, mid) &gt;= h) { l = mid + 1; int tmp2 = getHe(x1, y1, x2, y2, mid + 1); int hh = (h - tmp2) / mid + (bool)((h - tmp2) % mid); ans = getNum(x1, y1, x2, y2, mid + 1) + hh; } else r = mid - 1; } if (ans == -1) printf(&quot;Poor QLW\n&quot;); else printf(&quot;%d\n&quot;, ans); } return 0; } } namespace task2 { const int MAXN = 500000 + 5, MV = 1000 + 5; #define M ((l + r) &gt;&gt; 1) int a[MAXN]; int sz, rt[MAXN], lc[MAXN * 20], rc[MAXN * 20], sumv[MAXN * 20], he[MAXN * 20]; void update(int &amp;now, int l, int r, int x, int v, int pre) { if (!now) now = ++sz; sumv[now] = sumv[pre] + 1, he[now] = he[pre] + v; // if (l == r) return ; if (x &lt;= M) rc[now] = rc[pre], update(lc[now], l, M, x, v, lc[pre]); else lc[now] = lc[pre], update(rc[now], M + 1, r, x, v, rc[pre]); } int query(int x, int l, int r, int v) { if (l == r) return he[x]; if (v &lt;= M) { return he[rc[x]] + query(lc[x], l, M, v); } else { return query(rc[x], M + 1, r, v); } } int queryNum(int x, int l, int r, int v) { if (l == r) return sumv[x]; if (v &lt;= M) { return sumv[rc[x]] + queryNum(lc[x], l, M, v); } else { return queryNum(rc[x], M + 1, r, v); } } int solve() { for (int i = 1; i &lt;= c; ++i) scanf(&quot;%d&quot;, &amp;a[i]), update(rt[i], 1, MV, a[i], a[i], rt[i - 1]); //query(rt[3], 1, MV, 9); while (Q--) { int x1, y1, x2, y2, h; scanf(&quot;%d%d%d%d%d&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2, &amp;h); int l = 1, r = 1000 + 1, ans = -1; while (l &lt;= r) { int mid = (l + r) &gt;&gt; 1; if (query(rt[y2], 1, MV, mid) - query(rt[y1 - 1], 1, MV, mid) &gt;= h) { l = mid + 1; int tmp2 = query(rt[y2], 1, MV, mid + 1) - query(rt[y1 - 1], 1, MV, mid + 1); int hh = (h - tmp2) / mid + (bool)((h - tmp2) % mid); ans = queryNum(rt[y2], 1, MV, mid + 1) - queryNum(rt[y1 - 1], 1, MV, mid + 1) + hh; } else r = mid - 1; } if (ans == -1) printf(&quot;Poor QLW\n&quot;); else printf(&quot;%d\n&quot;, ans); } return 0; } } void clean() {} int solve() { clean(); cin &gt;&gt; r &gt;&gt; c &gt;&gt; Q; if (r == 1) task2::solve(); else task1::solve(); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>二分</tag>
        <tag>前缀和</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 590E (AC自动机 + Dilworth定理 + DAG最小路径覆盖)]]></title>
    <url>%2FCodeforces590E%2F</url>
    <content type="text"><![CDATA[Codeforces 590E题意：给定$n$个字符串，求出最大的集合使得没有任意两个字符串是包含关系。 第一题Div1E… 多模式串可以想到用AC自动机，然后包含关系可以看作一个偏序关系，那么题意就是求最长反链。最长反链等于最小链覆盖，传递闭包后二分图匹配。注意输出方案，即为最小点覆盖取反，具体方法看算法竞赛进阶指南上。AC自动机注意要沿着fail指针找子串否则不能找全，并且找到最近的即可，因为我们要传递闭包，找多个会TLE 知识点：1、多模式串可以想到用AC自动机2、包含关系、到达关系、大于等于关系都是偏序关系 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #include&lt;vector&gt; #include&lt;string&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 750 + 5, MAXV = 10000000 + 5; int n, sz, G[MAXN][MAXN], ch[MAXV][2], id[MAXV], f[MAXV]; char s[MAXV]; string str[MAXN]; void ins(int ith) { int now = 0, len = strlen(s); for (int i = 0; i &lt; len; ++i) { int c = s[i] - &#39;a&#39;; if (!ch[now][c]) ch[now][c] = ++sz; now = ch[now][c]; if (i == len - 1) id[now] = ith; } } void getFail() { queue&lt;int &gt; q; f[0] = 0; for (int c = 0; c &lt; 2; ++c) { int v = ch[0][c]; if (v) q.push(v), f[v] = 0; } while (!q.empty()) { int u = q.front(); q.pop(); for (int c = 0; c &lt; 2; ++c) { int v = ch[u][c]; if (!ch[u][c]) {ch[u][c] = ch[f[u]][c]; continue ;} q.push(v); int j = f[u]; while (j &amp;&amp; !ch[j][c]) j = f[j]; f[v] = ch[j][c]; if (!id[v]) id[v] = id[f[v]]; } } } void find(int ith) { int now = 0; for (int i = 0; i &lt; (int)str[ith].length(); ++i) { int c = str[ith][i] - &#39;a&#39;; now = ch[now][c]; if (id[now]) G[ith][id[now]] = 1; if (id[f[now]]) G[ith][id[f[now]]] = 1; } } int vis[MAXN], lk[MAXN], to[MAXN], cnt; bool hungary(int u) { for (int v = 1; v &lt;= n; ++v) if (G[u][v]) { if (vis[v] != cnt) { vis[v] = cnt; if (!lk[v] || hungary(lk[v])) { lk[v] = u, to[u] = v; return true; } } } return false; } int mx[MAXN], my[MAXN]; void dfs(int u) { if (mx[u]) return ; mx[u] = 1; for (int v = 1; v &lt;= n; ++v) if (G[u][v]) { if (!my[v]) my[v] = 1, dfs(lk[v]); // lk[v] } } void clean() { } int solve() { clean(); scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%s&quot;, s), ins(i), str[i] = s; getFail(); for (int i = 1; i &lt;= n; ++i) find(i); for (int k = 1; k &lt;= n; ++k) for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) if (i != j &amp;&amp; i != k &amp;&amp; j != k) G[i][j] |= G[i][k] &amp;&amp; G[k][j]; for (int i = 1; i &lt;= n; ++i) G[i][i] = 0; //for (int i = 1; i &lt;= n; ++i, putchar(&#39;\n&#39;)) //for (int j = 1; j &lt;= n; ++j) printf(&quot;%d &quot;, G[i][j]); int ans = 0; for (int i = 1; i &lt;= n; ++i) ans += hungary(cnt = i); printf(&quot;%d\n&quot;, n - ans); for (int i = 1; i &lt;= n; ++i) if (!to[i]) dfs(i); for (int i = 1; i &lt;= n; ++i) if (mx[i] &amp;&amp; !my[i]) printf(&quot;%d &quot;, i); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>二分图</tag>
        <tag>AC自动机</tag>
        <tag>Dilworth定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 2744」「HEOI2012」朋友圈 (二分图最大团)]]></title>
    <url>%2Fbzoj2744%2F</url>
    <content type="text"><![CDATA[Bzoj 2744题意：见上。 本题本质上是求一个最大团。分析A发现一个最大团中A最多有两个，否则是不合题意的然后我们就可以枚举A有几个，然后将这几个A相连的B一起做一个最大团我们发现B条件即为一个奇偶的二分图，在二分图上求最大团即可然后这里最大团=总点数-补图最大独立集要将奇数放在二分图左边，注意不清空数组的技巧 知识点1、|不要打成|| #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #include&lt;vector&gt; #include&lt;string&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; int T; namespace flyinthesky { const int MAXN = 3005; int na, nb, m, a[205], b[MAXN], ma[205][MAXN]; vector&lt;int &gt; G[MAXN]; void ins(int u, int v) {G[u].push_back(v);} int chk(int x) {int ret = 0; while (x) ++ret, x &amp;= (x - 1); return ret &amp; 1;} int lk[MAXN], tm[MAXN], vis[MAXN], ban[MAXN], Tban, Tvis; bool hungary(int u) { if (ban[u] == Tban) return false; for (int i = 0; i &lt; (int)G[u].size(); ++i) { int v = G[u][i]; if (ban[v] != Tban &amp;&amp; vis[v] != Tvis) { vis[v] = Tvis; if (tm[v] != Tban || !lk[v] || hungary(lk[v])) { tm[v] = Tban, lk[v] = u; return true; } } } return false; } int work(int x = 0, int y = 0) { int ret = 0; ++Tban; for (int i = 1; i &lt;= nb; ++i) if (ma[x][i] || ma[y][i]) ban[i] = Tban, ++ret; for (int i = 1; i &lt;= nb; ++i) if ((b[i] &amp; 1) == 1) ++Tvis, ret += hungary(i); // return nb - ret; } void clean() { ms(lk, 0), ms(tm, 0), ms(vis, 0), ms(ban, 0), Tban = Tvis = 0; for (int i = 0; i &lt;= 201; ++i) for (int j = 0; j &lt;= 3001; ++j) ma[i][j] = 1; } int solve() { cin &gt;&gt; na &gt;&gt; nb &gt;&gt; m; clean(); for (int i = 1; i &lt;= na; ++i) scanf(&quot;%d&quot;, &amp;a[i]); for (int i = 1; i &lt;= nb; ++i) scanf(&quot;%d&quot;, &amp;b[i]); for (int x, y, i = 1; i &lt;= m; ++i) scanf(&quot;%d%d&quot;, &amp;x, &amp;y), ma[x][y] = 0; for (int i = 1; i &lt;= nb; ++i) ma[0][i] = 0; for (int x = 1; x &lt;= nb; ++x) if ((b[x] &amp; 1) == 1) { for (int y = 1; y &lt;= nb; ++y) if ((b[y] &amp; 1) == 0) { if (chk(b[x] | b[y]) == 0) ins(x, y); // | } } int ans = work(); for (int i = 1; i &lt;= na; ++i) ans = max(ans, work(i) + 1); for (int u = 1; u &lt;= na; ++u) if ((a[u] &amp; 1) == 1) for (int v = 1; v &lt;= na; ++v) if ((a[v] &amp; 1) == 0) ans = max(ans, work(u, v) + 2); printf(&quot;%d\n&quot;, ans); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <tags>
        <tag>Bzoj</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 3295」「CQOI2011」动态逆序对 (带修主席树 / CDQ分治)]]></title>
    <url>%2Fbzoj3295%2F</url>
    <content type="text"><![CDATA[BZOJ 3295题意：给定一个排列，每次删一个数，求整个序列逆序对。 先求出原序列逆序对维护一个数前面比他大的数的个数$a_1$, 后面比他小的数的个数$a_2$本题删除一个数，那么当前答案减去$a_1[i-1], a_2[i+1]​$但是考虑删掉的数不会贡献答案，用一个带修主席树维护被删的数的个数，在主席树上二分找比某数小某数大即可。 本题也可以CDQ分治，显然是个三维偏序 我们把删除反过来看作添加新数字，然后考虑$(T_i, x_i, y_i)$，$T_i$为插入时间，$x_i$为位置，$y_i$为值 将第一维排序，第二维 CDQ，第三维树状数组维护 带修主席树 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL MAXN = 100000 + 5; LL n, m, a[MAXN], pos[MAXN], a1[MAXN], a2[MAXN], ans; LL c[MAXN]; LL lowbit(LL x) {return x &amp; (-x);} void add(LL x, LL v) {for (LL i = x; i &lt;= n; i += lowbit(i)) c[i] += v;} LL query(LL x) {LL ret = 0; for (LL i = x; i &gt; 0; i -= lowbit(i)) ret += c[i]; return ret;} #define M ((l + r) &gt;&gt; 1) LL lc[MAXN * 50], rc[MAXN * 50], sumv[MAXN * 50], rt[MAXN], xx[MAXN], yy[MAXN], sz; void update(LL &amp;now, LL l, LL r, LL x, LL v) { if (!now) now = ++sz; sumv[now] += v; if (l == r) return ; if (x &lt;= M) update(lc[now], l, M, x, v); else update(rc[now], M + 1, r, x, v); } LL queryLarger(LL x, LL y, LL v) { for (LL i = x; i; i -= lowbit(i)) xx[i] = rt[i]; for (LL i = y; i; i -= lowbit(i)) yy[i] = rt[i]; LL l = 1, r = n, ans = 0; while (l &lt; r) { if (v &lt;= M) { for (LL i = x; i; i -= lowbit(i)) ans -= sumv[rc[xx[i]]]; for (LL i = y; i; i -= lowbit(i)) ans += sumv[rc[yy[i]]]; for (LL i = x; i; i -= lowbit(i)) xx[i] = lc[xx[i]]; for (LL i = y; i; i -= lowbit(i)) yy[i] = lc[yy[i]]; r = M; } else { for (LL i = x; i; i -= lowbit(i)) xx[i] = rc[xx[i]]; for (LL i = y; i; i -= lowbit(i)) yy[i] = rc[yy[i]]; l = M + 1; } } return ans; } LL querySmaller(LL x, LL y, LL v) { for (LL i = x; i; i -= lowbit(i)) xx[i] = rt[i]; for (LL i = y; i; i -= lowbit(i)) yy[i] = rt[i]; LL l = 1, r = n, ans = 0; while (l &lt; r) { if (v &lt;= M) { for (LL i = x; i; i -= lowbit(i)) xx[i] = lc[xx[i]]; for (LL i = y; i; i -= lowbit(i)) yy[i] = lc[yy[i]]; r = M; } else { for (LL i = x; i; i -= lowbit(i)) ans -= sumv[lc[xx[i]]]; for (LL i = y; i; i -= lowbit(i)) ans += sumv[lc[yy[i]]]; for (LL i = x; i; i -= lowbit(i)) xx[i] = rc[xx[i]]; for (LL i = y; i; i -= lowbit(i)) yy[i] = rc[yy[i]]; l = M + 1; } } return ans; } void clean() { } int solve() { clean(); cin &gt;&gt; n &gt;&gt; m; for (LL i = 1; i &lt;= n; ++i) scanf(&quot;%lld&quot;, &amp;a[i]), pos[a[i]] = i; for (LL i = 1; i &lt;= n; ++i) ans += (a1[i] = i - 1 - query(a[i])), add(a[i], 1); ms(c, 0); for (LL i = n; i; --i) a2[i] = query(a[i] - 1), add(a[i], 1); while (m--) { LL x; scanf(&quot;%lld&quot;, &amp;x), printf(&quot;%lld\n&quot;, ans); x = pos[x]; ans -= (a1[x] + a2[x] - queryLarger(1 - 1, x - 1, a[x]) - querySmaller(x + 1 - 1, n, a[x])); for (int i = x; i &lt;= n; i += lowbit(i)) update(rt[i], 1, n, a[x], 1); } return 0; } } int main() { flyinthesky::solve(); return 0; } CDQ分治： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #include&lt;vector&gt; #include&lt;string&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL MAXN = 100000 + 5; LL n, m, a[MAXN], pos[MAXN], ans[MAXN]; struct data { LL t, x, y; bool operator &lt; (const data &amp;rhs) const { if (x == rhs.x) return y &lt; rhs.y; return x &lt; rhs.x; } } xw[MAXN], b[MAXN]; bool cmp(data u, data v) {return u.t &lt; v.t;} LL c[MAXN], stp[MAXN]; LL lowbit(LL x) {return x &amp; (-x);} void add(LL x, LL v) {for (LL i = x; i &lt;= n; i += lowbit(i)) c[i] += v;} LL query(LL x) {LL ret = 0; for (LL i = x; i &gt; 0; i -= lowbit(i)) ret += c[i]; return ret;} void CDQ(LL l, LL r) { if (l &gt;= r) return ; LL mid = (l + r) &gt;&gt; 1; CDQ(l, mid), CDQ(mid + 1, r); int t1 = l, t2 = mid + 1, tot = 0, totstp = 0; while (t1 &lt;= mid || t2 &lt;= r) { if (t2 &gt; r || (t1 &lt;= mid &amp;&amp; xw[t1] &lt; xw[t2])) { add(xw[t1].y, 1), stp[++totstp] = xw[t1].y; b[++tot] = xw[t1++]; } else { ans[xw[t2].t] += query(n) - query(xw[t2].y - 1); b[++tot] = xw[t2++]; } } for (int i = l; i &lt;= r; ++i) xw[i] = b[i - l + 1]; for (int i = 1; i &lt;= totstp; ++i) add(stp[i], -1); // clear totstp = 0; for (int i = r; i &gt;= l; --i) { if (xw[i].t &lt;= mid) add(xw[i].y, 1), stp[++totstp] = xw[i].y; else ans[xw[i].t] += query(xw[i].y); } for (int i = 1; i &lt;= totstp; ++i) add(stp[i], -1); // clear } void clean() { } int solve() { clean(); cin &gt;&gt; n &gt;&gt; m; for (LL i = 1; i &lt;= n; ++i) scanf(&quot;%lld&quot;, &amp;a[i]), pos[a[i]] = i, xw[i] = (data){0, i, a[i]}; LL tmp = n; for (LL x, i = 1; i &lt;= m; ++i) scanf(&quot;%lld&quot;, &amp;x), xw[pos[x]].t = tmp--; for (LL i = 1; i &lt;= n; ++i) if (!xw[i].t) xw[i].t = tmp--; sort(xw + 1, xw + 1 + n, cmp); CDQ(1, n); for (LL i = 1; i &lt;= n; ++i) ans[i] += ans[i - 1]; for (LL i = n; i &gt;= n - m + 1; --i) printf(&quot;%lld\n&quot;, ans[i]); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>树状数组</tag>
        <tag>CDQ分治</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 2303」「Apio2011」方格染色 (带权并查集+异或方程+数学归纳法)]]></title>
    <url>%2Fbzoj2303%2F</url>
    <content type="text"><![CDATA[BZOJ 2303题意：有一个$n \times m$的矩阵，可以放入$0$或$1$，现在已经有$k$个格子放好了$0$或$1$，要把矩阵放满，要求是矩阵中每个$2 \times 2$的格子有奇数个$1$。输入$n、m$和已经放了的格子，求方案数。 根据异或性质$a \oplus b \oplus a = b$考虑一个矩阵 ABCD EFGH IJKL 我们发现对于任意$2 \times 2$矩形异或和都是$1$，因为要符合题意 那么我们发现$$A \oplus B \oplus E \oplus F=1 \tag{1}$$$$B \oplus C \oplus F \oplus G=1 \tag{2}$$$(1), (2)$异或，则得$$A \oplus E \oplus C \oplus G=0 \tag{3}$$又可以得到$$C \oplus G \oplus D \oplus H = 1 \tag{4}$$$(3), (4)$异或，则得$$A \oplus E \oplus D \oplus H = 1$$我们发现横向异或可以数学归纳法证明，$(1,1) \to (i, j)​$, 如果列数是偶数，则异或和为1，否则为0对于列同理那么我们发现只要行列都是偶数，那么异或和是1，否则是0 也可以直观上来看，对于$(1,1) \to (i, j)$这个矩形，考虑矩形包含$2 \times 2$矩形的个数。 根据数学归纳法，如果原方格内的第一行和第一列的格子被确定，那么整个方格即可被唯一确定。 我们可以发现$(1,1) \oplus (i,1) \oplus (1,j) \oplus (i,j)=0 / 1$ (取决于上述规则) 那么我们就可以枚举$(1,1)$填什么(如果没有限定，否则就只填一种)，然后维护异或关系。 显然可以用带权并查集来做。具体看代码实现。最后答案是除了$(1,1)$联通块的个数$k$, $2^k$ #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 200000 + 5, MO = 1e9; int n, m, k, x[MAXN], y[MAXN], c[MAXN]; int f[MAXN], g[MAXN]; // g[i] 是 i 和 rt 的关系 int find(int x) { if (x == f[x]) return x; int rt = find(f[x]); g[x] ^= g[f[x]]; return f[x] = rt; } void mge(int a, int b, int ans) { // 带权并查集 int x = find(a), y = find(b); if (x != y) { f[x] = y; g[x] = g[a] ^ g[b] ^ ans; } } LL ksm(LL a, LL b) { LL ans = 1, bs = a; while (b) { if (b &amp; 1) ans = (ans * bs) % MO; bs = (bs * bs) % MO; b &gt;&gt;= 1; } return ans; } LL work(int whw) { for (int i = 0; i &lt;= n + m; ++i) f[i] = i, g[i] = 0; f[n + 1] = 1; // n + 1, 1 是同一个位置 for (int i = 1; i &lt;= k; ++i) { int tx = x[i], ty = y[i]; if (tx == 1 &amp;&amp; ty == 1) continue ; if (tx % 2 == 0 &amp;&amp; ty % 2 == 0) { // 行列均偶 if (whw ^ c[i] ^ 1) { if (find(tx) == find(ty + n) &amp;&amp; (g[tx] ^ g[ty + n]) != 1) return 0; mge(tx, ty + n, 1); } else { if (find(tx) == find(ty + n) &amp;&amp; (g[tx] ^ g[ty + n]) != 0) return 0; mge(tx, ty + n, 0); } } else { if (whw ^ c[i]) { if (find(tx) == find(ty + n) &amp;&amp; (g[tx] ^ g[ty + n]) != 1) return 0; mge(tx, ty + n, 1); } else { if (find(tx) == find(ty + n) &amp;&amp; (g[tx] ^ g[ty + n]) != 0) return 0; mge(tx, ty + n, 0); } } } int tot = 0; for (int i = 1; i &lt;= n + m; ++i) if (find(i) == i) ++tot; // 找连通块 return ksm(2ll, tot - 1); } void clean() { } int solve() { clean(); cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; int fl = -1; for (int i = 1; i &lt;= k; ++i) { scanf(&quot;%d%d%d&quot;, &amp;x[i], &amp;y[i], &amp;c[i]); if (x[i] == 1 &amp;&amp; y[i] == 1) fl = c[i]; // 1 被确定 } if (fl == -1) { printf(&quot;%lld\n&quot;, (work(1) + work(0)) % MO); } else printf(&quot;%lld\n&quot;, work(fl)); return 0; } } int main() { flyinthesky::solve(); return 0; } // /* 1 1 1 1 1 0 */]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>带权并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 3123」「SDOI2013」森林 (主席树 + 启发式合并)]]></title>
    <url>%2Fbzoj3123%2F</url>
    <content type="text"><![CDATA[bzoj 3123题意：小$Z$有一片森林，含有$N$个节点，每个节点上都有一个非负整数作为权值。初始的时候，森林中有$M$条边。小Z希望执行$T$个操作，操作有两类： Q x y k查询点$x$到点$y$路径上所有的权值中，第$k$小的权值是多少。此操作保证点$x$和点$y$连通，同时这两个节点的路径上至少有$k$个点。 L x y在点$x$和点$y$之间连接一条边。保证完成此操作后，仍然是一片森林。 这题查询$k$小值点，显然主席树。考虑怎么处理合并两棵树。我们想到了LCT。但是这题我们完全可以启发式合并。每次合并两个集合，然后对小的集合重新算倍增、深度等注意本题是合并的时候再建链，而不是先建链再合并，否则会合并很多次，造成数据重复 知识点：1、加边要加双向边 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 100000 + 1, LOGS = 20; int tmp, n, m, Q, val_o[MAXN], ls[MAXN]; vector&lt;int &gt; G_o[MAXN]; int f_o[MAXN], siz_o[MAXN], pre_o[MAXN][LOGS + 2], sz, dep_o[MAXN]; int find(int x) {return x == f_o[x] ? x : f_o[x] = find(f_o[x]);} void ins(int u, int v) {G_o[u].push_back(v);} #define M ((l + r) &gt;&gt; 1) int lc[MAXN * 20], rc[MAXN * 20], rt_o[MAXN], sumv[MAXN * 20]; void update(int l, int r, int p, int &amp;now, int pre) { if (!now) now = ++sz; sumv[now] = sumv[pre] + 1; if (l == r) return ; if (p &lt;= M) rc[now] = rc[pre], update(l, M, p, lc[now], lc[pre]); else lc[now] = lc[pre], update(M + 1, r, p, rc[now], rc[pre]); } void dfs(int u, int fa) { pre_o[u][0] = fa, dep_o[u] = dep_o[fa] + 1; for (int i = 1; i &lt;= LOGS; ++i) pre_o[u][i] = pre_o[pre_o[u][i - 1]][i - 1]; update(1, tmp, val_o[u], rt_o[u], rt_o[fa]); for (int i = 0; i &lt; (int)G_o[u].size(); ++i) { int v = G_o[u][i]; if (v != fa) dfs(v, u); } } int LCA(int a, int b) { if (dep_o[a] &lt; dep_o[b]) swap(a, b); for (int i = LOGS; i &gt;= 0; --i) if (dep_o[pre_o[a][i]] &gt;= dep_o[b]) a = pre_o[a][i]; if (a == b) return a; for (int i = LOGS; i &gt;= 0; --i) if (pre_o[a][i] != pre_o[b][i]) a = pre_o[a][i], b = pre_o[b][i]; return pre_o[a][0]; } int query(int l, int r, int x, int y, int lca, int flca, int kth) { if (l == r) return ls[l]; int sum = sumv[lc[x]] + sumv[lc[y]] - sumv[lc[lca]] - sumv[lc[flca]]; if (sum &gt;= kth) return query(l, M, lc[x], lc[y], lc[lca], lc[flca], kth); else return query(M + 1, r, rc[x], rc[y], rc[lca], rc[flca], kth - sum); } void clean() { sz = 0, ms(f_o, 0), ms(siz_o, 0), ms(pre_o, 0); ms(lc, 0), ms(rc, 0), ms(rt_o, 0), ms(sumv, 0); for (int i = 0; i &lt;= n; ++i) G_o[i].clear(); } int solve() { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;Q); clean(); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;val_o[i]), ls[i] = val_o[i], siz_o[i] = 0, f_o[i] = i; sort(ls + 1, ls + 1 + n); tmp = unique(ls + 1, ls + 1 + n) - ls - 1; for (int i = 1; i &lt;= n; ++i) val_o[i] = lower_bound(ls + 1, ls + 1 + tmp, val_o[i]) - ls; for (int u, v, i = 1; i &lt;= m; ++i) { scanf(&quot;%d%d&quot;, &amp;u, &amp;v), ins(u, v), ins(v, u); int x = find(u), y = find(v); f_o[x] = y, siz_o[y] += siz_o[x]; } for (int u = 1; u &lt;= n; ++u) if (u == find(u)) dfs(u, 0); int la = 0; char s[5]; while (Q--) { scanf(&quot;%s&quot;, s); if (s[0] == &#39;Q&#39;) { int x, y, k; scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;k); x ^= la, y ^= la, k ^= la; int l = LCA(x, y); printf(&quot;%d\n&quot;, la = query(1, tmp, rt_o[x], rt_o[y], rt_o[l], rt_o[pre_o[l][0]], k)); } else { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); x ^= la, y ^= la; int a = find(x), b = find(y); if (siz_o[a] &gt; siz_o[b]) swap(a, b), swap(x, y); f_o[a] = b, siz_o[b] += siz_o[a]; ins(x, y), ins(y, x), dfs(x, y); } } return 0; } } int main() { int T; while (scanf(&quot;%d&quot;, &amp;T) == 1) flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>主席树</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 3997」「TJOI2015」组合数学 (Dilworth定理+DP)]]></title>
    <url>%2Fbzoj3997%2F</url>
    <content type="text"><![CDATA[BZOJ 3997题意： 给出一个网格图，其中某些格子有财宝，每次从左上角出发，只能向下或右走。问至少走多少次才能将财宝捡完。此对此问题变形，假设每个格子中有好多财宝，而每一次经过一个格子至多只能捡走一块财宝，至少走多少次才能把财宝全部捡完。 一开始觉得是上下界网络流。。范围太大了这题是一个最小链覆盖问题，可以转化为最长反链覆盖。考虑这里的反链，我们让$x$能到$y$看作偏序关系，然后对于$x,y$在同一反链当且仅当这两个点是右上、左下关系那么设$dp(i,j)$为以$(i,j)$为左下角的矩形中的最长反链长。那么考虑转移$$dp(i,j)=\max(dp(i-1,j), dp(i,j+1), dp(i-1, j-1)+a_{i,j})$$前两个是继承关系，后一个是包含$(i,j)$的最长反链长，显然$(i,j)$和$(i-1, j-1)$在一个反链。 知识点1、只向下/右：DP2、二分图网络流问题：链、反链、最小点覆盖、最大独立集的转化 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; int T; namespace flyinthesky { const LL MAXN = 1000 + 5; LL n, m, a[MAXN][MAXN], dp[MAXN][MAXN]; void clean() { ms(dp, 0); } int solve() { clean(); cin &gt;&gt; n &gt;&gt; m; for (LL i = 1; i &lt;= n; ++i) for (LL j = 1; j &lt;= m; ++j) scanf(&quot;%lld&quot;, &amp;a[i][j]); for (LL i = 1; i &lt;= n; ++i) { for (LL j = m; j &gt;= 1; --j) { dp[i][j] = max(dp[i - 1][j], max(dp[i][j + 1], dp[i - 1][j + 1] + a[i][j])); } } cout &lt;&lt; dp[n][1] &lt;&lt; endl; return 0; } } int main() { cin &gt;&gt; T; while (T--) flyinthesky::solve(); return 0; } // /* */]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>Bzoj</tag>
        <tag>Dilworth定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1143」「CTSC2008」祭祀 (Dilworth定理 + 二分图匹配(最小链覆盖))]]></title>
    <url>%2Fbzoj1143%2F</url>
    <content type="text"><![CDATA[Bzoj 1143题意：见上。 补充两个问题 (Luogu题面) 接下来一行输出一种可行的选取方案。对于每个岔口依次输出一个整数，如果在该岔口设置了祭祀点，那么输出一个$1$，否则输出一个$0$。应确保你输出的$1$的个数最多，且中间没有空格。 接下来一行输出，在选择最多祭祀点的前提下，每个岔口是否能够设置祭祀点。对于每个岔口依次输出一个整数，如果在该岔口能够设置祭祀点，那么输出一个$1$，否则输出一个$0$。 本题就是求一个最长反链。Dilworth定理转化为最小链覆盖。然后二分图匹配求最小链覆盖(最大独立集)即可。对于输出方案，可以取反最小点覆盖的方案，具体看算法竞赛进阶指南相关内容。对于第三问，我们考虑枚举点，然后删掉这个点所有可以到达的点和删掉所有可以到达这个点的点，求一次最大独立集，如果少了1，则这个点是可以的。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 100 + 5; int n, m, f[MAXN][MAXN], g[MAXN][MAXN], cnt, vis[MAXN], lk[MAXN]; bool hungary(int u) { for (int v = 1; v &lt;= n; ++v) { if (g[u][v]) { if (vis[v] != cnt) { vis[v] = cnt; if (!lk[v] || hungary(lk[v])) { lk[v] = u; return true; } } } } return false; } void clean() { ms(f, 0), ms(vis, 0), ms(lk, 0); } int solve() { clean(); cin &gt;&gt; n &gt;&gt; m; for (int x, y, i = 1; i &lt;= m; ++i) { scanf(&quot;%d%d&quot;, &amp;x, &amp;y); f[x][y] = 1; } //Floyd for (int k = 1; k &lt;= n; ++k) for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) if (i != j &amp;&amp; i != k &amp;&amp; j != k) f[i][j] |= (f[i][k] &amp; f[k][j]); memcpy(g, f, sizeof f); int ans = 0; for (int i = 1; i &lt;= n; ++i) ans += hungary(cnt = i); printf(&quot;%d\n&quot;, n - ans); return 0; } } int main() { flyinthesky::solve(); return 0; } /* */]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>二分图</tag>
        <tag>Dilworth定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu 4934」礼物 (Dilworth定理 + 拓扑排序DAG求最长链 + 连边优化)]]></title>
    <url>%2FLuogu4934%2F</url>
    <content type="text"><![CDATA[4934 礼物题意：$n$个$[0,2^k)$的数，分最少的组使得对于每个组的任意$a_1,a_2$, $a_1 \text{and} a_2 &lt; \min(a_i,a_2)$，输出最少分组和一组方案。 首先将$a_1 \text{and} a_2 &lt; \min(a_i,a_2)$转化，我们发现$a_1 \text{and} a_2$是不可能大于$\min(a_i,a_2)$的，所以这里就相当于只有等于的情况不成立。进一步分析可得，对于每个组的任意$a_1,a_2$，都不存在$a_1 \subseteq a_2$。 先介绍偏序： 偏序的定义设$R$是集合$A$上的一个二元关系，若R满足：1、自反性：对任意$x∈A$，有$xRx$；2、反对称性（即反对称关系）：对任意$x,y∈A$，若$xRy$，且$yRx$，则$x=y$；3、传递性：对任意$x, y,z∈A$，若$xRy$，且$yRz$，则$xRz$。则称$R$为$A$上的偏序关系。符号$≤$ 具有偏序关系的集合$P$为偏序集，对应一个DAG图 严格偏序的定义1、非自反性：$x ≮ x$2、非对称性：若$x &lt; y$, 则$y ≮ x$3、传递性：若$x &lt; y, y &lt; z$, 则$x &lt; y$ 严格偏序也对应一个DAG图。但是不能使用Dilworth定理 Dilworth定理在DAG图中1、最小反链覆盖等于最长链长度等于拓扑序层次数：拓扑排序2、最小链覆盖等于最长反链长度等于链的起点数：二分图反链：在DAG图中不存在任意两个点是前驱后继关系的点集 将$a \subseteq b$看作一个偏序关系(题目保证$a_i$互不相同，则为集合)，然后建立一个 DAG 图，根据Dilworth定理，我们可以发现这里就是在求一个最小反链覆盖，那么求图的最长链即为答案。 注意本题的连边优化，若$u$到$v$有一条边，$v$到$w$有一条边，那么$u$到$w$的边是无意义的。所以我们每次连边只用连与当前状态二进制下1相差一位的。因为这样连就不会连出上面的$u$到$w$的边，并且将边的数量转到了$k \cdot 2^n$级别。 知识点：1、Dilworth定理、偏序 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 1100000 + 5; int n, k, vd[MAXN], dp[MAXN], ino[MAXN]; vector&lt;int &gt; G[MAXN], vec[MAXN]; queue&lt;int &gt; q; void clean() { ms(vd, 0), ms(dp, 0), ms(ino, 0); } int solve() { clean(); cin &gt;&gt; n &gt;&gt; k; for (int x, i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;x), vd[x] = 1; for (int S = 0; S &lt; (1 &lt;&lt; k); ++S) for (int i = 0; i &lt; k; ++i) if ((S &amp; (1 &lt;&lt; i)) == 0) G[S].push_back(S ^ (1 &lt;&lt; i)), ++ino[S ^ (1 &lt;&lt; i)]; q.push(0); while (!q.empty()) { int u = q.front(); q.pop(); if (vd[u]) ++dp[u]; for (int i = 0; i &lt; (int)G[u].size(); ++i) { int v = G[u][i]; ino[v]--; dp[v] = max(dp[v], dp[u]); if (ino[v] == 0) q.push(v); } } for (int u = 0; u &lt; (1 &lt;&lt; k); ++u) { if (!vd[u]) continue ; vec[dp[u]].push_back(u); } int sz = 0; for (int i = 0; i &lt;= dp[(1 &lt;&lt; k) - 1]; ++i) if ((int)vec[i].size() &gt; 0) ++sz; printf(&quot;1\n%d\n&quot;, sz); for (int u = 0; u &lt;= dp[(1 &lt;&lt; k) - 1]; ++u) { if ((int)vec[u].size() &lt;= 0) continue ; printf(&quot;%d &quot;, (int)vec[u].size()); for (int i = 0; i &lt; (int)vec[u].size(); ++i) printf(&quot;%d &quot;, vec[u][i]); printf(&quot;\n&quot;); } return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <tags>
        <tag>拓扑排序</tag>
        <tag>Dilworth定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Loj 2312」「HAOI2017」供给侧改革 (Trie + 类似数论分块)]]></title>
    <url>%2Floj2312%2F</url>
    <content type="text"><![CDATA[Loj 2312题意：给出一个 $n​$ 位随机 $01​$ 串，定义 $\text{data}(l,r)=\max(\text{LCP}(\text{Suf}_i,\text{Suf}_j)|i≠j,l≤i,j≤r)​$ 。给出 $m​$ 个询问 $[l,r]​$ ，求$$\sum\limits_{i=l}^{r-1}\text{data}(i,r)$$ 题目说随机生成，那么估计LCP相同的概率为$({1\over 2})^{len} \cdot C^{2}_{r-l+1}$，在取$40$时，这个几率已经很小，我们直接对于每个后缀存前$40$个字符即可。考虑依次加入每个位置的后缀 我们发现对于一个区间$[l,r]$的答案，一定比$[l+1,r], [l+2,r], \dots , [r-1,r]$答案更大，因为他们是包含关系那么我们可以运用这个单调性，还能发现答案是一块一块的，我们联想到数论分块的思想。 设$pos(i,j)$为$[1,i]$中后缀$\exists \text{LCP}=j$的最大位置。那么求答案我们分成一块一块地求，具体看代码注释。 知识点：1、单调性运用 (类似品酒大会从后往前求答案)2、离线思想 (按某元素排序) #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 100000 + 1; struct qry { int l, r, id; bool operator &lt; (const qry &amp;rhs) const { return r == rhs.r ? l &lt; rhs.l : r &lt; rhs.r; } } xw[MAXN]; int n, Q, sz, ch[MAXN * 40][2], maxd[MAXN * 40], lst[MAXN * 40], pos[MAXN][55]; // maxd_i i \in [0,40]：存在 LCP 长度为 i 的最大位置 // lst_i： 访问该节点的最后子串(用于求maxd) // pos：如上述 char s[MAXN]; LL ans[MAXN]; void insert(int l, int r) { int now = 0, p = 1; for (int i = l; i &lt;= r; ++i, ++p) { int c = s[i] - &#39;0&#39;; if (!ch[now][c]) ch[now][c] = ++sz; now = ch[now][c]; maxd[p] = max(maxd[p], lst[now]); // 更新 lst[now] = l; // 更新当前节点的信息 } } void clean() { ms(maxd, 0), ms(lst, 0), ms(pos, 0), ms(ch, 0), sz = 0; } int solve() { clean(); cin &gt;&gt; n &gt;&gt; Q; scanf(&quot;%s&quot;, s + 1); for (int i = 1; i &lt;= Q; ++i) scanf(&quot;%d%d&quot;, &amp;xw[i].l, &amp;xw[i].r), xw[i].id = i; sort(xw + 1, xw + 1 + Q); for (int i = 1; i &lt;= n; ++i) { // 求 pos insert(i, min(i + 40, n)); for (int j = 1; j &lt;= 40; ++j) pos[i][j] = maxd[j]; pos[i][0] = i - 1; } int T = 1; for (int i = 1; i &lt;= n; ++i) { // 枚举 r (其实这里求出来 pos 就不用离线的) while (T &lt;= Q &amp;&amp; xw[T].r == i) { int lst = 0; for (int j = 1; j &lt;= 40; ++j) { // 扩展 LCP if (pos[i][j]) { if (pos[i][j] &lt; xw[T].l) break ; // 已经不存在在区间 [l, r] 的更长 LCP else ans[xw[T].id] += (pos[i][lst] - pos[i][j]) * lst, lst = j; // 加上这一块的答案，更新端点值 } } ans[xw[T].id] += (pos[i][lst] - xw[T].l + 1) * lst; // 加上最后一块答案 ++T; } } for (int i = 1; i &lt;= Q; ++i) printf(&quot;%lld\n&quot;, ans[i]); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Loj</category>
      </categories>
      <tags>
        <tag>Trie</tag>
        <tag>Loj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 4566」「Haoi2016」找相同字符 (后缀数组 + 单调栈)]]></title>
    <url>%2Fbzoj4566%2F</url>
    <content type="text"><![CDATA[BZOJ 4566题意：给定两个字符串，求出在两个字符串中各取出一个子串使得这两个子串相同的方案数。两个方案不同当且仅当这两个子串中有一个位置不同。 一开始乱二分挂了……其实这题就是Bzoj 3238 差异，我们可以想到连接两个字符串，中间用一个没出现过的字符连接，然后单调栈维护所有区间的最小值。但是这里是两个字符串，可能会有答案算到是同串的，那么我们考虑容斥。 即求三次后缀数组，第一次求连接串的答案，然后求两个原串的答案，最后用连接串答案减掉后面的两个原串答案即为最终答案，正确性显然。 知识点1、多次求后缀数组，不要将思维局限2、不要乱在height上二分 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 400000 + 5; char ch[2][MAXN]; int a[MAXN], n, m; int SA[MAXN], rk[MAXN], tp[MAXN], tax[MAXN], height[MAXN]; void build(int n) {//11?¨¬o¨®¡Áo¨ºy¡Á¨¦ for (int i = 1; i &lt;= m; ++i) tax[i] = 0; for (int i = 1; i &lt;= n; ++i) tax[rk[i] = a[i]]++; for (int i = 1; i &lt;= m; ++i) tax[i] += tax[i - 1]; for (int i = n; i &gt;= 1; --i) SA[tax[rk[i]]--] = i;//?¨´¨ºy??D¨°??¦Ì¨²¨°??? for (int k = 1; k &lt;= n; k &lt;&lt;= 1) { int p = 0; for (int i = n - k + 1; i &lt;= n; i++) tp[++p] = i;//(n-k)~(n-1)?T¦Ì¨²?t1??¨¹¡Á?¡ê??¨´¨°???D¨°¨®|?????¨²?¡ã?? for (int i = 1; i &lt;= n; i++) if (SA[i] &gt; k) tp[++p] = SA[i] - k; //??¨®DSA[i]&gt;=k¦Ì?SA[i]2?¨º?¦Ì¨²?t1??¨¹¡Á?¦Ì????? //¡ä¨®¨ª??D?¨¦¨°??¡ä3?¦Ì¨²¨°?1??¨¹¡Á?o¨ª¦Ì¨²?t1??¨¹¡Á?¦Ì??????¨¤2?k¡ê?1¨ºSA[i] - k for (int i = 1; i &lt;= m; ++i) tax[i] = 0; for (int i = 1; i &lt;= n; ++i) tax[rk[tp[i]]]++;//x[tp[i]]?¨¤¦Ì¨¨¨®¨²????¦Ì¨²i¦Ì?¦Ì¨²?t1??¨¹¡Á?¦Ì?¦Ì¨²¨°?1??¨¹¡Á?¦Ì????? for (int i = 1; i &lt;= m; ++i) tax[i] += tax[i - 1]; for (int i = n; i &gt;= 1; --i) SA[tax[rk[tp[i]]]--] = tp[i];//¡À¡ê?¡è¨¢?¦Ì¨²¨°?1??¨¹¡Á?¦Ì??3D¨°?¨´??¦Ì¨²?t1??¨¹¡Á? //?¨´¨ºy??D¨°¦Ì¨²¨°?1??¨¹¡Á?(rank[i]¦Ì?¨ºy?¦Ì)o¨ª¦Ì¨²?t1??¨¹¡Á?(tp[i]¦Ì???¡À¨º) swap(rk, tp);//¡ä?¨º¡Àtp??¨®?¡ê??Y¡ä?¨¦?¨°???rank¦Ì??¦Ì p = 1, rk[SA[1]] = 1; for (int i = 2; i &lt;= n; ++i) rk[SA[i]] = (tp[SA[i]] == tp[SA[i - 1]] &amp;&amp; tp[SA[i] + k] == tp[SA[i - 1] + k]) ? p : ++p; //??????¦Ì¨²i¦Ì?¨ºy¦Ì?rank¡ê?¡ã¡äsa?3D¨°?¨¹1?¡À¡ê?¡èrank¦Ì??y¨¨¡¤D?¡ê?¦Ì?¨º?¨°acmp?D??¨®?¨¦?¨°???¡Á?¡¤?¡ä??¨¤¦Ì¨¨¦Ì??¨¦?? if (p &gt;= n) break;//???|¡ê?¨°??-??¨®D???¡ä?a?? m = p; } int k = 0;//k¨º?¡À¨¨i-1?¡ã¨°???¦Ì?o¨®¡Áo for (int i = 1; i &lt;= n; ++i) {//H[0], H[1], H[2] ...¦Ì??3D¨°???? if (k) k--;//¡ä¨®k-1?a¨º?¡À¨¨?? ,??¨®??¨¢??H[i]&gt;=H[i-1]-1, ¡Á?3¡è1?12?¡ã¡Áo¦Ì?3¡è?¨¨?¨¢¨¦¨´¨º?k-1(k = H[i-1]) int j = SA[rk[i] - 1]; //?¡ã¨°???¦Ì?o¨®¡Áo???? while (a[i + k] == a[j + k]) k++; //¨ª¨´o¨®¡À¨¨?? height[rk[i]] = k; //?¨¹D?¡äe¡ã? } } LL L[MAXN], R[MAXN], st[MAXN], top = 0, ans = 0; void clean() { n = 0, m = 200, ms(height, 0), ms(SA, 0), ms(rk, 0), ms(tax, 0), ms(tp, 0), ms(L, 0), ms(R, 0), ms(st, 0); } int solve() { // 1 clean(); scanf(&quot;%s&quot;, ch[0] + 1); int tmp = strlen(ch[0] + 1); for (int i = 1; i &lt;= tmp; ++i) a[++n] = ch[0][i] - &#39;a&#39; + 1; a[++n] = &#39;$&#39;; scanf(&quot;%s&quot;, ch[1] + 1); tmp = strlen(ch[1] + 1); for (int i = 1; i &lt;= tmp; ++i) a[++n] = ch[1][i] - &#39;a&#39; + 1; build(n); st[top = 1] = 1; for (int i = 2; i &lt;= n; ++i) { while (top &amp;&amp; height[st[top]] &gt; height[i]) R[st[top--]] = i; L[i] = st[top]; st[++top] = i; } while (top) R[st[top--]] = n + 1; for (int i = 1; i &lt;= n; ++i) ans += 1ll * (R[i] - i) * (i - L[i]) * height[i]; // 2 clean(); tmp = strlen(ch[0] + 1); for (int i = 1; i &lt;= tmp; ++i) a[++n] = ch[0][i] - &#39;a&#39; + 1; build(n); st[top = 1] = 1; for (int i = 2; i &lt;= n; ++i) { while (top &amp;&amp; height[st[top]] &gt; height[i]) R[st[top--]] = i; L[i] = st[top]; st[++top] = i; } while (top) R[st[top--]] = n + 1; for (int i = 1; i &lt;= n; ++i) ans -= 1ll * (R[i] - i) * (i - L[i]) * height[i]; // 3 clean(); tmp = strlen(ch[1] + 1); for (int i = 1; i &lt;= tmp; ++i) a[++n] = ch[1][i] - &#39;a&#39; + 1; build(n); st[top = 1] = 1; for (int i = 2; i &lt;= n; ++i) { while (top &amp;&amp; height[st[top]] &gt; height[i]) R[st[top--]] = i; L[i] = st[top]; st[++top] = i; } while (top) R[st[top--]] = n + 1; for (int i = 1; i &lt;= n; ++i) ans -= 1ll * (R[i] - i) * (i - L[i]) * height[i]; printf(&quot;%lld\n&quot;, ans); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>单调栈</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1212」「HNOI2004」L语言 (Trie + 存在性DP)]]></title>
    <url>%2Fbzoj1212%2F</url>
    <content type="text"><![CDATA[Bzoj 1212题意：一段文章$T$是由若干小写字母构成。一个单词$W$也是由若干小写字母构成。一个字典$D$是若干个单词的集合。我们称一段文章T在某个字典$D$下是可以被理解的，是指如果文章$T$可以被分成若干部分，且每一个部分都是字典$D$中的单词。给定一个字典$D$，你的程序需要判断若干段文章在字典$D$下是否能够被理解。并给出其在字典$D$下能够被理解的最长前缀的位置。 容易发现若一个串$S$能被理解，那么$S+D_i$也能理解那么我们就可以做一个存在性DP，按上面的来转移我们发现单词长度不超过10，那么我们将单词插进Trie树，树高最高为10，那么直接暴力转移即可。具体可以看代码实现。 知识点：1、数据范围小一定要重视2、思路想好再写，不要贪快 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 205; int ch[MAXN][27], val[MAXN], sz, dp[1000000 + 5]; int n, m; char s[1000000 + 5]; void insert() { int len = strlen(s), now = 0; for (int i = 0; i &lt; len; ++i) { int c = s[i] - &#39;a&#39;; if (!ch[now][c]) ch[now][c] = ++sz; now = ch[now][c]; if (i == len - 1) val[now] = 1; } } int pro(int ith) { dp[0] = ith; int len = strlen(s + 1), ans = 0; for (int i = 0; i &lt;= len; ++i) { if (dp[i] != ith) continue ; else ans = i; int now = 0; for (int j = i + 1; j &lt;= len; ++j) { int c = s[j] - &#39;a&#39;; if (!ch[now][c]) break ; now = ch[now][c]; if (val[now]) dp[j] = ith; } } return ans; } void clean() { ms(dp, 0), ms(ch, 0), ms(val, 0), sz = 0; } int solve() { clean(); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) scanf(&quot;%s&quot;, s), insert(); for (int i = 1; i &lt;= m; ++i) { scanf(&quot;%s&quot;, s + 1); printf(&quot;%d\n&quot;, pro(i)); } return 0; } } int main() { flyinthesky::solve(); return 0; } /* 4 3 is name what your whatisyouname whatisyourname whaisyourname 2 10 abc bc abcab 3 10 abcdefg cde 5 10 abc aba c bcbac a abacabcbacababcbacbcbbb */]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>Bzoj</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 3238」「AHOI2013」差异 (后缀数组+并查集/单调栈)]]></title>
    <url>%2Fbzoj3238%2F</url>
    <content type="text"><![CDATA[BZOJ 3238题意：给定一个长度为 $n$ 的字符串 $S$，令 $T_i$ 表示它从第 $i$ 个字符开始的后缀。求$$\sum_{i=1}^n \sum_{j=1}^{i-1} \text{len}(T_i) + \text{len}(T_j) - 2 \times \text{lcp}(T_i, T_j)$$其中，$\text{len}(a)$ 表示字符串 $a$ 的长度，$\text{lcp}(a,b)$ 表示字符串 $a$ 和字符串 $b$ 的最长公共前缀。 先将前面的求出来，等于$\frac{n(n+1)(n-1)}{2}​$, (可以分析一下合式组成或者将$j​$提取出来) 可以用艾佛森括号证明。$$\begin{aligned}ans &amp;= \sum_{i=1}^n\sum_{j=1}^i i+j \\&amp;= \sum_{i=1}^n\sum_{j=1}^n (i+j)[j &gt; i] \\&amp;= \sum_{i=1}^n\sum_{j=1}^n i[j &gt; i] + \sum_{i=1}^n\sum_{j=1}^n j[j &gt; i] \\&amp;= \sum_{i=1}^ni(n-i) + \sum_{i=1}^n\sum_{j=1}^n i(i-1) \\&amp;= \sum_{i=1}^ni(n-i) + i(i-1) \\&amp;= (n-1)\sum_{i=1}^ni \\&amp;= (n-1)\frac{n(n+1)(n-1)}{2} \\\end{aligned}$$ 考虑后面的$\text{lcp}(a,b)$，就是任意两个串的$\text{lcp}$的值。求出后缀数组，则$[2,n]$上$height$的每个区间对答案贡献区间最小值。 而这里可以仿造Bzoj 4199，用并查集来做下面考虑求每个区间最小值和的方法，这个是一个经典做法，即用单调栈解。我们对于每个$i \in [2,n]$，求出$L_i, R_i$分别表示这个$i$位置能扩展到左右多少位置(即当前$i$的$height$值的扩展区域)那么最后答案就是$\sum\limits_{i=2}^n (i - L_i)(R_i - i) $，即为区间端点在$i​$两端的方案。 考虑左边界怎么扩展，我们找到离$i$左边最近的$height_j \leq height_i$，则$L_i=j$右边界即找到离$i$右边最近的$height_j \geq height_i$，则$R_i=j$ 那么求单调栈维护这个就行了，单调栈维护的标志有上面加粗的关键字。具体可以看代码实现。注意处理一下边界状态。上面的可以画图更加清晰 知识点1、求每个区间最小值和的方法：单调栈 单调栈： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 500000 + 5; char ch[MAXN]; int a[MAXN], n, m; int SA[MAXN], rk[MAXN], tp[MAXN], tax[MAXN], height[MAXN]; void build() {//11?¨¬o¨®¡Áo¨ºy¡Á¨¦ for (int i = 1; i &lt;= m; ++i) tax[i] = 0; for (int i = 1; i &lt;= n; ++i) tax[rk[i] = a[i]]++; for (int i = 1; i &lt;= m; ++i) tax[i] += tax[i - 1]; for (int i = n; i &gt;= 1; --i) SA[tax[rk[i]]--] = i;//?¨´¨ºy??D¨°??¦Ì¨²¨°??? for (int k = 1; k &lt;= n; k &lt;&lt;= 1) { int p = 0; for (int i = n - k + 1; i &lt;= n; i++) tp[++p] = i;//(n-k)~(n-1)?T¦Ì¨²?t1??¨¹¡Á?¡ê??¨´¨°???D¨°¨®|?????¨²?¡ã?? for (int i = 1; i &lt;= n; i++) if (SA[i] &gt; k) tp[++p] = SA[i] - k; //??¨®DSA[i]&gt;=k¦Ì?SA[i]2?¨º?¦Ì¨²?t1??¨¹¡Á?¦Ì????? //¡ä¨®¨ª??D?¨¦¨°??¡ä3?¦Ì¨²¨°?1??¨¹¡Á?o¨ª¦Ì¨²?t1??¨¹¡Á?¦Ì??????¨¤2?k¡ê?1¨ºSA[i] - k for (int i = 1; i &lt;= m; ++i) tax[i] = 0; for (int i = 1; i &lt;= n; ++i) tax[rk[tp[i]]]++;//x[tp[i]]?¨¤¦Ì¨¨¨®¨²????¦Ì¨²i¦Ì?¦Ì¨²?t1??¨¹¡Á?¦Ì?¦Ì¨²¨°?1??¨¹¡Á?¦Ì????? for (int i = 1; i &lt;= m; ++i) tax[i] += tax[i - 1]; for (int i = n; i &gt;= 1; --i) SA[tax[rk[tp[i]]]--] = tp[i];//¡À¡ê?¡è¨¢?¦Ì¨²¨°?1??¨¹¡Á?¦Ì??3D¨°?¨´??¦Ì¨²?t1??¨¹¡Á? //?¨´¨ºy??D¨°¦Ì¨²¨°?1??¨¹¡Á?(rank[i]¦Ì?¨ºy?¦Ì)o¨ª¦Ì¨²?t1??¨¹¡Á?(tp[i]¦Ì???¡À¨º) swap(rk, tp);//¡ä?¨º¡Àtp??¨®?¡ê??Y¡ä?¨¦?¨°???rank¦Ì??¦Ì p = 1, rk[SA[1]] = 1; for (int i = 2; i &lt;= n; ++i) rk[SA[i]] = (tp[SA[i]] == tp[SA[i - 1]] &amp;&amp; tp[SA[i] + k] == tp[SA[i - 1] + k]) ? p : ++p; //??????¦Ì¨²i¦Ì?¨ºy¦Ì?rank¡ê?¡ã¡äsa?3D¨°?¨¹1?¡À¡ê?¡èrank¦Ì??y¨¨¡¤D?¡ê?¦Ì?¨º?¨°acmp?D??¨®?¨¦?¨°???¡Á?¡¤?¡ä??¨¤¦Ì¨¨¦Ì??¨¦?? if (p &gt;= n) break;//???|¡ê?¨°??-??¨®D???¡ä?a?? m = p; } int k = 0;//k¨º?¡À¨¨i-1?¡ã¨°???¦Ì?o¨®¡Áo for (int i = 1; i &lt;= n; ++i) {//H[0], H[1], H[2] ...¦Ì??3D¨°???? if (k) k--;//¡ä¨®k-1?a¨º?¡À¨¨?? ,??¨®??¨¢??H[i]&gt;=H[i-1]-1, ¡Á?3¡è1?12?¡ã¡Áo¦Ì?3¡è?¨¨?¨¢¨¦¨´¨º?k-1(k = H[i-1]) int j = SA[rk[i] - 1]; //?¡ã¨°???¦Ì?o¨®¡Áo???? while (ch[i + k] == ch[j + k]) k++; //¨ª¨´o¨®¡À¨¨?? height[rk[i]] = k; //?¨¹D?¡äe¡ã? } } LL L[MAXN], R[MAXN], st[MAXN], top = 0, ans = 0; void clean() { m = 30; } int solve() { clean(); scanf(&quot;%s&quot;, ch + 1); n = strlen(ch + 1); for (int i = 1; i &lt;= n; ++i) a[i] = ch[i] - &#39;a&#39; + 1, ans += 3ll * i * (i - 1ll) / 2ll; build(); st[top = 1] = 1; for (int i = 2; i &lt;= n; ++i) { while (top &amp;&amp; height[st[top]] &gt; height[i]) R[st[top--]] = i; // 找到第一个 height[j] &lt;= height[i], 并且没找到时 height[j] &gt; height[i]，则可以更新 j 的 R L[i] = st[top]; st[++top] = i; } while (top) R[st[top--]] = n + 1; for (int i = 1; i &lt;= n; ++i) ans -= 1ll * (R[i] - i) * (i - L[i]) * height[i] * 2ll; printf(&quot;%lld\n&quot;, ans); return 0; } } int main() { flyinthesky::solve(); return 0; } //22:37 /* */ 并查集： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 500000 + 5; char ch[MAXN]; int a[MAXN], n, m; int SA[MAXN], rk[MAXN], tp[MAXN], tax[MAXN], height[MAXN]; void build() {//¹¹Ôìºó×ºÊý×é for (int i = 1; i &lt;= m; ++i) tax[i] = 0; for (int i = 1; i &lt;= n; ++i) tax[rk[i] = a[i]]++; for (int i = 1; i &lt;= m; ++i) tax[i] += tax[i - 1]; for (int i = n; i &gt;= 1; --i) SA[tax[rk[i]]--] = i;//»ùÊýÅÅÐòÅÅµÚÒ»ÂÖ for (int k = 1; k &lt;= n; k &lt;&lt;= 1) { int p = 0; for (int i = n - k + 1; i &lt;= n; i++) tp[++p] = i;//(n-k)~(n-1)ÎÞµÚ¶þ¹Ø¼ü×Ö£¬ËùÒÔÅÅÐòÓ¦¸ÃÅÅÔÚÇ°Ãæ for (int i = 1; i &lt;= n; i++) if (SA[i] &gt; k) tp[++p] = SA[i] - k; //Ö»ÓÐSA[i]&gt;=kµÄSA[i]²ÅÊÇµÚ¶þ¹Ø¼ü×ÖµÄÎ»ÖÃ //´ÓÍ¼ÖÐ¿ÉÒÔ¿´³öµÚÒ»¹Ø¼ü×ÖºÍµÚ¶þ¹Ø¼ü×ÖµÄÎ»ÖÃÏà²îk£¬¹ÊSA[i] - k for (int i = 1; i &lt;= m; ++i) tax[i] = 0; for (int i = 1; i &lt;= n; ++i) tax[rk[tp[i]]]++;//x[tp[i]]ÏàµÈÓÚÅÅÃûµÚiµÄµÚ¶þ¹Ø¼ü×ÖµÄµÚÒ»¹Ø¼ü×ÖµÄÅÅÃû for (int i = 1; i &lt;= m; ++i) tax[i] += tax[i - 1]; for (int i = n; i &gt;= 1; --i) SA[tax[rk[tp[i]]]--] = tp[i];//±£Ö¤ÁËµÚÒ»¹Ø¼ü×ÖµÄË³ÐòÔÙÅÅµÚ¶þ¹Ø¼ü×Ö //»ùÊýÅÅÐòµÚÒ»¹Ø¼ü×Ö(rank[i]µÄÊýÖµ)ºÍµÚ¶þ¹Ø¼ü×Ö(tp[i]µÄÏÂ±ê) swap(rk, tp);//´ËÊ±tpÃ»ÓÃ£¬ÔÝ´æÉÏÒ»ÂÖrankµÄÖµ p = 1, rk[SA[1]] = 1; for (int i = 2; i &lt;= n; ++i) rk[SA[i]] = (tp[SA[i]] == tp[SA[i - 1]] &amp;&amp; tp[SA[i] + k] == tp[SA[i - 1] + k]) ? p : ++p; //ËãÅÅÃûµÚiµÄÊýµÄrank£¬°´saË³ÐòÄÜ¹»±£Ö¤rankµÄÕýÈ·ÐÔ£¬µ«ÊÇÒªcmpÅÐ¶ÏÓëÉÏÒ»¸ö×Ö·û´®ÏàµÈµÄÇé¿ö if (p &gt;= n) break;//¼ôÖ¦£¬ÒÑ¾­Ã»ÓÐÖØ¸´ÔªËØ m = p; } int k = 0;//kÊÇ±Èi-1Ç°Ò»ÃûµÄºó×º for (int i = 1; i &lt;= n; ++i) {//H[0], H[1], H[2] ...µÄË³Ðò¼ÆËã if (k) k--;//´Ók-1¿ªÊ¼±È½Ï ,ÔËÓÃ½áÂÛH[i]&gt;=H[i-1]-1, ×î³¤¹«¹²Ç°×ºµÄ³¤¶ÈÖÁÉÙÊÇk-1(k = H[i-1]) int j = SA[rk[i] - 1]; //Ç°Ò»ÃûµÄºó×ºÎ»ÖÃ while (ch[i + k] == ch[j + k]) k++; //Íùºó±È½Ï height[rk[i]] = k; //¸üÐÂ´ð°¸ } } LL ans = 0; vector&lt;int &gt; vec[MAXN]; int sz[MAXN], f[MAXN]; int find(int x) {return x == f[x] ? x : f[x] = find(f[x]);} void merge(int x, int y, int len) { if (sz[x] &gt; sz[y]) swap(x, y); ans -= 2ll * sz[x] * sz[y] * len; f[x] = y, sz[y] += sz[x]; } void clean() { m = 30; } int solve() { clean(); scanf(&quot;%s&quot;, ch + 1); n = strlen(ch + 1); for (int i = 1; i &lt;= n; ++i) a[i] = ch[i] - &#39;a&#39; + 1, ans += 3ll * i * (i - 1ll) / 2ll; build(); for (int i = 1; i &lt;= n; ++i) vec[height[i]].push_back(i), sz[i] = 1, f[i] = i; for (int len = n - 1; len &gt;= 1; --len) { for (int i = 0; i &lt; (int)vec[len].size(); ++i) { int v = vec[len][i]; merge(find(v), find(v - 1), len); } } printf(&quot;%lld\n&quot;, ans); return 0; } } int main() { flyinthesky::solve(); return 0; } //22:37 /* */]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>Bzoj</tag>
        <tag>单调栈</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 4567」「SCOI2016」背单词 (Trie 前缀关系树 + 贪心)]]></title>
    <url>%2Fbzoj4567%2F</url>
    <content type="text"><![CDATA[BZOJ 4567题意：给你$n$个字符串，不同的排列有不同的代价，代价按照如下方式计算（字符串$s$的位置为$x$）：1.排在$s$后面的字符串有$s$的后缀，则代价为$n^2$；2.排在$s$前面的字符串有$s$的后缀，且没有排在$s$后面的$s$的后缀，则代价为$x-y$（$y$为最后一个与$s$不相等的后缀的位置）；3.$s$没有后缀，则代价为$x$。求最小代价和。(吐槽一波题意) 显然第一种操作尽量少用($n^2$和$n$的增长级)，其实我们完全可以避免这种操作出现，即将他后缀权值安排在他前面。 那么我们将字符串翻转插进Trie，这样就可以维护后缀。现在问题是Trie上有很多没有单词虚节点，不好处理，我们将其全部删掉，然后将有单词的数组成Trie 前缀关系树，那么这个树上孩子的最长前缀一定是父亲节点。 那么现在问题就是给每个点标号，然后让孩子节点减父亲节点的标号的差的总和最小。考虑将所有单词连接的虚点设为0，那么将这个虚点算作其中，然后将操作2转化到操作3。 那么我们现在可以考虑一个贪心，即从根开始DFS，每次找子树大小最小的进去然后DFS序是最优的。具体证明比较困难，但是可以意会一下，即可以发现这样可以让后面的孩子的标号尽量小。 知识点1、将字符串翻转插进Trie，这样就可以维护后缀。2、将有单词的数组成Trie 前缀关系树 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 520000 + 5; int n, ch[MAXN][26], val[MAXN], sz; char s[MAXN]; vector&lt;int &gt; G[MAXN]; int sz_G, siz[MAXN], col[MAXN], idx; bool cmp(int x, int y) {return siz[x] &lt; siz[y];} void ins(int u, int v) {G[u].push_back(v);} void insert() { int now = 0, len = strlen(s); for (int i = len - 1; i &gt;= 0; --i) { int c = s[i] - &#39;a&#39;; if (!ch[now][c]) ch[now][c] = ++sz; now = ch[now][c]; if (i == 0) val[now] = 1; } } void dfs_build(int u, int chain) { if (val[u]) ins(chain, ++sz_G), chain = sz_G; for (int c = 0; c &lt; 26; ++c) { int v = ch[u][c]; if (v) dfs_build(v, chain); } } void dfs_siz(int u, int fa) { siz[u] = 1; for (int i = 0; i &lt; (int)G[u].size(); ++i) { int v = G[u][i]; if (v != fa) dfs_siz(v, u), siz[u] += siz[v]; } } LL ans = 0; void dfs(int u, int fa) { col[u] = ++idx; for (int i = 0; i &lt; (int)G[u].size(); ++i) { int v = G[u][i]; if (v != fa) { dfs(v, u); ans += col[v] - col[u]; } } } void clean() { ms(ch, 0), ms(val, 0), sz_G = sz = 0, ms(siz, 0), ms(col, 0), idx = -1; } int solve() { clean(); cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) scanf(&quot;%s&quot;, s), insert(); dfs_build(0, 0); dfs_siz(0, -1); for (int u = 0; u &lt;= sz_G; ++u) sort(G[u].begin(), G[u].end(), cmp); dfs(0, -1); //for (int u = 0; u &lt;= sz_G; ++u) for (int i = 0; i &lt; (int)G[u].size(); ++i) printf(&quot;u=%d, v=%d\n&quot;, u, G[u][i]); printf(&quot;%lld\n&quot;, ans); return 0; } } int main() { flyinthesky::solve(); return 0; } // /* 3 a ab c */]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>Bzoj</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 4199」「NOI2015」品酒大会 (后缀数组+并查集)]]></title>
    <url>%2Fbzoj4199%2F</url>
    <content type="text"><![CDATA[BZOJ 4199题意：见上。 40分即枚举两个点Hash即可。50分改为枚举长度+一个点，Hash即可。考虑100分情况我们发现两个答案都是都是递减的，所以我们可以逆向求答案。(后缀和过程)这题显然是要用后缀数组了我们将$height$值一样的存在一个vector里，然后按照$height$值倒着求答案。附上样例一说明，SA后我们会得到如下的信息： i height sa stringsai asai 1 0 10 i 7 2 1 5 iiipoi 4 3 2 6 iipoi 8 4 1 7 ipoi 3 5 0 3 noiiipoi 4 6 0 9 oi 4 7 2 4 oiiipoi 7 8 1 2 onoiiipoi 1 9 0 8 poi 6 10 2 1 ponoiiipoi2 具体可以看xht 37 大佬的题解这里直接讲并查集做法，即每次找一个位置，就把他和$SA$序上$i-1$位和$i$位的位置在并查集上合并，那么下次找的话，就可以直接统计两个连通块的信息。并查集维护集合大小，集合最大值最小值(有负数存在，所以最大乘积可能来自最小值)，以上从上面的表格中可以分析出来 知识点 1、注意不要将SA的任何字符映射到0 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 300000 + 5; const LL INF = 1e18 + 2; char ch[MAXN]; int a[MAXN], n, m, v[MAXN]; int SA[MAXN], rk[MAXN], tp[MAXN], tax[MAXN], height[MAXN]; void build() {//构造后缀数组 for (int i = 1; i &lt;= m; ++i) tax[i] = 0; for (int i = 1; i &lt;= n; ++i) tax[rk[i] = a[i]]++; for (int i = 1; i &lt;= m; ++i) tax[i] += tax[i - 1]; for (int i = n; i &gt;= 1; --i) SA[tax[rk[i]]--] = i;//基数排序排第一轮 for (int k = 1; k &lt;= n; k &lt;&lt;= 1) { int p = 0; for (int i = n - k + 1; i &lt;= n; i++) tp[++p] = i;//(n-k)~(n-1)无第二关键字，所以排序应该排在前面 for (int i = 1; i &lt;= n; i++) if (SA[i] &gt; k) tp[++p] = SA[i] - k; //只有SA[i]&gt;=k的SA[i]才是第二关键字的位置 //从图中可以看出第一关键字和第二关键字的位置相差k，故SA[i] - k for (int i = 1; i &lt;= m; ++i) tax[i] = 0; for (int i = 1; i &lt;= n; ++i) tax[rk[tp[i]]]++;//x[tp[i]]相等于排名第i的第二关键字的第一关键字的排名 for (int i = 1; i &lt;= m; ++i) tax[i] += tax[i - 1]; for (int i = n; i &gt;= 1; --i) SA[tax[rk[tp[i]]]--] = tp[i];//保证了第一关键字的顺序再排第二关键字 //基数排序第一关键字(rank[i]的数值)和第二关键字(tp[i]的下标) swap(rk, tp);//此时tp没用，暂存上一轮rank的值 p = 1, rk[SA[1]] = 1; for (int i = 2; i &lt;= n; ++i) rk[SA[i]] = (tp[SA[i]] == tp[SA[i - 1]] &amp;&amp; tp[SA[i] + k] == tp[SA[i - 1] + k]) ? p : ++p; //算排名第i的数的rank，按sa顺序能够保证rank的正确性，但是要cmp判断与上一个字符串相等的情况 if (p &gt;= n) break;//剪枝，已经没有重复元素 m = p; } int k = 0;//k是比i-1前一名的后缀 for (int i = 1; i &lt;= n; ++i) {//H[0], H[1], H[2] ...的顺序计算 if (k) k--;//从k-1开始比较 ,运用结论H[i]&gt;=H[i-1]-1, 最长公共前缀的长度至少是k-1(k = H[i-1]) int j = SA[rk[i] - 1]; //前一名的后缀位置 while (ch[i + k] == ch[j + k]) k++; //往后比较 height[rk[i]] = k; //更新答案 } } int f[MAXN], maxd[MAXN], mind[MAXN], sz[MAXN]; LL mp[MAXN], ans1, ans2, fans[MAXN][2]; vector&lt;int &gt; vec[MAXN]; int find(int x) {return x == f[x] ? x : f[x] = find(f[x]);} void merge(int x, int y) { if (sz[x] &gt; sz[y]) swap(x, y); f[x] = y; ans1 += 1ll * sz[x] * sz[y]; sz[y] += sz[x]; mp[y] = max(mp[y], max(1ll * maxd[x] * maxd[y], 1ll * mind[x] * mind[y])); maxd[y] = max(maxd[x], maxd[y]); mind[y] = min(mind[x], mind[y]); ans2 = max(ans2, mp[y]); } void clean() { ms(fans, 0), m = 30; } int solve() { clean(); cin &gt;&gt; n; scanf(&quot;%s&quot;, ch + 1); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;v[i]), a[i] = ch[i] - &#39;a&#39; + 1; build(); for (int i = 1; i &lt;= n; ++i) { f[i] = i, sz[i] = 1; maxd[i] = mind[i] = v[SA[i]]; mp[i] = -INF; } ans1 = 0, ans2 = -INF; for (int i = 1; i &lt;= n; ++i) vec[height[i]].push_back(i); for (int len = n - 1; len &gt;= 0; --len) { for (int i = 0; i &lt; (int)vec[len].size(); ++i) { int u = vec[len][i]; merge(find(u), find(u - 1)); if (ans1) fans[len][0] = ans1, fans[len][1] = ans2; } } for (int i = 0; i &lt; n; ++i) printf(&quot;%lld %lld\n&quot;, fans[i][0], fans[i][1]); return 0; } } int main() { flyinthesky::solve(); return 0; } /* 4 aaaa 1 1 1 1 */]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>Bzoj</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 2434」「Noi2011」阿狸的打字机 (AC自动机Fail树+DFS序+树状数组)]]></title>
    <url>%2Fbzoj2434%2F</url>
    <content type="text"><![CDATA[Bzoj 2434题意：见上。 先介绍 Trie，Trie图，Fail树 将字符串插入 Trie 即可得到下图 将失配函数连上，得到Trie图 Trie图可以将字符串问题转化为图论问题，具体可以看Bzoj 2938 将原边删掉，失配边反向，得到Fail树 Fail树每个点的祖先节点都是这个点失配后可以走到的点。对于AC自动机中的每一个节点，如果节点A的失配边指向节点B，就会发现B对应的字符串一定在A对应的字符串中出现，那么在Fail树上显然可以利用这一性质。 考虑暴力，即在Fail树上往上跳。 我们还可以离线，将$y$相等的并成一块，一起处理，能过$70$分。 逆向思维，我们考虑对于每个$x$去找$y$，那么标记一下$y$能跳到的点，求子树和即可。显然可以树状数组维护DFS序。 而这样还是不能通过。我们发现每次初始化$y$能跳到的点进树状数组时，时间开销非常大。我们考虑边加边统计。 我们在原Trie树上DFS，将当前点$u$根路径上的点标记为$1$，然后再Fail树上求每个$u$对应的询问的$x$的子树和即可。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 100000 + 5; // AC自动机 int Q, ch[MAXN][26], fa[MAXN], f[MAXN], val[MAXN], sz, pos[MAXN]; char s[MAXN]; queue&lt;int &gt; q; void getFail() { for (int c = 0; c &lt; 26; ++c) { int v = ch[0][c]; if (v) q.push(v), f[v] = 0; } while (!q.empty()) { int u = q.front(); q.pop(); for (int c = 0; c &lt; 26; ++c) { int v = ch[u][c]; if (!v) continue ; q.push(v); int j = f[u]; while (j &amp;&amp; !ch[j][c]) j = f[j]; f[v] = ch[j][c]; } } } // Fail树 vector&lt;int &gt; G[MAXN]; int dfn[MAXN], rr[MAXN], idx; void ins(int u, int v) {G[u].push_back(v);} void dfs_pre(int u, int p) { dfn[u] = ++idx; for (int i = 0; i &lt; (int)G[u].size(); ++i) { int v = G[u][i]; if (v != p) dfs_pre(v, u); } rr[u] = idx; } // 树状数组 int c[MAXN]; int lowbit(int x) {return x &amp; (-x);} void add(int x, int v) {for (int i = x; i &lt;= sz + 1; i += lowbit(i)) c[i] += v;} int query(int x) {int ret = 0; for (int i = x; i &gt; 0; i -= lowbit(i)) ret += c[i]; return ret;} // 询问 struct qry { int x, y, id; bool operator &lt; (const qry &amp;rhs) const {return y &lt; rhs.y;} } xw[MAXN]; int ql[MAXN], qr[MAXN], ans[MAXN]; void dfs_ans(int u, int p) { add(dfn[u], 1); if (val[u]) for (int i = ql[u]; i &lt;= qr[u]; ++i) ans[xw[i].id] = query(rr[pos[xw[i].x]]) - query(dfn[pos[xw[i].x]] - 1); for (int c = 0; c &lt; 26; ++c) { int v = ch[u][c]; if (v) dfs_ans(v, u); } add(dfn[u], -1); } void clean() { ms(ch, 0), ms(fa, 0), ms(f, 0), ms(val, 0), sz = 0; ms(dfn, 0), ms(rr, 0), idx = 0; ms(c, 0); } int solve() { clean(); scanf(&quot;%s&quot;, s); int len = strlen(s), now = 0, cnt = 0; for (int i = 0; i &lt; len; ++i) { if (s[i] == &#39;P&#39;) val[now] = 1, pos[++cnt] = now; else if (s[i] == &#39;B&#39;) now = fa[now]; else { int c = s[i] - &#39;a&#39;; if (!ch[now][c]) ch[now][c] = ++sz; fa[ch[now][c]] = now, now = ch[now][c]; } } getFail(); for (int i = 1; i &lt;= sz; ++i) ins(i, f[i]), ins(f[i], i); dfs_pre(0, -1); cin &gt;&gt; Q; for (int i = 1; i &lt;= Q; ++i) scanf(&quot;%d%d&quot;, &amp;xw[i].x, &amp;xw[i].y), xw[i].id = i; sort(xw + 1, xw + 1 + Q); for (int p = 1, i = 1; i &lt;= Q; i = p) { ql[pos[xw[i].y]] = qr[pos[xw[i].y]] = i; while (xw[i].y == xw[++p].y) ++qr[pos[xw[i].y]]; } dfs_ans(0, -1); for (int i = 1; i &lt;= Q; ++i) printf(&quot;%d\n&quot;, ans[i]); return 0; } } int main() { flyinthesky::solve(); return 0; } /* abbPcP 1 1 2 abbPcP 1 1 1 */]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>树状数组</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 2938」「Poi2000」病毒 (AC自动机Trie图 + DFS找环)]]></title>
    <url>%2Fbzoj2938%2F</url>
    <content type="text"><![CDATA[bzoj 2938题意：见上。 将AC自动机的Fail指针都连上，那么就形成了一个Trie图。在Trie图上找到一个不含危险点的环即有解，否则无解。 找环即用Tarjan的思想，模拟一个栈 知识点：1、Trie图的运用2、DFS找环 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 30000 + 5; int n, ch[MAXN][2], f[MAXN], danger[MAXN], sz; int vis[MAXN], ex[MAXN]; char s[30000 + 5]; queue&lt;int &gt; q; void insert(char *s) { int len = strlen(s), now = 0; for (int i = 0; i &lt; len; ++i) { int c = s[i] - &#39;0&#39;; if (!ch[now][c]) ch[now][c] = ++sz; now = ch[now][c]; if (i == len - 1) danger[now] = 1; } } void getFail() { f[0] = 0; for (int c = 0; c &lt; 2; ++c) { int v = ch[0][c]; if (v) q.push(v), f[v] = 0; } while (!q.empty()) { int u = q.front(); q.pop(); for (int c = 0; c &lt; 2; ++c) { int v = ch[u][c]; if (!v) {ch[u][c] = ch[f[u]][c]; continue ;} q.push(v); int j = f[u]; while (j &amp;&amp; !ch[j][c]) j = f[j]; f[v] = ch[j][c]; if (danger[f[v]]) danger[v] = 1; } } } void dfs(int u) { if (ex[u]) {printf(&quot;TAK\n&quot;); exit(0);} if (danger[u]) return ; if (vis[u]) return ; vis[u] = ex[u] = 1; dfs(ch[u][0]); dfs(ch[u][1]); ex[u] = 0; } void clean() { ms(ch, 0), ms(f, 0), ms(danger, 0), sz = 0; ms(vis, 0), ms(ex, 0); } int solve() { clean(); cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) { scanf(&quot;%s&quot;, s); insert(s); } getFail(); dfs(0); printf(&quot;NIE\n&quot;); return 0; } } int main() { flyinthesky::solve(); return 0; } /* 1 1 1 0 1 01 2 01 10 2 1 0 3 011 11 00000 3 011 11 0 */]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>DFS</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 2559」「IOI2011」Race (点分治)]]></title>
    <url>%2Fbzoj2559%2F</url>
    <content type="text"><![CDATA[BZOJ 2559题意：给一棵树，每条边有权。求一条简单路径，权值和等于 $K$，且边的数量最小。 点分治模板题，但是这里维护的是不可加信息，不能用容斥的方法，我们求每个点的值的时候按一定顺序遍历他的儿子，然后将前面的存起来供后面的合并(类似树直径DP)，然后就不用考虑容斥了，都是可行的合并。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 200000 + 5, INF = 0x3f3f3f3f; struct edge { int v, w, nxt; } ed[MAXN * 2]; int n, k, en, hd[MAXN]; int wt[MAXN], siz[MAXN], Tsz, rt; int vis[MAXN]; int ans; int tot, dis[MAXN], bs[MAXN]; void ins(int u, int v, int w) {ed[++en] = (edge){v, w, hd[u]}, hd[u] = en;} void getRt(int u, int fa) { // 找 u 子树的重心 siz[u] = 1, wt[u] = 0; for (int i = hd[u]; i &gt; 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (e.v != fa &amp;&amp; !vis[e.v]) getRt(e.v, u), siz[u] += siz[e.v], wt[u] = max(wt[u], siz[e.v]); } wt[u] = max(wt[u], Tsz - siz[u]); if(wt[rt] &gt; wt[u]) rt = u; } void getD(int u, int fa, int D, int b) { if (D &gt; k) return ; dis[++tot] = D, bs[tot] = b; for (int i = hd[u]; i &gt;= 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (e.v != fa &amp;&amp; !vis[e.v]) getD(e.v, u, D + e.w, b + 1); } } int tax[1000000 + 5]; void calc(int u) { tot = 0, tax[0] = 0; for (int i = hd[u]; i &gt;= 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (!vis[e.v]) { int whw = tot; getD(e.v, u, e.w, 1); for (int j = whw + 1; j &lt;= tot; ++j) ans = min(ans, tax[k - dis[j]] + bs[j]); for (int j = whw + 1; j &lt;= tot; ++j) tax[dis[j]] = min(tax[dis[j]], bs[j]); } } for (int i = 1; i &lt;= tot; ++i) tax[dis[i]] = INF; } void dfs(int u) { vis[u] = 1; calc(u); for (int i = hd[u]; i &gt;= 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (!vis[e.v]) { rt = 0, Tsz = siz[e.v], wt[0] = INF, getRt(e.v, 0); dfs(rt); // rt } } } void clean() { en = -1, ms(hd, -1); ms(wt, 0), ms(siz, 0), ms(vis, 0); ms(tax, 0x3f), ans = INF; } int solve() { clean(); cin &gt;&gt; n &gt;&gt; k; if (k == 0) return printf(&quot;0\n&quot;), 0; for (int x, y, w, i = 1; i &lt; n; ++i) { scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;w); ++x, ++y; ins(x, y, w), ins(y, x, w); } rt = 0, Tsz = n, wt[0] = INF, getRt(1, 0); dfs(rt); if (ans &gt;= n) printf(&quot;-1\n&quot;); else printf(&quot;%d\n&quot;, ans); return 0; } } int main() { flyinthesky::solve(); return 0; } /* 5 3 0 1 1 1 3 1 0 2 1 2 4 5 */]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu 3674」小清新人渣的本愿 (Bitset + 莫队 + 复杂度分析)]]></title>
    <url>%2FLuogu3674%2F</url>
    <content type="text"><![CDATA[Luogu 3674题意：给你一个序列，长度为$n$，有$m$次操作，每次询问一个区间是否可以选出两个数它们的差为$x$，或者询问一个区间是否可以选出两个数它们的和为$x$，或者询问一个区间是否可以选出两个数它们的乘积为x ，这三个操作分别为操作$1,2,3$。选出的这两个数可以是同一个位置的数 无修改无强制在线，则离线即可。给出了值域范围，那么就是让我们记录这些值考虑如何记录。可以开桶来记录。但是这里我们并不需要知道某个数出现了几次，只需要知道有没有即可。对于这种01数组，我们可以想到bitset 设维护值域下的bitset为$\operatorname{bs}$对于询问一个$x=a-b$，那么就相当于bs &amp; (bs &gt;&gt; x)不为假。可以当做一个平移的感觉。对于询问$x=a+b$，我们可以维护一个反的bitset，然后达到将其左移后能和原来正着的bitset有值的效果，具体可以模拟一下。 对于乘法，直接$\sqrt x$枚举即可。 知识点：1、Bitset 左移右移 技巧2、乘法复杂度分析 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;bitset&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 100000 + 5, ZY = 100000; int n, m, blolen, bl[MAXN], a[MAXN]; int nl, nr, tax[MAXN], ans[MAXN]; bitset&lt;ZY + 5 &gt; bs1, bs2; struct qry { int l, r, ty, x, id; bool operator &lt; (const qry &amp;rhs) const { return bl[l] == bl[rhs.l] ? r &lt; rhs.r : bl[l] &lt; bl[rhs.l]; } } xw[MAXN]; void inc(int pos) { if (++tax[a[pos]] == 1) bs1[a[pos]] = bs2[ZY - a[pos]] = 1; } void dec(int pos) { if (--tax[a[pos]] == 0) bs1[a[pos]] = bs2[ZY - a[pos]] = 0; } void clean() { ms(ans, 0), ms(bl, 0), ms(tax, 0); } int solve() { clean(); cin &gt;&gt; n &gt;&gt; m; blolen = (int)sqrt(n); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i]), bl[i] = (i - 1) / blolen + 1; for (int i = 1; i &lt;= m; ++i) { scanf(&quot;%d%d%d%d&quot;, &amp;xw[i].ty, &amp;xw[i].l, &amp;xw[i].r, &amp;xw[i].x); xw[i].id = i; } sort(xw + 1, xw + 1 + m); nl = 1, nr = 0; for (int i = 1; i &lt;= m; ++i) { while (nl &gt; xw[i].l) inc(nl - 1), --nl; while (nr &lt; xw[i].r) inc(nr + 1), ++nr; while (nl &lt; xw[i].l) dec(nl), ++nl; while (nr &gt; xw[i].r) dec(nr), --nr; if (xw[i].ty == 1) { if ((bs1 &amp; (bs1 &gt;&gt; xw[i].x)).count()) ans[xw[i].id] = 1; } else if (xw[i].ty == 2) { if ((bs1 &amp; (bs2 &gt;&gt; (ZY - xw[i].x))).count()) ans[xw[i].id] = 1; //for (int i = ZY; i &gt;= ZY - 10; --i) printf(&quot;%d&quot;, (int)bs2[i]); } else if (xw[i].ty == 3) { for (int j = 1; j * j &lt;= xw[i].x; ++j) { if (xw[i].x % j == 0) { if (bs1[j] &amp;&amp; bs1[xw[i].x / j]) { ans[xw[i].id] = 1; break; } } } } } for (int i = 1; i &lt;= m; ++i) printf(&quot;%s&quot;, ans[i] ? &quot;hana\n&quot; : &quot;bi\n&quot;); return 0; } } int main() { flyinthesky::solve(); return 0; } /* 5 1 1 1 2 3 4 2 3 5 7 */]]></content>
      <tags>
        <tag>STL</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 3410」「HNOI2013」消毒 (最小点覆盖)]]></title>
    <url>%2Fbzoj3410%2F</url>
    <content type="text"><![CDATA[BZOJ 3410题意：有一个长方体，有一些格子上有$1$，你可以进行$k$次操作，每次选择一个长方体区域$(x,y,z)$，代价为$\min(x,y,z)$，可以将这个区域所以$1$改为$0$，求最小的$k$使得整个长方体都为$0$ 先是要发现代价为$\min(x,y,z)$其实就意思是，我们选择一个代价不为$1$的操作，都可以转化成若干代价为$1$的操作，并且答案不会更差。所以这题就是一个三维的poj 3041。 然而三维并不能三分图，那么我们发现题目给的数据范围$A\cdot B \cdot C \leq 5000$，那么必然有一个数小于$\sqrt[3]{5000} \approx 17$，所以我们假设$A$就是这个最小的数(不是的话可以交换坐标，几何意义就是将长方体换个方向)。那么暴力枚举每一层是否操作，然后再将另外两维做平面上最小点覆盖即可。 知识点1、隐含小数据：乘积 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; int T; namespace flyinthesky { const int MAXN = 5000 + 5; struct EDGE { int v, nxt; } ED[MAXN]; int EN, HD[MAXN]; int A, B, C, oA, oB, oC; int lk[MAXN], vis[MAXN], cnt, ys[4], tot; struct edge { int pos[4]; } ed[MAXN]; bool hungary(int u) { for (int i = HD[u]; i &gt;= 0; i = ED[i].nxt) { int v = ED[i].v; if (vis[v] != cnt) { vis[v] = cnt; if (!lk[v] || hungary(lk[v])) { lk[v] = u; return true; } } } return false; } void ins(int x, int y) {ED[++EN] = (EDGE){y, HD[x]}, HD[x] = EN;} void clean() { tot = 0; } int solve() { clean(); scanf(&quot;%d%d%d&quot;, &amp;A, &amp;B, &amp;C), oA = A, oB = B, oC = C; ys[0] = 0, ys[1] = 1, ys[2] = 2; if (B &gt; A) swap(A, B), swap(ys[0], ys[1]); if (C &gt; A) swap(A, B), swap(ys[0], ys[2]); for (int i = 1; i &lt;= oA; ++i) { for (int j = 1; j &lt;= oB; ++j) { for (int x, k = 1; k &lt;= oC; ++k) { scanf(&quot;%d&quot;, &amp;x); if (x == 1) { ++tot; ed[tot].pos[ys[0]] = i; ed[tot].pos[ys[1]] = j; ed[tot].pos[ys[2]] = k; } } } } int ans = 2000000000; for (int S = 0; S &lt; (1 &lt;&lt; A); ++S) { EN = -1; for (int i = 0; i &lt;= B; ++i) HD[i] = -1; for (int i = 0; i &lt;= C; ++i) vis[i] = lk[i] = 0; int whw = 0; for (int tmp = S; tmp; tmp &amp;= (tmp - 1)) ++whw; for (int i = 1; i &lt;= tot; ++i) { if (!(S &amp; (1 &lt;&lt; (ed[i].pos[0] - 1)))) { ins(ed[i].pos[1], ed[i].pos[2]); } } int ret = 0; for (int i = 1; i &lt;= B; ++i) if (hungary(cnt = i)) ++ret; ans = min(ans, ret + whw); } cout &lt;&lt; ans &lt;&lt; endl; return 0; } } int main() { //freopen(&quot;1.in&quot;, &quot;r&quot;, stdin); cin &gt;&gt; T; while (T--) flyinthesky::solve(); return 0; } /* 10 4 4 4 1 0 1 1 0 0 1 1 0 0 0 0 0 0 0 0 0 0 1 1 1 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 4 4 4 1 0 1 1 0 0 1 1 0 0 0 0 0 0 0 0 0 0 1 1 1 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 3 2 1 1 0 1 1 0 0 */]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1503」「NOI2004」郁闷的出纳员 (Splay)]]></title>
    <url>%2Fbzoj1503%2F</url>
    <content type="text"><![CDATA[BZOJ 1503题意：见上。 发现是每个数加上某个数或者减掉某个数，可以想到用一个全局增量$\Delta$来维护。 刚开始想到后面的人不能增了然后就不会了…其实后面插进来的减掉当前的$\Delta$就行了。 查询就直接查，删数方法比较好，就是先插入一个$\operatorname{mind}-\Delta$，然后将$-INF$所在点转到根，再将加入的点转到$INF$的孩子，然后左子树直接打标记删除即可。然后再将加入的$\operatorname{mind}-\Delta$删掉。 知识点：1、每个数加上某个数或者减掉某个数，可以想到用一个全局增量$\Delta$来维护 2、Splay 删子树方法 3、全局增量$\Delta$的应用 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 1000000 + 5, INF = 1000000000; int n, m, arr[MAXN]; int ch[MAXN][2], fa[MAXN], siz[MAXN], val[MAXN], ls[MAXN], rs[MAXN], gss[MAXN], sum[MAXN], lazy[MAXN], upd[MAXN], rt, ncnt; char s[10]; queue&lt;int &gt; q; int rel(int x) {return ch[fa[x]][1] == x;} void pushup(int x) { int l = ch[x][0], r = ch[x][1]; siz[x] = siz[l] + siz[r] + 1; ls[x] = max(ls[l], sum[l] + ls[r] + val[x]); rs[x] = max(rs[r], sum[r] + rs[l] + val[x]); sum[x] = sum[l] + sum[r] + val[x]; gss[x] = max(max(gss[l], gss[r]), rs[l] + ls[r] + val[x]); } void pushdown(int x) { int l = ch[x][0], r = ch[x][1]; if (upd[x]) { upd[l] = upd[r] = 1; if (l) val[l] = val[x], sum[l] = val[x] * siz[l], ls[l] = rs[l] = max(sum[l], 0), gss[l] = max(sum[l], val[x]); if (r) val[r] = val[x], sum[r] = val[x] * siz[r], ls[r] = rs[r] = max(sum[r], 0), gss[r] = max(sum[r], val[x]); upd[x] = lazy[x] = 0; } if (lazy[x]) { lazy[l] ^= 1, lazy[r] ^= 1; swap(ch[l][0], ch[l][1]), swap(ch[r][0], ch[r][1]); swap(ls[l], rs[l]), swap(ls[r], rs[r]); lazy[x] = 0; } } void rotate(int x) { pushdown(fa[x]), pushdown(x); int y = fa[x], z = fa[y], k = rel(x), w = ch[x][k ^ 1]; ch[z][rel(y)] = x, fa[x] = z; ch[y][k] = w, fa[w] = y; ch[x][k ^ 1] = y, fa[y] = x; pushup(y), pushup(x); } void splay(int x, int gl = 0) { while (fa[x] != gl) { pushdown(fa[x]), pushdown(x); int y = fa[x], z = fa[y]; if (z != gl) { if (rel(x) == rel(y)) rotate(y); else rotate(x); } rotate(x); } if (!gl) rt = x; } int kth(int k) { int cur = rt; while (1) { pushdown(cur); if (k &lt;= siz[ch[cur][0]]) cur = ch[cur][0]; else if (k &gt; siz[ch[cur][0]] + 1) k -= siz[ch[cur][0]] + 1, cur = ch[cur][1]; else return cur; } } int newNode(int v) { int cur; if (q.empty()) cur = ++ncnt; else cur = q.front(), q.pop(); ch[cur][0] = ch[cur][1] = 0, fa[cur] = 0, siz[cur] = 1, val[cur] = v, ls[cur] = rs[cur] = max(v, 0), gss[cur] = sum[cur] = v, lazy[cur] = upd[cur] = 0; return cur; } int build(int l, int r) { if (l &gt; r) return 0; int mid = (l + r) &gt;&gt; 1, cur = newNode(arr[mid]); if (l == r) return cur; if ((ch[cur][0] = build(l, mid - 1))) fa[ch[cur][0]] = cur; if ((ch[cur][1] = build(mid + 1, r))) fa[ch[cur][1]] = cur; pushup(cur); return cur; } void recycle(int x) { if (ch[x][0]) recycle(ch[x][0]); if (ch[x][1]) recycle(ch[x][1]); q.push(x); } void insert(int x, int gg) { int lb = kth(x + 1), rb = kth(x + 2); splay(lb), splay(rb, lb); fa[gg] = rb, ch[rb][0] = gg; // important pushup(rb), pushup(lb); } void remove(int l, int r) { int lb = kth(l), rb = kth(r + 2); splay(lb), splay(rb, lb); int del = ch[rb][0]; recycle(del), ch[rb][0] = 0; pushup(rb), pushup(lb); } void rev(int l, int r) { int lb = kth(l), rb = kth(r + 2); splay(lb), splay(rb, lb); int gg = ch[rb][0]; if (!upd[gg]) lazy[gg] ^= 1, swap(ch[gg][0], ch[gg][1]), swap(ls[gg], rs[gg]), pushup(rb), pushup(lb); } void update(int l, int r, int v) { int lb = kth(l), rb = kth(r + 2); splay(lb), splay(rb, lb); int gg = ch[rb][0]; upd[gg] = 1, val[gg] = v, sum[gg] = v * siz[gg], ls[gg] = rs[gg] = max(0, sum[gg]), gss[gg] = max(v, sum[gg]); pushup(rb), pushup(lb); } int qsum(int l, int r) { int lb = kth(l), rb = kth(r + 2); splay(lb), splay(rb, lb); return sum[ch[rb][0]]; } int qmax() {return gss[rt];} void clean() { rt = ncnt = 0; ms(ch, 0), ms(fa, 0), ms(siz, 0), ms(val, 0), ms(ls, 0), ms(rs, 0), ms(gss, 0), ms(sum, 0), ms(lazy, 0), ms(upd, 0); gss[0] = val[0] = -INF; } int solve() { clean(); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;arr[i + 1]); arr[1] = arr[n + 2] = -INF, rt = build(1, n + 2); while (m--) { scanf(&quot;%s&quot;, s); if (s[0] == &#39;I&#39;) { // insert int pos, tot; scanf(&quot;%d%d&quot;, &amp;pos, &amp;tot); for (int i = 1; i &lt;= tot; ++i) scanf(&quot;%d&quot;, &amp;arr[i]); insert(pos, build(1, tot)); } if (s[0] == &#39;D&#39;) { // delete int pos, tot; scanf(&quot;%d%d&quot;, &amp;pos, &amp;tot); remove(pos, pos + tot - 1); } if (s[0] == &#39;M&#39; &amp;&amp; s[5] == &#39;S&#39;) { // update int pos, tot, c; scanf(&quot;%d%d%d&quot;, &amp;pos, &amp;tot, &amp;c); update(pos, pos + tot - 1, c); } if (s[0] == &#39;R&#39;) { // rev int pos, tot; scanf(&quot;%d%d&quot;, &amp;pos, &amp;tot); rev(pos, pos + tot - 1); } if (s[0] == &#39;G&#39;) { // qsum int pos, tot; scanf(&quot;%d%d&quot;, &amp;pos, &amp;tot); printf(&quot;%d\n&quot;, qsum(pos, pos + tot - 1)); } if (s[0] == &#39;M&#39; &amp;&amp; s[4] == &#39;S&#39;) { // qmax printf(&quot;%d\n&quot;, qmax()); } } return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>Splay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1854」「SCOI2010」股票交易 (单调队列优化DP)]]></title>
    <url>%2Fbzoj1854%2F</url>
    <content type="text"><![CDATA[BZOJ 1854题意：第 $i$ 天的股票买入价为每股 $AP_i$，第 $i$ 天的股票卖出价为每股 $BP_i$, 股票交易所规定在两次交易（某一天的买入或者卖出均算是一次交易）之间，至少要间隔 $W$ 天, 在任何时间，一个人的手里的股票数不能超过 \text{MaxP}。在第 $1$ 天之前，有无限钱，但是没有任何股票，求 $T$ 天以后最大收益。 容易设$dp(i,j)$为前$i$天有$j$股票的最大收益则分情况讨论1、买入股票$$dp(i,j)=\max_{k \in [j-AS[i], j-1]}(dp(i,j), dp(i-w-1,k) + AP_i (k-j))$$2、卖出股票$$dp(i,j)=\max_{k \in [j+1,j+BS[i]]}(dp(i,j), dp(i-w-1,k) + BP_i (j-k))$$3、什么也不做$$dp(i,j)=\max(dp(i,j), dp(i-1,j))$$ 初值：$$dp(i,j)=-AP_i \cdot j$$其中$0 \leq j \leq AS_i$其余均为$-∞$ 然后考虑优化我们将$i,j$看作定值，则将与$k$无关式子移到$\max$外面，发现这可以单调队列优化。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;set&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 2000 + 5, INF = 2000000000; int n, maxP, w, AP[MAXN], BP[MAXN], AS[MAXN], BS[MAXN]; int dp[MAXN][MAXN]; int l, r, q[MAXN]; void clean() { } int solve() { clean(); cin &gt;&gt; n &gt;&gt; maxP &gt;&gt; w; for (int i = 1; i &lt;= n; ++i) { scanf(&quot;%d%d%d%d&quot;, &amp;AP[i], &amp;BP[i], &amp;AS[i], &amp;BS[i]); } for (int i = 0; i &lt;= n; ++i) for (int j = 0; j &lt;= maxP; ++j) dp[i][j] = -INF; for (int i = 1; i &lt;= n; ++i) for (int j = 0; j &lt;= AS[i]; ++j) dp[i][j] = -AP[i] * j; for (int i = 1; i &lt;= n; ++i) { l = 1, r = 0; for (int j = 0; j &lt;= maxP; ++j) dp[i][j] = max(dp[i][j], dp[i - 1][j]); if (i &lt;= w) continue ; for (int j = 0; j &lt;= maxP; ++j) { // buy while (l &lt;= r &amp;&amp; q[l] &lt; j - AS[i]) ++l; while (l &lt;= r &amp;&amp; dp[i - w - 1][j] + AP[i] * j &gt;= dp[i - w - 1][q[r]] + AP[i] * q[r]) --r; q[++r] = j; if (l &lt;= r) dp[i][j] = max(dp[i - w - 1][q[l]] + AP[i] * q[l] - AP[i] * j, dp[i][j]); } l = 1, r = 0; for (int j = maxP; j &gt;= 0; --j) { // sell while (l &lt;= r &amp;&amp; q[l] &gt; j + BS[i]) ++l; while (l &lt;= r &amp;&amp; dp[i - w - 1][j] + BP[i] * j &gt;= dp[i - w - 1][q[r]] + BP[i] * q[r]) --r; q[++r] = j; if (l &lt;= r) dp[i][j] = max(dp[i - w - 1][q[l]] + BP[i] * q[l] - BP[i] * j, dp[i][j]); } } //for (int i = 0; i &lt;= n; ++i) //for (int j = 0; j &lt;= maxP; ++j) printf(&quot;i=%d, j=%d, dp=%d\n&quot;, i, j, dp[i][j]); int ans = 0; for (int j = 0; j &lt;= maxP; ++j) ans = max(ans, dp[n][j]); cout &lt;&lt; ans; return 0; } } int main() { flyinthesky::solve(); return 0; } /* */]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>Bzoj</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu 2219」「HAOI2007」修筑绿化带 (单调队列+细节)]]></title>
    <url>%2FLuogu2219%2F</url>
    <content type="text"><![CDATA[2219题意：在$n \times m$的矩阵中找出一块$a \times b$的矩形，在这个矩形中找出一块$c \times d$的矩形(必须在内部)，得分为$a \times b$的矩形分数减去$c \times d$的矩形，求分数最大的$a \times b$的矩形，输出分数。 细节题这题感觉类似Bzoj 1047，问法类似，并且都是压缩了一段区间然后边成序列问题。这题可以考虑枚举每个$a \times b$的矩形，然后每次在矩形中找出一块分数最小的$c \times d$的矩形(注意必须在内部)，然后减掉即可。 1、 先预处理$n \times m$的矩阵的二维前缀和2、 然后预处理每个$((x,y) | x+c \leq m, y+d \leq n)$为左上角的$c \times d$的矩形的分值和记为$S(x,y)$3、 对于每个$((x,y) | x+c \leq m, y+d \leq n)$，记录$$C(x,y)=\min\limits_{1 \leq i \leq a - 2 -c +1}S(x+i-1,y)$$这个相当于把这个$a \times b$的矩形的一列决策点都压缩成一个元素4、对于每行$(x | x+a-1 \leq m)$, 每列$(y|y \geq 2, y+d-1\leq n)$，单调队列记录$$\min\limits_{y \in [y-(b - 2 - d + 1 + 1), y]}C(x+1,k)$$然后得到了最小值，按上面方法计算即可( 范围什么的还是自己算算吧，太杂乱了可能上面的公式会有错误 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; #include&lt;string&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 1000 + 5, INF = 2000000000; int m, n, a, b, c, d, orz[MAXN][MAXN], qzh[MAXN][MAXN]; int S[MAXN][MAXN], C[MAXN][MAXN]; int q[MAXN], l, r; int qry(int u, int v, int x, int y) {return qzh[x][y] - qzh[x][v - 1] - qzh[u - 1][y] + qzh[u - 1][v - 1];} int work(int a, int b, int c, int d) { ms(S, 0), ms(C, 0); int ret = 0; for (int i = 1; i + c - 1 &lt;= m; ++i) for (int j = 1; j + d - 1 &lt;= n; ++j) S[i][j] = qry(i, j, i + c - 1, j + d - 1); for (int y = 1; y + d - 1 &lt;= n; ++y) { l = 1, r = 0; for (int x = m - c + 1; x &gt;= 1; --x) { while (l &lt;= r &amp;&amp; q[l] - x &gt;= a - 2 - c + 1) ++l; while (l &lt;= r &amp;&amp; S[x][y] &lt;= S[q[r]][y]) --r; q[++r] = x; C[x][y] = S[q[l]][y]; } } for (int x = 1; x + a - 1 &lt;= m; ++x) { int tr = x + 1; l = 1, r = 0; for (int i = 2; i &lt;= b - d; ++i) { while (l &lt;= r &amp;&amp; C[tr][i] &lt;= C[tr][q[r]]) --r; q[++r] = i; } ret = max(ret, qry(x, 1, x + a - 1, b) - C[tr][q[l]]); for (int y = b - d + 1; y + d - 1 &lt;= n; ++y) { while (l &lt;= r &amp;&amp; y - q[l] &gt;= b - 2 - d + 1) ++l; while (l &lt;= r &amp;&amp; C[tr][y] &lt;= C[tr][q[r]]) --r; q[++r] = y; ret = max(ret, qry(x, y - (b - 2 - d + 1), x + a - 1, y + d) - C[tr][q[l]]); } } return ret; } void clean() { ms(qzh, 0); } int solve() { clean(); cin &gt;&gt; m &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; for (int i = 1; i &lt;= m; ++i) for (int j = 1; j &lt;= n; ++j) scanf(&quot;%d&quot;, &amp;orz[i][j]), qzh[i][j] = orz[i][j] + qzh[i - 1][j] + qzh[i][j - 1] - qzh[i - 1][j - 1]; int ans = 0; ans = max(ans, work(a, b, c, d)); printf(&quot;%d\n&quot;, ans); return 0; } } int main() { flyinthesky::solve(); return 0; } /* 4 3 4 3 2 1 2 2 3 4 5 1 3 1 6 4 8 6 4 3 3 3 1 1 2 2 3 4 5 1 3 1 6 4 8 6 */]]></content>
      <tags>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu 2219」「SHOI2001」小狗散步 (二分图最大匹配)]]></title>
    <url>%2FLuogu2526%2F</url>
    <content type="text"><![CDATA[2219题意：见上。 考虑错误的解法(没有考虑一个景点走一次)，即枚举主人的路线，然后枚举一个可行景点给狗走。但是如果一个景点走一次，这个方法就是错误的，因为枚举的可行景点之前可能已经被走过了。 那么这样的话，意思是一个地方有多个选择，最多选一个，求所有地方选的最大值。 转化成图论，发现是个二分图，而这就是二分图最大匹配。输出方案就输出连边的方案即可。网络流做法即找有流量的地方 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 1000 + 5; int cnt, n, m, lk[MAXN], vis[MAXN]; vector&lt;int&gt; G[MAXN]; int x[MAXN], y[MAXN], tot, fl[MAXN]; db dist(int i, int j) { return sqrt(1.0 * (x[i] - x[j]) * (x[i] - x[j]) + 1.0 * (y[i] - y[j]) * (y[i] - y[j])); } bool hungary(int u) { for (int i = 0; i &lt; G[u].size(); i++) {//枚举每个右边的点匹配 int v = G[u][i]; if (vis[v] != cnt) {//尝试修改过的节点就不需要遍历了 vis[v] = cnt; if (!lk[v] || hungary(lk[v])) { lk[v] = u; return true;//成功匹配 } } } return false; } void clean() { for (int i = 0; i &lt;= max(n, m); i++) vis[i] = lk[i] = 0, G[i].clear(); } int solve() { cin &gt;&gt; n &gt;&gt; m; clean(); for (int i = 1; i &lt;= n + m; ++i) scanf(&quot;%d%d&quot;, &amp;x[i], &amp;y[i]); for (int i = 1; i &lt; n; ++i) { db zr_d = dist(i, i + 1) * 2.0; for (int j = 1; j &lt;= m; ++j) { db dog_d = dist(i, j + n) + dist(i + 1, j + n); if (dog_d &lt;= zr_d) G[j + n].push_back(i); } } tot = 0; for (int i = 1; i &lt;= m; ++i) { if (hungary(cnt = n + i)) ++tot; } printf(&quot;%d\n&quot;, tot + n); for (int i = 1; i &lt;= n; ++i) { printf(&quot;%d %d &quot;, x[i], y[i]); if (lk[i]) printf(&quot;%d %d &quot;, x[lk[i]], y[lk[i]]); } return 0; } } int main() { flyinthesky::solve(); return 0; } /* */]]></content>
      <tags>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1117DE (DP+矩阵快速幂 / 交互题)]]></title>
    <url>%2FCodeforces1117DE%2F</url>
    <content type="text"><![CDATA[Codeforces 1117D题意：一列魔石排成一排，一块魔石可以分裂成$m$块魔石，你可以选择任意魔石进行分裂，求最后$n$块魔石的方案数。$n \leq 10^{18}$ 可以发现组合数公式，即选择出魔石出来分裂，但是并不能通过。可以考虑DP($n \leq 10^{18}$也是可能DP的，小心，矩阵快速幂)，设$dp(i)$为$i$个未分裂魔石时的方案。则$$dp(i)=dp(i-1)+dp(i-m)$$那么就可以矩阵快速幂了。 Codeforces 1117E题意：现在有一个长度 $\leq10000$ 的字符串和一个位置上的双射 $f$ ，使得字符串 $i$ 上的字符换到 $f(i)$ 上来。 交互题其实就是数字游戏……把题目里的数字拿出来，即$3,26,10000$考虑关系，则发现$26^2\leq 10000 \leq 26^3 $就考虑如何一次交互如何扩大 $26$ 倍 以下转载自题解 CF1117E【Decypher the String】 - sysjuruo 的博客 - 洛谷博客 我们可以通过以下方式第一次: aaa...aaa(26∗26)bbb...bbb(26∗26)ccc...ccc(26∗26)... 我们称 $26 \times 26$ 个为一个大块 第二次: aaa...aaa(26)bbb...bbb(26)ccc...ccc(26)... 第三次: abcdefg...xyzabcdefg...xyz 这样，对于一个位置$i$，第一次我们可以知道 $f(i)$ 属于哪一个大块，第二次可以知道属于哪一个小块，第三次便可以知道属于哪里 我们称 $26$ 个为一个小块 知识点：1、$n \leq 10^{18}$也是可能DP的，小心，矩阵快速幂1117D： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;set&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL MO = 1000000007ll; LL n, m; struct mat { LL a[205][205]; mat() {ms(a, 0);} } tr, f; mat mul(mat a, mat b) { mat ret; for (LL i = 1ll; i &lt;= m; ++i) { for (LL j = 1ll; j &lt;= m; ++j) { for (LL k = 1ll; k &lt;= m; ++k) { ret.a[i][j] = (ret.a[i][j] + a.a[i][k] * b.a[k][j] % MO) % MO; } } } //for (LL i = 1; i &lt;= m; ++i, putchar(&#39;\n&#39;)) for (LL j = 1; j &lt;= m; ++j) printf(&quot;%lld &quot;, ret.a[i][j]); return ret; } mat ksm(mat a, LL b) { mat ans, bs = a; LL fl = 0ll; while (b) { if (b &amp; 1ll) { if (fl == 0ll) fl = 1ll, ans = bs; else ans = mul(ans, bs); } bs = mul(bs, bs); b &gt;&gt;= 1ll; } return ans; } void clean() { } int solve() { clean(); cin &gt;&gt; n &gt;&gt; m; if (n == m) return printf(&quot;2\n&quot;), 0; if (n &lt; m) return printf(&quot;1\n&quot;), 0; for (LL i = 1; i &lt; m; ++i) { tr.a[i][i + 1] = 1; } tr.a[m][1] = tr.a[m][m] = 1; for (LL i = 1; i &lt; m; ++i) f.a[1][i] = 1; f.a[1][m] = 2; tr = ksm(tr, n - m); f = mul(f, tr); printf(&quot;%lld\n&quot;, f.a[1][m]); return 0; } } int main() { flyinthesky::solve(); return 0; } 1117E： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;string&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 20000 + 5; string s, t, pt; int n, bl[MAXN]; char ans[MAXN]; void clean() { } int solve() { clean(); cin &gt;&gt; s; n = s.length(); // 1 pt = &quot;? &quot;; char ch = &#39;a&#39;; for (int i = 0; i &lt; n; ++i) { pt += ch; if ((i + 1) % (26 * 26) == 0) ++ch; } cout &lt;&lt; pt &lt;&lt; endl; cin &gt;&gt; t; for (int i = 0; i &lt; n; ++i) bl[i] += (t[i] - &#39;a&#39;) * (26 * 26); // 2 pt = &quot;? &quot;; ch = &#39;a&#39;; for (int i = 0; i &lt; n; ++i) { pt += ch; if ((i + 1) % 26 == 0) ++ch; if (ch &gt; &#39;z&#39;) ch = &#39;a&#39;; } cout &lt;&lt; pt &lt;&lt; endl; cin &gt;&gt; t; for (int i = 0; i &lt; n; ++i) bl[i] += (t[i] - &#39;a&#39;) * 26; // 3 pt = &quot;? &quot;; ch = &#39;a&#39;; for (int i = 0; i &lt; n; ++i) { pt += ch++; if (ch &gt; &#39;z&#39;) ch = &#39;a&#39;; } cout &lt;&lt; pt &lt;&lt; endl; cin &gt;&gt; t; for (int i = 0; i &lt; n; ++i) bl[i] += t[i] - &#39;a&#39;; for (int i = 0; i &lt; n; ++i) ans[bl[i]] = s[i]; cout &lt;&lt; &quot;! &quot; &lt;&lt; ans &lt;&lt; endl; return 0; } } int main() { flyinthesky::solve(); return 0; } /* abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz */]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>计数DP</tag>
        <tag>Codeforces</tag>
        <tag>交互</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1562」「NOI2009」变换序列 (二分图最大匹配 / 贪心)]]></title>
    <url>%2Fbzoj1562%2F</url>
    <content type="text"><![CDATA[BZOJ 1562题意：初始有一个序列$[0,n-1]$升序排列$a_i$，然后给出每个位置的$D=\min(∣T_i−a_i∣,N−∣T_i−a_i∣)$，然后你要找到一组字典序最小的方案$T_i$ 显然一个$a_i$对应两个$T$: (i + d) % n + 1, ((i - d) % n + n) % n + 1构造二分图，左边是$a_i$，右边是$T$，连边，就是求一个最大匹配。但是匈牙利求不一定字典序最小，我们强制让匈牙利先连序号小的点，这样是不是对的呢？答案是否定的，因为后面不能匹配就会动到前面的匹配，这样就不最优了。其实可以倒过来求匈牙利，这样就能保证前面的要最小边能够从后面的修正得到。具体证明可以参见NOI 2009 变换序列 - BYVoid，本文下面也搬运了一份。 这题其实类似于Luogu 2526，都是一个位置有多个选择，并且这些选择都是一个集合的，然后就可以考虑二分图最大匹配。 其实这类问题写暴力时就会发现时间复杂度瓶颈于多个选择。 知识点原来$0$的改为$1$时注意!x的判断修改 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 100000 + 5; int cnt, n, lk[MAXN], vis[MAXN], flk[MAXN]; vector&lt;int&gt; G[MAXN]; bool hungary(int u) { for (int i = 0; i &lt; (int)G[u].size(); i++) {//枚举每个右边的点匹配 int v = G[u][i]; if (vis[v] != cnt) {//尝试修改过的节点就不需要遍历了 vis[v] = cnt; if (!lk[v] || hungary(lk[v])) { lk[v] = u, flk[u] = v; return true;//成功匹配 } } } return false; } void clean() {} int solve() { clean(); cin &gt;&gt; n; for (int d, i = 0; i &lt; n; ++i) { scanf(&quot;%d&quot;, &amp;d); int t1 = (i + d) % n + 1; int t2 = ((i - d) % n + n) % n + 1; if (t1 &gt; t2) swap(t1, t2); G[i + 1].push_back(t1 + n), G[i + 1].push_back(t2 + n); } int ans = 0; for (int i = n; i &gt;= 1; --i) ans += hungary(cnt = i); if (ans != n) return puts(&quot;No Answer&quot;); for (int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, flk[i] - n - 1); return 0; } } int main() { flyinthesky::solve(); return 0; } 搬运自 NOI 2009 变换序列 - BYVoid算法证明实现简单的方法往往证明并不容易，该算法运用了贪心的思想。首先我们可以发现，有一些可以直接确定的匹配，这些就是度为1的顶点，必须与其唯一的对应点对应。样例如图2所示，(1,2),(4,3)一定存在于任意一个解中（如果有解的话）。这样的话，我们就可以把已经确定的顶点去除，删除后如果又发现了剩余度为1的顶点，那么继续去除，直到不存在为止。剩下的顶点中，X集合顶点个数一定与Y集合顶点个数相等。X集合每个顶点的度都是2，所以Y集合中的所有顶点度也都是2。于是剩下的顶点构成了若干个互不连同的环，每个顶点属于且只属于一个环，我们只需在此图上求字典序最小的匹配即可。每个环的匹配只有两种方式，如果我们从环上X集合中序号最小的顶点贪心的选择与序号较小的点匹配，那么该环上的匹配就是字典序最小。样例如图3。由于事先不知道那些顶点在环上，哪些可以直接确定。从X集合每个顶点倒序查找增广路，就可以保证最后的最优，也就是字典序尽量小。因为如果一个顶点在环上，找到的一定是环上较优的匹配方式，而不在环上的点也可以被后来的增广而修正。 图2图3 解法4 贪心算法描述按照解法3证明中的描述，我们可以预处理所有已经确定的匹配，并在图中删去。对于剩下的每个环，只需从序号最小的点开始深度优先搜索，并进行匹配即可。算法证明证明同解法3。]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>Bzoj</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1576」「Usaco2009 Jan」安全路经 (最短路树 + 并查集 + 贪心)]]></title>
    <url>%2Fbzoj1576%2F</url>
    <content type="text"><![CDATA[BZOJ 1576题意：给定一张$n$点$m$边无向图，请你找出$1 \to n$不经过$1 \to n$的最短路的最后一条边的最短路。保证最短路唯一 保证最短路唯一，那么构造最短路树。接着最短路树上就是最短路，考虑非树边才能得到答案。对于每条非树边$u,v$，他加入树就形成了环，这个环$u,v$上所有点(除了$\text{LCA}(u,v)$)都可以得到一个新的路径长，即为$dis(u)+dis(v)+W_{u,v}-dis(i)$，发现这个答案只与这条边有关，所以我们可以直接按这个排序，然后从小到大枚举非树边$u,v$，更新环上没更新的点。 这里可以树剖+线段树维护，但是有最方便的方法：没更新的点更新明显是一个合并的过程，用并查集维护即可。类似倍增跳LCA/树剖的方法来合并 知识点保证最短路唯一：最短路树并查集妙用不要开小关于边的数组 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;string&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 100000 + 5; int cnt, n, lk[MAXN], vis[MAXN], flk[MAXN]; vector&lt;int&gt; G[MAXN]; bool hungary(int u) { for (int i = 0; i &lt; (int)G[u].size(); i++) {//枚举每个右边的点匹配 int v = G[u][i]; if (vis[v] != cnt) {//尝试修改过的节点就不需要遍历了 vis[v] = cnt; if (!lk[v] || hungary(lk[v])) { lk[v] = u, flk[u] = v; return true;//成功匹配 } } } return false; } void clean() {} int solve() { clean(); cin &gt;&gt; n; for (int d, i = 0; i &lt; n; ++i) { scanf(&quot;%d&quot;, &amp;d); int t1 = (i + d) % n + 1; int t2 = ((i - d) % n + n) % n + 1; if (t1 &gt; t2) swap(t1, t2); G[i + 1].push_back(t1 + n), G[i + 1].push_back(t2 + n); } int ans = 0; for (int i = n; i &gt;= 1; --i) ans += hungary(cnt = i); if (ans != n) return puts(&quot;No Answer&quot;); for (int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, flk[i] - n - 1); return 0; } } int main() { flyinthesky::solve(); return 0; } 搬运自 NOI 2009 变换序列 - BYVoid算法证明实现简单的方法往往证明并不容易，该算法运用了贪心的思想。首先我们可以发现，有一些可以直接确定的匹配，这些就是度为1的顶点，必须与其唯一的对应点对应。样例如图2所示，(1,2),(4,3)一定存在于任意一个解中（如果有解的话）。这样的话，我们就可以把已经确定的顶点去除，删除后如果又发现了剩余度为1的顶点，那么继续去除，直到不存在为止。剩下的顶点中，X集合顶点个数一定与Y集合顶点个数相等。X集合每个顶点的度都是2，所以Y集合中的所有顶点度也都是2。于是剩下的顶点构成了若干个互不连同的环，每个顶点属于且只属于一个环，我们只需在此图上求字典序最小的匹配即可。每个环的匹配只有两种方式，如果我们从环上X集合中序号最小的顶点贪心的选择与序号较小的点匹配，那么该环上的匹配就是字典序最小。样例如图3。由于事先不知道那些顶点在环上，哪些可以直接确定。从X集合每个顶点倒序查找增广路，就可以保证最后的最优，也就是字典序尽量小。因为如果一个顶点在环上，找到的一定是环上较优的匹配方式，而不在环上的点也可以被后来的增广而修正。 图2图3 解法4 贪心算法描述按照解法3证明中的描述，我们可以预处理所有已经确定的匹配，并在图中删去。对于剩下的每个环，只需从序号最小的点开始深度优先搜索，并进行匹配即可。算法证明证明同解法3。]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>并查集</tag>
        <tag>Bzoj</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 3669」「NOI2014」魔法森林 (LCT动态维护最小生成树)]]></title>
    <url>%2Fbzoj3669%2F</url>
    <content type="text"><![CDATA[BZOJ 3669题意：给定$n$点$m$边无向图，每条边有一个边权$(a, b)$，能经过某条边当且仅当当前的$A \leq a, B \leq b$，试确定$A,B$，使得能从$1$走到$n$。 第一眼以为二分套二分，但是这题二分后再二分没有单调性了…但是还是能拿到$65$分贪心两者和最小：将前者排序后，在不大于前者的情况下，让后者尽量小。那么将边按照$a$排序，然后我们想想怎么样能让$b$最小。显然一条路径最长边最小的路径在当前图的最小瓶颈生成树上，那么这里就是动态维护一个最小生成树 即，若两点不连通，则直接连边；否则将路径上的最大边删除加入这条边(或者这条边比较小不用动任何东西) 那么 LCT 维护路径。注意重边和自环。 这里边权可以变成点权，是个经典套路 注意Splay后所有的信息都不能再用之前的，变量改变后不要再用，要留意变量是否会在中途改变，会的话开临时数组存储 (特别是用了一个值之前调用了一个函数，这个函数可能改变这个值)！！！ 知识点：1、边权变点权 (网络流常用技巧)2、Splay后所有的信息都不能再用之前的，变量改变后不要再用，要留意变量是否会在中途改变，会的话开临时数组存储 (特别是用了一个值之前调用了一个函数，这个函数可能改变这个值)3、贪心两者和最小：将前者排序后，在不大于前者的情况下，让后者尽量小。4、注意重边自环 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { #define lc ch[x][0] #define rc ch[x][1] const int MAXN = 200000 + 5, INF = 1000000000; struct edge { int x, y, a, b; bool operator &lt; (const edge &amp;rhs) const { return a == rhs.a ? b &lt; rhs.b : a &lt; rhs.a; } } ed[100000 + 5]; int n, m; int val[MAXN], ch[MAXN][2], fa[MAXN], rev[MAXN], maxv[MAXN], id[MAXN]; int top, stk[MAXN]; int isRt(int x) {return ch[fa[x]][0] != x &amp;&amp; ch[fa[x]][1] != x;} //???Splay??? int rel(int x) {return ch[fa[x]][1] == x;} // ? Splay void prorev(int x) {swap(lc, rc), rev[x] ^= 1;} // ?????? (????) void pushup(int x) { maxv[x] = val[x], id[x] = x; if (maxv[x] &lt; maxv[lc]) maxv[x] = maxv[lc], id[x] = id[lc]; if (maxv[x] &lt; maxv[rc]) maxv[x] = maxv[rc], id[x] = id[rc]; } void pushdown(int x) { //???? if (rev[x]) { if (lc) prorev(lc); if (rc) prorev(rc); rev[x] = 0; } } void rotate(int x) { // ? Splay pushdown(fa[x]), pushdown(x); int y = fa[x], z = fa[y], k = rel(x), w = ch[x][k ^ 1]; if (!isRt(y)) ch[z][rel(y)] = x; fa[x] = z; // y ??? (z, y) ???,???? (??? Splay ???? 1) ch[y][k] = w, fa[w] = y; ch[x][k ^ 1] = y, fa[y] = x; pushup(y), pushup(x); } void splay(int x) { // ? Splay //printf(&quot;%d\n&quot;, x); top = 0; stk[++top] = x; for (int pos = x; !isRt(pos); pos = fa[pos]) stk[++top] = fa[pos]; while (top) pushdown(stk[top--]); // ? x ?????????????? pushdown (??? Splay ???? 2) //???1:???? isRt ???,????pushdown while (!isRt(x)) { // (??? Splay ???? 3.1) int y = fa[x]; if (!isRt(y)) { // (??? Splay ???? 3.2) if (rel(x) == rel(y)) rotate(y); else rotate(x); } rotate(x); } //pushup(x); ?????? } void access(int x) { // ????? x ???????????,??? x ???????????????? for (int y = 0; x; y = x, x = fa[x]) splay(x), rc = y, pushup(x); } void makeRt(int x) { // ?????? access(x), splay(x); prorev(x); } int findRt(int x) { // ????? x ?? access(x), splay(x); while (pushdown(x), lc) x = lc; splay(x); // splay ???? return x; } void split(int x, int y) { // ???????? x-y makeRt(x); access(y), splay(y); // splay ???? //???2:?(x)?y??????,???? access ??,y ??????,????? } void link(int x, int y) { // ?????? x-y makeRt(x); if (findRt(y) != x) fa[x] = y; } void cut(int x, int y) { // ?????? x-y makeRt(x); if (findRt(y) == x &amp;&amp; fa[y] == x &amp;&amp; !ch[y][0]) { fa[y] = rc = 0; pushup(x); } //split(x, y), fa[x] = ch[y][0] = 0, pushup(y); } void clean() { ms(val, 0), ms(ch, 0), ms(fa, 0), ms(rev, 0), ms(maxv, 0), ms(id, 0); } int solve() { clean(); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= m; ++i) scanf(&quot;%d%d%d%d&quot;, &amp;ed[i].x, &amp;ed[i].y, &amp;ed[i].a, &amp;ed[i].b); sort(ed + 1, ed + 1 + m); for (int i = 1; i &lt;= m; ++i) val[i + n] = ed[i].b; int ans = INF; for (int i = 1; i &lt;= m; ++i) { int &amp;u = ed[i].x, &amp;v = ed[i].y; if (u == v) continue ; if (findRt(u) == findRt(v)) { split(u, v); if (val[id[v]] &lt;= ed[i].b) { if (findRt(1) == findRt(n)) { split(1, n); ans = min(ans, ed[i].a + maxv[n]); } continue ; } int whw = id[v]; // 一定要这样！！id会变化！！ cut(whw, ed[whw - n].x); cut(whw, ed[whw - n].y); link(u, i + n); link(v, i + n); } else { link(u, i + n); link(v, i + n); } if (findRt(1) == findRt(n)) { split(1, n); ans = min(ans, ed[i].a + maxv[n]); } } if (ans == INF) cout &lt;&lt; -1; else cout &lt;&lt; ans; return 0; } } int main() { flyinthesky::solve(); return 0; } /* 4 6 2 4 2 9 4 3 4 6 2 3 6 5 4 4 9 9 4 1 7 7 1 3 7 4 4 4 1 3 7 4 4 3 4 6 2 3 6 5 2 4 2 9 4 6 2 3 8 10 4 1 9 9 2 1 7 8 3 1 7 7 4 3 10 5 3 1 2 10 4 3 4 1 9 9 3 1 7 7 4 3 10 5 */]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>生成树</tag>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 4650」「NOI2016」优秀的拆分 (后缀数组+ST表+差分)]]></title>
    <url>%2Fbzoj4650%2F</url>
    <content type="text"><![CDATA[BZOJ 4650题意：如果一个字符串可以被拆分为 $AABB$ 的形式，其中 $A$ 和 $B$ 是任意非空字符串，则我们称该字符串的这种拆分是优秀的。给出一个长度为 $n$ 的字符串 $S$，我们需要求出，在它所有子串的所有拆分方式中，优秀拆分的总个数。 本题直接无脑Hash有85分，思考一下，可以发现$AA$和$BB$本质上相同，只需要统计每个位置向左向右可能有几种$AA$串，乘法原理即可。这个Hash有95分。(发现这个方法我还是用后缀数组想的时候推出来的，但是没想出后缀数组做法没有回来用Hash暴力…) 后缀数组做的话也要用到上面的方法，考虑枚举$AA$串的$len$，然后在字符串上每$len$个字符作一个「关键点」，可以发现每个当前$AA$串必过两个「关键点」。 考虑两个「关键点」。假设$LCP$是这两个「关键点」的最长公共前缀，$LCS$是这两个「关键点」的最长公共后缀(不是最长公共子序列)，那么 当$LCS+LCP \leq len$时 当$LCS+LCP \geq len$时 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; int T; namespace flyinthesky { const int MAXN = 30000 + 5, LOGS = 17; struct suffixArray { char a[MAXN]; int n, m, SA[MAXN], rk[MAXN], height[MAXN], tp[MAXN], tax[MAXN]; int f[MAXN][LOGS + 5], lg2[MAXN]; void build() { ms(SA, 0), ms(rk, 0), ms(height, 0), ms(tp, 0); for (int i = 0; i &lt;= m; ++i) tax[i] = 0; for (int i = 1; i &lt;= n; ++i) tax[rk[i] = a[i]]++; for (int i = 1; i &lt;= m; ++i) tax[i] += tax[i - 1]; for (int i = n; i &gt;= 1; --i) SA[tax[rk[i]]--] = i; for (int k = 1; k &lt;= n; k &lt;&lt;= 1) { int p = 0; for (int i = n - k + 1; i &lt;= n; ++i) tp[++p] = i; for (int i = 1; i &lt;= n; ++i) if (SA[i] &gt; k) tp[++p] = SA[i] - k; for (int i = 0; i &lt;= m; ++i) tax[i] = 0; for (int i = 1; i &lt;= n; ++i) tax[rk[tp[i]]]++; for (int i = 1; i &lt;= m; ++i) tax[i] += tax[i - 1]; for (int i = n; i &gt;= 1; --i) SA[tax[rk[tp[i]]]--] = tp[i]; swap(rk, tp), p = rk[SA[1]] = 1; for (int i = 2; i &lt;= n; ++i) { rk[SA[i]] = (tp[SA[i]] == tp[SA[i - 1]] &amp;&amp; tp[SA[i] + k] == tp[SA[i - 1] + k]) ? p : ++p; } if (p &gt;= n) break ; m = p; } int k = 0; for (int i = 1; i &lt;= n; ++i) { if (k) --k; int j = SA[rk[i] - 1]; while (a[i + k] == a[j + k]) ++k; height[rk[i]] = k; } } void buildst() { ms(f, 0); lg2[0] = -1; for (int i = 1; i &lt;= n; ++i) lg2[i] = lg2[i &gt;&gt; 1] + 1; lg2[0] = 0; for (int i = 1; i &lt;= n; ++i) f[i][0] = height[i]; for (int j = 1; (1 &lt;&lt; j) &lt;= n; j++) for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i++) f[i][j] = min(f[i][j - 1], f[i + (1 &lt;&lt; (j - 1))][j - 1]); } int LCP(int l, int r) { l = rk[l], r = rk[r]; if(l &gt; r) swap(l, r); l++; int k = lg2[r - l + 1]; return min(f[l][k], f[r - (1 &lt;&lt; k) + 1][k]); } }sa[2]; int cfa[MAXN], cfb[MAXN]; void clean() { ms(cfa, 0), ms(cfb, 0); } int solve() { clean(); scanf(&quot;%s&quot;, sa[0].a + 1); sa[0].n = strlen(sa[0].a + 1), sa[0].m = 256; for (int i = 1; i &lt;= sa[0].n; ++i) sa[1].a[i] = sa[0].a[sa[0].n - i + 1]; sa[1].n = sa[0].n, sa[1].m = 256; sa[0].build(), sa[1].build(); sa[0].buildst(), sa[1].buildst(); for (int len = 1; len &lt;= sa[0].n / 2; ++len) { for (int i = len; i + len &lt;= sa[0].n; i += len) { int l = i, r = i + len; int L = sa[0].n - (r - 1) + 1, R = sa[0].n - (l - 1) + 1; int lcp = sa[0].LCP(l, r); lcp = min(lcp, len); int lcs = sa[1].LCP(L, R); lcs = min(lcs, len - 1); if (lcp + lcs &gt;= len) { int g = lcp + lcs - len; cfa[l - lcs]++, cfa[l - (lcs - g) + 1]--; cfb[r + (lcp - g) - 1]++, cfb[r + lcp]--; } } } for (int i = 1; i &lt;= sa[0].n; ++i) cfa[i] += cfa[i - 1], cfb[i] += cfb[i - 1]; LL ans = 0; for (int i = 1; i &lt;= sa[0].n; ++i) ans += 1.0 * cfa[i] * cfb[i - 1]; printf(&quot;%lld\n&quot;, ans); return 0; } } int main() { scanf(&quot;%d&quot;, &amp;T); while (T--) flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>后缀数组</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1049」「HAOI2006」数字序列 (DP+LIS+结论)]]></title>
    <url>%2Fbzoj1049%2F</url>
    <content type="text"><![CDATA[Bzoj 1049题意：现在我们有一个长度为$n$的整数序列$A$。但是它太不好看了，于是我们希望把它变成一个单调严格上升的序列。但是不希望改变过多的数，也不希望改变的幅度太大。 第一问即经典问题。考虑不严格上升的序列，则为$n-LIS$，(这里的$LIS$为不下降的)严格上升，则说明$i-j \geq a_i-a_j$，不然这个区间不可能严格上升。 移项，则$i-a_i \geq j-a_j$，那么将原来的$a_i$变为$a_i-i$按照同样方法处理即可。 对于第二问，我们设$f(i)$为$[1,i]$的答案，则$$f(i)=\max\limits_{dp(j)+1=dp(i)}(f(j)+w(j+1,i))$$那么我们怎么计算$w$呢我们可以发现对于任意区间$[i,j]$都$\exists k$使得$[i,k]=a_i$, $[k+1,j]=a_j$，并且一定$\exists k$使得其为最优策略那么对于每个$w$暴力$k$的位置。由于数据随机，所以$i$的的决策点$j$很少，复杂度跑不满 注意代码细节，加上前后最小值最大值方便操作 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL MAXN = 35000 + 10, INF = 1e10; LL n, a[MAXN], b[MAXN], len; LL dp[MAXN], f[MAXN], cst1[MAXN], cst2[MAXN]; vector&lt;LL &gt; vec[MAXN]; LL abss(LL x) {return x &gt; 0 ? x : -x;} void clean() { len = 0; } int solve() { clean(); cin &gt;&gt; n; for (LL i = 1; i &lt;= n; ++i) scanf(&quot;%lld&quot;, &amp;a[i]), a[i] -= i; ++n, a[n] = INF; b[++len] = a[1], dp[1] = 1; for (LL i = 2; i &lt;= n; ++i) { if (a[i] &gt;= b[len]) b[++len] = a[i], dp[i] = len; else { int pos = upper_bound(b + 1, b + 1 + len, a[i]) - b; // 1 upper_bound b[pos] = a[i], dp[i] = pos; } } printf(&quot;%lld\n&quot;, n - len); a[0] = -INF; vec[0].push_back(0); for (LL i = 1; i &lt;= n; ++i) { f[i] = INF; for (LL j = 0; j &lt; (LL)vec[dp[i] - 1].size(); ++j) { LL v = vec[dp[i] - 1][j]; if (a[v] &gt; a[i]) continue ; cst1[v - 1] = cst2[v - 1] = 0; for (LL k = v; k &lt;= i; ++k) cst1[k] = abss(a[k] - a[v]), cst2[k] = abss(a[k] - a[i]); for (LL k = v + 1; k &lt;= i; ++k) cst1[k] += cst1[k - 1], cst2[k] += cst2[k - 1]; for (LL k = v; k &lt;= i; ++k) { LL now = cst1[k] - cst1[v] + cst2[i] - cst2[k]; f[i] = min(f[i], f[v] + now); } } vec[dp[i]].push_back(i); } printf(&quot;%lld\n&quot;, f[n]); return 0; } } int main() { flyinthesky::solve(); return 0; } /* 5 1 2 4 3 1 */]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>Bzoj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 3675」「Apio2014」序列分割 (斜率优化DP)]]></title>
    <url>%2Fbzoj3675%2F</url>
    <content type="text"><![CDATA[BZOJ 3675题意：你正在玩一个关于长度为 $n$ 的非负整数序列 $a_i$ 的游戏。这个游戏中你需要把序列分成 $k+1$ 个非空的块。为了得到 $k+1$ 块，你需要重复下面的操作 $k$ 次：选择一个有超过一个元素的块（初始时你只有一块，即整个序列）选择两个相邻元素把这个块从中间分开，得到两个非空的块。每次操作后你将获得那两个新产生的块的元素和的乘积的分数。你想要最大化最后的总得分。 引理： 最终答案和分割顺序无关。 证明：若分了$3$块，设为$a_1,a_2,a_3$则$$a_1 a_2 + (a_1+a_2)a_3 = a_2 a_3 + (a_2 + a_3)a_1$$所以两者等价，并且容易扩展到更多块的情况。并且答案是$a$两两相乘的和(或者是$a_1 + (a_1+a_2)a_3 + (a_1+a_2+a_3)a_4 +\dots + (a_1+a_2+ \dots + a_{k-1})a_k$) 那么设$dp(k,i)$为前$i$个分了$k$次的最大值。根据上面的式子，可以有DP方程$$dp(k,i)=\max(dp(k-1, j)+s(j) \cdot (s(i) - s(j)))$$其中$s(i)$为前缀和。显然可以斜率优化。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL MAXN = 100000 + 5; LL n, K, a[MAXN], s[MAXN], dp[205][MAXN], pre[205][MAXN]; LL q[MAXN], l, r; vector&lt;LL &gt; vec; LL getx(LL j) {return s[j];} LL gety(LL j, LL k) {return dp[k - 1][j] - s[j] * s[j];} db getsl(LL a, LL b, LL k) { if (getx(a) == getx(b)) return -1e18; return 1.0 * (gety(a, k) - gety(b, k)) / (getx(a) - getx(b)); } void clean() { ms(pre, 0), ms(s, 0), ms(dp, 0); } int solve() { clean(); cin &gt;&gt; n &gt;&gt; K; for (LL i = 1; i &lt;= n; ++i) scanf(&quot;%lld&quot;, &amp;a[i]), s[i] = a[i] + s[i - 1]; for (LL k = 1; k &lt;= K; ++k) { l = 1, r = 1, q[1] = 0; for (LL i = 1; i &lt;= n; ++i) { while (l &lt; r &amp;&amp; getsl(q[l], q[l + 1], k) &gt;= -s[i]) ++l; dp[k][i] = dp[k - 1][q[l]] + s[q[l]] * (s[i] - s[q[l]]); pre[k][i] = q[l]; while (l &lt; r &amp;&amp; getsl(q[r - 1], q[r], k) &lt;= getsl(q[r], i, k)) --r; q[++r] = i; } } printf(&quot;%lld\n&quot;, dp[K][n]); LL cur = n, tms = K; while (cur != 0) { vec.push_back(cur); cur = pre[tms][cur], --tms; } sort(vec.begin(), vec.end()); for (LL i = 0; i &lt; (LL)vec.size() - 1; ++i) printf(&quot;%lld &quot;, vec[i]); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>Bzoj</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 2754」「SCOI2012」喵星球上的点名 (后缀数组+二分+莫队+离线)]]></title>
    <url>%2Fbzoj2754%2F</url>
    <content type="text"><![CDATA[BZOJ 2754题意：见上。 考虑将所有名字姓和名用特殊符号链接，然后构造后缀数组 引理1： $S_2$ 是 $S_1$ 的子串当且仅当 $\exists S_1$的后缀和$S_2$的$height=len(S_2)$ 引理2： 后缀数组的$SA$数组具有二分单调性，即确定了前$i-1$位，可以在$SA$数组中二分第$i$位的位置 用引理1或者引理2(代码使用2)用上二分可以找出一个询问在$SA$数组上的区间范围，即这个区间上的后缀的前缀都有这个询问串。这里二分要用左闭右闭区间的，用左闭右开会莫名GG那么现在问题转化为求区间的不同颜色的个数，显然莫队裸题。第二问的话，在莫队的时候，如果第一次加入某种颜色，则加上当前最大可能的个数，然后某种颜色被完全删除后就减掉当前最大可能的个数 知识点1、二分2、后缀数组从1开始 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 200000 + 5; int n, m, lmt, which[MAXN], tmp1, tmp2; int a[MAXN], bl[MAXN], blolen; int SA[MAXN], rk[MAXN], tp[MAXN], tax[MAXN], height[MAXN]; int ans1[MAXN], ans2[MAXN]; struct qry { int l, r, id; bool operator &lt; (const qry &amp;rhs) const { return bl[l] != bl[rhs.l] ? r &lt; rhs.r : bl[l] &lt; bl[rhs.l]; } } xw[MAXN]; void build() { for (int i = 1; i &lt;= m; ++i) tax[i] = 0; for (int i = 1; i &lt;= n; ++i) tax[rk[i] = a[i]]++; for (int i = 1; i &lt;= m; ++i) tax[i] += tax[i - 1]; for (int i = n; i; --i) SA[tax[rk[i]]--] = i; for (int k = 1; k &lt;= n; k *= 2) { int p = 0; for (int i = n - k + 1; i &lt;= n; ++i) tp[++p] = i; for (int i = 1; i &lt;= n; ++i) if (SA[i] &gt; k) tp[++p] = SA[i] - k; for (int i = 1; i &lt;= m; ++i) tax[i] = 0; for (int i = 1; i &lt;= n; ++i) tax[rk[tp[i]]]++; for (int i = 1; i &lt;= m; ++i) tax[i] += tax[i - 1]; for (int i = n; i; --i) SA[tax[rk[tp[i]]]--] = tp[i]; swap(rk, tp), p = 1, rk[SA[1]] = 1; for (int i = 2; i &lt;= n; ++i) { rk[SA[i]] = (tp[SA[i]] == tp[SA[i - 1]] &amp;&amp; tp[SA[i] + k] == tp[SA[i - 1] + k]) ? p : ++p; } if (p &gt;= n) break ; m = p; } } int l, r, cnt, tax_md[MAXN]; void inc(int pos, int whw) { if (++tax_md[which[SA[pos]]] == 1) { ++cnt, ans2[which[SA[pos]]] += tmp2 - whw + 1; } } void dec(int pos, int whw) { if (--tax_md[which[SA[pos]]] == 0) { --cnt, ans2[which[SA[pos]]] -= tmp2 - whw + 1; } } void clean() { n = 0, lmt = 10000 + 2, m = 10000 + 2; ms(ans1, 0), ms(ans2, 0); } int solve() { clean(); scanf(&quot;%d%d&quot;, &amp;tmp1, &amp;tmp2); for (int len, i = 1; i &lt;= tmp1; ++i) { scanf(&quot;%d&quot;, &amp;len); for (int x, j = 1; j &lt;= len; ++j) { scanf(&quot;%d&quot;, &amp;x); a[++n] = x, which[n] = i; } a[++n] = lmt; scanf(&quot;%d&quot;, &amp;len); for (int x, j = 1; j &lt;= len; ++j) { scanf(&quot;%d&quot;, &amp;x); a[++n] = x, which[n] = i; } a[++n] = lmt; } build(); blolen = sqrt(n); for (int i = 1; i &lt;= n; ++i) bl[i] = (i - 1) / blolen + 1; for (int len, i = 1; i &lt;= tmp2; ++i) { // 在 SA 数组中二分 scanf(&quot;%d&quot;, &amp;len); int L = 1, R = n; for (int x, j = 1; j &lt;= len; ++j) { // 找加入第 i 位后符合的下界 scanf(&quot;%d&quot;, &amp;x); int l = L, r = R, ltmp; while (l &lt;= r) { int mid = (l + r) &gt;&gt; 1; if (a[SA[mid] + j - 1] &lt; x) l = mid + 1; else r = mid - 1; } ltmp = l; l = L, r = R; while (l &lt;= r) { // 找加入第 i 位后符合的上界 int mid = (l + r) &gt;&gt; 1; if (a[SA[mid] + j - 1] &lt;= x) l = mid + 1; else r = mid - 1; } L = ltmp, R = r; } if (L &lt;= R) xw[i] = (qry){L, R, i}; } sort(xw + 1, xw + 1 + tmp2); l = 1, r = 0, cnt = 0; for (int i = 1; i &lt;= tmp2; ++i) { while (l &gt; xw[i].l) inc(l - 1, i), --l; while (r &lt; xw[i].r) inc(r + 1, i), ++r; while (l &lt; xw[i].l) dec(l, i), ++l; while (r &gt; xw[i].r) dec(r, i), --r; ans1[xw[i].id] = cnt; } for (int i = 1; i &lt;= tmp2; ++i) printf(&quot;%d\n&quot;, ans1[i]); for (int i = 1; i &lt;= tmp1; ++i) printf(&quot;%d &quot;, ans2[i]); return 0; } } int main() { flyinthesky::solve(); return 0; } /* test 1 2 1 3 1 2 1 3 1 2 1 3 1 2 2 3 1 2 2 3 1 2 1 test 2 2 1 3 1 2 0 3 1 2 0 3 1 2 0 3 1 2 0 3 1 2 1 */]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>离线</tag>
        <tag>二分</tag>
        <tag>莫队</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 3527」「ZJOI2014」力 (卷积FFT)]]></title>
    <url>%2Fbzoj3527%2F</url>
    <content type="text"><![CDATA[BZOJ 3527给定$n, q_i$, 求$$E_j=\sum\limits_{i=1}^{j-1} \frac{q_i}{(i - j)^2} - \sum\limits_{i=j+1}^{n} \frac{q_i}{(i - j)^2}$$ 设$f(i)=q_i, g(i)=\frac 1{i^2}$则$$E_j=\sum\limits_{i=1}^{j-1} f(i)g(i-j) - \sum\limits_{i=j+1}^{n} f(i)g(i-j)$$因为$g(i)$为偶函数，则$$E_j=\sum\limits_{i=1}^{j-1} f(i)g(j-i) - \sum\limits_{i=j+1}^{n} f(i)g(i-j)$$那么前面是一个卷积形式，后面可以翻转$f(i)$后变为另一个卷积形式，FFT 计算即可。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 300000 + 5; const db PI = acos(-1); struct C { db r, i; C() {r = i = 0;} C(db x, db y) {r = x, i = y;} C operator + (C &amp;x) {return C(r + x.r, i + x.i);} C operator - (C &amp;x) {return C(r - x.r, i - x.i);} C operator * (C &amp;x) {return C(r * x.r - i * x.i, x.i * r + x.r * i);} void operator += (C &amp;x) {r += x.r, i += x.i;} void operator *= (C &amp;x) { db tr = r, ti = i; r = tr * x.r - ti * x.i; i = x.i * tr + x.r * ti; } } f[MAXN], g[MAXN]; int m, n, r[MAXN]; db p[MAXN], q[MAXN], a[MAXN], b[MAXN], gg[MAXN]; void FFT(C *a, int op) { for (int i = 0; i &lt; n; ++i) if (i &lt; r[i]) swap(a[i], a[r[i]]); for (int i = 1; i &lt; n; i &lt;&lt;= 1) { C Wn = C(cos(PI / i), sin(PI / i) * op); for (int j = 0; j &lt; n; j += (i &lt;&lt; 1)) { C w = C(1, 0), *a0 = a + j, *a1 = a0 + i; for (int k = 0; k &lt; i; ++k) { C t = *a1 * w; *a1 = *a0 - t, *a0 += t; ++a0, ++a1, w *= Wn; } } } } void pro(db *tf, db *tg, db *ret) { for (int i = 0; i &lt; n; ++i) f[i].r = tf[i], g[i].r = tg[i], f[i].i = 0, g[i].i = 0; FFT(f, 1), FFT(g, 1); for (int i = 0; i &lt; n; ++i) f[i] *= g[i]; FFT(f, -1); for (int i = 0; i &lt;= m; ++i) ret[i] = (fabs(f[i].r) / n); } void clean() { ms(r, 0); } int solve() { clean(); scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) { scanf(&quot;%lf&quot;, &amp;p[i]); q[i] = p[i], gg[i] = 1.0 / i / i; } reverse(q + 1, q + 1 + n); int l = 0; for (m = n, n = 1; n &lt;= m + m; n &lt;&lt;= 1, ++l); for (int i = 0; i &lt; n; ++i) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (l - 1)); pro(p, gg, a); pro(q, gg, b); for (int i = 1; i &lt;= m; ++i) printf(&quot;%.5f\n&quot;, a[i] - b[m - i + 1]); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 2733」「HNOI2012」永无乡 (权值线段树 / Splay森林 + 启发式合并)]]></title>
    <url>%2Fbzoj2733%2F</url>
    <content type="text"><![CDATA[Bzoj 2733题意：维护一个无向图，有两种操作： B x y 表示在岛 $x$ 与岛 $y$ 之间修建一座新桥。 Q x k 表示询问当前与岛 $x$ 连通的所有岛中第 $k$ 重要的是哪座岛，即所有与岛 $x$ 连通的岛中重要度排名第 $k$ 小的岛是哪座，请你输出那个岛的编号。 这题一开始看见连边以为是$LCT$，但是这题不断边，所以直接并查集维护即可。对于每个联通块开一个 Splay 处理第 $k$ 大即可，这里值域小也可以开权值线段树，更加方便。 合并则使用启发式合并，复杂度为$O(n\log n)$，注意代码实现细节 知识点1、Splay有时候值域小也可以开权值线段树，更加方便 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 100000 + 5; int n, m, q, f_dsu[MAXN]; int ch[MAXN][2], fa[MAXN], val[MAXN], siz[MAXN], sz, rt[MAXN]; int find(int x) {return x == f_dsu[x] ? x : f_dsu[x] = find(f_dsu[x]);} int rel(int x) {return ch[fa[x]][1] == x;} void pushup(int x) {siz[x] = siz[ch[x][0]] + siz[ch[x][1]] + 1;} void rotate(int x) { int y = fa[x], z = fa[y], k = rel(x), w = ch[x][k ^ 1]; ch[z][rel(y)] = x, fa[x] = z; ch[y][k] = w, fa[w] = y; ch[x][k ^ 1] = y, fa[y] = x; pushup(y), pushup(x); } void splay(int x, int gg) { // 在 gg 所在子 Splay 中将 x Splay 到根 while (fa[x] != 0) { int y = fa[x]; if (fa[y] != 0) { if (rel(x) == rel(y)) rotate(y); else rotate(x); } rotate(x); } rt[gg] = x; } int newNode(int v) { // 新建一个节点 ++sz; ch[sz][0] = ch[sz][1] = fa[sz] = 0, val[sz] = v, siz[sz] = 1; return sz; } void insert(int x, int gg) { // 在 gg 所在子 Splay 中插入 x 节点 int v = val[x]; int cur = rt[gg], p = 0; while (cur &amp;&amp; v != val[cur]) p = cur, cur = ch[cur][v &gt; val[cur]]; cur = x; fa[cur] = p, ch[p][v &gt; val[p]] = cur; splay(cur, gg); } int kth(int k, int gg) { // 在 gg 所在子 Splay 中找 k 大值 int cur = gg; while (1) { if (k &lt;= siz[ch[cur][0]]) cur = ch[cur][0]; else if (k &gt; siz[ch[cur][0]] + 1) k -= siz[ch[cur][0]] + 1, cur = ch[cur][1]; else return cur; } } void merge(int x, int &amp;to) { // 合并两个 Splay x -&gt; to if (ch[x][0]) merge(ch[x][0], to); if (ch[x][1]) merge(ch[x][1], to); ch[x][0] = ch[x][1] = 0, insert(x, to); pushup(x); } void clean() { sz = 0; } int solve() { clean(); cin &gt;&gt; n &gt;&gt; m; for (int x, i = 1; i &lt;= n; ++i) { scanf(&quot;%d&quot;, &amp;x), f_dsu[i] = rt[i] = i; insert(newNode(x), i); } for (int x, y, i = 1; i &lt;= m; ++i) { scanf(&quot;%d%d&quot;, &amp;x, &amp;y); int a = find(x), b = find(y); if (a != b) { if (siz[rt[a]] &gt; siz[rt[b]]) swap(a, b); f_dsu[a] = b, merge(rt[a], b); } } cin &gt;&gt; q; while (q--) { char s[3]; scanf(&quot;%s&quot;, s); if (s[0] == &#39;B&#39;) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); int a = find(x), b = find(y); if (a != b) { if (siz[rt[a]] &gt; siz[rt[b]]) swap(a, b); f_dsu[a] = b, merge(rt[a], b); } } else if (s[0] == &#39;Q&#39;) { int x, k; scanf(&quot;%d%d&quot;, &amp;x, &amp;k); int a = find(x); splay(rt[a], a); if (siz[rt[a]] &lt; k) printf(&quot;-1\n&quot;); else { printf(&quot;%d\n&quot;, kth(k, rt[a])); } } } return 0; } } int main() { flyinthesky::solve(); return 0; } /* 5 1 4 3 2 5 1 1 2 1000 B 1 4 Q 1 3 */]]></content>
      <tags>
        <tag>Splay</tag>
        <tag>权值线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 2002」「HNOI2010」弹飞绵羊 (LCT / 分块)]]></title>
    <url>%2Fbzoj2002%2F</url>
    <content type="text"><![CDATA[BZOJ 2002题意：见上。 如果没有修改就是个递推……有修改的话我们将这个递推状态抽象成图论的点，然后发现这是一棵树然后修改相当于断边连边，那么就是 LCT 裸题了。 这题也可以分块，每个块维护 $f[i]$表示从$i$开始，跳出所在块的步数 $to[i]$表示跳出所在块后到了哪里 知识点1、递推/DP等状态抽象成图论的点，树、DAG图等 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;map&gt; #include&lt;stack&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { #define lc ch[x][0] #define rc ch[x][1] const int MAXN = 200000 + 5; int ch[MAXN][2], fa[MAXN], sumv[MAXN], rev[MAXN]; // ch: ??????,fa: ????,val: ???,xorv: ?????, rev: ???? int n, q, top, stk[MAXN]; int ki[MAXN]; int isRt(int x) {return ch[fa[x]][0] != x &amp;&amp; ch[fa[x]][1] != x;} //???Splay??? int rel(int x) {return ch[fa[x]][1] == x;} // ? Splay void prorev(int x) {swap(lc, rc), rev[x] ^= 1;} // ?????? (????) void pushup(int x) {sumv[x] = sumv[lc] + sumv[rc] + 1;} //???? void pushdown(int x) { //???? if (rev[x]) { if (lc) prorev(lc); if (rc) prorev(rc); rev[x] = 0; } } void rotate(int x) { // ? Splay pushdown(fa[x]), pushdown(x); int y = fa[x], z = fa[y], k = rel(x), w = ch[x][k ^ 1]; if (!isRt(y)) ch[z][rel(y)] = x; fa[x] = z; // y ??? (z, y) ???,???? (??? Splay ???? 1) ch[y][k] = w, fa[w] = y; ch[x][k ^ 1] = y, fa[y] = x; pushup(y), pushup(x); } void splay(int x) { // ? Splay top = 0; stk[++top] = x; for (int pos = x; !isRt(pos); pos = fa[pos]) stk[++top] = fa[pos]; while (top) pushdown(stk[top--]); // ? x ?????????????? pushdown (??? Splay ???? 2) //???1:???? isRt ???,????pushdown while (!isRt(x)) { // (??? Splay ???? 3.1) int y = fa[x]; if (!isRt(y)) { // (??? Splay ???? 3.2) if (rel(x) == rel(y)) rotate(y); else rotate(x); } rotate(x); } //pushup(x); ?????? } void access(int x) { // ????? x ???????????,??? x ???????????????? for (int y = 0; x; y = x, x = fa[x]) splay(x), rc = y, pushup(x); } void makeRt(int x) { // ?????? access(x), splay(x); prorev(x); } int findRt(int x) { // ????? x ?? access(x), splay(x); while (pushdown(x), lc) x = lc; splay(x); // splay ???? return x; } void split(int x, int y) { // ???????? x-y makeRt(x); access(y), splay(y); // splay ???? //???2:?(x)?y??????,???? access ??,y ??????,????? } void link(int x, int y) { // ?????? x-y makeRt(x); if (findRt(y) != x) fa[x] = y; } void cut(int x, int y) { // ?????? x-y makeRt(x); if (findRt(y) == x &amp;&amp; fa[y] == x &amp;&amp; !ch[y][0]) { fa[y] = rc = 0; pushup(x); } } void clean() { ms(ch, 0), ms(fa, 0), ms(sumv, 0), ms(stk, 0), ms(rev, 0); } int solve() { clean(); scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) { scanf(&quot;%d&quot;, &amp;ki[i]); if (i + ki[i] &gt; n) link(i, n + 1); else link(i, i + ki[i]); } scanf(&quot;%d&quot;, &amp;q); while (q--) { int ty; scanf(&quot;%d&quot;, &amp;ty); if (ty == 1) { int i; scanf(&quot;%d&quot;, &amp;i); ++i; split(i, n + 1); printf(&quot;%d\n&quot;, sumv[n + 1] - 1); } else { int i, k; scanf(&quot;%d%d&quot;, &amp;i, &amp;k); ++i; if (i + ki[i] &gt; n) cut(i, n + 1); else cut(i, i + ki[i]); ki[i] = k; if (i + ki[i] &gt; n) link(i, n + 1); else link(i, i + ki[i]); } } return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>分块</tag>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FFT/NTT 学习笔记]]></title>
    <url>%2FszFFT%2F</url>
    <content type="text"><![CDATA[模板及讲解简介$DFT$：离散傅里叶变换$IDFT$：离散傅里叶逆变换$FFT$：快速傅里叶变换，计算多项式乘法 (卷积)$FNTT/NTT$：快速傅里叶变换的优化版，优化常数及误差 FFT多项式系数表示法设$A(x)$表示一个$n−1$次多项式 则$A(x)=\sum\limits_{i=0}^n a_ix^i$ 利用这种方法计算多项式乘法复杂度为$O(n^2)$（第一个多项式中每个系数都需要与第二个多项式的每个系数相乘） 点值表示法将$n$互不相同的$x$带入多项式，会得到$n$个不同的取值$y$ 则该多项式被这$n$个点$(x_1,y_1),(x_2,y_2),\dots,(x_n,y_n)$唯一确定 其中$y_i=\sum\limits_{j=0}^{n-1} a_jx_i^j$ 利用这种方法计算多项式乘法复杂度为$O(n^2)$ 点值表示法用处我们可以把系数表示转化成点值表示。点值表示下的多项式就是选相同的$x_i$，把对应的$y_i$相乘。两个长度为$n$的多项式相乘得到的是长度为$2n−1$的多项式，需要$2n−1$个点值才能唯一表示，因此一开始两个多项式也要选$2n−1$个点表示。 随意选$O(n)$个点，计算$y$是$O(n)$的，总时间还是$O(n^2)$的，所以我们要介绍后面的利器，单位根 复数定义设$a,b$为实数，$i^2=−1$，形如$a+bi$的数叫复数，其中$i$被称为虚数单位 在复平面中，$x$代表实数，$y$轴（除原点外的点）代表虚数，从原点$(0,0)$到$(a,b)$的向量表示复数$a+bi$模长：从原点$(0,0)$到点$(a,b)$的距离，即$\sqrt{a^2+b^2}$幅角：假设以逆时针为正方向，从$x$轴正半轴到已知向量的转角的有向角叫做幅角 运算法则加法：$(a,b)+(x,y)=(a+x,b+y)$乘法：$(a,b) \times (x,y)=(ac-bd, bc+ad)$ (可从定义式中推出) 单位根定义$n$次单位根（记为$\omega$）它是$n$个复数的集合，每一个的$n$次方都等于$1$。其中的一个是$e^{\frac {2\pi i} n}$，记为$\omega_n$。 欧拉公式$$e^{ix}=\cos x+(\sin x)i$$ $x$就是这个复数向量的旋转角。 易得$$\omega_{n}^{k}=\cos k \frac{2\pi}{n}+i\sin k\frac{2\pi}{n}$$ 几何意义在复平面上，以原点为圆心，$1$为半径作圆，所得的圆叫单位圆。以圆点为起点，圆的$n$等分点为终点，做$n$个向量，设幅角为正且最小的向量对应的复数为$\omega_n$，称为$n$次单位根。 下面是算导的图片，这$n$个复数向量在单位圆上呈放射状。 性质1、消去引理 (从定义式可推，可从图中观察)：$$\omega _{2n}^{2k}=\omega _{n}^{k}$$ 2、(从定义式可推，可从图中观察)$$\omega _{n}^{k+\frac{n}{2}}=-\omega _{n}^{k}$$ 3、(从定义式可推，可从图中观察)$$\omega_n^0=\omega_n^n=1$$ 4、(可从图中观察)$$\omega^{\frac n 2}_n=-1$$ $DFT$和$IDFT$$DFT$我们把$\omega ^k_n(k \in [n−1])$分别带入多项式求点值 假设$n$为偶数，那么我们可以把它的奇偶项分开，用两个多项式表示它$$A^{[0]}(x)=a_0+a_2x+a_4x^2+…+a_{n−2}x^{\frac n2−1} \\A^{[1]}(x)=a_1+a_3x+a_5x^2+…+a_{n−1}x^{\frac n2−1}$$则 $A(x)=A^{[0]}(x^2)+xA^{[1]}(x^2)$ 带入单位根$((k &lt; \frac n 2))$$$A(\omega^k_n)=A^{[0]}(\omega^{2k}_n)+\omega^k_nA^{[1]}(\omega^{2k}_n) \\=A^{[0]}(\omega^k_{\frac n 2})+\omega^k_nA^{[1]}(\omega^k_{\frac n 2})(k &lt; \frac n 2)$$ $((k \geq \frac n 2))$时$$A(\omega^{\frac n 2+k}_n)=A^{[0]}(\omega^{n+2k}_n)+\omega^{\frac n 2+k}_nA^{[1]}(\omega^{n+2k}_n)\\=A^{[0]}(\omega^{2k}_n)+\omega^{\frac n 2}_n\omega^k_nA^{[1]}(\omega^{2k}_n) \\ =A^{[0]}(\omega^k_{\frac n 2})-\omega^k_nA^{[1]}(\omega^k_{\frac n 2})$$ 可以由算法写出$DFT$的复杂度$T(n)=2T(\frac n 2)+O(n)=O(n\log n)$ $IDFT$还原成系数表示的过程叫做$IDFT​$。 只需要记住，$IDFT$的$\omega_n$是$e^{-\frac{2\pi i}n}$，最后的结果除以$n$，其它过程同$DFT$，可以写在一个函数里。 蝴蝶操作和$Rader$排序在操作过程中，取出了a0[k]和a1[k]的值，通过计算又求出了a[k]和a[k+n]的值。我们把这样的一次运算叫做「蝴蝶操作」。 以$n=8$为例，看看递归过程的结构 我们完全可以从底向上递推求解。剩下的问题就是把初始的数组变成最后一层的样子了。观察最后序列的编号的二进制表示000,100,010,110,001,101,011,111与原来000,001,010,011,100,101,110,111相比，每个位置上的二进制位都反过来了。这样的变化叫做$Rader$排序。 我们可以$O(n)$将$Rader$排序的映射关系求出。设$iRader$排序后的数为$r_i$，我们可以通过$r_{\frac i2}$递推求出 这个递推式相当于偶数位$i​$的值就是$\frac i2​$值的一半，而奇数位则在前一个偶数位上$\operatorname{or} 2^{l-1}​$，其中$l​$是$2^l​$超过多项式最终长度的最小$l​$ 例题：【模板】多项式乘法（FFT） #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 4200000 + 5; const double PI = acos(-1); struct C { // 手写 complex 类 double r, i; C() {r = i = 0;} C(double x, double y){r = x, i = y;} C operator + (C &amp;x) {return C(r + x.r, i + x.i);} C operator - (C &amp;x) {return C(r - x.r, i - x.i);} C operator * (C &amp;x) {return C(r * x.r - i * x.i, r * x.i + i * x.r);} void operator += (C &amp;x) {r += x.r, i += x.i;} void operator *= (C &amp;x) { double t = r; r = r * x.r - i * x.i, i = t * x.i + i * x.r; } }f[MAXN], g[MAXN]; int n, m, r[MAXN]; void FFT(C *a, int op) { // op = 1 DFT; op = -1 IDFT; for (int i = 0; i &lt; n; ++i) // 根据映射关系交换元素 if (i &lt; r[i]) swap(a[i], a[r[i]]); for (int i = 1; i &lt; n; i *= 2) { // 第几层 C Wn = C(cos(PI / i), sin(PI / i) * op); for (int j = 0; j &lt; n; j += i * 2) { // 一层中的子问题 [j, j + i * 2 - 1] C w = C(1, 0), *a0 = a + j, *a1 = a0 + i; // a0 = [j, j + i - 1], a1 = [j + i, j + i * 2 - 1] for (int k = 0; k &lt; i; ++k) { // 处理子问题 C t = *a1 * w; *a1 = *a0 - t, *a0 += t; // 蝴蝶操作 // a1 = a0 - a1w // a0 = a0 + a1w w *= Wn, ++a0, ++a1; } } } } void clean() { } int solve() { clean(); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int x, i = 0; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;x), f[i].r = (db)x; for (int x, i = 0; i &lt;= m; ++i) scanf(&quot;%d&quot;, &amp;x), g[i].r = (db)x; int l = 0; for (m += n, n = 1; n &lt;= m; n &lt;&lt;= 1, ++l); for (int i = 0; i &lt; n; ++i) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (l - 1)); //递推求r FFT(f, 1), FFT(g, 1); for (int i = 0; i &lt; n; ++i) f[i] *= g[i]; // 对应 y 相乘 FFT(f, -1); for (int i = 0; i &lt;= m; ++i) printf(&quot;%.0f &quot;,fabs(f[i].r) / n); // IDFT 要除以 n return 0; } } int main() { flyinthesky::solve(); return 0; } /* 1 6 5 6 1 2 3 4 5 6 7 */ 写时注意1、fabs(f[i].r)2、最好四舍五入 NTTFFT运用复数会有误差，并且不能取模，所以就有了NTT用原根代替单位根即可。 原根如果$G^n=1(\mod p)$中$n$的最小正整数解为欧拉函数$\varphi(p)$，则称$G$为$p$的一个原根。 因为$G^{p−1}=\omega^n_n=1$，所以有$\omega_n=g^{\frac{p−1}n}$，并且原根也满足原来FFT用的单位根的性质 常用NTT模数：$998244353(998244352=2^{23}×7×17)$，$3$是它的一个原根 代码例题：【模板】多项式乘法（FFT） #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL MAXN = 4200000 + 5, MO = 998244353, G = 3; LL f[MAXN], g[MAXN]; LL n, m, r[MAXN]; LL ksm(LL a, LL b) { LL bs = a, ans = 1; while (b) { if (b &amp; 1) ans = ans * bs % MO; bs = bs * bs % MO; b &gt;&gt;= 1; } return ans; } void NTT(LL *a, LL op) { // op = 1 DFT; op = -1 IDFT; for (LL i = 0; i &lt; n; ++i) // 根据映射关系交换元素 if (i &lt; r[i]) swap(a[i], a[r[i]]); for (LL i = 1; i &lt; n; i &lt;&lt;= 1) { // 第几层 LL Wn = ksm(G, (MO - 1) / (i &lt;&lt; 1)); if (op == -1) Wn = ksm(Wn, MO - 2); for (LL j = 0; j &lt; n; j += (i &lt;&lt; 1)) { // 一层中的子问题 [j, j + (i &lt;&lt; 1) - 1] LL w = 1, *a0 = a + j, *a1 = a0 + i; // a0 = [j, j + i - 1], a1 = [j + i, j + (i &lt;&lt; 1) - 1] for (LL k = 0; k &lt; i; ++k) { // 处理子问题 LL t = *a1 * w % MO; *a1 = (*a0 - t + MO) % MO, *a0 = (*a0 + t) % MO; // 蝴蝶操作 // a1 = a0 - a1w // a0 = a0 + a1w w = w * Wn % MO, ++a0, ++a1; } } } } void clean() { } int solve() { clean(); scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m); for (LL i = 0; i &lt;= n; ++i) scanf(&quot;%lld&quot;, &amp;f[i]); for (LL i = 0; i &lt;= m; ++i) scanf(&quot;%lld&quot;, &amp;g[i]); LL l = 0; for (m += n, n = 1; n &lt;= m; n &lt;&lt;= 1, ++l); for (LL i = 0; i &lt; n; ++i) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (l - 1)); //递推求r NTT(f, 1), NTT(g, 1); for (LL i = 0; i &lt; n; ++i) f[i] = f[i] * g[i] % MO; // 对应 y 相乘 NTT(f, -1); LL inv = ksm(n, MO - 2); for (LL i = 0; i &lt;= m; ++i) printf(&quot;%lld &quot;, f[i] * inv % MO); // IDFT 要除以 n return 0; } } int main() { flyinthesky::solve(); return 0; } /* 1 6 5 6 1 2 3 4 5 6 7 */ 卷积定义卷积就是形如$$C_n=\sum\limits_{i=0}^{n}a_ib_{n-i}$$ 卷积的两项底数相加要为一个常数。乘法竖式就是一个卷积，所以我们可以用 FFT 求大整数乘法上述多项式乘法也是卷积 卷积题型1、翻转数组形成卷积Bzoj 3527，Bzoj 4827 参考文章 快速傅里叶变换(FFT)详解 - 自为风月马前卒 - 博客园 FFT/NTT总结+洛谷P3803 【模板】多项式乘法（FFT）（FFT/NTT） - Flash_Hu - 博客园]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>FFT</tag>
        <tag>算法笔记</tag>
        <tag>NTT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 2298」「HAOI2011」problem a (DP)]]></title>
    <url>%2Fbzoj2298%2F</url>
    <content type="text"><![CDATA[BZOJ 2299题意：一次考试共有$n$个人参加，第$i$个人说：「有$a_i$个人分数比我高，$b_i$个人分数比我低。」问最少有几个人没有说真话(可能有相同的分数) 没有相同的分数的话就是水题……虽然本题DP好像也挺水的有相同分数考虑将这个相同分数的区间拎出来($1$到$n$范围内)设$s(i,j)$为$[i,j]$为相同分数, 有几个人说自己是这个分数。这个显然可以预处理出来，具体看代码实现题目所求答案可以补集转化，即求最多有几个人说实话设$dp(i)$为排名前$i$个人的最多有几个人说实话那么$$dp(i)=\max(dp(i-1),dp(j-1)+\min(i-j+1,s(j,i)))$$$j$为当前这个名次的最左边的一个人，即从上一个名次转移过来这里相当于将每个分数的人按顺序变成几个块来处理。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 100000 + 5; map&lt;pair&lt;int, int &gt;, int &gt; ma; vector&lt;int &gt; l[MAXN]; int n, dp[MAXN]; void clean() { ms(dp, 0); } int solve() { clean(); cin &gt;&gt; n; for (int x, y, i = 1; i &lt;= n; ++i) { scanf(&quot;%d%d&quot;, &amp;x, &amp;y); ++x, y = n - y; if (x &lt;= y) { // [x, y] if (++ma[make_pair(x, y)] == 1) l[y].push_back(x); } } for (int i = 1; i &lt;= n; ++i) { dp[i] = dp[i - 1]; for (int o = 0; o &lt; (int)l[i].size(); ++o) { int j = l[i][o]; dp[i] = max(dp[i], dp[j - 1] + min(i - j + 1, ma[make_pair(j, i)])); } } cout &lt;&lt; n - dp[n]; return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>Bzoj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 4071」「Apio2015」巴邻旁之桥 (权值线段树维护前缀中位数 / Splay / 主席树)]]></title>
    <url>%2Fbzoj4071%2F</url>
    <content type="text"><![CDATA[BZOJ 4071题意：$[0,10^9]$范围有$n$个区间，要求选一个点$x$或两个点$x,y$，对于任意区间$i$代价为$\min(|l_i-x|+|r_i-x|, |l_i-y|+|r_i-y|)$，求最小代价 对于只选一个点的，设选了$p$点，则$$ans=\sum_{i=1}^n |l_i-p|+|r_i-p|$$将端点视为同等的，那么答案即为$$ans=\sum |x-p|$$这是一个中位数的模型，直接取中位数是最优的。 对于选两个点的，考虑每个区间$[l,r]$会过离$\frac{l+r}{2}$最近的桥，所以我们可以将区间按照$l_i+r_i$排序，然后顺序枚举每个区间作分界点，左边右边分开处理，变成一个点的做法。 那么我们需要支持一个动态中位数。显然可以用 Splay / 主席树 求第$k$大($k=\frac{n}{2}$)然而这里只需要求出一个前缀、后缀的中位数，那么可以考虑不用主席树而是权值线段树代替之。在权值线段树上找$k$大，然后再分类讨论求所有点到中位数距离即可。 另外这题还满足单峰性质，那么三分套三分枚举桥位置即可。 知识点：1、中位数的运用：多个点到某个点距离和最近2、权值线段树 / Splay / 主席树动态中位数的方法 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 200000 + 10; struct data { int x, y; bool operator &lt; (const data &amp;rhs) const {return (x + y) &lt; (rhs.x + rhs.y);} } itv[MAXN]; int k, n, itv_tot, tax[MAXN], tax_tot, fl; LL ans, pre[MAXN]; #define lc (o &lt;&lt; 1) #define rc (o &lt;&lt; 1 | 1) #define M ((l + r) &gt;&gt; 1) LL siz[MAXN * 4], sumv[MAXN * 4]; void pushup(int o) {siz[o] = siz[lc] + siz[rc], sumv[o] = sumv[lc] + sumv[rc];} void build(int o, int l, int r) { siz[o] = sumv[o] = 0; if (l == r) return ; else { build(lc, l, M), build(rc, M + 1, r); pushup(o); } } void update(int o, int l, int r, int p, int v) { if (l == r) sumv[o] += v, ++siz[o]; else { if (p &lt;= M) update(lc, l, M, p, v); else update(rc, M + 1, r, p, v); pushup(o); } } int querykth(int o, int l, int r, int k) { if (l == r) return l; if (k &lt;= siz[lc]) return querykth(lc, l, M, k); // &lt;= else return querykth(rc, M + 1, r, k - siz[lc]); } LL queryitv_sum(int o, int l, int r, int x, int y) { if (x &lt;= l &amp;&amp; r &lt;= y) { return sumv[o]; } LL ret = 0; if (x &lt;= M) ret += queryitv_sum(lc, l, M, x, y); if (M &lt; y) ret += queryitv_sum(rc, M + 1, r, x, y); return ret; } LL queryitv_N(int o, int l, int r, int x, int y) { if (x &lt;= l &amp;&amp; r &lt;= y) { return siz[o]; } LL ret = 0; if (x &lt;= M) ret += queryitv_N(lc, l, M, x, y); if (M &lt; y) ret += queryitv_N(rc, M + 1, r, x, y); return ret; } void clean() { fl = tax_tot = itv_tot = ans = 0; } int solve() { clean(); scanf(&quot;%d%d&quot;, &amp;k, &amp;n); char sa[5], sb[5]; for (int i = 1; i &lt;= n; ++i) { int s, t; scanf(&quot;%s%d%s%d&quot;, sa, &amp;s, sb, &amp;t); if (s &gt; t) swap(s, t); if (sa[0] == sb[0]) { ans += t - s; continue ; } ++ans, fl = 1; itv[++itv_tot] = (data){s, t}; tax[++tax_tot] = s; tax[++tax_tot] = t; } if (!fl) return printf(&quot;%lld\n&quot;, ans), 0; // 特判 sort(tax + 1, tax + 1 + tax_tot), tax_tot = unique(tax + 1, tax + 1 + tax_tot) - tax - 1; sort(itv + 1, itv + 1 + itv_tot); for (int i = 1; i &lt;= itv_tot; ++i) itv[i].x = lower_bound(tax + 1, tax + 1 + tax_tot, itv[i].x) - tax, itv[i].y = lower_bound(tax + 1, tax + 1 + tax_tot, itv[i].y) - tax; build(1, 1, tax_tot); for (int i = 1; i &lt;= itv_tot; ++i) { update(1, 1, tax_tot, itv[i].x, tax[itv[i].x]); update(1, 1, tax_tot, itv[i].y, tax[itv[i].y]); int p = querykth(1, 1, tax_tot, i); LL S1 = queryitv_sum(1, 1, tax_tot, 1, p), N1 = queryitv_N(1, 1, tax_tot, 1, p); LL S2 = queryitv_sum(1, 1, tax_tot, p + 1, tax_tot), N2 = queryitv_N(1, 1, tax_tot, p + 1, tax_tot); pre[i] = tax[p] * N1 - S1 + S2 - tax[p] * N2; // tax[p] } if (k == 1) return printf(&quot;%lld\n&quot;, pre[itv_tot] + ans), 0; build(1, 1, tax_tot); LL whw = pre[itv_tot]; for (int i = itv_tot; i &gt;= 1; --i) { update(1, 1, tax_tot, itv[i].x, tax[itv[i].x]); update(1, 1, tax_tot, itv[i].y, tax[itv[i].y]); int p = querykth(1, 1, tax_tot, itv_tot - i + 1); // 注意 LL S1 = queryitv_sum(1, 1, tax_tot, 1, p), N1 = queryitv_N(1, 1, tax_tot, 1, p); LL S2 = queryitv_sum(1, 1, tax_tot, p + 1, tax_tot), N2 = queryitv_N(1, 1, tax_tot, p + 1, tax_tot); whw = min(whw, pre[i - 1] + tax[p] * N1 - S1 + S2 - tax[p] * N2); } return printf(&quot;%lld\n&quot;, whw + ans), 0; return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>Splay</tag>
        <tag>三分</tag>
        <tag>主席树</tag>
        <tag>权值线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1260」「CQOI2007」涂色 (区间DP染色问题三题)]]></title>
    <url>%2Fbzoj1260%2F</url>
    <content type="text"><![CDATA[BZOJ 1260 CQOI2007 涂色题意：给定一个$n$长序列，你可以每次选择一段区间染色，请问从空状态转移到目标最少要多少步。 Hdu 2476 String painter题意：给定一个$n$长序列，你可以每次选择一段区间染色，请问从初始状态$A$转移到目标$B$最少要多少步。 Codeforces 1114 D. Flood Fill题意：给定一个$n$长序列，你要最开始选择一段连续区间，然后每次可以修改初始区间块的颜色，请问将区间变为一个颜色最少要多少步。 对于 Bzoj 1260，我们可以设$dp(i,j)$为$[i,j]$修改的最少步数。则可以列出$$dp(i,j)=\min(dp(i,k)+dp(k+1,j))$$对于$a_i=a_j$，我们可以列出$$dp(i,j)=\min(dp(i+1,j), dp(i,j-1))$$相当于$[i,j]$可以在前面先修改，可以证明这是最优的。$dp(i+1,j)$等价于$[i+1,j]$修改时可以带上$i$, 后面同理。 对于 Hdu 2476，要从初始状态出发，我们先求出 Bzoj 1260 的 DP 值，然后设$f(i)$为前$i$个位置修改的最少步数。则$$f(i)=f(j)+dp(j+1,i)$$而对于$a_i=b_i$，那么$i$可以不涂，则$$f(i)=f(i-1)$$ 对于 CF 1114 D，我们必须改初始块的颜色，所以可以设$g(i,j)$为$[i,j]$修改的最小步数。则$$g(i,j)=\min(g(i + 1, j), g(i, j-1))$$对于$a_i=a_j$，则$$g(i,j)=\min(g(i+1,j-1)+1)$$ 这三题都运用了区间DP的套路转移$$dp(i,j) \Leftarrow dp(i,k), dp(k+1,j) \\dp(i,j) \Leftarrow dp(i+1,j), dp(i,j-1) \\dp(i,j) \Leftarrow dp(i+1,j-1) \\$$以及区间覆盖的相关性质。 //BZOJ 1260 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 50 + 5, INF = 2000000000; char gg[MAXN]; int n, dp[MAXN][MAXN], c[MAXN]; int dfs(int i, int j) { if (i &gt; j) return 0; if (dp[i][j] != INF) return dp[i][j]; if (i == j) return dp[i][j] = 1; if (c[i] == c[j]) { dp[i][j] = min(dp[i][j], dfs(i + 1, j - 1) + 1); dp[i][j] = min(dp[i][j], dfs(i + 1, j)); dp[i][j] = min(dp[i][j], dfs(i, j - 1)); } for (int k = i; k &lt; j; ++k) dp[i][j] = min(dp[i][j], dfs(i, k) + dfs(k + 1, j)); return dp[i][j]; } void clean() { } int solve() { clean(); scanf(&quot;%s&quot;, gg + 1); n = strlen(gg + 1); for (int i = 1; i &lt;= n; ++i) c[i] = gg[i] - &#39;A&#39;; for (int i = 0; i &lt;= n + 1; ++i) for (int j = 0; j &lt;= n + 1; ++j) dp[i][j] = INF; cout &lt;&lt; dfs(1, n); return 0; } } int main() { flyinthesky::solve(); return 0; } //Hdu 2476 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 100 + 5, INF = 2000000000; char a[MAXN], b[MAXN]; int n, dp[MAXN][MAXN], c[MAXN]; int f[MAXN]; int dfs(int i, int j) { if (i &gt; j) return 0; if (dp[i][j] != INF) return dp[i][j]; if (i == j) return dp[i][j] = 1; if (b[i] == b[j]) { dp[i][j] = min(dp[i][j], dfs(i + 1, j)); dp[i][j] = min(dp[i][j], dfs(i, j - 1)); } for (int k = i; k &lt; j; ++k) dp[i][j] = min(dp[i][j], dfs(i, k) + dfs(k + 1, j)); return dp[i][j]; } void clean() { } int solve() { clean(); n = strlen(a + 1); for (int i = 0; i &lt;= n + 1; ++i) for (int j = 0; j &lt;= n + 1; ++j) dp[i][j] = INF; dfs(1, n); f[0] = 0; for (int i = 1; i &lt;= n; ++i) f[i] = dp[1][i]; for (int i = 1; i &lt;= n; ++i) { if (a[i] != b[i]) { for (int j = 1; j &lt; i; ++j) { f[i] = min(f[i], f[j] + dp[j + 1][i]); } } else f[i] = f[i - 1]; } cout &lt;&lt; f[n] &lt;&lt; endl; return 0; } } int main() { while (scanf(&quot;%s%s&quot;, (flyinthesky::a + 1), (flyinthesky:: b + 1)) == 2) flyinthesky::solve(); return 0; } //CF 1114D //==========================Head files========================== #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;map&gt; #define LL long long #define db double #define mp make_pair #define pr pair&lt;int, int&gt; #define fir first #define sec second #define pb push_back #define ms(i, j) memset(i, j, sizeof i) using namespace std; //==========================Templates========================== inline int read() { int x = 0, f = 1; char c = getchar(); while(c &lt; &#39;0&#39; || c &gt; &#39;9&#39;){if (c == &#39;-&#39;) f = -1; c = getchar();} while(c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;){x = x * 10 + c - &#39;0&#39;; c = getchar();} return x * f; } inline LL readl() { LL x = 0, f = 1; char c = getchar(); while(c &lt; &#39;0&#39; || c &gt; &#39;9&#39;){if (c == &#39;-&#39;) f = -1; c = getchar();} while(c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;){x = x * 10 + c - &#39;0&#39;; c = getchar();} return x * f; } int power(int a, int b) { int ans = 1; while (b) { if(b &amp; 1) ans = ans * a; b &gt;&gt;= 1; a = a * a; } return ans; } int power_mod(int a, int b, int mod) { a %= mod; int ans = 1; while (b) { if(b &amp; 1) ans = (ans * a) % mod; b &gt;&gt;= 1, a = (a * a) % mod; } return ans; } LL powerl(LL a, LL b) { LL ans = 1ll; while (b) { if(b &amp; 1ll) ans = ans * a; b &gt;&gt;= 1ll;a = a * a; } return ans; } LL power_modl(LL a, LL b, LL mod) { a %= mod; LL ans = 1ll; while (b) { if(b &amp; 1ll) ans = (ans * a) % mod; b &gt;&gt;= 1ll, a = (a * a) % mod; } return ans; } LL gcdl(LL a, LL b) {return b == 0 ? a : gcdl(b, a % b);} LL abssl(LL a) {return a &gt; 0 ? a : -a;} int gcd(int a, int b) {return b == 0 ? a : gcd(b, a % b);} int abss(int a) {return a &gt; 0 ? a : -a;} //==========================Main body========================== #define LD &quot;%I64d&quot; #define D &quot;%d&quot; #define pt printf #define sn scanf #define pty printf(&quot;YES\n&quot;) #define ptn printf(&quot;NO\n&quot;) //==========================Code here========================== const LL INF = 1152921504606846976ll; LL n, c[5005]; LL dp[5005][5005]; LL dfs(LL i, LL j) { if (i &gt; j) return INF; if (i == j) return 0; if (dp[i][j] != INF) return dp[i][j]; if (c[i] == c[j]) dp[i][j] = min(dp[i][j], dfs(i + 1, j - 1) + 1); else dp[i][j] = min(dfs(i, j - 1) + 1, dfs(i + 1, j) + 1); return dp[i][j]; } int main() { cin &gt;&gt; n; for (LL i = 1; i &lt;= n; ++i) scanf(&quot;%lld&quot;, &amp;c[i]); n = unique(c + 1, c + 1 + n) - c - 1; for (LL i = 0; i &lt;= n + 1; ++i) for (LL j = 0; j &lt;= n + 1; ++j) dp[i][j] = INF; printf(&quot;%lld\n&quot;, dfs(1, n)); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1058」「ZJOI2007」报表统计 (Set)]]></title>
    <url>%2Fbzoj1058%2F</url>
    <content type="text"><![CDATA[Bzoj 1058题意：有一个长度为$N$的整数序列，并且有以下三种操作：INSERT i k：在原数列的第$i$个元素后面添加一个新元素$k$；如果原数列的第ii个元素已经添加了若干元素，则添加在这些元素的最后（见下面的例子）MIN_GAP：查询相邻两个元素的之间差值（绝对值）的最小值MIN_SORT_GAP：查询所有元素中最接近的两个元素的差值（绝对值） 本题如果原数列的第$i$个元素已经添加了若干元素，则添加在这些元素的最后非常关键，因为这样我们就可以每个位置维护一个数组，然后对每个位置处理即可。对于MIN_SORT_GAP，就是bzoj1588 &amp; 1208，直接开个 set 维护对于MIN_GAP，我们每个位置维护$\min(a_i-a_{i-1})$, $a[1,g]$是每个位置维护的数组然后再将后面的一个位置的第一个数的值和这个位置维护的数组的最后一个值的最小值更新然后将这些位置的值都插进一个multiset里面维护最小值即可。 知识点：这种操作读文字的字符串大小数好，开够数组 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;map&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 500000 + 5, INF = 2000000000; int n, q, a[MAXN], now[MAXN], qc[MAXN]; vector&lt;int &gt; pos[MAXN]; int MIN_SORT_GAP; set&lt;int &gt; s; multiset&lt;int &gt; mind; int abss(int x) {return x &gt; 0 ? x : -x;} inline int read() { int x=0,f=1;char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();} return x*f; } void clean() { MIN_SORT_GAP = INF; } int solve() { clean(); scanf(&quot;%d%d&quot;, &amp;n, &amp;q); s.insert(-INF), s.insert(INF); for (int i = 1; i &lt;= n; ++i) { a[i] = read(), pos[i].push_back(a[i]); set&lt;int &gt;::iterator it = s.lower_bound(a[i]); if (*it != INF) MIN_SORT_GAP = min(MIN_SORT_GAP, abss(a[i] - *it)); --it; if (*it != -INF) MIN_SORT_GAP = min(MIN_SORT_GAP, abss(a[i] - *it)); s.insert(a[i]); qc[i] = INF; } for (int i = 1; i &lt; n; ++i) mind.insert(now[i] = abss(a[i + 1] - a[i])); mind.insert(INF), qc[n] = now[n] = INF; char ch[20]; while (q--) { scanf(&quot;%s&quot;, ch); if (ch[0] == &#39;I&#39;) { int i, k; i = read(), k = read(); set&lt;int &gt;::iterator it = s.lower_bound(k); if (*it != INF) MIN_SORT_GAP = min(MIN_SORT_GAP, abss(k - *it)); --it; if (*it != -INF) MIN_SORT_GAP = min(MIN_SORT_GAP, abss(k - *it)); s.insert(k); mind.erase(mind.find(now[i])); qc[i] = min(qc[i], abss(k - pos[i].back())); now[i] = min(qc[i], abss(a[i + 1] - k)); mind.insert(now[i]); pos[i].push_back(k); } else if (ch[4] == &#39;G&#39;) { printf(&quot;%d\n&quot;, *mind.begin()); } else if (ch[4] == &#39;S&#39;) { printf(&quot;%d\n&quot;, MIN_SORT_GAP); } } return 0; } } int main() { flyinthesky::solve(); return 0; } /* 2 1000 10 800 */]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>Set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1861」「Zjoi2006」书架 (Splay)]]></title>
    <url>%2Fbzoj1861%2F</url>
    <content type="text"><![CDATA[BZOJ 1861题意：给定一个排列，求对排列支持以下操作 Top S，将排列中的$S$放到排列最前面 Bottom S，将排列中的$S$放到排列最后面 Insert S T：若$S$的前面有$X$个数，则这个数放回去后它的前面有$X+T$个数 ($T∈(-1，0，1)$) Ask S：询问$S$前面有几个数 Query S：询问从前往后第$S$个数是什么。 显然 Splay 可做，kth可以定每个数在排列中的位置然后因为这里是排列，所以可以建立一个数组映射，即每个数在Splay上的点编号和数对应。然后将Splay上的某点转到根之后的左子树大小即为该点在排列中的位置。 知识点：1、函数功能写清楚2、实在调不出来/想不出来可以放下来之后再看3、Splay 的序列区间最好都建在 $[1,n+2]$，避免与$0$冲突，加上虚节点非常有用4、Splay 维护序列一定要用build函数5、对于维护序列的数据结构，可以通过某个操作来得到整个序列来查程序的错误 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;map&gt; #include&lt;stack&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 100000 + 5; int n, q, arr[MAXN], pos[MAXN]; int ch[MAXN][2], fa[MAXN], val[MAXN], siz[MAXN], sz, rt; int rel(int x) {return ch[fa[x]][1] == x;} void pushup(int x) {siz[x] = siz[ch[x][0]] + siz[ch[x][1]] + 1;} void rotate(int x) { int y = fa[x], z = fa[y], k = rel(x), w = ch[x][k ^ 1]; ch[z][rel(y)] = x, fa[x] = z; ch[y][k] = w, fa[w] = y; ch[x][k ^ 1] = y, fa[y] = x; pushup(y), pushup(x); } void splay(int x, int gl = 0) { while (fa[x] != gl) { int y = fa[x], z = fa[y]; if (z != gl) { if (rel(x) == rel(y)) rotate(y); else rotate(x); } rotate(x); } if (!gl) rt = x; } int newNode(int v) { val[++sz] = v, ch[sz][0] = ch[sz][1] = fa[sz] = 0, siz[sz] = 1; pos[v] = sz; return sz; } int build(int l, int r) { if (l &gt; r) return 0; int mid = (l + r) &gt;&gt; 1; int cur = newNode(arr[mid]); if (l == r) return cur; if ((ch[cur][0] = build(l, mid - 1))) fa[ch[cur][0]] = cur; if ((ch[cur][1] = build(mid + 1, r))) fa[ch[cur][1]] = cur; pushup(cur); return cur; } int getnum(int x) { // 得到 x 点的位置 splay(x); return siz[ch[x][0]]; } int kth(int k) { int cur = rt; while (1) { if (k &lt;= siz[ch[cur][0]]) cur = ch[cur][0]; else if (k &gt; siz[ch[cur][0]] + 1) k -= siz[ch[cur][0]] + 1, cur = ch[cur][1]; else return cur; } } void insert(int x, int p) { // 将 x 点插到 p 位置后面 int pre = kth(p + 1), succ = kth(p + 2); splay(pre), splay(succ, pre); ch[succ][0] = x, fa[x] = succ; pushup(succ), pushup(pre); splay(x); } void move(int x, int y) { // 将 x 位置上的移到 y 位置后面 int pre = kth(x), succ = kth(x + 2); splay(pre), splay(succ, pre); int fr = ch[succ][0]; ch[succ][0] = 0, fa[fr] = 0; pushup(succ), pushup(pre); insert(fr, y); } void clean() { ms(arr, 0), ms(pos, 0), ms(ch, 0), ms(fa, 0), ms(val, 0), ms(siz, 0), sz = 0; rt = 0; } int solve() { scanf(&quot;%d%d&quot;, &amp;n, &amp;q); clean(); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;arr[i + 1]); rt = build(1, n + 2); char s[10]; while (q--) { int S, T; scanf(&quot;%s&quot;, s); if (s[0] == &#39;T&#39;) scanf(&quot;%d&quot;, &amp;S), move(getnum(pos[S]), 0); if (s[0] == &#39;B&#39;) scanf(&quot;%d&quot;, &amp;S), move(getnum(pos[S]), n - 1); if (s[0] == &#39;I&#39;) scanf(&quot;%d%d&quot;, &amp;S, &amp;T), move(getnum(pos[S]), getnum(pos[S]) + T - 1); if (s[0] == &#39;A&#39;) scanf(&quot;%d&quot;, &amp;S), printf(&quot;%d\n&quot;, getnum(pos[S]) - 1); if (s[0] == &#39;Q&#39;) scanf(&quot;%d&quot;, &amp;S), printf(&quot;%d\n&quot;, val[kth(S + 1)]); if (s[0] == &#39;G&#39;) { // tester for (int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, val[kth(i + 1)]); printf(&quot;\n&quot;); } } return 0; } } int main() { flyinthesky::solve(); return 0; } /* 10 1000 1 3 2 7 5 8 10 4 9 6 */]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>Splay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1226」「SDOI2009」学校食堂 (状压DP)]]></title>
    <url>%2Fbzoj1226%2F</url>
    <content type="text"><![CDATA[BZOJ 1226题意：见上。 看见$B_i \leq 7$就要留意状压了。(本蒟蒻没想到)这题一个状态和前和后都有关，这样状压DP就排上用场。前面DP顺推，后面的状态状压记录。然后可以设$dp(i,st)$为$[1,i-1]$吃完饭了，$[i, i+7]$是否吃饭的状态发现这样无法转移，不能算出做菜时间，那么加一维$k$表示上一层吃饭的人相对$i$的位置的距离$k \in [{\color{red}{-8}}, 7]$注意要到$-8$，因为可以后面$7$个人都吃完再轮到$i$吃。转移考虑$i$是否吃了。1、吃了的话，则$$dp(i+1,st / 2, k-1)=\min(dp(i,st,k))$$其中$st / 2$意义为左移，$k-1$的原因是之前吃的位置相对$i+1$是远了。这两个式子表示的意义实际是一样。2、没吃，就枚举$h\in [0,7]$吃$$dp(i, st | h, h)=\min(dp(i, st, k) + T(i+k,i+h))$$其中$T(x,y)=x \operatorname{xor} y$，即题目中的$x\operatorname{or} y - x \operatorname{and} y$ 还要考虑容忍度。因为每个人的$B_i$不同，所以边扫描边维护最小的容忍区间，即代码中的bd 因为这题又刷表又递推，$i$要循环到$n$，注意集合的最大值为1&lt;&lt;8 1、一个状态和前和后都有关，这样状压DP就排上用场。前面DP顺推，后面的状态状压记录2、边界是否+1想好。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;map&gt; #include&lt;stack&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; int T; namespace flyinthesky { const int MAXN = 1000 + 5; int n, C[MAXN], B[MAXN]; int dp[MAXN][300][21]; void clean() { for (int i = 0; i &lt;= n; ++i) for (int j = 0; j &lt;= 289; ++j) for (int k = 0; k &lt;= 20; ++k) dp[i][j][k] = 1000000000; } int solve() { scanf(&quot;%d&quot;, &amp;n); clean(); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d%d&quot;, &amp;C[i], &amp;B[i]); dp[1][0][-1 + 8] = 0; for (int i = 1; i &lt;= n; ++i) { for (int st = 0; st &lt;= (1 &lt;&lt; 8) - 1; ++st) { for (int k = -8; k &lt;= 7; ++k) { if (!(i + k &gt;= 0 &amp;&amp; i + k &lt;= n)) continue ; if (st &amp; 1) dp[i + 1][st &gt;&gt; 1][k - 1 + 8] = dp[i][st][k + 8]; else { int bd = 1000000000; for (int h = 0; h &lt;= 7; ++h) if (!(st &amp; (1 &lt;&lt; h))) { if (i + h &gt; bd) break ; bd = min(bd, i + h + B[i + h]); dp[i][st | (1 &lt;&lt; h)][h + 8] = min(dp[i][st | (1 &lt;&lt; h)][h + 8], dp[i][st][k + 8] + ((i + k == 0) ? 0 : ( (C[i + k]) ^ (C[i + h]) )) ); } } } } } int ans = 1000000000; for (int k = -8; k &lt;= 7; ++k) ans = min(ans, dp[n][1][k + 8]); printf(&quot;%d\n&quot;, ans); return 0; } } int main() { scanf(&quot;%d&quot;, &amp;T); while (T--) flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 3126」「Usaco2013 Open」Photo (单调队列优化DP / 差分约束)]]></title>
    <url>%2Fbzoj3126%2F</url>
    <content type="text"><![CDATA[bzoj 3126题意：给定数轴$[1,n]$，有$m$个区间，每个区间有且只有一个黑点。不被任何区间包含的点也算黑点。求黑点最大个数。 可以差分约束，建立$a(r)-a(l-1)=1,0 \leq a(i)-a(i-1) \leq 1,-1 \geq a(i-1)-a(i) \geq 0$，但是本题卡SPFA DP做法： 设$dp(i)$为$i$位置，$i$位置必黑的最优方案。则$$dp(i)=\max_{l[i] \leq j \leq r[i]}(dp(j)+1)$$对于$j$的取值集合$[l[i], r[i]]$，我们可以预处理出来。显然对于一个区间$[x, y]$，在$y+1$位置向左最远选点位置是$x$(否则$[x,y]$没黑点)在$y$位置向左最近选点位置是$x-1$(否则$[x,y]$有多个黑点) 然后$r$没有加入区间时默认$r[i]=i-1$区间加完后就做个前缀$\max$和后缀$\min$ 然后单调队列优化DP即可。 1、单调队列区间的写法2、$n+1$位置的妙用 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;map&gt; #include&lt;stack&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { int n, m, ll[200000 + 5], rr[200000 + 5], dp[200000 + 5]; int q[200000 + 5], l, r; void clean() { } int solve() { clean(); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n + 1; ++i) rr[i] = i - 1, ll[i] = 0, dp[i] = -1; for (int x, y, i = 1; i &lt;= m; ++i) { scanf(&quot;%d%d&quot;, &amp;x, &amp;y); ll[y + 1] = max(ll[y + 1], x); rr[y] = min(rr[y], x - 1); } for (int i = n - 1; i; --i) rr[i] = min(rr[i], rr[i + 1]); for (int i = 2; i &lt;= n + 1; ++i) ll[i] = max(ll[i], ll[i - 1]); l = 1, r = 1, q[1] = 0, dp[0] = 0; int p = 1; for (int i = 1; i &lt;= n + 1; ++i) { if (ll[i] &gt; rr[i]) {dp[i] = -1; continue ;} while (p &lt;= rr[i] &amp;&amp; p &lt;= n) { while (l &lt;= r &amp;&amp; dp[p] &gt;= dp[q[l]]) --r; q[++r] = p, ++p; } while (l &lt;= r &amp;&amp; q[l] &lt; ll[i]) ++l; // 放后面 if (dp[q[l]] != -1) dp[i] = dp[q[l]] + 1; else dp[i] = -1; } if (dp[n + 1] == -1) printf(&quot;-1\n&quot;); else printf(&quot;%d\n&quot;, dp[n + 1] - 1); return 0; } } int main() { flyinthesky::solve(); return 0; } /* 2 2 1 5 3 8 2 3 1 2 1 1 2 2 2 2 1 2 1 2 */]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>Bzoj</tag>
        <tag>单调队列</tag>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1110D (DP)]]></title>
    <url>%2FCodeforces1110D%2F</url>
    <content type="text"><![CDATA[Codeforces 1106E题意：给定一个$n$长值域为$m$的序列，你要将其组成尽可能多的三元组$(a, b, c)$满足$a=b=c$或者$b=a+1,c=b+1$。 一开始读错题了。先将所有数存在一个桶里，按数大小来DP。显然对于一种方案$(a,b,c)$，他只会重复至多$2$次。那么对于一个方案$(i,i+1,i+2)$，他最多只会有$2$个那么设$dp(i,0/1/2,0/1/2)$为前$i$个数，第一个数是$i$的三元组个数，第二个数是$i$的三元组个数的最大个数。转移$$dp(i,a,b)=\max_{0\leq c \leq 2}(dp(i-1,b,c)+c+(cnt-a-b-c) / 3)$$其中$cnt$为$i$数的个数。 后面$(cnt-a-b-c) / 3)$等价于将多余的$i$组成三元组$(i,i,i)$ #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;map&gt; #include&lt;stack&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { LL n, m, cnt[1000000 + 5]; LL dp[1000000 + 5][3][3]; void clean() { ms(dp, -1); } int solve() { clean(); cin &gt;&gt; n &gt;&gt; m; for (LL x, i = 1; i &lt;= n; ++i) scanf(&quot;%lld&quot;, &amp;x), ++cnt[x]; dp[0][0][0] = 0; for (LL i = 1; i &lt;= m; ++i) { for (LL a = 0; a &lt; 3; ++a) { for (LL b = 0; b &lt; 3; ++b) { for (LL c = 0; c &lt; 3; ++c) { LL tmp = cnt[i] - a - b - c; if (tmp &gt;= 0 &amp;&amp; dp[i - 1][b][c] &gt;= 0) { dp[i][a][b] = max(dp[i][a][b], dp[i - 1][b][c] + c + tmp / 3); } } } } } LL ans = 0; for (LL a = 0; a &lt; 3; ++a) for (LL b = 0; b &lt; 3; ++b) ans = max(ans, dp[m][a][b]); cout &lt;&lt; ans; return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Hdu 5608」function (莫比乌斯反演 + 杜教筛)]]></title>
    <url>%2Fhdu5608%2F</url>
    <content type="text"><![CDATA[hdu 5608题意：给定$n$和函数$f, g$满足$$g(n)=n^2−3n+2\\g(n)=\sum_{d|n} f(d)$$求$$\sum_{i=1}^n f(i) \mod 10^9+7$$ 显然$f * I = g$，杜教筛即可。即$$S(n)=\sum_{i=1}^n g(i) - \sum_{i=2}^n S(\lfloor \frac nd \rfloor)$$将$g$每个项分离出来，用平方数列前缀和公式+等差数列公式即可求解。 对于前$n^{\frac 23}$的$f$，反演一下即可。即$$f(n)=\sum_{d|n} g(d) \mu(\frac nd)$$注意这个式子不是很常用。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;map&gt; #include&lt;stack&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; int T; namespace flyinthesky { const int N = 1000000; const LL MO = 1000000000 + 7; LL n, f[N + 5], inv3; int mu[N + 5], pri[400000 + 5], vis[N + 5], tot; map&lt;LL, LL &gt; ansf; LL ksm(LL a, LL b) { LL ans = 1ll, bs = a; while (b) { if (b &amp; 1) ans = (ans * bs) % MO; bs = (bs * bs) % MO; b &gt;&gt;= 1; } return ans; } LL getf(LL n) { if (n &lt;= N) return f[n]; if (ansf[n]) return ansf[n]; LL ret = (n * n % MO * n % MO + 2ll * n % MO - 3ll * n % MO * n % MO) * inv3 % MO; ret = (ret % MO + MO) % MO; int l = 2; while (l &lt;= n) { int r = n / (n / l); ret = ((ret - (r - l + 1ll) * getf(n / l) % MO) % MO + MO) % MO; l = r + 1; } return ansf[n] = ret; } void init() { ms(f, 0), ms(mu, 0), ms(pri, 0), ms(vis, 0), tot = 0; mu[1] = 1; for (int i = 2; i &lt;= N; ++i) { if (!vis[i]) pri[++tot] = i, mu[i] = -1; for (int j = 1; j &lt;= tot &amp;&amp; 1ll * pri[j] * i &lt;= 1ll * N; ++j) { vis[pri[j] * i] = 1; if (i % pri[j] == 0) { mu[pri[j] * i] = 0; break ; } else mu[pri[j] * i] = mu[pri[j]] * mu[i]; } } for (int i = 1; i &lt;= N; ++i) for (int j = i; j &lt;= N; j += i) f[j] = (f[j] + (i - 2ll) * (i - 1ll) % MO * mu[j / i] % MO + MO) % MO; for (int i = 1; i &lt;= N; ++i) f[i] = (f[i] + f[i - 1]) % MO; inv3 = ksm(3, MO - 2); } void clean() { } int solve() { clean(); scanf(&quot;%lld&quot;, &amp;n); printf(&quot;%lld\n&quot;, getf(n)); return 0; } } int main() { scanf(&quot;%d&quot;, &amp;T); flyinthesky::init(); while (T--) flyinthesky::solve(); return 0; } /* 1 2000001 */]]></content>
      <categories>
        <category>Hdu</category>
      </categories>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>杜教筛</tag>
        <tag>Hdu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LCT 学习笔记]]></title>
    <url>%2FszLCT%2F</url>
    <content type="text"><![CDATA[模板及讲解LCT，也就是Link-Cut Tree的缩写。它是最常见的一种解决动态树问题的工具。不过说它是树也不准确，因为它维护的可以是一片森林。 实链剖分将某一个儿子的连边划分为实边，而连向其他子树的边划分为虚边。区别在于虚实是可以动态变化的，因此要使用更高级、更灵活的Splay来维护每一条由若干实边连接而成的实链。LCT维护的对象其实是一个森林。 LCT 性质1、每一个Splay维护的是一条从上到下按在原树中深度严格递增的路径，且中序遍历Splay得到的每个点的深度序列严格递增。 2、每个节点包含且仅包含于一个Splay中 3、边分为实边和虚边，实边包含在Splay中，而虚边总是由一棵Splay指向另一个节点（指向该Splay中中序遍历最靠前的点在原树中的父亲）。 LCT 操作LCT 支持以下几种操作： 核心操作1、void access(int x)：原树中将 $x$ 和根之间的路径变为实边，并且让 $x$ 成为所在的重链中的深度最大的结点 辅助操作Splay操作1、int rel(int x)2、void pushup(int x)3、void pushdown(int x)4、void rotate(int x)LCT操作1、int isRt(int x)：$x$是当前Splay的根吗2、void makeRt(int x)：在原树中换根3、int findRt(int x)：在原树中找$x$的根 实现操作1、void link(int x, int y)：在原树中连边 $(x,y)$2、void cut(int x, int y)：在原树中断边 $(x,y)$2、void split(int x, int y)：在原树中提取路径 $(x,y)$ 核心操作实现1、access： 原树中将 $x$ 和根之间的路径变为实边，并且让 $x$ 成为所在的重链中的深度最大的结点 其它所有的操作都是在此基础上完成的。因为性质$3$，我们不能总是保证两个点之间的路径是直接连通的（在一个Splay上）。$access$即定义为打通根节点到指定节点的实链，使得一条中序遍历以根开始、以指定点结束的Splay出现。 图见Link Cut Tree(动态树) - linjiayang2016的博客 - CSDN博客 void access(int x) { // 在原树中将 x 和根之间的路径变为实边，并且让 x 成为所在的重链中的深度最大的结点 for (int y = 0; x; y = x, x = fa[x]) splay(x), rc = y, pushup(x); } 辅助操作Splay操作 有些地方与普通 Splay 不同，详情看代码 void rotate(int x) { // 同 Splay pushdown(fa[x]), pushdown(x); int y = fa[x], z = fa[y], k = rel(x), w = ch[x][k ^ 1]; if (!isRt(y)) ch[z][rel(y)] = x; fa[x] = z; // y 是根则 (z, y) 为轻边，父不认子 (与普通 Splay 不同之处 1) ch[y][k] = w, fa[w] = y; ch[x][k ^ 1] = y, fa[y] = x; pushup(y), pushup(x); } void splay(int x) { // 同 Splay top = 0; stk[++top] = x; for (int pos = x; !isRt(pos); pos = fa[pos]) stk[++top] = fa[pos]; while (top) pushdown(stk[top--]); // 将 x 到根的路径上的点从上面到下面 pushdown (与普通 Splay 不同之处 2) //疑难点1：因为在普通Splay中(文艺平衡树)kth的时候pushdown了，所以要先pushdown while (!isRt(x)) { // (与普通 Splay 不同之处 3.1) int y = fa[x]; if (!isRt(y)) { // (与普通 Splay 不同之处 3.2) if (rel(x) == rel(y)) rotate(y); else rotate(x); } rotate(x); } //pushup(x); 好像不必要? } LCT操作 isRt: $x$是当前Splay的根吗 判断一下父亲是否没有指向该点即可。因为根一定和父亲连轻边，轻边父亲不认孩子，孩子认父亲 int isRt(int x) {return ch[fa[x]][0] != x &amp;&amp; ch[fa[x]][1] != x;} //是当前Splay的根吗 makeRt: 在原树中换根 先将$x$和根打通，然后再splay到根然后发现这个没有右孩子，我们可以考虑翻转左右孩子来解决(打标记) 图见Link Cut Tree(动态树) - linjiayang2016的博客 - CSDN博客 void makeRt(int x) { // 在原树中换根 access(x), splay(x); prorev(x); } findRt(int x): 在原树中找$x$的根 一般用来判连通性findRt(x)==findRt(y)，可以类比并查集先将$x$和根打通，然后再splay到根然后现在根和$x$在一个splay，并且根是splay中深度最小的，那么不断找左孩子即可。注意pushdown 假如LCT题目在维护连通性的情况中只可能出现合并而不会出现分离的话，可以用并查集减小常数 int findRt(int x) { // 在原树中找 x 的根 access(x), splay(x); while (pushdown(x), lc) x = lc; splay(x); // splay 保持平衡 return x; } 实现操作link: 在原树中连边 $(x,y)$ 要判断是否已经连通。先将$x$转成根，然后再找$y$的根是否和$x$相同(是否连通)，若连通则连边 void link(int x, int y) { // 在原树中连边 x-y makeRt(x); if (findRt(y) != x) fa[x] = y; } cut: 在原树中断边 $(x,y)$ 要判断是否已经不连通。先将$x$转成根，然后要判三个条件1、连通性2、$x,y$是否有父子关系3、看$y$是否有左儿子 void cut(int x, int y) { // 在原树中断边 x-y makeRt(x); if (findRt(y) == x &amp;&amp; fa[y] == x &amp;&amp; !ch[y][0]) { fa[y] = ch[x][1] = 0; pushup(x); } } 如果维护了$size$，还可以换一种判断 findRt(y) != x || sz[x] &gt; 2 解释一下，如果他们有直接连边的话，$access(y)$以后，为了满足性质$1$，该Splay只会剩下$x,y$两个点了。反过来说，如果有其它的点，$size$就大于$2$了 split: 在原树中提取路径 $(x,y)$ void split(int x, int y) { // 在原树中提取路径 x-y makeRt(x); access(y), splay(y); // splay 保持平衡 //疑难点2：根(x)与y形成一条重链，并且根据 access 性质，y 是最深的节点，该操作成立 } 模板题：【模板】Link Cut Tree （动态树）代码： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;map&gt; #include&lt;stack&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { #define lc ch[x][0] #define rc ch[x][1] const int MAXN = 300000 + 5; int ch[MAXN][2], fa[MAXN], val[MAXN], xorv[MAXN], rev[MAXN]; // ch: 节点左右子树，fa: 父亲节点，val: 节点值，xorv: 异或和标记， rev: 翻转标记 int n, m, top, stk[MAXN]; int isRt(int x) {return ch[fa[x]][0] != x &amp;&amp; ch[fa[x]][1] != x;} //是当前Splay的根吗 int rel(int x) {return ch[fa[x]][1] == x;} // 同 Splay void prorev(int x) {swap(lc, rc), rev[x] ^= 1;} // 处理翻转操作 (简化代码) void pushup(int x) {xorv[x] = xorv[lc] ^ xorv[rc] ^ val[x];} //上传标记 void pushdown(int x) { //下传标记 if (rev[x]) { if (lc) prorev(lc); if (rc) prorev(rc); rev[x] = 0; } } void rotate(int x) { // 同 Splay pushdown(fa[x]), pushdown(x); int y = fa[x], z = fa[y], k = rel(x), w = ch[x][k ^ 1]; if (!isRt(y)) ch[z][rel(y)] = x; fa[x] = z; // y 是根则 (z, y) 为轻边，父不认子 (与普通 Splay 不同之处 1) ch[y][k] = w, fa[w] = y; ch[x][k ^ 1] = y, fa[y] = x; pushup(y), pushup(x); } void splay(int x) { // 同 Splay top = 0; stk[++top] = x; for (int pos = x; !isRt(pos); pos = fa[pos]) stk[++top] = fa[pos]; while (top) pushdown(stk[top--]); // 将 x 到根的路径上的点从上面到下面 pushdown (与普通 Splay 不同之处 2) //疑难点1：因为下面 isRt 的调用，所以要先pushdown while (!isRt(x)) { // (与普通 Splay 不同之处 3.1) int y = fa[x]; if (!isRt(y)) { // (与普通 Splay 不同之处 3.2) if (rel(x) == rel(y)) rotate(y); else rotate(x); } rotate(x); } //pushup(x); 好像不必要? } void access(int x) { // 在原树中将 x 和根之间的路径变为实边，并且让 x 成为所在的重链中的深度最大的结点 for (int y = 0; x; y = x, x = fa[x]) splay(x), rc = y, pushup(x); } void makeRt(int x) { // 在原树中换根 access(x), splay(x); prorev(x); } int findRt(int x) { // 在原树中找 x 的根 access(x), splay(x); while (pushdown(x), lc) x = lc; splay(x); // splay 保持平衡 return x; } void split(int x, int y) { // 在原树中提取路径 x-y makeRt(x); access(y), splay(y); // splay 保持平衡 //疑难点2：根(x)与y形成一条重链，并且根据 access 性质，y 是最深的节点，该操作成立 } void link(int x, int y) { // 在原树中连边 x-y makeRt(x); if (findRt(y) != x) fa[x] = y; } void cut(int x, int y) { // 在原树中断边 x-y makeRt(x); if (findRt(y) == x &amp;&amp; fa[y] == x &amp;&amp; !ch[y][0]) { fa[y] = rc = 0; pushup(x); } } void clean() { ms(ch, 0), ms(fa, 0), ms(val, 0), ms(xorv, 0), ms(stk, 0), ms(rev, 0); } int solve() { clean(); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;val[i]); for (int t, x, y, i = 1; i &lt;= m; ++i) { scanf(&quot;%d%d%d&quot;, &amp;t, &amp;x, &amp;y); if (t == 0) split(x, y), printf(&quot;%d\n&quot;, xorv[y]); if (t == 1) link(x, y); if (t == 2) cut(x, y); if (t == 3) splay(x), val[x] = y; } return 0; } } int main() { flyinthesky::solve(); return 0; } 写时注意1、split和findRt要Splay保持平衡 应用1、动态维护最小生成树Bzoj 3669 参考资料 LCT总结——概念篇 - Flash_Hu - 博客园：大部分思路 Link Cut Tree(动态树) - linjiayang2016的博客 - CSDN博客：参考图片资源 Link-Cut-Tree - 作业部落 Cmd Markdown 编辑阅读器：LCT的Splay与普通Splay区别的写法 若本文侵犯了您的权益，请联系我删除，谢谢]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>LCT</tag>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 2730」「HNOI2012」矿场搭建 (边双联通分量+分类讨论)]]></title>
    <url>%2Fbzoj2730%2F</url>
    <content type="text"><![CDATA[Bzoj 2730题意：给一张无向图，让你加一些出口，使得任意点删除后图上任意点都能找到出口。 复习一波点双联通分量考虑求出割点和双联通分量，然后对于每个双联通分量，我们考虑若这个双联通分量有两个及以上割点，那么不需要建立出口若这个双联通分量有一个割点，那么如果这个割点删了这个图就找不到出口了，要加一个出口若这个双联通分量没有割点，即这个子图与其他子图不连通，要加两个出口 加出口即加在任意非割点的点上即可 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;map&gt; #include&lt;stack&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; int kse = 0; namespace flyinthesky { struct edge { int v, nxt; } ed[1005]; int m, n, dfn[505], low[505], sz, dcc_tot, cut[505]; int hd[505], en, ans2; unsigned LL ans; stack&lt;int &gt; s; vector&lt;int &gt; dcc[505]; void ins(int u, int v) {ed[++en] = (edge){v, hd[u]}, hd[u] = en;} void tarjan(int u, int fa) { dfn[u] = low[u] = ++sz, s.push(u); if (fa == 0 &amp;&amp; hd[u] &lt; 0) { s.pop(); return ; } int flag = 0; for (int i = hd[u]; i &gt;= 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (e.v == fa) continue ; if (!dfn[e.v]) { tarjan(e.v, u); low[u] = min(low[u], low[e.v]); if (low[e.v] &gt;= dfn[u]) { ++flag; if (fa != 0 || flag &gt; 1) cut[u] = 1; int whw; ++dcc_tot; do { whw = s.top(); s.pop(); dcc[dcc_tot].push_back(whw); } while (whw != e.v); dcc[dcc_tot].push_back(u); } } else low[u] = min(low[u], dfn[e.v]); } } void clean() { ans = 1ll, ans2 = 0, dcc_tot = 0; en = -1, ms(hd, -1), ms(cut, 0); sz = n = 0, ms(dfn, 0), ms(low, 0); for (int i = 0; i &lt;= 501; ++i) dcc[i].clear(); } int solve() { clean(); for (int x, y, i = 1; i &lt;= m; ++i) { scanf(&quot;%d%d&quot;, &amp;x, &amp;y); ins(x, y), ins(y, x); n = max(n, max(x, y)); } for (int i = 1; i &lt;= n; ++i) if (!dfn[i]) tarjan(i, 0); for (int x = 1; x &lt;= dcc_tot; ++x) { unsigned LL tmp = 0, gd = 0; for (int i = 0; i &lt; (int)dcc[x].size(); ++i) { int u = dcc[x][i]; if (!cut[u]) ++tmp; else ++gd; } if (gd == 0) { ans2 += 2; ans *= (tmp - 1) * tmp / 2; } else if (gd == 1) { ans *= tmp; ++ans2; } } printf(&quot;Case %d: %d %llu\n&quot;, ++kse, ans2, ans); return 0; } } int main() { while (scanf(&quot;%d&quot;, &amp;flyinthesky::m) == 1 &amp;&amp; flyinthesky::m) flyinthesky::solve(); return 0; }]]></content>
      <tags>
        <tag>双连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1911」「Apio2010」特别行动队 (最大化斜率优化DP)]]></title>
    <url>%2Fbzoj1911%2F</url>
    <content type="text"><![CDATA[BZOJ 1911题意：有$n$个数$x_i$，将其分成连续的组，每组的分为$a\sum x_i + b\sum x_i +c$，求最大的总分。设$dp(i)$为前$i$个分组的最大的总分。设$\operatorname{sum}(n)$为$\sum\limits_{i=1}^n x_i$则$$dp(i)=\max(dp(j)+a[\operatorname{sum}(i)-\operatorname{sum}(j)]^2 + b[\operatorname{sum}(i)-\operatorname{sum}(j)] + c)$$则决策点可以表示为点$(\operatorname{sum}(j), dp(j)+a \cdot \operatorname{sum}(j)^2 - b \cdot \operatorname{sum}(j))​$ 这里要维护最大值，所以与之前的斜率优化不同，维护一个上凸包即可。 注意有负数时不要用叉积，符号不能确定！ 知识点1、有负数时不要用叉积，符号不能确定 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;map&gt; #include&lt;string&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL MAXN = 1000000 + 5; LL n, x[MAXN], a, b, c, s[MAXN]; LL dp[MAXN], q[MAXN]; LL getx(LL j) {return s[j];} LL gety(LL j) {return dp[j] + a * s[j] * s[j] - b * s[j];} db slp(LL i, LL j) { return 1.0 * (gety(j) - gety(i)) / (getx(j) - getx(i)); } void clean() { ms(s, 0), ms(dp, 0); } int solve() { clean(); cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; c; for (LL i = 1; i &lt;= n; ++i) scanf(&quot;%lld&quot;, &amp;x[i]), s[i] = s[i - 1] + x[i]; LL l = 1, r = 1; q[l] = 0; for (LL i = 1; i &lt;= n; ++i) { /*while (l &lt; r &amp;&amp; (gety(q[l + 1]) - gety(q[l])) &gt;= 2 * a * s[i] * (getx(q[l + 1]) - getx(q[l]))) ++l; dp[i] = dp[q[l]] + a * (s[i] - s[q[l]]) * (s[i] - s[q[l]]) + b * (s[i] - s[q[l]]) + c; while (l &lt; r &amp;&amp; (gety(q[r]) - gety(q[r - 1])) * (getx(i) - getx(q[r])) &lt;= (getx(q[r]) - getx(q[r - 1])) * (gety(i) - getx(q[r]))) --r; q[++r] = i;*/ while (l &lt; r &amp;&amp; slp(q[l], q[l + 1]) &gt;= 2.0 * a * s[i]) ++l; dp[i] = dp[q[l]] + a * (s[i] - s[q[l]]) * (s[i] - s[q[l]]) + b * (s[i] - s[q[l]]) + c; while (l &lt; r &amp;&amp; slp(q[r - 1], q[r]) &lt;= slp(q[r], i)) --r; q[++r] = i; // 有负数不要用叉积，符号不能确定 } cout &lt;&lt; dp[n]; return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>Bzoj</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu 3765」总统选举 (线段树 + Splay, 摩尔投票法求区间大于一半数的众数)]]></title>
    <url>%2FLuogu3765%2F</url>
    <content type="text"><![CDATA[Luogu 3765题意：维护序列的区间大于一半数的众数，带修。 第一眼以为带修主席树，感觉肯定跑不过 前置知识：Luogu 2397 求序列大于一半数的众数 本题可以采用摩尔投票法求，即将不同数两两消除，最后一定剩下的是这个众数。这个方法必须存在大于一半数的众数 然后看这题，显然摩尔投票法是满足可加性的，那么线段树维护之。 但是如果不满足存在大于一半数的众数怎么办？ 我们可以维护一个数在某个区间出现次数，这个方法是经典套路，静态则用 vector 排序后二分，而动态则需要名次树Splay维护。具体方法为在名次树上类似静态方法二分即可。 然后每次查询，更改即可。 知识点：1、摩尔投票法2、vector 版平衡树 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;set&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 500000 + 5, INF = 2000000000; int n, m, vt[MAXN]; struct qwq { vector&lt;int &gt; a; void insert(int x) {a.insert(lower_bound(a.begin(), a.end(), x), x);} void del(int x) {a.erase(lower_bound(a.begin(), a.end(), x));} int rank(int x) {return lower_bound(a.begin(), a.end(), x) - a.begin() + 1;} int kth(int k) {return a[k - 1];} int pre(int x) {return a[lower_bound(a.begin(), a.end(), x) - a.begin() - 1];} int succ(int x) {return a[upper_bound(a.begin(), a.end(), x) - a.begin()];} }s[MAXN]; int chk(int l, int r, int i) { // 1 if (i == 0) return 0; return upper_bound(s[i].a.begin(), s[i].a.end(), r) - upper_bound(s[i].a.begin(), s[i].a.end(), l - 1); } #define lc (o &lt;&lt; 1) #define rc (o &lt;&lt; 1 | 1) #define M ((l + r) &gt;&gt; 1) #define lson lc, l, M #define rson rc, M + 1, r int cnt[MAXN * 4], num[MAXN * 4]; void pushup(int o) { // 1 if (num[lc] == num[rc]) num[o] = num[lc], cnt[o] = cnt[lc] + cnt[rc]; else { if (cnt[lc] &gt; cnt[rc]) cnt[o] = cnt[lc] - cnt[rc], num[o] = num[lc]; else cnt[o] = cnt[rc] - cnt[lc], num[o] = num[rc]; } } void build(int o, int l, int r) { // 1 cnt[o] = num[o] = 0; if (l == r) return ; else { build(lson), build(rson); pushup(o); } } int query(int o, int l, int r, int x, int y, int &amp;whw) { if (x &lt;= l &amp;&amp; r &lt;= y) { // 1 return whw = cnt[o], num[o]; } int ret = 0, cc = 0; if (x &lt;= M) { ret = query(lson, x, y, cc); } if (M &lt; y) { int tmp1, tmp2; tmp1 = query(rson, x, y, tmp2); if (tmp1 == ret) cc += tmp2; else { if (tmp2 &gt; cc) ret = tmp1, cc = tmp2 - cc; else cc = cc - tmp2; } } return whw = cc, ret; } void update(int o, int l, int r, int p, int v) { // 1 if (l == r) { cnt[o] = 1, num[o] = v; return ; } if (p &lt;= M) update(lson, p, v); else update(rson, p, v); pushup(o); } void clean() { } int solve() { clean(); cin &gt;&gt; n &gt;&gt; m; build(1, 1, n); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;vt[i]), update(1, 1, n, i, vt[i]), s[vt[i]].insert(i), s[i].insert(INF), s[i].insert(-INF); while (m--) { int l, r, si, k; scanf(&quot;%d%d%d%d&quot;, &amp;l ,&amp;r, &amp;si, &amp;k); int gg, ret = query(1, 1, n, l, r, gg); if (chk(l, r, ret) &lt;= (r - l + 1) / 2) printf(&quot;%d\n&quot;, ret = si); else printf(&quot;%d\n&quot;, ret); for (int x, i = 1; i &lt;= k; ++i) { scanf(&quot;%d&quot;, &amp;x); update(1, 1, n, x, ret); s[vt[x]].del(x), s[vt[x] = ret].insert(x); } } int gg, ret = query(1, 1, n, 1, n, gg); if (chk(1, n, ret) &lt;= (n - 1 + 1) / 2) printf(&quot;-1\n&quot;); else printf(&quot;%d\n&quot;, ret); return 0; } } int main() { flyinthesky::solve(); return 0; } /* 3 1000 1 2 3 2 3 0 0 5 400 1 2 3 4 5 1 2 1 1 3 5 5 1 2 2 4 2 4 0 0 5 400 1 5 1 5 5 2 4 0 0 */]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>Splay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu 3768」简单的数学题 (莫比乌斯反演 + Dirichlet卷积 + 杜教筛)]]></title>
    <url>%2FLuogu3768%2F</url>
    <content type="text"><![CDATA[3768 简单的数学题题意：给定$n, p$，求$$\sum_{i=1}^n \sum_{i=1}^n ij\gcd(i,j) \mod p$$枚举约数$$\sum_{d=1}^n d\sum_{i=1}^n \sum_{i=1}^n ij [\gcd(i,j)=d]$$将后面的提取因数$$\sum_{d=1}^n d^3 \sum_{i=1}^{\lfloor \frac nd \rfloor} \sum_{i=1}^{\lfloor \frac nd \rfloor} ij [\gcd(i,j)=1]$$将布尔式化成$\mu$$$\sum_{d=1}^n d^3 \sum_{i=1}^{\lfloor \frac nd \rfloor} \sum_{i=1}^{\lfloor \frac nd \rfloor} ij \sum_{k|i,k|j}\mu(k)$$先枚举$k$$$\sum_{d=1}^n d^3 \sum_{k=1}^{\lfloor \frac nd \rfloor} k^2 \mu(k) (\sum_{i=1}^{\lfloor \frac n{kd} \rfloor} i)^2$$设$T=kd​$$$\sum_{T=1}^n (\sum_{i=1}^{\lfloor \frac nT \rfloor} i)^2 \sum_{d|T}d^3 (\frac Td)^2 \mu(\frac Td) \\\sum_{T=1}^n (\sum_{i=1}^{\lfloor \frac nT \rfloor} i)^2 T^2\sum_{d|T}d \mu(\frac Td)$$后面是个卷积形式，根据$\mu * id = \varphi$$$\sum_{T=1}^n (\sum_{i=1}^{\lfloor \frac nT \rfloor} i)^2 T^2 \varphi(T)$$现在要求$T^2 \varphi(T)$的前缀和。不妨先设$g=id^2$ $$(f * g)(i)=\sum_{d|i} d^2 \varphi(d) \times id^2(\frac id) \\= \sum_{d|i} d^2 \varphi(d) \times (\frac id)^2 \\= \sum_{d|i} i^2\varphi(d) \\= i^2\sum_{d|i} \varphi(d) \\= i^3$$ 则 $$g(1)S(n)=\sum_{i=1}^n(f * g)(n) - \sum_{i=2}^n g(i)S(\lfloor \frac ni \rfloor) \ S(n)=\sum_{i=1}^n i^3 - \sum_{i=2}^n i^2 S(\lfloor \frac ni \rfloor)$$ 再由两个公式$$1^3+2^3+ \dots + n^3 = (1+2+ \dots + n)^2 \\1^2+2^2+ \dots + n^2 = \frac{n(n+1)(2n+1)}{6}$$即可完成求解 坑：1、$n$要运算时一定要先模，否则$10^{10} \times 10^{10}$马上爆炸2、$2n$也要模知识点：1、整除分块只有$\lfloor \frac nd \rfloor$部分相同，可以用来乘2、Dirichlet卷积运用3、LCM和那题没搞明白的东西4、预处理逆元免除$\log$ #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;map&gt; #include&lt;string&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL N = 8000000; LL vis[N + 5], pri[2000000 + 5], tot; LL phi[N + 5], nn, p, inv6, inv2; map&lt;LL, LL &gt; ansphi; LL ksm(LL a, LL b) { LL ret = 1, bs = a; while (b) { if (b &amp; 1) ret = (ret * bs) % p; bs = (bs * bs) % p; b &gt;&gt;= 1; } return ret; } LL get2(LL n) { return n % p * (n + 1ll) % p * (2 * n % p + 1ll) % p * inv6 % p; // n % p，2 * n % p } LL get3(LL n) { return n % p * (n + 1ll) % p * inv2 % p; } LL getphi(LL n) { if (n &lt;= N) return phi[n]; if (ansphi[n]) return ansphi[n]; LL ret = get3(n) * get3(n) % p; LL l = 2; while (l &lt;= n) { LL r = n / (n / l); ret = (ret - ((get2(r) - get2(l - 1)) % p + p) % p * getphi(n / l) % p) % p; ret = (ret + p) % p; l = r + 1; } return ansphi[n] = (ret + p) % p; } void init() { ms(vis, 0), ms(pri, 0), tot = 0, ms(phi, 0); phi[1] = 1; for (LL i = 2; i &lt;= N; ++i) { if (!vis[i]) pri[++tot] = i, phi[i] = i - 1ll; for (LL j = 1; j &lt;= tot &amp;&amp; 1ll * pri[j] * i &lt;= 1ll * N; ++j) { vis[pri[j] * i] = 1; if (i % pri[j] == 0) { phi[i * pri[j]] = phi[i] * pri[j] % p; break ; } else phi[i * pri[j]] = phi[i] * phi[pri[j]] % p; } } for (LL i = 2; i &lt;= N; ++i) phi[i] = (phi[i] % p * i % p * i % p + phi[i - 1]) % p; } void clean() { } int solve() { clean(); cin &gt;&gt; p &gt;&gt; nn; init(); inv6 = ksm(6, p - 2), inv2 = ksm(2, p - 2); // 预处理逆元少一个log! LL l = 1, ans = 0; while (l &lt;= nn) { LL r = nn / (nn / l); LL tmp2 = ((getphi(r) - getphi(l - 1)) % p + p) % p; LL tmp3 = get3(nn / l) % p * get3(nn / l) % p; ans = (ans + tmp2 % p * tmp3 % p) % p; l = r + 1; } cout &lt;&lt; ans; return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>杜教筛</tag>
        <tag>Dirichlet卷积</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Loj 6008」「网络流 24 题」餐巾计划 (最小费用最大流，资源调配)]]></title>
    <url>%2Floj6008%2F</url>
    <content type="text"><![CDATA[Loj 2632题意：见上。 orz 网络流24题之餐巾计划问题 - five20 - 博客园 做法($(c=容量, w=费用)$)：将每天拆点拆成$x_i,y_i$($x$为脏餐巾点，$y$为干净餐巾点)1、$S$到$x_i$：$(r_i, 0)$，补脏的 (用过的毛巾假设全丢掉，然后再从$S$补偿脏毛巾。以达到一个毛巾用$n$次有流量$n$)2、$S$到$y_i$：$(∞, P)$，买入毛巾3、$y_i$到$T$：$(r_i, 0)$，使用毛巾 (用过的毛巾假设全丢掉)4、$x_i$到$y_{i+M}$：$(∞, F)$，快洗5、$x_i$到$y_{i+N}$：$(∞, S)$，慢洗6、$x_i​$到$x_{i+1}​$：$(∞, 0)​$，存着脏毛巾 上述博客思路为：1、先拆点，然后考虑快洗慢洗、不洗(存着脏毛巾)2、发现错误(一个毛巾用两次只有流量$1$)，修改为舍弃流和补偿流 知识点：1、资源调配问题，舍弃流和补偿流的方法 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int INF = 2147483647ll; struct edge { int u, v, cap, w, nxt; } ed[500000 + 5]; int n, m, hd[10000 + 5], en, s, t, ans, V; int incf[10000 + 5], dis[10000 + 5], pre[10000 + 5], vis[10000 + 5]; int ID(int x, int y) {return (x - 1) * m + y;} void ins_c(int u, int v, int cap, int w) { ed[++en] = (edge){u, v, cap, w, hd[u]}, hd[u] = en; ed[++en] = (edge){v, u, 0, -w, hd[v]}, hd[v] = en; } queue&lt;int &gt; q; bool spfa() { for (int i = 0; i &lt;= V; ++i) incf[i] = INF, dis[i] = -INF, pre[i] = -1, vis[i] = 0; vis[s] = 1, dis[s] = 0, q.push(s); while (!q.empty()) { int u = q.front(); q.pop(); vis[u] = 0; for (int i = hd[u]; i &gt;= 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (e.cap &amp;&amp; dis[u] != -INF &amp;&amp; dis[e.v] &lt; dis[u] + e.w) { dis[e.v] = dis[u] + e.w; incf[e.v] = min(incf[u], e.cap); pre[e.v] = i; if (!vis[e.v]) vis[e.v] = 1, q.push(e.v); } } } return dis[t] != -INF; } void update() { int now = pre[t]; while (now != -1) { ed[now].cap -= incf[t], ed[now ^ 1].cap += incf[t]; now = pre[ed[now].u]; } ans += incf[t] * dis[t]; } void clean() { ans = 0, en = -1, ms(hd, -1); } int solve() { int a, b; clean(); scanf(&quot;%d%d%d%d&quot;, &amp;a, &amp;b, &amp;n, &amp;m); ++n, ++m; s = n * m + 1, t = V = n * m + 2; for (int i = 1; i &lt;= n; ++i) for (int x, j = 1; j &lt; m; ++j) { scanf(&quot;%d&quot;, &amp;x); ins_c(ID(i, j), ID(i, j) + 1, 1, x); ins_c(ID(i, j), ID(i, j) + 1, INF, 0); } for (int i = 1; i &lt;= m; ++i) for (int x, j = 1; j &lt; n; ++j) { scanf(&quot;%d&quot;, &amp;x); ins_c(ID(j, i), ID(j, i) + m, 1, x); ins_c(ID(j, i), ID(j, i) + m, INF, 0); } for (int k, x, y, i = 1; i &lt;= a; ++i) { scanf(&quot;%d%d%d&quot;, &amp;k, &amp;x, &amp;y); ++x, ++y; ins_c(s, ID(x, y), k, 0); } for (int k, x, y, i = 1; i &lt;= b; ++i) { scanf(&quot;%d%d%d&quot;, &amp;k, &amp;x, &amp;y); ++x, ++y; ins_c(ID(x, y), t, k, 0); } while (spfa()) update(); cout &lt;&lt; ans; return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Loj</category>
      </categories>
      <tags>
        <tag>Loj</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「poj 3709」K-Anonymous Sequence (斜率优化DP，延迟加入决策)]]></title>
    <url>%2Fpoj3709%2F</url>
    <content type="text"><![CDATA[poj 3709题意：给定一个数列 $a$， 分成若干段，每段至少有$k$个数， 将每段中的数减少至所有数都相同， 求最小的变化量 设$dp(i)$为前$i$个的最小变化量。则$$dp(i)=\min_{i-j \leq k}(dp(j)+\operatorname{sum}(i)-\operatorname{sum}(j)-i \cdot a_{j+1} +j \cdot a_{j+1})$$ 显然可以斜率优化。决策表示为$(a_{j+1}, dp(j)-sum(j)+j \cdot a_{j+1})$，即可算斜率。注意$i-j \leq k$的限制，我们可以考虑延迟加入决策(具体看代码)，预处理$[0,2k]$的答案。 知识点对于这种有限制的斜率优化可以考虑延迟加入决策 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; #include&lt;string&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; int T; namespace flyinthesky { const LL INF = 3000000000000ll; LL n, k, a[500000 + 5], sum[500000 + 5]; LL dp[500000 + 5], q[500000 + 5]; LL getx(LL j) {return a[j + 1];} LL gety(LL j) {return dp[j] - sum[j] + j * a[j + 1];} void clean() { ms(sum, 0); } int solve() { clean(); cin &gt;&gt; n &gt;&gt; k; for (LL i = 1; i &lt;= n; ++i) scanf(&quot;%lld&quot;, &amp;a[i]), sum[i] = sum[i - 1] + a[i]; sort(a + 1, a + 1 + n); ms(dp, 0); for (LL i = 1; i &lt; k; ++i) dp[i] = INF; for (LL i = k; i &lt;= 2 * k; ++i) dp[i] = sum[i] - i * a[1]; // 预处理 LL l = 1, r = 1; q[1] = k; for (LL i = 2 * k; i &lt;= n; ++i) { while (l &lt; r &amp;&amp; (gety(q[l + 1]) - gety(q[l])) &lt;= i * (getx(q[l + 1]) - getx(q[l]))) ++l; dp[i] = dp[q[l]] + sum[i] - sum[q[l]] - i * a[q[l] + 1] + q[l] * a[q[l] + 1]; while (l &lt; r &amp;&amp; (gety(q[r]) - gety(q[r - 1])) * (getx(i - k + 1) - getx(q[r])) &gt;= (gety(i - k + 1) - gety(q[r])) * (getx(q[r]) - getx(q[r - 1]))) --r; // 延迟加入决策 q[++r] = i - k + 1; // 延迟加入决策 } printf(&quot;%lld\n&quot;, dp[n]); return 0; } } int main() { scanf(&quot;%d&quot;, &amp;T); while (T--) flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>倍增</tag>
        <tag>斜率优化</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1106E (倒序DP + Set)]]></title>
    <url>%2FCodeforces1106E%2F</url>
    <content type="text"><![CDATA[Codeforces 1106E题意：有 $k$ 个区间 $[s_j, t_j]$ 表示一段时间，每个区间有 $t_j, w_j$ 表示若选择这个区间则 $t_j$ 后才能选其他的区间，选择区间的权为 $w_j$ 。现在有一个人从 $1$ 时刻开始选区间，他会选当前能选的最大权的区间，若存在多个，选 $d_j$ 大的区间。现在有 $m$ 次机会，每次可以使得这个人在某一秒不能选区间。求当这 $m$ 次机会使用得最优时，这个人最小能选择区间权和。 正序DP不太好做。考虑倒序DP，设$dp(i,j)$为$[i,n]$用了$j$次机会的最小权和。则$$dp(i,j)=\min(dp(i+1,j-1),dp(i+1,j),dp(g, j))$$其中$g=\max\limits_{i \in {[s_j, t_j], j\in[1,k]}}(d_j)$ 这个$g$可以用set维护。具体就是将区间端点存起来，然后枚举时间线时看是否超出了，超出即删掉，如果有新的加入，就加入。 知识点：1、倒序DP方法可以使正序DP时多个转移变成一个转移 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; #include&lt;string&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { LL n, m, k; vector&lt;pair&lt;LL, LL &gt; &gt; st[100000 + 5], ed[100000 + 5]; LL dp[100000 + 5][200 + 5]; multiset&lt;pair&lt;LL, LL &gt; &gt; S; void clean() { ms(dp, 0); } int solve() { clean(); cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (LL s, t, d, w, i = 1; i &lt;= k; ++i) { scanf(&quot;%lld%lld%lld%lld&quot;, &amp;s, &amp;t, &amp;d, &amp;w); st[t].push_back(make_pair(-w, -d)); ed[s].push_back(make_pair(-w, -d)); } for (LL i = n; i &gt;= 1; --i) { for (LL o = 0; o &lt; (LL)st[i].size(); ++o) S.insert(st[i][o]); pair&lt;LL, LL &gt; whw = make_pair(0, 0); if (!S.empty()) whw = *S.begin(); for (LL j = 0; j &lt;= m; ++j) { LL hh = i + 1; if (whw.first) hh = -whw.second + 1; dp[i][j] = dp[hh][j] + (-whw.first); if (j) dp[i][j] = min(dp[i + 1][j - 1], dp[i][j]); } for (LL o = 0; o &lt; (LL)ed[i].size(); ++o) S.erase(S.lower_bound(ed[i][o])); } cout &lt;&lt; dp[1][m]; return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>Codeforces</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 3930」「CQOI2015」选数(莫比乌斯反演 + GCD性质 / 杜教筛)]]></title>
    <url>%2Fbzoj3930%2F</url>
    <content type="text"><![CDATA[BZOJ 3930题意：给定$n,K,H,L$，求 这个形式和在$[1,n],[1,m]$中的$gcd$类似，我们从$N=2$开始考虑。显然$$f(k)=\sum_{d=1}^{\lfloor \frac nk \rfloor} \mu(d) \left \lfloor \frac n{kd} \right \rfloor^2$$扩展到高维也类似，所以可以得到$$f(k)= \sum_{d=1}^{\lfloor \frac Hk \rfloor} \mu(d) \left (\left \lfloor \frac H{kd} \right \rfloor - \left \lfloor \frac {L - 1}{kd} \right \rfloor \right )^n$$ 然而$\lfloor \frac Hk \rfloor$是$O(H)$级的，不能满足。 引理： 当所有数不全部相同时，$\gcd\left ( i_1, i_2, \dots, i_N \right ) \leq \max\left ( i_1, i_2, \dots, i_N \right ) - \min\left ( i_1, i_2, \dots, i_N \right )$ 证明：设$d = \gcd\left ( i_1, i_2, \dots, i_N \right ), a = \min\left ( i_1, i_2, \dots, i_N \right ), b = \max\left ( i_1, i_2, \dots, i_N \right )$显然$a = k_1d (k_1 \in \mathbb{Z}^+), b = k_2d (k_2 \in \mathbb{Z}^+, k_2 &gt; k_1)$， 所以$b - a \geq d$，证毕。 所以$[H, L]$中的一个不全部相同的序列的$\gcd$不会超过$H - L$个，只用处理不全部相同的序列，所以可以得到 $$f(k)= \sum_{d=1}^{\lfloor \frac Hk \rfloor - \lfloor \frac {L-1}k \rfloor} \mu(d) \left( \left (\left \lfloor \frac H{kd} \right \rfloor - \left \lfloor \frac {L - 1}{kd} \right \rfloor \right )^n - \left (\left \lfloor \frac H{kd} \right \rfloor - \left \lfloor \frac {L - 1}{kd} \right \rfloor \right )\right)+[L \leq k \leq H]$$ 注意需要加上$[L \leq k \leq H]$，因为这样就可以选$n$个$k$。 本题也可以直接杜教筛筛出$\mu(d)$的前缀和，但是我并不会……等学了杜教筛再来填坑吧。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; #include&lt;string&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL MO = 1000000007ll, MAXN = 100000 + 5; LL n, k, L, H; LL vis[MAXN], mu[MAXN], pri[MAXN], tot; LL ksm(LL a, LL b) { LL bs = a, ans = 1; while (b) { if (b &amp; 1) ans = (ans * bs) % MO; bs = (bs * bs) % MO; b &gt;&gt;= 1; } return ans; } void clean() { ms(vis, 0), ms(mu, 0), ms(pri, 0), tot = 0; } int solve() { clean(); cin &gt;&gt; n &gt;&gt; k &gt;&gt; L &gt;&gt; H; mu[1] = 1; for (LL i = 2; i &lt;= 100000; ++i) { if (!vis[i]) pri[++tot] = i, mu[i] = -1; for (LL j = 1; j &lt;= tot &amp;&amp; pri[j] * i &lt;= 100000; ++j) { vis[pri[j] * i] = 1; if (i % pri[j] == 0) { mu[pri[j] * i] = 0; break ; } else mu[pri[j] * i] = mu[i] * mu[pri[j]]; } } for (LL i = 2; i &lt;= 100000; ++i) mu[i] += mu[i - 1]; LL ans = 0; if (L &lt;= k &amp;&amp; k &lt;= H) ++ans; LL l = 1, len = H - L; H /= k, L = (L - 1) / k; while (l &lt;= len &amp;&amp; l &lt;= H) { LL r; if (L / l == 0) r = H / (H / l); else r = min(H / (H / l), L / (L / l)); LL tmp = ( ksm( (H / l - L / l + MO) % MO, n ) - (H / l - L / l + MO) % MO + MO ) % MO * ( ( mu[r] - mu[l - 1] + MO ) % MO ) % MO; ans = (ans + tmp) % MO; l = r + 1; } printf(&quot;%lld\n&quot;, ans); return 0; } } int main() { flyinthesky::solve(); return 0; } /* 2 3 2 4 3 2 2 4 */]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>GCD</tag>
        <tag>莫比乌斯反演</tag>
        <tag>杜教筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 2064」分裂 (集合DP)]]></title>
    <url>%2Fbzoj2064%2F</url>
    <content type="text"><![CDATA[BZOJ 2060题意：一个初始集合($n$个元素)和一个目标集合($m$个元素)($1 \leq n,m \leq 10$)，两个操作 操作$1$将集合里的两个数合成一个数 操作$2$将集合的一个数分成两个数 问对初始集合最少进行几次操作可以到达目标集合 显然最多的次数就是将初始集合全部合成一个数然后再分成目标集合，也就是次数上界为$n+m-2$把初始集合和目标集合分成尽量多的子集让这些子集都能对应(子集元素和相等)，如果能分成$x$个子集，那么次数就是$n+m-2x$ 考虑设$dp(S_1,S_2)$为把$S_1$和$S_2$最多能分成几个能相对应的子集(子集元素和相等)。则$$dp(S_1,S_2)=\max(dp(S_1 - k,S_2), dp(S_1,S_2 - k))$$若$\operatorname{sum}(S_1)=\operatorname{sum}(S_1)$，则$dp(S_1,S_2)+=1$ 因为不相同时不能用上所有的，相同时加减掉一个元素一定少一个集合 知识点1、集合DP思想2、$\operatorname{lowbit}$来快速枚举子串，用于合并答案的递推非常好用(看代码) #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; #include&lt;string&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { int n, m; int sum1[1030], sum2[1030]; int dp[1030][1030]; int lowbit(int x) {return x &amp; (-x);} void clean() { ms(sum1, 0), ms(sum2, 0), ms(dp, 0); } int solve() { clean(); scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; ++i) scanf(&quot;%d&quot;, &amp;sum1[1 &lt;&lt; i]); scanf(&quot;%d&quot;, &amp;m); for (int i = 0; i &lt; m; ++i) scanf(&quot;%d&quot;, &amp;sum2[1 &lt;&lt; i]); for (int i = 1; i &lt; (1 &lt;&lt; n); ++i) sum1[i] = sum1[lowbit(i)] + sum1[i ^ lowbit(i)]; for (int i = 1; i &lt; (1 &lt;&lt; m); ++i) sum2[i] = sum2[lowbit(i)] + sum2[i ^ lowbit(i)]; // lowbit 求集合和 for (int i = 1; i &lt; (1 &lt;&lt; n); ++i) { for (int j = 1; j &lt; (1 &lt;&lt; m); ++j) { for (int k = 0; k &lt; max(n, m); ++k) { if ((1 &lt;&lt; k) &amp; i) dp[i][j] = max(dp[i][j], dp[i ^ (1 &lt;&lt; k)][j]); if ((1 &lt;&lt; k) &amp; j) dp[i][j] = max(dp[i][j], dp[i][j ^ (1 &lt;&lt; k)]); } if (sum1[i] == sum2[j]) ++dp[i][j]; } } printf(&quot;%d\n&quot;, n + m - 2 * dp[(1 &lt;&lt; n) - 1][(1 &lt;&lt; m) - 1]); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 311B (二维斜率优化DP)]]></title>
    <url>%2FCodeforces311B%2F</url>
    <content type="text"><![CDATA[Codeforces 311B题意：有$m$只猫，放在一些位置$[1,n]$，每个位置之间的距离$d_i$，每个猫出现的时间$t_i$，假设派出$P$个人，可以自由安排其出发时间，沿途将已经出现的猫取掉，猫等待的时间是被取的时间减去出现的时间。现在有$P$个人，问总时间$T$最小是多少。 考虑设$a_i= t_i - \sum_\limits{j=1}^{h_i} d_i$，那么这个时间即为人什么时候出发，能取到猫$i$。那么如果人出发时间为$g$，则该猫的等待时间为$a_i - g$(能取到的话)。那么这样题目清楚了很多，如果$P=1$，那么答案就是最大值减去其他所有值的和。 考虑$p \leq 2$的情况：我们可以发现这些猫现在的$a_i$和位置没有关系了，可以考虑将$a_i$按从小到大排序，然后发现只用用$P$个序列覆盖$a_i$即可。这样还是麻烦，注意观察，序列一定是子串。因为不连续的一定不优，假设有$[1,3],[4,5],[6,8]$，则如果$[1,3], [6,8]$一个人，那么一定没有$[4, 5], [6,8]$一个人优。 所以可以开始DP：设$dp(i,j)$为分了$i$段，前$j$只猫的最小等待值，则$$dp(i,j)=\min_{1 \leq k \leq j} (dp(i-1,k)+a_j \cdot (j-k) - (\operatorname{sum}(j) - \operatorname{sum}(k)))$$直接枚举会炸。发现这里有$j,k$的乘积项，考虑斜率优化。转化，得$$dp(i-1,k)+\operatorname{sum}(k)=dp(i,j)-a_j \cdot j + a_j \cdot k +\operatorname{sum}(j)$$那么决策可以写作点$(k, dp(i-1,k)+\operatorname{sum}(k))$用这个算下斜率，即可斜率优化，注意开数组简化$dp(i-1,k)+\operatorname{sum}(k)$并且一定要斜率大减小，避免负数对叉积的影响 知识点1、斜率大减小，避免负数对叉积的影响2、适当开数组简化一些东西 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; #include&lt;string&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL MAXN = 100000 + 5; LL n, m, p, d[MAXN], h[MAXN], t[MAXN]; LL a[MAXN], sum[MAXN], dp[105][MAXN]; LL q[MAXN], g[MAXN]; void clean() { ms(dp, 0), ms(sum, 0); } int solve() { clean(); scanf(&quot;%lld%lld%lld&quot;, &amp;n, &amp;m, &amp;p); for (LL i = 2; i &lt;= n; ++i) scanf(&quot;%lld&quot;, &amp;d[i]), d[i] += d[i - 1]; for (LL i = 1; i &lt;= m; ++i) scanf(&quot;%lld%lld&quot;, &amp;h[i], &amp;t[i]); for (LL i = 1; i &lt;= m; ++i) a[i] = t[i] - d[h[i]]; sort(a + 1, a + 1 + m); for (LL i = 1; i &lt;= m; ++i) sum[i] = sum[i - 1] + a[i]; ms(dp, 0x3f); dp[0][0] = 0; for (LL i = 1; i &lt;= p; ++i) { for (LL j = 1; j &lt;= m; ++j) g[j] = dp[i - 1][j] + sum[j]; // 简化 LL l = 1, r = 1; q[1] = 0; for (LL j = 1; j &lt;= m; ++j) { while (l &lt; r &amp;&amp; (g[q[l + 1]] - g[q[l]]) &lt;= a[j] * (q[l + 1] - q[l])) ++l; // 斜率大减小，避免负数对叉积的影响 dp[i][j] = min(dp[i - 1][j], g[q[l]] + a[j] * (j - q[l]) - sum[j]); if (g[j] &gt;= 0x3f3f3f3f3f3f3f3fll) continue ; // dp[i - 1][j] 为非法状态 while (l &lt; r &amp;&amp; (g[q[r]] - g[q[r - 1]]) * (j - q[r]) &gt;= (g[j] - g[q[r]]) * (q[r] - q[r - 1])) --r; // 斜率大减小，避免负数对叉积的影响 q[++r] = j; } } printf(&quot;%lld\n&quot;, dp[p][m]); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 3529」「Sdoi2014」数表 (莫比乌斯反演+离线+树状数组)]]></title>
    <url>%2Fbzoj3529%2F</url>
    <content type="text"><![CDATA[BZOJ 3529题意：给定多组$n,m,a$，设$d_1(n)$为$n$约数和，求$$\sum_{i=1}^n \sum_{j=1}^m d_1(\gcd(i, j))$$并且满足$d_1(\gcd(i, j)) \leq a$ 不考虑$a$的限制，枚举约数$$\sum_{d=1}^n \sum_{i=1}^n \sum_{j=1}^m d_1(d)[gcd(i,j)=d]$$发现$d_1(d)$与$i,j$无关，移到前面$$\sum_{d=1}^n d_1(d) \sum_{i=1}^n \sum_{j=1}^m [gcd(i,j)=d]$$将后面用反演套路化简，得$$\sum_{d=1}^n d_1(d) \sum_{k=1}^{\lfloor \frac nd \rfloor} \mu(k) \lfloor \frac n{kd} \rfloor \lfloor \frac m{kd} \rfloor$$设$T=kd$，则$$\sum_{T=1}^n \lfloor \frac nT \rfloor \lfloor \frac mT \rfloor \sum_{d|T}d_1(d) \mu(\frac Td)$$如果没有$a$的限制，则线性筛后面的函数即可。考虑$a$的限制。只有$d_1(x) \leq a$的才会有贡献。所以将$d_1(x)$从小到大排序，将询问离线后按$a$从小到大排序每次按照$a$的单增补齐到$a$，补齐即枚举$x$的倍数进行增加。维护一个单调修改区间查值的数据结构，用树状数组维护之。时间复杂度：$O(n\log ^2 n + q \sqrt n \log n)$知识点：1、枚举因数非常常用 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 100000 + 5; struct data { int n, m, a, id; bool operator &lt; (const data &amp;rhs) const {return a &lt; rhs.a;} }qry[20000 + 5]; int mu[MAXN], pri[MAXN], vis[MAXN], tot; int e[MAXN], ans[MAXN]; pair&lt;int, int &gt; d1[MAXN]; int Q; int a[MAXN]; int min(int x, int y) {return x &lt; y ? x : y;} int lowbit(int x) {return x &amp; (-x);} int query(int x) { int ret = 0; for (int i = x; i; i -= lowbit(i)) ret += a[i]; return ret; } void add(int x, int v) { for (int i = x; i &lt;= 100000; i += lowbit(i)) a[i] += v; } int cal(int n, int m) { int l = 1, ret = 0; while (l &lt;= n) { int r = min(n / (n / l), m / (m / l)); ret = ret + (n / l) * (m / l) * (query(r) - query(l - 1)); l = r + 1; } /*for (LL d = 1; d &lt;= n; ++d) { ret = (ret + (n / d) * (m / d) % MO * (query(d) - query(d - 1) + MO) % MO) % MO; }*/ return ret; } void init() { ms(mu, 0), ms(pri, 0), ms(vis, 0), ms(e, 0), tot = 0; mu[1] = 1, d1[1] = make_pair(1, 1), e[1] = 1; for (int i = 2; i &lt;= 100000; ++i) { if (!vis[i]) pri[++tot] = i, d1[i] = make_pair(i + 1, i), e[i] = i + 1, mu[i] = -1; for (int j = 1; j &lt;= tot &amp;&amp; (LL)i * pri[j] &lt;= 100000ll; ++j) { vis[i * pri[j]] = 1; if (i % pri[j] == 0) { mu[i * pri[j]] = 0; d1[i * pri[j]] = make_pair(d1[i].first / e[i] * (e[i] * pri[j] + 1), i * pri[j]); e[i * pri[j]] = e[i] * pri[j] + 1; break ; } else { mu[i * pri[j]] = mu[i] * mu[pri[j]]; d1[i * pri[j]] = make_pair(d1[i].first * d1[pri[j]].first, i * pri[j]); e[i * pri[j]] = pri[j] + 1; } } } } void clean() { ms(a, 0); } int solve() { clean(); scanf(&quot;%d&quot;, &amp;Q); for (int i = 1; i &lt;= Q; ++i) { scanf(&quot;%d%d%d&quot;, &amp;qry[i].n, &amp;qry[i].m, &amp;qry[i].a); if (qry[i].n &gt; qry[i].m) swap(qry[i].n, qry[i].m); qry[i].id = i; } sort(qry + 1, qry + 1 + Q); sort(d1 + 1, d1 + 1 + 100000); int now = 1; for (int i = 1; i &lt;= Q; ++i) { while (d1[now].first &lt;= qry[i].a) { for (int j = d1[now].second; j &lt;= 100000; j += d1[now].second) add(j, (d1[now].first * mu[j / d1[now].second])); ++now; } ans[qry[i].id] = cal(qry[i].n, qry[i].m); } for (int i = 1; i &lt;= Q; ++i) printf(&quot;%d\n&quot;, ans[i] &amp; (~(1 &lt;&lt; 31))); return 0; } } int main() { flyinthesky::init(); flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>离线</tag>
        <tag>树状数组</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「poj 2374」Fence Obstacle Course (线段树+DP)]]></title>
    <url>%2Fpoj2374%2F</url>
    <content type="text"><![CDATA[poj 2374题意：给你$n$个围栏，对于每个围栏你必须走到其边上才可以往下跳，现在问你从初始最高位置的$n$个围栏，到原点，水平走过的路程最少是多少？ 设$dp(i,0/1)$为前$i$个围栏在左/右的最短距离，则$$dp(i, 0)=\min(dp(a, 0) + |x_i - x_a|, dp(a, 1) + |x_i - y_a|) \\dp(i, 1)=\min(dp(b, 0) + |y_i - x_b|, dp(b, 1) + |y_i - y_b|)$$ 其中$a,b$是这个围栏端点掉下去能掉到的围栏，这个可以用线段树染色维护。知识点1、线段树优化 DP 不一定是要维护最优值 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL MAXN = 200000 + 5, INF = 4223372036854775808ll, BS = 100000; LL n, s, x[MAXN], y[MAXN]; LL dp[MAXN][2]; LL abss(LL x) {return x &gt; 0 ? x : -x;} #define M ((l + r) &gt;&gt; 1) #define lc (o &lt;&lt; 1) #define rc (o &lt;&lt; 1 | 1) LL col[MAXN * 4]; void pushdown(LL o, LL len) { if (len == 1) return ; if (col[o]) { col[lc] = col[rc] = col[o]; col[o] = 0; } } void build(LL o, LL l, LL r) { col[o] = 0; if (l == r) return ; else { build(lc, l, M), build(rc, M + 1, r); } } void update(LL o, LL l, LL r, LL x, LL y, LL v) { pushdown(o, r - l + 1); if (x &lt;= l &amp;&amp; r &lt;= y) { col[o] = v; return ; } if (x &lt;= M) update(lc, l, M, x, y, v); if (M &lt; y) update(rc, M + 1, r, x, y, v); } LL query(LL o, LL l, LL r, LL p) { pushdown(o, r - l + 1); if (l == r) return col[o]; if (p &lt;= M) return query(lc, l, M, p); return query(rc, M + 1, r, p); } void clean() { dp[1][0] = dp[1][1] = 0; for (LL i = 2; i &lt;= n; ++i) dp[i][0] = dp[i][1] = INF; } int solve() { clean(); scanf(&quot;%lld%lld&quot;, &amp;n, &amp;s); s += BS; build(1, 0, 200000); x[0] = y[0] = BS; for (LL i = 1; i &lt;= n; ++i) { scanf(&quot;%lld%lld&quot;, &amp;x[i], &amp;y[i]); x[i] += BS, y[i] += BS; LL a = query(1, 0, 200000, x[i]); LL b = query(1, 0, 200000, y[i]); dp[i][0] = min(dp[a][0] + abss(x[i] - x[a]), dp[a][1] + abss(x[i] - y[a])); dp[i][1] = min(dp[b][0] + abss(y[i] - x[b]), dp[b][1] + abss(y[i] - y[b])); update(1, 0, 200000, x[i], y[i], i); } printf(&quot;%lld\n&quot;, min(dp[n][0] + abss(s - x[n]), dp[n][1] + abss(s - y[n]))); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>线段树</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 2005」「Noi2010」能量采集 (莫比乌斯反演)]]></title>
    <url>%2Fbzoj2005%2F</url>
    <content type="text"><![CDATA[BZOJ 2005题意：给定$n,m$，求$$2 \times \sum_{i=1}^n\sum_{j=1}^m (\gcd(i,j) -1)$$ 按照套路反演以后得到 $$\sum_{d=1}^n d \sum_{i=1}^{\lfloor \frac nd \rfloor} \mu(i) \lfloor \frac n{di} \rfloor \lfloor \frac m{di}\rfloor$$ 然后我们设$T=di​$，则 $$\sum_{T=1}^n \lfloor \frac nT \rfloor \lfloor \frac mT \rfloor \sum_{d|T} \mu(d) \lfloor \frac Tk \rfloor$$ 设$h(T)=\sum_{d|T} \mu(d) \lfloor \frac Tk \rfloor$，则可以线性筛。 也可以发现这就是欧拉函数，直接筛欧拉函数即可。 答案为$$2 \times \sum_{i=1}^n\sum_{j=1}^m \gcd(i,j) - nm$$ #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL MAXN = 100000 + 5; LL n, m; LL pri[MAXN], vis[MAXN], tot, h[MAXN]; void clean() { ms(vis, 0), tot = 0; } int solve() { clean(); scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m); if (n &gt; m) swap(n, m); h[1] = 1; for (LL i = 2; i &lt;= m; ++i) { if (!vis[i]) pri[++tot] = i, h[i] = i - 1; for (LL j = 1; j &lt;= tot &amp;&amp; i * pri[j] &lt;= m; ++j) { vis[pri[j] * i] = 1; if (i % pri[j] == 0) { h[i * pri[j]] = h[i] * pri[j]; break ; } else h[i * pri[j]] = h[i] * h[pri[j]]; } } for (LL i = 1; i &lt;= m; ++i) h[i] += h[i - 1]; LL ans = 0, l = 1; while (l &lt;= n) { LL r = min(n / (n / l), m / (m / l)); ans += (n / l) * (m / l) * (h[r] - h[l - 1]); l = r + 1; } printf(&quot;%lld\n&quot;, 2 * ans - n * m); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「bzoj1787 / 1832」「Ahoi2008」Meet 紧急集合 (LCA倍增)]]></title>
    <url>%2Fbzoj1787%261832%2F</url>
    <content type="text"><![CDATA[BZOJ 1787BZOJ 1832题意：给一棵无权无根树，每次询问三元组$(x,y,z)$，求树上到$x,y,z$的距离最短的那个点，输出距离。很容易想到就是三对$LCA$取最小值。这里主要是想要讲的是树上三个点的三对$LCA$必有两个相同然后其实这题答案就是那个不一样的那个$LCA$。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 500000 + 1, LOGS = 20; vector&lt;int &gt; G[MAXN]; int n, m, dep[MAXN], pre[MAXN][LOGS + 1]; void dfs(int u, int fa) { dep[u] = dep[fa] + 1, pre[u][0] = fa; for (int i = 1; i &lt;= LOGS; ++i) pre[u][i] = pre[pre[u][i - 1]][i - 1]; for (int i = 0; i &lt; (int)G[u].size(); ++i) { int v = G[u][i]; if (v != fa) dfs(v, u); } } int LCA(int a, int b) { if (dep[a] &lt; dep[b]) swap(a, b); for (int i = LOGS; i &gt;= 0; --i) if (dep[pre[a][i]] &gt;= dep[b]) a = pre[a][i]; if (a == b) return a; for (int i = LOGS; i &gt;= 0; --i) if (pre[a][i] != pre[b][i]) a = pre[a][i], b = pre[b][i]; return pre[a][0]; } int dist(int u, int v) { return (dep[u] - 1) + (dep[v] - 1) - 2 * (dep[LCA(u, v)] - 1); } int getans(int x, int y, int z, int gl) { return dist(x, gl) + dist(y, gl) + dist(z, gl); } void clean() { ms(dep, 0), ms(pre, 0); } int solve() { clean(); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int x, y, i = 1; i &lt; n; ++i) { scanf(&quot;%d%d&quot;, &amp;x, &amp;y); G[x].push_back(y), G[y].push_back(x); } dfs(1, 0); while (m--) { int x, y, z; scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z); int mind = 1000000000, pos = 0; int lca = LCA(x, y); int tmp = getans(x, y, z, lca); if (tmp &lt; mind) mind = tmp, pos = lca; lca = LCA(y, z); tmp = getans(x, y, z, lca); if (tmp &lt; mind) mind = tmp, pos = lca; lca = LCA(x, z); tmp = getans(x, y, z, lca); if (tmp &lt; mind) mind = tmp, pos = lca; lca = LCA(LCA(x, y), z); tmp = getans(x, y, z, lca); if (tmp &lt; mind) mind = tmp, pos = lca; printf(&quot;%d %d\n&quot;, pos, mind); } return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1233」「HNOI2001」产品加工 (单调队列优化DP+贪心)]]></title>
    <url>%2Fbzoj1233%2F</url>
    <content type="text"><![CDATA[BZOJ 1233题意：给出$n$个数，将这$n$个数按顺序分组，并且每一组都不能比前面一组和大。求最大能分几组。引理： 在多种可行的堆叠方案中，至少有一种能使层数最高的方案同时使得底边最短。即底边最短的，层数一定最高。 证明略去。可以感性认为底边越短，层数就能堆得越高。 所以可以设$dp(i)$为$[i,n]$的最小底边长度，$g(i)$为其层数，$\operatorname{sum}$为$n$个数前缀和。则$$dp(i)=\min_{i &lt; j \leq n, dp(j)\leq \operatorname{sum}(j - 1) - \operatorname{sum}(i - 1)}(\operatorname{sum}(j - 1) - \operatorname{sum}(i - 1))$$ 最小的$j$更优，因为$\operatorname{sum}$的单调性。将条件$dp(j)\leq \operatorname{sum}(j - 1) - \operatorname{sum}(i - 1)$转化为$\operatorname{sum}(j - 1) - dp(j)\geq \operatorname{sum}(i - 1)$ 则如果存在$k &lt; j$，且$$\operatorname{sum}(k - 1) - dp(k) &gt; \operatorname{sum}(j - 1) - dp(j)$$则$j$为无用决策。单调队列维护。单调队列左端点维护最小的$\operatorname{sum}(j - 1) - dp(j)\geq \operatorname{sum}(i - 1)$右端点维护$\operatorname{sum}(j - 1) - dp(j)$递减 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { LL n, w[100000 + 5], sum[100000 + 5]; LL f[100000 + 5], g[100000 + 5], q[100000 + 5]; void clean() { ms(sum, 0), ms(f, 0), ms(g, 0); } int solve() { clean(); scanf(&quot;%lld&quot;, &amp;n); for (LL i = 1; i &lt;= n; ++i) scanf(&quot;%lld&quot;, &amp;w[i]), sum[i] = sum[i - 1] + w[i]; LL l = 1, r = 1; q[1] = n + 1; for (LL i = n; i; --i) { while (l &lt; r &amp;&amp; sum[q[l + 1] - 1] - f[q[l + 1]] &gt;= sum[i - 1]) ++l; f[i] = sum[q[l] - 1] - sum[i - 1]; g[i] = g[q[l]] + 1; while (l &lt;= r &amp;&amp; sum[i - 1] - f[i] &gt;= sum[q[r] - 1] - f[q[r]]) --r; q[++r] = i; } printf(&quot;%lld\n&quot;, g[1]); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>DP</tag>
        <tag>Bzoj</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 3994」「SDOI2015」约数个数和 (莫比乌斯反演)]]></title>
    <url>%2Fbzoj3994%2F</url>
    <content type="text"><![CDATA[BZOJ 3994题意：设$d(x)$为$x$的约数个数，给定$n,m$, 求$$\sum_{i=1}^n \sum_{j=1}^m d(ij)$$ 首先知道结论$$d(ij)=\sum_{a|i} \sum_{b|j} [\gcd(a,b)=1]$$具体可以通过展开唯一分解式子，根据 $gcd$ 性质，然后得出两个式子等价。然后原答案可以化为$$\sum_{i=1}^n \sum_{j=1}^m \sum_{a|i} \sum_{b|j} [\gcd(a, b)=1]$$将$a,b$放到前面，并且改成$i,j$$$\sum_{i=1}^n \sum_{j=1}^m \lfloor \frac ni \rfloor \lfloor \frac mj \rfloor [\gcd(i, j)=1]$$设$$f(k)=\sum_{i=1}^n \sum_{j=1}^m \lfloor \frac ni \rfloor \lfloor \frac mj \rfloor [\gcd(i, j)=k] \\g(k) = \sum_{i=1}^{\lfloor \frac nk \rfloor}f(ki) \\$$则$$g(k) =\sum_{i=1}^n \sum_{j=1}^m \lfloor \frac ni \rfloor \lfloor \frac mj \rfloor [k|\gcd(i, j)]$$将$k$提出来$$g(k) =\sum_{i=1}^{\lfloor \frac nk \rfloor} \sum_{j=1}^{\lfloor \frac mk \rfloor} \lfloor \frac n{ik} \rfloor \lfloor \frac m{jk} \rfloor$$由反演，得$$f(1)=\sum_{d=1}^n \mu(d) \sum_{i=1}^{\lfloor \frac nd \rfloor} \sum_{j=1}^{\lfloor \frac md \rfloor} \lfloor \frac n{di} \rfloor \lfloor \frac m{dj} \rfloor$$设$g(n)=\sum_\limits{i=1}^{n} \lfloor \frac ni \rfloor$，那么$$f(1)=\sum_{d=1}^n \mu(d) g(\lfloor \frac nd \rfloor) g(\lfloor \frac md \rfloor)$$预处理$g(n), \mu(n)$的前缀和，即可整除分块得到$O(T\sqrt n)$的复杂度 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; LL T; namespace flyinthesky { const LL MAXN = 50000 + 5; LL n, m; LL mu[MAXN], vis[MAXN], pri[MAXN], tot; LL g[MAXN]; void init() { tot = 0, ms(vis, 0), ms(mu, 0), ms(g, 0); mu[1] = 1; for (LL i = 2; i &lt;= 50000; ++i) { if (!vis[i]) pri[++tot] = i, mu[i] = -1; for (LL j = 1; j &lt;= tot &amp;&amp; i * pri[j] &lt;= 50000; ++j) { vis[pri[j] * i] = 1; if (i % pri[j] == 0) { mu[i * pri[j]] = 0; break; } else mu[i * pri[j]] = mu[i] * mu[pri[j]]; } } for (LL i = 2; i &lt;= 50000; ++i) mu[i] += mu[i - 1]; for (LL i = 1; i &lt;= 50000; ++i) { LL ans = 0, l = 1; while (l &lt;= i) { LL r = i / (i / l); ans += (i / l) * (r - l + 1); l = r + 1; } g[i] = ans; } } void clean() { } int solve() { clean(); scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m); if (n &gt; m) swap(n, m); LL ans = 0, l = 1; while (l &lt;= n) { LL r = min(n / (n / l), m / (m / l)); ans += (mu[r] - mu[l - 1]) * g[n / l] * g[m / l]; l = r + 1; } /*for (LL i = 1; i &lt;= m; ++i) { ans += (mu[i] - mu[i - 1]) * g[n / i] * g[m / i]; }*/ printf(&quot;%lld\n&quot;, ans); return 0; } } int main() { flyinthesky::init(); scanf(&quot;%lld&quot;, &amp;T); while (T--) flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 3124」「SDOI2013」直径 (树的直径)]]></title>
    <url>%2Fbzoj3124%2F</url>
    <content type="text"><![CDATA[bzoj 3124题解：对于给定的一棵树，求其直径的长度是多少，以及有多少条边满足所有的直径都经过该边。 第一问直接两次 DFS 求直径。考虑第二问求直径必须边。记录 $Ldis$: 从直径左边端点到直径右边点的距离$Rdis$: 从直径右边端点到直径左边点的距离$Edis$: 直径上的点的最大偏心距 我们从一个直径端点在直径上开始往右走，若存在$Rdis(i)+Edis(i)=len$，$len$为直径长，那么这里开始后面的就不是必须边。 然后相反地，我们从右往左做一次，然后得出了一个范围$[l,r]$，然后就非常好处理了 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 200000 + 5; struct edge { int v, w, nxt; } ed[MAXN * 2]; int n, hd[MAXN], en, dd1, dd2, vis[MAXN], zjd[MAXN], cnt; LL tmp_dis[MAXN], l_dis[MAXN], r_dis[MAXN], e_dis[MAXN]; void ins(int u, int v, int w) {ed[++en] = (edge){v, w, hd[u]}, hd[u] = en;} void dfs_dis(int u, int fa) { for (int i = hd[u]; i &gt;= 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (e.v != fa) { tmp_dis[e.v] = tmp_dis[u] + e.w; dfs_dis(e.v, u); } } } int dfs_vis(int u, int fa) { if (u == dd2) return zjd[++cnt] = u, vis[u] = 1, 1; for (int i = hd[u]; i &gt;= 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (e.v != fa) { int fl = dfs_vis(e.v, u); if (fl &amp;&amp; !vis[u]) zjd[++cnt] = u, vis[u] = 1; } } return vis[u]; } void dfs_e(int u, int fa) { for (int i = hd[u]; i &gt;= 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (e.v != fa &amp;&amp; !vis[e.v]) { dfs_e(e.v, u); e_dis[u] = max(e_dis[u], e_dis[e.v] + e.w); } } } void clean() { cnt = 0, en = -1, ms(hd, -1), ms(vis, 0), ms(e_dis, 0); } int solve() { clean(); scanf(&quot;%d&quot;, &amp;n); for (int u, v, w, i = 1; i &lt; n; ++i) { scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); ins(u, v, w), ins(v, u, w); } ms(tmp_dis, 0), dfs_dis(1, 0); dd1 = 0; for (int i = 1; i &lt;= n; ++i) if (tmp_dis[i] &gt; tmp_dis[dd1]) dd1 = i; ms(tmp_dis, 0), dfs_dis(dd1, 0); dd2 = 0; for (int i = 1; i &lt;= n; ++i) if (tmp_dis[i] &gt; tmp_dis[dd2]) dd2 = i; memcpy(l_dis, tmp_dis, sizeof tmp_dis); ms(tmp_dis, 0), dfs_dis(dd2, 0); memcpy(r_dis, tmp_dis, sizeof tmp_dis); dfs_vis(dd1, 0); for (int u = 1; u &lt;= n; ++u) if (vis[u]) dfs_e(u, 0); int l = 1; for (int i = 1; i &lt;= cnt &amp;&amp; l &lt; cnt; ++i) { int u = zjd[i]; if (e_dis[u] &amp;&amp; r_dis[u] + e_dis[u] == l_dis[dd2]) break; else ++l; } int r = cnt; for (int i = cnt; i &amp;&amp; r &gt; 1; --i) { int u = zjd[i]; if (e_dis[u] &amp;&amp; l_dis[u] + e_dis[u] == l_dis[dd2]) break; else --r; } printf(&quot;%lld\n%d\n&quot;, l_dis[dd2], l - r); return 0; } } int main() { flyinthesky::solve(); return 0; } /* 3 1 2 3 2 3 5 14 1 2 10 1 3 5 1 4 10 1 9 9 9 10 1 9 12 1 3 5 3 5 7 2 5 6 6 7 8 4 3 13 3 13 11 1 13 14 2 */]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>树的直径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 2154」Crash的数字表格 (莫比乌斯反演)]]></title>
    <url>%2Fbzoj2154%2F</url>
    <content type="text"><![CDATA[Bzoj 2154题意：给定$n, m$，求$$\sum_{i=1}^n \sum_{j=1}^m \operatorname{lcm}(i, j)$$ 化为$\gcd$式子$$\sum_{d=1}^n d \sum_{i=1}^{n}\sum_{j=1}^{m}\frac{ij}{\gcd(i,j)} \\\sum_{d=1}^n d \sum_{i=1}^{\lfloor \frac nd \rfloor}\sum_{j=1}^{\lfloor \frac md \rfloor}ij \cdot [\gcd(i,j)=1]$$设$$f(n,m)=\sum_{i=1}^n \sum_{j=1}^m ij \cdot [\gcd(i,j)=1] \\=\sum_{d=1}^n \sum_{d|i} \sum_{d|j} \mu(d) \cdot d^2 \sum_{i=1}^{\lfloor \frac nd \rfloor}\sum_{j=1}^{\lfloor \frac md \rfloor}ij$$设 (两个等差数列相乘)$$g(n,m)=\sum_{i=1}^n \sum_{j=1}^m ij =\frac{n(n+1)}{2} \times \frac{m(m+1)}{2}$$则$$f(n,m)=\sum_{d=1}^n \mu(d) \cdot d^2 \cdot g(\lfloor \frac nd \rfloor, \lfloor \frac md \rfloor)$$即原式为$$\sum_{d=1}^m d \cdot f(\lfloor \frac nd \rfloor, \lfloor \frac md \rfloor)$$ 计算$f(n,m)$时整除分块，计算答案时整除分块，时间复杂度$O(n+m)$ #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL MAXN = 10000000 + 5; const LL MO = 20101009; LL n, m, mu[MAXN], vis[MAXN], pri[100000 + 5], tot, qzhmu[MAXN]; LL ksm(LL a, LL b) { LL bs = a % MO, ans = 1ll; while (b) { if (b &amp; 1) ans = (ans * bs) % MO; bs = (bs * bs) % MO; b &gt;&gt;= 1ll; } return ans; } LL g(LL x, LL y) { LL tmp1 = x * (x + 1ll) / 2ll % MO; LL tmp2 = y * (y + 1ll) / 2ll % MO; return tmp1 * tmp2 % MO; } LL f(LL x, LL y) { if (x &gt; y) swap(x, y); LL l = 1, ans = 0; while (l &lt;= x) { LL r = min(x / (x / l), y / (y / l)); ans = (ans + (qzhmu[r] - qzhmu[l - 1] + MO) % MO * g(x / l, y / l) % MO) % MO; l = r + 1; } return ans; } void clean() { ms(vis, 0), ms(mu, 0), ms(qzhmu, 0), tot = 0; } int solve() { clean(); scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m); if (n &gt; m) swap(n, m); mu[1] = 1, vis[1] = 1; for (LL i = 2; i &lt;= m; ++i) { if (!vis[i]) vis[i] = 1, pri[++tot] = i, mu[i] = -1; for (LL j = 1; j &lt;= tot &amp;&amp; i * pri[j] &lt;= m; ++j) { vis[i * pri[j]] = 1; if (i % pri[j] == 0) { mu[i * pri[j]] = 0; break; } else mu[i * pri[j]] = -mu[i]; } } for (LL i = 1; i &lt;= m; ++i) qzhmu[i] = (qzhmu[i - 1] + (((mu[i] + MO) % MO * i) % MO) * i % MO) % MO; LL l = 1, ans = 0; while (l &lt;= n) { LL r = min(n / (n / l), m / (m / l)); ans = (ans + 1ll * (r - l + 1ll) * (l + r) / 2ll % MO * f(n / l, m / l) % MO) % MO; l = r + 1; } printf(&quot;%lld\n&quot;, ans); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1009F(树上启发式合并)]]></title>
    <url>%2FCodeforces1009F%2F</url>
    <content type="text"><![CDATA[Codeforces 1011D题意：给出一棵有根树，对于每个节点$x$，定义一个无穷序列$d$，其中$d(x,i)$表示以$x$为根节点的子树中到$x$的距离恰好为$i$的点的个数，$i \in [0， INF]$，现在对每个点$x$，希望求出一个东西$j$，使得对于任意$k &lt; j$，$d(x,k) &lt; d(x,j)$，对于任意$k &gt; j,d(x,k) \leq d(x,j)$ 本题类似于CF600E其实就是对每个点求出这个点子树的的某层节点最多的那层。考虑将层作为颜色，维护子树中颜色最多的那个颜色。那么这里没有修改，并且也是子树操作，那么我们可以考虑用树上启发式合并。也就是将树轻重链剖分(求出重儿子)，然后对于每个点，先遍历所有的轻儿子子树，然后再回退所有当前答案，然后遍历重儿子子树，不回退答案，然后再直接遍历所有的轻儿子子树，不回退答案，并且不管下面的轻重链了。那么这题就是一个裸题了，注意用map方便。更新答案方式类似莫队。复杂度证明：引理1： 根节点到树上任意节点的轻边数不超过$\log n$条。 证明：我们设根到该节点有$x$条轻边, 该节点的子树大小为$y$，显然轻边连接的子节点的子树大小小于父亲的一半（若大于一半就不是轻边了），则 $y &lt; n/2^x$，显然$ n &gt; 2^x$所以 $x &gt; \log n$ 一个节点的被遍历的次数等于他到根节点路径上的轻边树$+1$ 证明：显然，只要上面有一条轻边下面才会被遍历一次 综上，时间复杂度大约为$O(\log n)$ #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; #include&lt;cmath&gt; #include&lt;map&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 1000000 + 5; vector&lt;int &gt; G[MAXN]; int n, son[MAXN], siz[MAXN], dep[MAXN]; int pos, ans[MAXN]; map&lt;int, int &gt; ma; void dfs_son(int u, int fa) { siz[u] = 1, dep[u] = dep[fa] + 1; for (int i = 0; i &lt; (int)G[u].size(); ++i) { int v = G[u][i]; if (v != fa) { dfs_son(v, u); siz[u] += siz[v]; if (son[u] &lt; 0 || siz[son[u]] &lt; siz[v]) son[u] = v; } } } void add(int u, int fa) { ++ma[dep[u]]; if (ma[dep[u]] &gt; ma[dep[pos]] || (ma[dep[u]] == ma[dep[pos]] &amp;&amp; dep[u] &lt; dep[pos])) pos = u; for (int i = 0; i &lt; (int)G[u].size(); ++i) { int v = G[u][i]; if (v != fa) add(v, u); } } void dfs_dsu(int u, int fa) { for (int i = 0; i &lt; (int)G[u].size(); ++i) { int v = G[u][i]; if (v == son[u]) continue ; if (v == fa) continue ; dfs_dsu(v, u); ma.clear(), pos = 0; } if (son[u] &gt;= 0) dfs_dsu(son[u], u); for (int i = 0; i &lt; (int)G[u].size(); ++i) { int v = G[u][i]; if (v == son[u]) continue ; if (v == fa) continue ; add(v, u); } ++ma[dep[u]]; if (ma[dep[u]] &gt; ma[dep[pos]] || (ma[dep[u]] == ma[dep[pos]] &amp;&amp; dep[u] &lt; dep[pos])) pos = u; ans[u] = dep[pos] - dep[u]; } void clean() { ms(son, -1), ms(siz, 0), ms(dep, 0), pos = 0, ms(ans, 0); } int solve() { clean(); scanf(&quot;%d&quot;, &amp;n); for (int u, v, i = 1; i &lt; n; ++i) { scanf(&quot;%d%d&quot;, &amp;u, &amp;v); G[u].push_back(v), G[v].push_back(u); } dfs_son(1, 0); dfs_dsu(1, 0); for (int i = 1; i &lt;= n; ++i) printf(&quot;%d\n&quot;, ans[i]); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>树上启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 4033」「HAOI2015」树上染色 (贡献型树形DP)]]></title>
    <url>%2Fbzoj4033%2F</url>
    <content type="text"><![CDATA[Bzoj 4033题意：有一棵点数为$N$的树，树边有边权。给你一个在$[0,N]$之内的正整数$K$，你要在这棵树中选择$K$个点，将其染成黑色，并将其他的$N-K$个点染成白色。将所有点染色后，你会获得黑点两两之间的距离加上白点两两之间距离的和的收益。问收益最大值是多少。 本题抛开颜色就是一个树边贡献模板题。然后这里加入颜色的话就肯定要DP，DP方程受前面的启发设为$dp(u,j)$为以$u$点为根子树，有$j$个黑点对答案的贡献。然后转移就是$$dp(u,j)=\max(dp(u, j - k)+dp(v, k)+val \times w)$$ 其中$w$为贡献，$val$为$$val=k \cdot (m - k) + (siz(v)-k) \cdot (n - m - (sz(v) - k))$$ 即考虑边$(u, v)$的贡献，左边有几个黑点，右边有几个白点，同色点相乘，异色点相加即可。 然后注意细节，$dp$初始化为$-∞$，然后要判if (dp[u][j - k] &gt;= 0) 并且每个循环的上界都要加上$siz$的限制，以确保复杂度大概为$O(n^2)$ for (int j = min(siz[u], m); j &gt;= 0; --j) for (int k = 0; k &lt;= min(siz[e.v], j); ++k) #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 2000 + 5; struct edge { int v, w, nxt; } ed[MAXN * 2]; int n, m, en, hd[MAXN], siz[MAXN]; LL dp[MAXN][MAXN]; void dfs(int u, int fa) { siz[u] = 1, dp[u][0] = dp[u][1] = 0; for (int i = hd[u]; i &gt;= 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (e.v != fa) { dfs(e.v, u); siz[u] += siz[e.v]; for (int j = min(siz[u], m); j &gt;= 0; --j) { // for (int k = 0; k &lt;= min(siz[e.v], j); ++k) { // LL val = 1ll * k * (m - k) + 1ll * (siz[e.v] - k) * (n - m - (siz[e.v] - k)); if (dp[u][j - k] &gt;= 0) // dp[u][j] = max(dp[u][j], dp[u][j - k] + dp[e.v][k] + val * e.w); } } } } } void ins(int u, int v, int w) {ed[++en] = (edge){v, w, hd[u]}, hd[u] = en;} void clean() { ms(hd, -1), en = -1, ms(dp, -1); } int solve() { clean(); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int u, v, w, i = 1; i &lt; n; ++i) { scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); ins(u, v, w), ins(v, u, w); } dfs(1, 0); cout &lt;&lt; dp[1][m]; return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>计数DP</tag>
        <tag>Bzoj</tag>
        <tag>贡献</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1099F (树形DP+树状数组+二分+贪心)]]></title>
    <url>%2FCodeforces1099F%2F</url>
    <content type="text"><![CDATA[Codeforces 1099F题意：一棵 $n$ 个节点，以 $1$ 为根的带边权树，每个点包含 $x_i$ 个曲奇， 需要 $t_i$ 的时间吃掉一块曲奇。有两个人Mitya和Vasya在轮流玩游戏，Mitya先手。在根处有一个小动物，Mitya每次可以选择花费边权$l_i$的时间来到达当前点的孩子节点或者直接结束游戏，从这里返回选择性吃一些曲奇。Vasya 切断当前节点到一个儿子的连接(可以不一定要切)。整个游戏限时为 $T$求最坏情况下能吃到的曲奇个数。 这题比较麻烦……可以发现我们不用模拟整个过程，直接在往下的过程中路程乘二，然后直接吃曲奇即可。而且我们尽量要在花费最小的位置吃曲奇。那么当前节点位置到根上的曲奇都可以作为候选。那么我们可以用数据结构维护曲奇。 我们先忽略掉 Vasya，即不考虑断边的情况，设$f(u)$为根到$u$的不考虑断边下的最优解。我们要尽量多吃曲奇，那么我们尽量要在花费最小的位置吃曲奇，所以我们不妨维护一个值域在$t$上的一个树状数组，记录值为$t_i \cdot x_i$，这个树状数组上的前缀和即为最优吃曲奇的时间，我们在树状数组上二分找到一个位置使得其是$\leq T - 2 \cdot S$的最大值，其中$S$为从根到该位置的路径长度。这样找到的一定是最优的。因为值域从$1,2,3,\cdots,maxt$排序。为了统计到底有多少个曲奇能吃，那么再开一个值域在$t$上的一个树状数组，记录值为$x_i$，那么前缀和就是有多少个曲奇。最后还需要补不足够部分的曲奇，具体看代码实现，小技巧是有余数要补的可以方便化直接减一，这样整除就不用讨论。 然后考虑 Vasya，Vasya 一定断开获益最大的一条边，所以 Mitya 只能取到次优值。设$dp(u)$为$u$为子树，考虑断边的最优值，$maxd(u), cid(u)$分别为$u$为子树不包括$u$，考虑断边的最优值的次优值。如果当前是根，那么$dp(1)=max(f(1), maxd(1))$，因为 Mitya 先手否则只能取到次大值，则$dp(u)=max(f(u), cid(u))$$maxd(u)$和$cid(u)$用次大值的更新方法来更新即可。用子树的$dp$值来更新。 真是一个数据结构+DP好题。。 知识点：有余数要补的可以方便化直接减一，这样整除就不用讨论 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL MAXN = 100000 + 5; struct edge { LL v, w, nxt; } ed[MAXN * 2]; LL n, T, x[MAXN], t[MAXN], hd[MAXN], en; LL t_bit[1000000 + 5], tx_bit[1000000 + 5], maxt; LL f[MAXN], dp[MAXN], maxd[MAXN], cid[MAXN]; void ins(LL u, LL v, LL l) {ed[++en] = (edge){v, l, hd[u]}, hd[u] = en;} LL lowbit(LL x) {return x &amp; (-x);} void t_add(LL x, LL v) { for (LL i = x; i &lt;= maxt; i += lowbit(i)) t_bit[i] += v; } void tx_add(LL x, LL v) { for (LL i = x; i &lt;= maxt; i += lowbit(i)) tx_bit[i] += v; } LL t_query(LL x) { LL ret = 0; for (LL i = x; i &gt; 0; i -= lowbit(i)) ret += t_bit[i]; return ret; } LL tx_query(LL x) { LL ret = 0; for (LL i = x; i &gt; 0; i -= lowbit(i)) ret += tx_bit[i]; return ret; } void dfs_ign(LL u, LL fa, LL D) { // 忽略 Vasya 的答案 t_add(t[u], x[u]); tx_add(t[u], x[u] * t[u]); LL l = 1, r = maxt + 1; while (l &lt; r) { LL mid = (l + r) &gt;&gt; 1ll; LL val = tx_query(mid); if (val &lt; T - 2ll * D) l = mid + 1; else r = mid; } LL k = l - 1; // 有余数要补的可以方便化直接减一，这样整除就不用讨论 f[u] = t_query(k); if (k != maxt) f[u] += (T - 2ll * D - tx_query(k)) / (k + 1); for (LL i = hd[u]; i &gt;= 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (e.v != fa) dfs_ign(e.v, u, D + e.w); } t_add(t[u], -x[u]); tx_add(t[u], -x[u] * t[u]); } void dfs_dp(LL u, LL fa) { for (LL i = hd[u]; i &gt;= 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (e.v != fa) { dfs_dp(e.v, u); if (dp[e.v] &gt; maxd[u]) { cid[u] = maxd[u]; maxd[u] = dp[e.v]; } else if (dp[e.v] &gt; cid[u]) cid[u] = dp[e.v]; } } if (u == 1) dp[u] = max(f[u], maxd[u]); else dp[u] = max(f[u], cid[u]); } void clean() { maxt = 0, en = -1, ms(hd, -1); ms(t_bit, 0), ms(tx_bit, 0); ms(f, 0), ms(dp, 0), ms(maxd, 0), ms(cid, 0); } int solve() { clean(); scanf(&quot;%lld%lld&quot;, &amp;n, &amp;T); for (LL i = 1; i &lt;= n; ++i) scanf(&quot;%lld&quot;, &amp;x[i]); for (LL i = 1; i &lt;= n; ++i) scanf(&quot;%lld&quot;, &amp;t[i]), maxt = max(maxt, t[i]); for (LL p, l, i = 2; i &lt;= n; ++i) { scanf(&quot;%lld%lld&quot;, &amp;p, &amp;l); ins(i, p, l), ins(p, i, l); } dfs_ign(1, 0, 0); dfs_dp(1, 0); cout &lt;&lt; dp[1]; return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>树状数组</tag>
        <tag>Codeforces</tag>
        <tag>二分</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019.01.23-2019.07.01 计划]]></title>
    <url>%2F%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93-before-20190501%2F</url>
    <content type="text"><![CDATA[$${\color{red}{211}}/350$$ 1、CF 1009F (树上启发式合并)2、Bzoj 2154 (莫比乌斯反演)3、Bzoj 3124 (树的直径)4、CF 1108 E1 (枚举)5、Bzoj 3994 (莫比乌斯反演)6、Bzoj 1233 (DP+单调队列+结论)7、CF 1107 ABC8、Bzoj 1832/Bzoj 1787 (倍增LCA)9、Bzoj 1858 (线段树维护01序列翻转最大字段和)10、Bzoj 2005 (莫比乌斯反演)11、CF 984 ABC12、Poj 2374 (线段树)13、Bzoj 1718 (桥+贪心)14、Bzoj 3529 (莫比乌斯反演+离线+树状数组)15、DG联考16、CF 975 ABC17、CF 311B (DP，二维斜率优化)18、Bzoj 3930 (莫比乌斯反演 + GCD性质 / 杜教筛)19、《差分与前缀和》 by ruanxingzhi20、Bzoj 1385 (规律，GCD)21、Bzoj 2064 (集合DP)22、DG联考23、Bzoj 3033 (欧拉回路+DFS)24、Dirichlet 卷积25、CF 1109 ACD26、CF 1106 (倒序DP，set)27、Bzoj 1497 (最大权闭合子图，最小割)28、Loj 6008 「网络流 24 题」餐巾计划 (最小费用最大流，资源调配)29、Poj 3709 (斜率优化DP，延迟加入决策)30、杜教筛模板31、dfs序七个经典问题 in 《数据结构漫谈》 by ruanxingzhi32、Luogu 3768 简单的数学题 (莫比乌斯反演)33、Bzoj 1911 (最大化斜率优化)34、Bzoj 1012 (树状数组最大值)35、Bzoj 2730 (双联通分量+分类讨论)36、Bzoj 1925 (组合数DP，波动序列性质)37、CF 1111 ABC38、LCT 模板39、Hdu 5608 (莫比乌斯反演，杜教筛)40、CF 1110 ABCE41、CF 1110 D42、Bzoj 3126 (DP+单调队列/差分约束)43、Bzoj 1047 (单调队列)44、Bzoj 1226 (状压DP)45、CF 1104D (交互，二分，倍增)46、Bzoj 1861 (Splay)47、Bzoj 1058 (Set)48、Bzoj 1801 (DP)49、CF 1114 ABC50、CF 1114 D (区间DP) $\color{green}(\text{Finished on Feb. 10th, 2019})$51、CF 1260 (区间DP)52、Hdu 2476 (区间DP)53、Bzoj 1996 (区间DP)54、Bzoj 1060 (树形DP)55、Bzoj 4071 (权值线段树维护动态前缀中位数)56、Bzoj 2298 (DP)57、FFT 模板58、Bzoj 2002 (LCT)59、Bzoj 2733 (Splay森林，启发式合并)60、练FFT板子61、Bzoj 3527(卷积FFT)62、Bzoj 2754 (后缀数组+二分+莫队+离线)63、重打Bzoj 275464、Bzoj 3675 (斜率优化)65、Bzoj 1049 (LIS，结论，DP)66、Luogu 3396 (预处理前$\sqrt n$)67、Bzoj 4650 (后缀数组，ST表，差分 / Hash)68、Bzoj 3669 (LCT)69、Bzoj 4034 (DFS序经典题)70、Bzoj 3191 (概率DP)71、Bzoj 3631 (树上差分)72、Luogu 3765 (线段树+Splay)73、Luogu 2709 (莫队)74、Luogu 2526 (二分图最大匹配)75、Luogu 2219 (单调队列+精准的范围)76、Bzoj 1562 (二分图最大匹配)77、Luogu 3709 (莫队)78、CF 1117 ABC79、CF 1117 D (矩阵快速幂)80、CF 1117 E (交互)81、CF 1118F1 (DFS)82、Bzoj 1503 (Splay)83、Bzoj 1855 (单调队列优化DP)84、CF 1118C (构造)85、NOIP2011tgD2T2 (二分+前缀和)86、Bzoj 3410 (隐含复杂度+二分图最小点覆盖)87、Luogu 3674 (莫队+bitset)88、Bzoj 1293 (单调队列)89、Bzoj 4698 (后缀数组，二分 / Hash / KMP / 暴力)90、CF 1114 D1D2 (二分+贪心)91、Bzoj 2599 (点分治)92、AC自动机复习 (Bzoj 2938, 复习AC自动机上DP，查单词)93、牛客OI周赛7-提高组94、CF 1131 ABCD95、Bzoj 2434 (AC自动机，Fail树，DFS序，树状数组)96、一堆水题97、Bzoj 2049 (LCT)98、Atcoder 119 ABC ABCD99、CF1130 ABCD100、CF1130 E(构造) $\color{green}(\text{Finished on Feb. 26th, 2019})$101、Bzoj 4199 (后缀数组+并查集+倒序)102、Luogu 5148 (组合数)103、NOIP2015普及组T3 (前缀和，奇偶性)104、Bzoj 3238 (后缀数组+并查集+倒序)105、Bzoj 1792 (Trie + 贪心)106、Bzoj 4567 (Trie前缀关系树+树贪心)107、Bzoj 3238 (后缀数组+单调栈)108、Bzoj 3670 (KMP)109、Bzoj 1511 (KMP)110、Bzoj 1212 (Trie + 存在性DP)111、Bzoj 1559 (AC自动机+状压DP+爆搜结论)112、Bzoj 3530 (AC自动机+数位DP)113、Bzoj 4566 (后缀数组+单调栈)114、Bzoj 3172 (后缀数组+二分查找)115、Bzoj 1031 (后缀数组)116、Luogu 3878 (折半搜索+Set)117、Luogu 2456 (并查集维护自由元)118、Luogu 三月月赛119、Loj 2313 (Trie)120、Bzoj 3942 (KMP+栈)121、Bzoj 3732 (Kruskal 重构树)122、Atcoder 120 ABC ABCD123、Luogu 4934 (Dilworth 定理)124、Bzoj 3997 (Dilworth 定理 + DP)125、Bzoj 1143 (Dilworth 定理 + 二分图匹配)126、Bzoj 4516 (后缀数组 + Set / 链表)127、Bzoj 3123 (主席树+启发式合并)128、重打Bzoj 3123129、CF 1132 ABCF130、Bzoj 2303 (带权并查集+异或方程+数学归纳法)131、NOIP2018Day1T3 (multiset + 二分 + 贪心)132、CF 1132 D (二分)133、Bzoj 3295 (带修主席树，动态逆序对)134、luogu 3065 (Trie + 拓扑排序)135、重打 Bzoj 3295136、CF 1138 ACD (KMP，离散化)137、Bzoj 3295 (CDQ分治)138、Bzoj 2744 (二分图最大团)139、Bzoj 3932 (主席树+差分)140、Bzoj 1524 (Trie+Hash)141、Hzwer 数学杂题选讲142、CF 590E (AC自动机+Dilworth定理+DAG最小路径覆盖)143、Bzoj 1926 (二分+主席树/二维前缀和)144、牛客392J (DP思想)145、Bzoj 2179 (FFT卷积)146、牛客392F (根号算法)，牛客392C (筛选法求幂)147、Bzoj 4827 (FFT)148、Luogu 数论小题149、拉格朗日插值模板150、Bzoj 3887 (Tarjan + 最长路 + 枚举点) $\color{green}(\text{Finished on Mar. 11th, 2019})$151、Bzoj 2956 (数论分块)152、Bzoj 4552 (线段树合并分裂+Set / 二分 + 线段树)153、重打 Bzoj 4552154、Bzoj 3508 (Xor 前缀和，BFS，状压DP)155、Bzoj 3668 (位运算)156、Bzoj 2006 (堆 / 主席树+堆)157、Bzoj 2286 (虚树+树形DP)158、Bzoj 1047 (LIS问题、贪心)159、重打 Bzoj 4552，Bzoj 2286，Bzoj 3508160、Bzoj 4542 (莫队 + 区间某数倍数)161、Bzoj 3173 (Splay / Rope(pbds))162、pbds:Rope 模板 (Luogu 3835)163、Bzoj 1211 (Prufer序列)164、Bzoj 1430 (prufer序列数量(Cayley定理))165、Bzoj 1492 (CDQ分治/Set维护凸包，斜率优化)166、CF 55D (数位DP，整除技巧)167、Loj 2483 (CDQ分治/Set维护凸包，斜率优化)168、Poj 3189 (枚举+网络流(类二分图))169、Bzoj 5157 (树状数组，LIS)170、Luogu 3924 (期望，分式化简)171、Spoj GSS2 (线段树+离线)172、CF 24D (期望DP+高斯消元)173、Bzoj 5290 (树形DP+dfn卡空间)174、Bzoj 2957 (线段树)175、Loj 6252 (最短路图DAG+DP，Bitset)176、Bzoj 3875 (SPFA解带环DP)177、Luogu1875 佳佳的魔法药水 (SPFA解带环DP)178、Bzoj 2834 (分层图最短路，不记录无用点)179、Loj 6354 (最短路+位运算优化建边)180、Bzoj 1576 (最短路+并查集+贪心)181、Bzoj 2118 (同余最短路)182、Bzoj 2143 (线段树优化连边，最短路)183、Bzoj 3167 (树形DP，组合计数DP)184、Bzoj 3166 (可持久化01Trie + Set / 二分)185、Bzoj 5495 (可持久化01Trie + 堆 (超级钢琴))186、CF 1155E (同余高斯消元)187、Bzoj 5299 (状压DP)188、Bzoj 4571 (主席树+按位贪心)189、Bzoj 5338 (可持久化Trie差分版)190、CF1156E (分治)191、Bzoj 4568 (线性基+树上倍增)192、CF 451E (组合，多重集组合数)193、CF 1156D (树形DP，树上合成路径)194、CF 888G (异或最小生成树，Trie+分治)195、luogu 1365 / luogu 1297 (期望 / 期望DP)196、CF 1163D (AC自动机+DP)197、CF 1156F (概率DP)198、牛客小白月赛199、CF 1154G (数论，倍数法)200、CF 1140E (DP)201、CF 1166E (构造+线性基)202、Loj 6185 (计数DP，无标号有根树统计)203、ABC 126204、Bzoj 4517 (错排公式)205、Bzoj 2111 (树形计数DP)206、Bzoj 2302 (计数DP)207、Bzoj 1485 (卡特兰数)208、Bzoj 4665 (计数，容斥DP)209、CF 1148E (构造)210、CF 1175 ABCD211、CF 1175 E]]></content>
      <categories>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>杂文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「poj 2135」Farm Tour (最小费用最大流)]]></title>
    <url>%2Fpoj2135%2F</url>
    <content type="text"><![CDATA[poj 2135题意：一个无向图，起点终点固定，来回一次，不重复任何一条道路，求最小道路数(就是路径长度) 这种最短路没法解决的可以想想网络流，因为网络流的最小费用和最短路有相似点，而可以通过容量等方式限制最短路的形式。 设一个超级源和一个超级汇，超级源连$1$点边$(cap=2, w=0)$, $n$点连超级汇边$(cap=2, w=0)$然后对于图中的一条边$(x,y)$，连边$(cap=1,w=v_{x,y})$这个容量就是限制路径条数的，相当于走了一次以后即割断不能再走，而连接超级源汇的边容量为$2$，为的是找到两条路径。 知识点：1、最短路没法解决的可以想想网络流，因为网络流的最小费用和最短路有相似点，而可以通过容量等方式限制最短路的形式。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int INF = 2147483647ll; struct edge { int u, v, cap, w, nxt; } ed[500000 + 5]; int n, m, hd[10000 + 5], en, s, t, ans, V; int incf[10000 + 5], dis[10000 + 5], pre[10000 + 5], vis[10000 + 5]; int ID(int x, int y) {return (x - 1) * m + y;} void ins_c(int u, int v, int cap, int w) { ed[++en] = (edge){u, v, cap, w, hd[u]}, hd[u] = en; ed[++en] = (edge){v, u, 0, -w, hd[v]}, hd[v] = en; } queue&lt;int &gt; q; bool spfa() { for (int i = 0; i &lt;= V; ++i) incf[i] = INF, dis[i] = INF, pre[i] = -1, vis[i] = 0; vis[s] = 1, dis[s] = 0, q.push(s); while (!q.empty()) { int u = q.front(); q.pop(); vis[u] = 0; for (int i = hd[u]; i &gt;= 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (e.cap &amp;&amp; dis[u] != -INF &amp;&amp; dis[e.v] &gt; dis[u] + e.w) { dis[e.v] = dis[u] + e.w; incf[e.v] = min(incf[u], e.cap); pre[e.v] = i; if (!vis[e.v]) vis[e.v] = 1, q.push(e.v); } } } return dis[t] != INF; } void update() { int now = pre[t]; while (now != -1) { ed[now].cap -= incf[t], ed[now ^ 1].cap += incf[t]; now = pre[ed[now].u]; } ans += incf[t] * dis[t]; } void clean() { ans = 0, en = -1, ms(hd, -1); } int solve() { clean(); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); s = n + 1, t = V = n + 2; ins_c(s, 1, 2, 0); ins_c(n, t, 2, 0); for (int x, y, v, i = 1; i &lt;= m; ++i) { scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;v); ins_c(x, y, 1, v), ins_c(y, x, 1, v); } while (spfa()) update(); cout &lt;&lt; ans; return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>费用流</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Loj 6224」「网络流 24 题」深海机器人问题 (最大费用最大流)]]></title>
    <url>%2Floj6224%2F</url>
    <content type="text"><![CDATA[Loj 2632题意：见上。 类似Poj 3422，本题也是利用拆边技巧。对于几个源和几个汇，建超级源 / 超级汇连边最大费用最大流即可。 知识点：1、拆边技巧 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int INF = 2147483647ll; struct edge { int u, v, cap, w, nxt; } ed[500000 + 5]; int n, m, hd[10000 + 5], en, s, t, ans, V; int incf[10000 + 5], dis[10000 + 5], pre[10000 + 5], vis[10000 + 5]; int ID(int x, int y) {return (x - 1) * m + y;} void ins_c(int u, int v, int cap, int w) { ed[++en] = (edge){u, v, cap, w, hd[u]}, hd[u] = en; ed[++en] = (edge){v, u, 0, -w, hd[v]}, hd[v] = en; } queue&lt;int &gt; q; bool spfa() { for (int i = 0; i &lt;= V; ++i) incf[i] = INF, dis[i] = -INF, pre[i] = -1, vis[i] = 0; vis[s] = 1, dis[s] = 0, q.push(s); while (!q.empty()) { int u = q.front(); q.pop(); vis[u] = 0; for (int i = hd[u]; i &gt;= 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (e.cap &amp;&amp; dis[u] != -INF &amp;&amp; dis[e.v] &lt; dis[u] + e.w) { dis[e.v] = dis[u] + e.w; incf[e.v] = min(incf[u], e.cap); pre[e.v] = i; if (!vis[e.v]) vis[e.v] = 1, q.push(e.v); } } } return dis[t] != -INF; } void update() { int now = pre[t]; while (now != -1) { ed[now].cap -= incf[t], ed[now ^ 1].cap += incf[t]; now = pre[ed[now].u]; } ans += incf[t] * dis[t]; } void clean() { ans = 0, en = -1, ms(hd, -1); } int solve() { int a, b; clean(); scanf(&quot;%d%d%d%d&quot;, &amp;a, &amp;b, &amp;n, &amp;m); ++n, ++m; s = n * m + 1, t = V = n * m + 2; for (int i = 1; i &lt;= n; ++i) for (int x, j = 1; j &lt; m; ++j) { scanf(&quot;%d&quot;, &amp;x); ins_c(ID(i, j), ID(i, j) + 1, 1, x); ins_c(ID(i, j), ID(i, j) + 1, INF, 0); } for (int i = 1; i &lt;= m; ++i) for (int x, j = 1; j &lt; n; ++j) { scanf(&quot;%d&quot;, &amp;x); ins_c(ID(j, i), ID(j, i) + m, 1, x); ins_c(ID(j, i), ID(j, i) + m, INF, 0); } for (int k, x, y, i = 1; i &lt;= a; ++i) { scanf(&quot;%d%d%d&quot;, &amp;k, &amp;x, &amp;y); ++x, ++y; ins_c(s, ID(x, y), k, 0); } for (int k, x, y, i = 1; i &lt;= b; ++i) { scanf(&quot;%d%d%d&quot;, &amp;k, &amp;x, &amp;y); ++x, ++y; ins_c(ID(x, y), t, k, 0); } while (spfa()) update(); cout &lt;&lt; ans; return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Loj</category>
      </categories>
      <tags>
        <tag>Loj</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 817F (线段树上二分)]]></title>
    <url>%2FCodeforces817F%2F</url>
    <content type="text"><![CDATA[Codeforces 817F题意：对一个维护三种操作：1 将$[l,r]$中的数全部加入集合中。2 将集合中$[l,r]$范围内的数删去。3 将集合中在$[l,r]$中的数删去，并将之前不在集合中的数加入集合 考虑将每个数字当前一个位置，$0$表示有，$1$表示没有，然后$mex$就是最前面的$0$。显然可以二分。 数据大，考虑离散化。对于1操作，则是区间修改为$1$。对于$2$操作，则是区间修改为$0$若没有第三个操作，我们完全可以用树状数组+二分完成。而这里可以用线段树代替。 区间翻转相当于$sum=(r-l+1)-sum$线段树维护两个标记即可。注意标记的抵消的写法。具体看代码。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { struct xw { LL t, l, r, l_s, r_s; } qy[100000 + 5]; LL n; LL tax[1000000 + 5], tax_tot; #define M ((l + r) &gt;&gt; 1) #define lc (o &lt;&lt; 1) #define rc (o &lt;&lt; 1 | 1) LL sumv[5000000 + 5], rev[5000000 + 5], upd[5000000 + 5]; void pushdown(LL o, LL len) { if (len == 1) return ; if (upd[o] != -1) { upd[lc] = upd[rc] = upd[o]; sumv[lc] = (len - len / 2) * upd[lc], sumv[rc] = (len / 2) * upd[rc]; upd[o] = -1, rev[o] = 0; } if (rev[o]) { if (upd[lc] != -1) upd[lc] ^= 1, sumv[lc] = (len - len / 2) * upd[lc]; else rev[lc] ^= 1, sumv[lc] = (len - len / 2) - sumv[lc]; if (upd[rc] != -1) upd[rc] ^= 1, sumv[rc] = (len / 2) * upd[rc]; else rev[rc] ^= 1, sumv[rc] = (len / 2) - sumv[rc]; rev[o] = 0; } } void pushup(LL o) {sumv[o] = sumv[lc] + sumv[rc];} void build(LL o, LL l, LL r) { if (l == r) sumv[o] = rev[o] = 0, upd[o] = -1; else { build(lc, l, M), build(rc, M + 1, r); pushup(o); } } void update(LL o, LL l, LL r, LL x, LL y, LL v) { pushdown(o, r - l + 1); if (x &lt;= l &amp;&amp; r &lt;= y) { upd[o] = v; sumv[o] = v * (r - l + 1); return ; } if (x &lt;= M) update(lc, l, M, x, y, v); if (M &lt; y) update(rc, M + 1, r, x, y, v); pushup(o); } void reverse(LL o, LL l, LL r, LL x, LL y) { pushdown(o, r - l + 1); if (x &lt;= l &amp;&amp; r &lt;= y) { if (upd[o] != -1) upd[o] ^= 1, sumv[o] = upd[o] * (r - l + 1); else rev[o] ^= 1, sumv[o] = (r - l + 1) - sumv[o]; return ; } if (x &lt;= M) reverse(lc, l, M, x, y); if (M &lt; y) reverse(rc, M + 1, r, x, y); pushup(o); } LL query(LL o, LL l, LL r) { pushdown(o, r - l + 1); if (l == r) return tax[l]; if (sumv[lc] &lt; M - l + 1) return query(lc, l, M); return query(rc, M + 1, r); } void clean() { tax_tot = 0; } int solve() { clean(); scanf(&quot;%lld&quot;, &amp;n); tax[++tax_tot] = 1; for (LL i = 1; i &lt;= n; ++i) { scanf(&quot;%lld%lld%lld&quot;, &amp;qy[i].t, &amp;qy[i].l, &amp;qy[i].r); tax[++tax_tot] = qy[i].l, tax[++tax_tot] = qy[i].r; tax[++tax_tot] = qy[i].l + 1, tax[++tax_tot] = qy[i].r + 1; if (qy[i].l - 1 &gt; 0) tax[++tax_tot] = qy[i].l - 1; if (qy[i].r - 1 &gt; 0) tax[++tax_tot] = qy[i].r - 1; } sort(tax + 1, tax + 1 + tax_tot); tax_tot = unique(tax + 1, tax + 1 + tax_tot) - tax - 1; for (LL i = 1; i &lt;= n; ++i) { qy[i].l_s = lower_bound(tax + 1, tax + 1 + tax_tot, qy[i].l) - tax; qy[i].r_s = lower_bound(tax + 1, tax + 1 + tax_tot, qy[i].r) - tax; //printf(&quot;%lld %lld\n&quot;, qy[i].l_s, qy[i].r_s); } build(1, 1, tax_tot); for (LL i = 1; i &lt;= n; ++i) { if (qy[i].t == 1) { update(1, 1, tax_tot, qy[i].l_s, qy[i].r_s, 1); } if (qy[i].t == 2) { update(1, 1, tax_tot, qy[i].l_s, qy[i].r_s, 0); } if (qy[i].t == 3) { reverse(1, 1, tax_tot, qy[i].l_s, qy[i].r_s); } printf(&quot;%lld\n&quot;, query(1, 1, tax_tot)); } return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>Codeforces</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 4004」「JLOI2015」装备购买 (高斯消元 + 线性基)]]></title>
    <url>%2Fbzoj4004%2F</url>
    <content type="text"><![CDATA[BZOJ 4004题意：给你$n$个$m$维向量，每个向量有一个权值，求最小权极大线性无关组。 直接将其看作一个矩阵高斯消元，然后解出来的简化阶梯矩阵所有非零向量线性无关，称为秩。 对答案统计直接在消元过程中统计。 这题也让我知道高斯消元最后矩阵如果有一行有多个元素大于$0$意思是因为其他元没消掉这一位的数，并不是无解。 注意本题卡精度，可以开 long double #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int INF = 1000000000; const db eps = 1e-8; int n, m, c[505]; db a[505][505]; void clean() { } int solve() { clean(); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) scanf(&quot;%Lf&quot;, &amp;a[i][j]); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;c[i]); int dim = 0, ans = 0; for (int i = 1; i &lt;= min(m, n); ++i) { int mind = INF; for (int j = i; j &lt;= n; ++j) if (fabs(a[j][i]) &gt; eps &amp;&amp; mind &gt; c[j]) swap(a[i], a[j]), mind = c[j], swap(c[i], c[j]); if (fabs(a[i][i]) &lt; eps) continue ; ++dim, ans += c[i]; // 新增一个基底 for (int j = 1; j &lt;= n; ++j) if (i != j) { db rate = a[j][i] / a[i][i]; for (int k = 1; k &lt;= m; ++k) a[j][k] -= a[i][k] * rate; } } printf(&quot;%d %d\n&quot;, dim, ans); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>线性基</tag>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOIP2012 Day2 T3」 疫情控制 (树上倍增+二分+贪心)]]></title>
    <url>%2FNOIP2012tgD2T3%2F</url>
    <content type="text"><![CDATA[Luogu 1084题意：见上。 可以发现答案具有二分性质，所以我们二分一个答案$mid$来判断。只要保证每个移动长度不超过$mid$即可。那么我们可以将一些不能到达根子节点的军队直接能爬上来多少就爬上来多少，在爬上来的位置标记，不能爬到根。爬完之后，对树进行一次 DFS，更新根节点子节点下的子树是否全部被封锁。然后将其他军队爬到根节点的子节点，这些军队分成两种：第一种是剩余距离不足以经过根再回去原来的位置的军队第二种是除了这些的其他军队 对于第一种军队所在的位置，一定是这个子树中的军队占领。因为如果是其他子树的军队来占领，不那么优，因为第一种军队去占领其他子树的军队，那个占领这个位置的军队绝对可以占领那个位置，证毕。 所以我们可以留下一个剩余距离最小的第一种军队来占领这颗子树，然后其他军队通过贪心的方法，用剩余距离尽量小的军队取占领距离小的位置。 注意 $chk$ 实现，找了一年BUG… #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 50000 + 5, LOGS = 20; const LL INF = 1e18 + 5; struct edge { int v, w, nxt; } ed[MAXN * 2]; struct data { int u, bl, fl1; LL rest; }am[MAXN], tmpam[MAXN]; int n, m, en, hd[MAXN]; int pre[MAXN][LOGS + 5], dep[MAXN], val[MAXN]; LL d[MAXN][LOGS + 5], dis[MAXN]; void ins(int u, int v, int w) {ed[++en] = (edge){v, w, hd[u]}, hd[u] = en;} bool cmp(data a, data b) {return a.rest &lt; b.rest;} void dfs_pre(int u, int fa) { // 预处理 dep[u] = dep[fa] + 1, pre[u][0] = fa; for (int i = 1; i &lt;= LOGS; ++i) { pre[u][i] = pre[pre[u][i - 1]][i - 1]; d[u][i] = d[u][i - 1] + d[pre[u][i - 1]][i - 1]; } for (int i = hd[u]; i &gt;= 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (e.v != fa) { d[e.v][0] = e.w, dis[e.v] = dis[u] + e.w; if (u == 1) val[e.v] = e.w; dfs_pre(e.v, u); } } } int pa_pre(int u) { // 找每个军队属于哪个 s for (LL i = LOGS; i &gt;= 0; --i) if (pre[u][i] &amp;&amp; pre[u][i] != 1) { u = pre[u][i]; } return u; } int vis[MAXN], ok[MAXN], lst[MAXN]; LL whw[MAXN], H[MAXN]; // vis[n]=n节点是否打标记, ok[n]=n节点是否覆盖, whw[n]=n点的最小rest，lst[n]=n点的最小rest是哪个m void pa(int u, LL mid) { // 能爬多少爬多少 LL tot = 0; for (LL i = LOGS; i &gt;= 0; --i) if (pre[u][i] &amp;&amp; pre[u][i] != 1) { if (tot + d[u][i] &lt;= mid) u = pre[u][i], tot += d[u][i]; } vis[u] = 1; } bool dfs_ok(int u, int fa) { // 找没有标记的 if (vis[u] &amp;&amp; u != 1) return ok[u] = 1, 1; int fl = false; for (int i = hd[u]; i &gt;= 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (e.v != fa) { if (fl) ok[u] &amp;= dfs_ok(e.v, u); // else fl = true, ok[u] = dfs_ok(e.v, u); } } return ok[u]; } bool chk(LL mid) { for (int u = 1; u &lt;= n; ++u) vis[u] = 0, ok[u] = 0, whw[u] = INF, lst[u] = 0; for (int i = 1; i &lt;= m; ++i) am[i].fl1 = 0; for (int i = 1; i &lt;= m; ++i) if (dis[am[i].u] &gt; mid) pa(am[i].u, mid), am[i].fl1 = 1;// dis[am[i].u] &gt; mid dfs_ok(1, 0); for (int i = 1; i &lt;= m; ++i) if (dis[am[i].u] &lt;= mid) { LL rest = mid - dis[am[i].u]; int pos = am[i].bl; am[i].rest = rest; if (val[pos] &gt; rest &amp;&amp; !ok[pos]) { // !ok[pos] if (whw[pos] &lt;= rest) continue ; am[lst[pos]].fl1--, am[i].fl1++; lst[pos] = i; whw[pos] = rest; // } } for (int i = 1; i &lt;= n; ++i) ok[am[lst[i]].bl] = 1; int tot1 = 0; for (int i = 1; i &lt;= m; ++i) if (!am[i].fl1) tmpam[++tot1] = am[i]; int tot2 = 0; for (int i = hd[1]; i &gt;= 0; i = ed[i].nxt) { int v = ed[i].v; if (!ok[v]) H[++tot2] = val[v]; } sort(tmpam + 1, tmpam + 1 + tot1, cmp); sort(H + 1, H + 1 + tot2); int hh = 1, i; if (tot1 &lt; tot2) return false; for (i = 1; i &lt;= tot2; ++i) { while (hh &lt;= tot1 &amp;&amp; tmpam[hh].rest &lt; H[i]) ++hh; if (hh &gt; tot1) return false; ++hh; } return true; } void clean() { en = -1, ms(hd, -1), ms(pre, 0); } int solve() { clean(); scanf(&quot;%d&quot;, &amp;n); for (int u, v, w, i = 1; i &lt;= n - 1; ++i) { scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); ins(u, v, w), ins(v, u, w); } scanf(&quot;%d&quot;, &amp;m); for (int i = 1; i &lt;= m; ++i) scanf(&quot;%d&quot;, &amp;am[i].u); dep[0] = 0, dfs_pre(1, 0); for (int i = 1; i &lt;= m; ++i) am[i].bl = pa_pre(am[i].u); LL l = 0, r = 1e18, ans = -1; //LL l = 9, r = 10, ans = -1; //LL l = 13, r = 14, ans = -1; while (l &lt; r) { LL mid = (l + r) &gt;&gt; 1; if (chk(mid)) ans = mid, r = mid; else l = mid + 1; } printf(&quot;%lld\n&quot;, ans); return 0; } } int main() { flyinthesky::solve(); return 0; } /* 2 1 2 5 1 2 5 2 1 2 3 2 7 4 3 1 5 3 0 2 4 3 5 2 1 6 3 2 9 4 3 3 5 3 3 2 4 3 5 2 1 3 3 2 6 4 1 0 5 4 8 2 2 3 5 2 1 5 3 2 9 4 3 5 5 2 4 2 4 4 5 2 1 5 3 1 3 4 2 7 5 4 8 2 4 2 5 2 1 10 3 2 1 4 1 3 5 2 6 2 2 3 5 2 1 7 3 2 10 4 1 5 5 4 9 2 4 3 5 2 1 4 3 1 5 4 3 2 5 4 10 2 4 3 */]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>二分</tag>
        <tag>倍增</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「poj 3422」Kaka's Matrix Travels (最大费用最大流，K-方格取数)]]></title>
    <url>%2Fpoj3422%2F</url>
    <content type="text"><![CDATA[poj 3422题意：给定 $n^2$的矩阵，含有元素值，每次从最左上角开始出发，每次向右或者向下一格。终点是右下角, 每经过一个格子，获取它的值，并把该格子的值变成$0$.问经过$k$次从左上角到右下角。能得到的数值和最大多少。 把走几次看成容量，数值和看出权值。$(w=w_0,cap=c_0)$表示权值$w_0$, 容量$c_0$本题如果格子值不会变，那么直接点转边，入点到出点连边$(w=a_{i,j},cap=k)$，然后在网格图中连边$(w=0,cap=k)$，然后求最大费用最大流。 但是这里格子值会变化，所以我们要限制多次走这个点获得多次收益的情况。我们将入点到出点的边拆边，拆成$(w=a_{i,j}, cap=1), (w=0, cap=k-1)$两条边，然后这样做就可以解决问题了，由于最大费用基于最大流，所以一定能完成不超过$k$次(全部数取完后也可以随便选择路径走，等效)。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int INF = 2147483647ll; struct edge { int u, v, cap, w, nxt; } ed[500000 + 5]; int n, k, hd[10000 + 5], en, s, t, ans; int incf[10000 + 5], dis[10000 + 5], pre[10000 + 5], vis[10000 + 5]; int getIDbyPos(int x, int y) {return (x - 1) * n + y;} void ins_c(int u, int v, int cap, int w) { ed[++en] = (edge){u, v, cap, w, hd[u]}, hd[u] = en; ed[++en] = (edge){v, u, 0, -w, hd[v]}, hd[v] = en; } queue&lt;int &gt; q; bool spfa() { for (int i = 0; i &lt;= n * n * 2; ++i) incf[i] = INF, dis[i] = -INF, pre[i] = -1, vis[i] = 0; vis[s] = 1, dis[s] = 0, q.push(s); while (!q.empty()) { int u = q.front(); q.pop(); vis[u] = 0; for (int i = hd[u]; i &gt;= 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (e.cap &amp;&amp; dis[u] != -INF &amp;&amp; dis[e.v] &lt; dis[u] + e.w) { dis[e.v] = dis[u] + e.w; incf[e.v] = min(incf[u], e.cap); pre[e.v] = i; if (!vis[e.v]) vis[e.v] = 1, q.push(e.v); } } } //for (int i = 1; i &lt;= n * n * 2; ++i) printf(&quot;%d &quot;, dis[i]); puts(&quot;&quot;); return dis[t] != -INF; } void update() { int now = pre[t]; while (now != -1) { ed[now].cap -= incf[t], ed[now ^ 1].cap += incf[t]; now = pre[ed[now].u]; } ans += incf[t] * dis[t]; } void clean() { ans = 0, en = -1, ms(hd, -1); } int solve() { clean(); scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for (int i = 1; i &lt;= n; ++i) for (int x, j = 1; j &lt;= n; ++j) { scanf(&quot;%d&quot;, &amp;x); ins_c(getIDbyPos(i, j), getIDbyPos(i, j) + n * n, 1, x); ins_c(getIDbyPos(i, j), getIDbyPos(i, j) + n * n, k - 1, 0); if (i &lt; n) ins_c(getIDbyPos(i, j) + n * n, getIDbyPos(i + 1, j), k, 0); if (j &lt; n) ins_c(getIDbyPos(i, j) + n * n, getIDbyPos(i, j + 1), k, 0); } s = 1, t = 2 * n * n; while (spfa()) update(); cout &lt;&lt; ans; return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>费用流</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1791」「Ioi2008」岛屿 (基环树DP + 单调队列 + 时间戳栈找环)]]></title>
    <url>%2Fbzoj1791%2F</url>
    <content type="text"><![CDATA[BZOJ 1791题意：求基环森林中的每棵基环树的直径之和。 可以对每个基环树进行求解，显然答案为每个基环树直径的和。考虑怎么求基环树的直径。我们可以将环找出来，然后当成一个广义根，对环上每个点向下做树直径DP，然后问题转化为在一个环上选取两个数使得$$a(x)+a(y)+\max(|dis_x-dis_y|, dis_n - |dis_x-dis_y|)$$其中$dis_i$为从环上某个点某个方向出发到$i$的距离，$a$为每个点向下做的树直径长度。注意到这个式子和CH 5501的式子类似，所以可以单调队列维护。具体方法和那题差不多。 找环的方法为dfs，同时记录时间戳，将当前搜索链(当前点到最祖先的节点的链)上的的加入到栈，若出现一条反向边，则一定存在一个环，并且这条边是环上的边，所以一直退栈直到取出反向边所指的节点。这些节点就是环上的点。但是注意了提前退出要把所有标记都标记好，否则有错解。 注意环上一个点有几个分支的情况，这必须在处理树直径时加上ans = max(ans, d[u] + d[e.v] + e.w)单调队列中如果没有元素，则不能直接转移，只能更新为他的$a$值 fault1：提前退出没有把所有标记fault2: 环上最优化错误fault3：没有理解之前的题目(CH 5501)fault4：单调队列没有元素时没有讨论fault5: 基环树特殊数据 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 1000000 + 5; struct edge { int v, w, nxt; } ed[MAXN * 2]; int n, hd[MAXN], en; LL ans, finans, d[MAXN], ok[MAXN]; int dfn[MAXN], sz; int vis[MAXN], cir[MAXN * 2], cnt_cir, fl, bq; int stk[MAXN], top; LL dis_cir[MAXN * 2]; int q[MAXN * 2], l, r; void ins(int u, int v, int w) {ed[++en] = (edge){v, w, hd[u]}, hd[u] = en;} LL abss(LL x) {return x &gt; 0 ? x : -x;} void dfs_graph(int u, int pre) { // fault1：提前退出没有把所有标记 if (fl) return ; dfn[u] = ++sz, stk[++top] = u; for (int i = hd[u]; i &gt;= 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (fl) return ; if (i != (pre ^ 1)) { if (dfn[e.v]) { if (fl) return ; fl = 1; int whw; do { whw = stk[top--]; vis[whw] = 1, cir[++cnt_cir] = whw; } while (top &amp;&amp; whw != e.v); return ; } else dfs_graph(e.v, i); } } --top; } void dfs_cir(int ith) { for (int i = hd[cir[ith]]; i &gt;= 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (ith == cnt_cir) { if (e.v == cir[1]) {bq = e.w; return ;} } if (e.v == cir[ith + 1]) { dis_cir[ith + 1] = dis_cir[ith] + e.w; dfs_cir(ith + 1); } } } void dfs_tree(int u, int fa) { ok[u] = 1; for (int i = hd[u]; i &gt;= 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (!vis[e.v] &amp;&amp; e.v != fa) { dfs_tree(e.v, u); ans = max(ans, d[u] + d[e.v] + e.w);// fault5: 基环树特殊数据 d[u] = max(d[u], d[e.v] + e.w); } } } void clean() { ms(hd, -1), en = -1, finans = 0, ms(ok, 0); ms(dfn, 0), ms(d, 0), sz = 0ll; } int solve() { clean(); scanf(&quot;%d&quot;, &amp;n); for (int v, w, u = 1; u &lt;= n; ++u) { scanf(&quot;%d%d&quot;, &amp;v, &amp;w); ins(u, v, w), ins(v, u, w); } for (int u = 1; u &lt;= n; ++u) if (!ok[u]) { // fault1：提前退出没有把所有标记 for (int i = 1; i &lt;= cnt_cir; ++i) vis[cir[i]] = 0, dis_cir[i] = dis_cir[i + cnt_cir] = 0; cnt_cir = 0ll, top = 0, ans = 0; fl = 0; dfs_graph(u, -1); dfs_cir(1); for (int i = 1; i &lt;= cnt_cir; ++i) dfs_tree(cir[i], 0); dis_cir[cnt_cir + 1] = dis_cir[cnt_cir] + bq; for (int i = 2; i &lt;= cnt_cir; ++i) dis_cir[cnt_cir + i] = dis_cir[cnt_cir + 1] + dis_cir[i]; for (int i = 1; i &lt;= cnt_cir; ++i) cir[i + cnt_cir] = cir[i]; // fault2: 环上最优化错误 l = 1, r = 0; for (int i = 1; i &lt;= cnt_cir * 2; ++i) { while (l &lt;= r &amp;&amp; i - q[l] &gt;= cnt_cir) ++l; // fault3：没有理解之前的题目 if (l &lt;= r) ans = max(ans, d[cir[i]] + dis_cir[i] + d[cir[q[l]]] - dis_cir[q[l]]); else ans = max(ans, d[cir[i]]); // fault4：单调队列没有元素时没有讨论 while (l &lt;= r &amp;&amp; d[cir[q[r]]] - dis_cir[q[r]] &lt;= d[cir[i]] - dis_cir[i]) --r; q[++r] = i; } finans += ans; } cout &lt;&lt; finans; return 0; } } int main() { flyinthesky::solve(); return 0; } /* 6 7 1 2 1 2 3 3 2 4 4 4 5 5 4 6 2 3 5 6 5 6 2 */]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>单调队列</tag>
        <tag>树形DP</tag>
        <tag>基环树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「poj 3565」 Ants (二分图完美匹配)]]></title>
    <url>%2Fpoj3565%2F</url>
    <content type="text"><![CDATA[poj 3565题意：在坐标系中有$N$只蚂蚁，$N$棵苹果树，给你蚂蚁和苹果树的坐标。让每只蚂蚁去一棵苹果树，一棵苹果树对应一只蚂蚁。这样就有$N$条直线路线，问：怎样分配，才能使总路程和最小，且$N$条线不相交。 可以发现如果相交的两个线段一定可以修改为不相交(三角形)，且总路程和更小。题目保证有解，那么直接带权二分图完美匹配。这里可以费用流做，设源点$s$，汇点$t$，$s$到蚂蚁连边$(1,0)$($(cap, w)$表示容量和价值)，苹果树到$t$连边$(1, 0)$，每个蚂蚁到每个苹果树连边$(1, dist(a_i,b_j))$ 最后在蚂蚁到苹果树边中容量为0的即为匹配边。 知识点： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int INF = 2147483647ll; const db eps = 1e-8; struct edge { int u, v, cap, nxt; db w; } ed[30000 + 5]; struct node { int x, y; } nd[300 + 5]; int n, s, t; int en, hd[300 + 5]; int vis[300 + 5], incf[300 + 5], pre[300 + 5]; db dis[300 + 5]; db dist(int a, int b) {return sqrt((nd[a].x - nd[b].x) * (nd[a].x - nd[b].x) + (nd[a].y - nd[b].y) * (nd[a].y - nd[b].y));} void ins_c(int u, int v, int c, db w) { ed[++en] = (edge){u, v, c, hd[u], w}, hd[u] = en; ed[++en] = (edge){v, u, 0, hd[v], -w}, hd[v] = en; } queue&lt;int &gt; q; bool spfa() { for (int i = 0; i &lt;= 2 * n + 2; ++i) vis[i] = 0, incf[i] = INF, dis[i] = INF, pre[i] = -1; vis[s] = 1, dis[s] = 0.0, q.push(s); while (!q.empty()) { int u = q.front(); q.pop(); vis[u] = 0; for (int i = hd[u]; i &gt;= 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (fabs(dis[u] - INF) &gt; eps &amp;&amp; e.cap &amp;&amp; dis[e.v] &gt; dis[u] + e.w) { dis[e.v] = dis[u] + e.w; incf[e.v] = min(incf[u], e.cap); pre[e.v] = i; if (!vis[e.v]) vis[e.v] = 1, q.push(e.v); } } } return fabs(dis[t] - INF) &gt; eps; } void update() { int now = pre[t]; while (now != -1) { ed[now].cap -= incf[t], ed[now ^ 1].cap += incf[t]; now = pre[ed[now].u]; } } void clean() { en = -1, ms(hd, -1); } int solve() { clean(); scanf(&quot;%d&quot;, &amp;n), s = 2 * n + 1, t = 2 * n + 2; for (int i = 1; i &lt;= 2 * n; ++i) scanf(&quot;%d%d&quot;, &amp;nd[i].x, &amp;nd[i].y); for (int i = 1; i &lt;= n; ++i) ins_c(s, i, 1, 0.0), ins_c(i + n, t, 1, 0.0); for (int i = 1; i &lt;= n; ++i) { for (int j = n + 1; j &lt;= 2 * n; ++j) { ins_c(i, j, 1, dist(i, j)); } } // 费用流 while (spfa()) update(); for (int u = 1; u &lt;= n; ++u) { for (int i = hd[u]; i &gt;= 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (n + 1 &lt;= e.v &amp;&amp; e.v &lt;= 2 * n &amp;&amp; e.cap == 0) { printf(&quot;%d\n&quot;, e.v - n); break ; } } } return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>二分图</tag>
        <tag>费用流</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「poj 3017」Cut the Sequence (DP+堆+单调队列)]]></title>
    <url>%2Fpoj3017%2F</url>
    <content type="text"><![CDATA[poj 3017给定一个数列$a_n$，任意将连续的$a_i$分块，使所有块的和都不超过$M$，最小化各块的最大值的和。 设$dp(i)$为前$i$个的最优值。$$dp(i)=\min(dp(j)+\max(a[j,i-1]))$$ 这个是$O(n^2)$的。考虑优化。这里$\max(a[j,i-1])$不能表示为多项式，所以不能斜率优化了。那么我们考虑缩小候选集合$j$的大小。 引理： 若$j$可能成为$f(i)$的最优决策，则必有$a_j &gt; \max[j+1,i]$ 证明很容易，假设如果$a_k \leq \max[k+1,i]$，那么我们可以在前面找到一个位置$k$，使得$a_k &gt; \max[k+1,i]$，然后因为$f(i)$单调递增，所以$k$比$j$优，证毕。 那么我们可以维护一个单调队列，满足$a_i - a_{q_{l}} \leq m$，且对于$i$单增则$a_i$单减。那么对于每个$q_k$，他转移到$i$的代价为$dp(q_k)+a(q_{k+1})$，显然$[q_k,i]$的最大值为$a(q_{k+1})$。那么 $$dp(i)=\min_{k \in [j,i]} (dp(q_k)+a(q_{k+1}))$$ 发现$dp(q_k)+a(q_{k+1})$与$i$无关，用数据结构维护之。这里可以用堆来维护，将单调队列和堆构成一一映射关系，堆维护$\min_{k \in [j,i]} (dp(q_k)+a(q_{k+1}))$，然后每次查询即可。这里方便删除可以用multiset 1、方便删除的堆可以用multiset #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;stack&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { LL n, m, a[100000 + 5], q[100000 + 5], sum[100000 + 5], dp[100000 + 5]; multiset&lt;LL &gt; s; void clean() { ms(sum, 0), ms(q, 0), ms(dp, 0); } int solve() { clean(); scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m); for (LL i = 1; i &lt;= n; ++i) { scanf(&quot;%lld&quot;, &amp;a[i]), sum[i] = sum[i - 1] + a[i]; if (a[i] &gt; m) return printf(&quot;-1\n&quot;), 0; } LL l = 1, r = 0, p = 0; for (LL i = 1; i &lt;= n; ++i) { while (sum[i] - sum[p] &gt; m) ++p; while (l &lt;= r &amp;&amp; q[l] &lt;= p) { if (l &lt; r) s.erase(dp[q[l]] + a[q[l + 1]]); ++l; } while (l &lt;= r &amp;&amp; a[q[r]] &lt;= a[i]) { if (l &lt; r) s.erase(dp[q[r - 1]] + a[q[r]]); --r; } q[++r] = i; if (l &lt; r) s.insert(dp[q[r - 1]] + a[i]); dp[i] = dp[p] + a[q[l]]; if (l &lt; r) dp[i] = min(dp[i], *s.begin()); } cout &lt;&lt; dp[n]; return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>堆</tag>
        <tag>DP</tag>
        <tag>单调队列</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1097F (Bitset+位运算技巧+莫比乌斯反演)]]></title>
    <url>%2FCodeforces1097F%2F</url>
    <content type="text"><![CDATA[Codeforces 1097F题意：给$n(n\leq 10^5)$个multiset，然后进行如下操作：1 x v：把第$x$个multiset变成${v}$2 x y z：把第$x$个multiset变成$y∪z$3 x y z：把第$x$个multiset变成如下内容：$gcd(a,b)|a∈y,b∈z$4 x v：查询$v$在第$x$个multiset里出现的次数奇偶性 只关注奇偶性所以想到了bitset……然后刚开始我发现$gcd$操作可以反演/容斥去做……然后跪了看别人代码发现只需要对询问进行反演即可。。维护$f_x(i)$为第$x$个multiset中$i$倍数的个数。那么显然$y∪z$等价于$f_y(i)+f_z(i)$，$gcd(a,b)|a∈y,b∈z$等价于$f_y(i) \times f_z(i)$然后根据位运算的技巧，$xor​$是不进位的加法，$and​$是不进位的乘法，所以上面操作$f_y(i)+f_z(i) \Leftrightarrow f_y(i) xor f_z(i)$$f_y(i) \times f_z(i) \Leftrightarrow f_y(i) and f_z(i)$ 然后考虑怎么询问答案。设$g(i)$为$i$的个数。我们已经维护了$f_x(i)$为第$x$个multiset中$i$倍数的个数，那么根据反演：$$g(i)=\sum_{d=1}^{\lfloor \frac ni \rfloor} \mu(d)g(di)$$即可求出。对于反演式子中的乘法，可以预处理$bitset$的$\mu$，然后做$and$运算，加法即为最后得到的$bitset$中的$1$的个数。 知识点：1、bitset的空间计算方式为位数除以82、$xor$是不进位的加法，$and$是不进位的乘法 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;stack&gt; #include&lt;bitset&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { bitset&lt;7001 &gt; bs[100000 + 5], gg[7005], hh[7005]; // bs 即为上述 f, gg 为预处理的 mu, hh 为预处理的倍数 int n, q, mu[7005], pri[7005], vis[7005], tot; void clean() { ms(vis, 0), tot = 0; } int solve() { clean(); mu[1] = 1; for (int i = 2; i &lt;= 7000; ++i) { if (!vis[i]) vis[i] = 1, pri[++tot] = i, mu[i] = -1; for (int j = 1; j &lt;= tot &amp;&amp; 1ll * pri[j] * i &lt;= 7000ll; ++j) { vis[i * pri[j]] = 1; if (i % pri[j] == 0) { mu[i * pri[j]] = 0; break ; } else mu[i * pri[j]] = mu[i] * mu[pri[j]]; } } for (int i = 1; i &lt;= 7000; ++i) for (int j = i; j &lt;= 7000; j += i) hh[j][i] = 1, gg[i][j] = ((mu[j / i] == 0) ? 0 : 1); // 加减 1 等价 scanf(&quot;%d%d&quot;, &amp;n, &amp;q); while (q--) { int ty, x, y, z, v; scanf(&quot;%d&quot;, &amp;ty); if (ty == 1) scanf(&quot;%d%d&quot;, &amp;x, &amp;v), bs[x] = hh[v]; if (ty == 2) scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z), bs[x] = bs[y] ^ bs[z]; if (ty == 3) scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z), bs[x] = bs[y] &amp; bs[z]; if (ty == 4) scanf(&quot;%d%d&quot;, &amp;x, &amp;v), printf(&quot;%d&quot;, (int)((bs[x] &amp; gg[v]).count() &amp; 1)); } return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>STL</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「poj 2942」(点双连通分量+二分图判定)]]></title>
    <url>%2Fpoj2942%2F</url>
    <content type="text"><![CDATA[poj 2942题意：亚瑟王要在圆桌上召开骑士会议，为了不引发骑士之间的冲突，并且能够让会议的议题有令人满意的结果，每次开会前都必须对出席会议的骑士有如下要求：1、 相互憎恨的两个骑士不能坐在直接相邻的$2$个位置；2、 出席会议的骑士数必须是奇数，这是为了让投票表决议题时都能有结果。如果出现有某些骑士无法出席所有会议（例如这个骑士憎恨所有的其他骑士），则亚瑟王为了世界和平会强制把他剔除出骑士团。现在给定准备去开会的骑士数$n$，再给出$m$对憎恨对（表示某$2$个骑士之间使互相憎恨的），问亚瑟王至少要剔除多少个骑士才能顺利召开会议？ 建补图，补图中的边即为两个骑士能一起开会议。 引理： 一个双联通分量中存在奇环，那么整个双联通分量的点一定至少被一个奇环包含。 那么本题就是在点双连通分量中求是否是奇环即可，奇环判断用二分图判定判。容易发现二分图没有奇环，所以可以判断。 知识点：1、点双联通分量最好记录点而不是边 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;stack&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 1000 + 5; struct edge { int v, nxt; } ed[10000000 * 2 + 5]; int n, m, gx[MAXN][MAXN], hd[MAXN], en; int low[MAXN], dfn[MAXN], sz; int vcc_num; int av[MAXN], col[MAXN], ok[MAXN]; vector&lt;int &gt; vcc[MAXN]; stack&lt;int &gt; s; void ins(int u, int v) {ed[++en] = (edge){v, hd[u]}, hd[u] = en;} void tarjan(int u, int fa) { dfn[u] = low[u] = ++sz, s.push(u); for (int i = hd[u]; i &gt;= 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (e.v == fa) continue ; if (!dfn[e.v]) { tarjan(e.v, u); low[u] = min(low[u], low[e.v]); if (low[e.v] &gt;= dfn[u]) { int whw; ++vcc_num; do { whw = s.top(); s.pop(); vcc[vcc_num].push_back(whw); } while (whw != e.v); vcc[vcc_num].push_back(u); } } else low[u] = min(low[u], dfn[e.v]); } } int dfs_col(int u, int fa, int c) { int fl = 1; for (int i = hd[u]; i &gt;= 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (e.v == fa) continue ; if (!av[e.v]) continue ; if (col[e.v] == c) return false; if (!col[e.v]) { col[e.v] = 3 - c; int gg = dfs_col(e.v, u, 3 - c); if (!gg) fl = 0; } } return fl; } void clean() { ms(gx, 0), ms(hd, -1), en = -1; ms(low, 0), ms(dfn, 0), sz = 0; vcc_num = 0; ms(av, 0), ms(col, 0), ms(ok, 0); for (int i = 0; i &lt;= n; ++i) vcc[i].clear(); } int solve() { clean(); for (int x, y, i = 1; i &lt;= m; ++i) scanf(&quot;%d%d&quot;, &amp;x, &amp;y), gx[x][y] = gx[y][x] = 1; for (int i = 1; i &lt;= n; ++i) for (int j = i + 1; j &lt;= n; ++j) if (!gx[i][j]) ins(i, j), ins(j, i); for (int i = 1; i &lt;= n; ++i) if (!dfn[i]) tarjan(i, 0); /*for (int i = 1; i &lt;= vcc_num; ++i, puts(&quot;&quot;)) for (int j = 0; j &lt; (int)vcc[i].size(); ++j) printf(&quot;%d &quot;, vcc[i][j]);*/ for (int i = 1; i &lt;= vcc_num; ++i) { for (int j = 0; j &lt; (int)vcc[i].size(); ++j) col[vcc[i][j]] = 0, av[vcc[i][j]] = 1; col[vcc[i][0]] = 1; int fl = dfs_col(vcc[i][0], 0, 1); if (!fl) for (int j = 0; j &lt; (int)vcc[i].size(); ++j) ok[vcc[i][j]] = 1; for (int j = 0; j &lt; (int)vcc[i].size(); ++j) col[vcc[i][j]] = 0, av[vcc[i][j]] = 0; } int ans = 0; for (int i = 1; i &lt;= n; ++i) if (ok[i]) ++ans; cout &lt;&lt; n - ans &lt;&lt; endl; return 0; } } int main() { while (scanf(&quot;%d%d&quot;, &amp;flyinthesky::n, &amp;flyinthesky::m) == 2 &amp;&amp; flyinthesky::n &amp;&amp; flyinthesky::m) flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>二分图</tag>
        <tag>双连通分量</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1101D (树形DP + GCD)]]></title>
    <url>%2FCodeforces1101D%2F</url>
    <content type="text"><![CDATA[Codeforces 1101D题意：给出一棵无向带点权树，定义$dist(x,y)$为$x,y$之间的点(包含$x,y$)的个数，$g(x,y)$为$x,y$之间所有点权$gcd$，求最大的$dist(x,y)$，并且$g(x,y) \geq 2$ 由于$2 \times 10^5$以内的数最多$7$种质数相乘，所以可以对点权分解质因数，指数不重要，只考虑质因子，因为质因子相同的$gcd$一定$\geq 2$。 所以我一开始想对每个质因子建一棵树，然后在树上做类似直径的DP。这样的树的总大小不会超过$7n$，但是空间就比较爆炸，虽然可以用map之类的搞但是麻烦得要死还带了$log$。 其实不需要建那么多棵树，直接一次DFS，找到孩子如果和自己有公质因数，那么像树直径DP那样转移即可。 注意这里距离为点的个数而不是边的条数，DP 方程要特别注意 即某个点初始化长度即更新为1，然后转移时 ans = max(ans, st_dfs[u][k].second + st_dfs[v][j].second); st_dfs[u][k].second = max(st_dfs[u][k].second, st_dfs[v][j].second + 1); 注意加一的位置，画画图更好。 知识点：1、时间不够了也要冷静分析，一定相信自己能找出问题2、点权边权的问题要考虑清楚再写 //==========================Head files========================== #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;map&gt; #define LL long long #define db double #define mp make_pair #define pr pair&lt;int, int&gt; #define fir first #define sec second #define pb push_back #define ms(i, j) memset(i, j, sizeof i) using namespace std; //==========================Templates========================== inline int read() { int x = 0, f = 1; char c = getchar(); while(c &lt; &#39;0&#39; || c &gt; &#39;9&#39;){if (c == &#39;-&#39;) f = -1; c = getchar();} while(c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;){x = x * 10 + c - &#39;0&#39;; c = getchar();} return x * f; } inline LL readl() { LL x = 0, f = 1; char c = getchar(); while(c &lt; &#39;0&#39; || c &gt; &#39;9&#39;){if (c == &#39;-&#39;) f = -1; c = getchar();} while(c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;){x = x * 10 + c - &#39;0&#39;; c = getchar();} return x * f; } int power(int a, int b) { int ans = 1; while (b) { if(b &amp; 1) ans = ans * a; b &gt;&gt;= 1; a = a * a; } return ans; } int power_mod(int a, int b, int mod) { a %= mod; int ans = 1; while (b) { if(b &amp; 1) ans = (ans * a) % mod; b &gt;&gt;= 1, a = (a * a) % mod; } return ans; } LL powerl(LL a, LL b) { LL ans = 1ll; while (b) { if(b &amp; 1ll) ans = ans * a; b &gt;&gt;= 1ll;a = a * a; } return ans; } LL power_modl(LL a, LL b, LL mod) { a %= mod; LL ans = 1ll; while (b) { if(b &amp; 1ll) ans = (ans * a) % mod; b &gt;&gt;= 1ll, a = (a * a) % mod; } return ans; } LL gcdl(LL a, LL b) {return b == 0 ? a : gcdl(b, a % b);} LL abssl(LL a) {return a &gt; 0 ? a : -a;} int gcd(int a, int b) {return b == 0 ? a : gcd(b, a % b);} int abss(int a) {return a &gt; 0 ? a : -a;} //==========================Main body========================== #define LD &quot;%I64d&quot; #define D &quot;%d&quot; #define pt printf #define sn scanf #define pty printf(&quot;YES\n&quot;) #define ptn printf(&quot;NO\n&quot;) //==========================Code here========================== const LL MAXN = 200000 + 5; LL n, a[MAXN], ans = 1ll; vector&lt;LL &gt; st_a[MAXN]; vector&lt;LL &gt; G[MAXN]; vector&lt;pair&lt;LL, LL&gt; &gt; st_dfs[MAXN]; void dfs(LL u, LL fa) { for (LL i = 0; i &lt; (LL)st_a[u].size(); ++i) st_dfs[u].push_back(make_pair(st_a[u][i], 1)); for (LL i = 0; i &lt; (LL)G[u].size(); ++i) { LL v = G[u][i]; if (v != fa) { dfs(v, u); for (LL j = 0; j &lt; (LL)st_dfs[v].size(); ++j) { // st_dfs[v][j] LL whw = st_dfs[v][j].first; for (LL k = 0; k &lt; (LL)st_dfs[u].size(); ++k) { // st_dfs[u][k] LL gg = st_dfs[u][k].first; if (whw == gg) { ans = max(ans, st_dfs[u][k].second + st_dfs[v][j].second); //printf(&quot;ans=%d, u=%d, v=%d, whw=%d\n&quot;, ans, u, v, whw); st_dfs[u][k].second = max(st_dfs[u][k].second, st_dfs[v][j].second + 1); } } } } } } int main() { cin &gt;&gt; n; for (LL i = 1; i &lt;= n; ++i) scanf(&quot;%lld&quot;, &amp;a[i]); int fl = 0; for (LL i = 1; i &lt;= n; ++i) if (a[i] != 1) fl = 1; if (!fl) return printf(&quot;0\n&quot;), 0; for (LL u = 1; u &lt;= n; ++u) { LL tmp = a[u]; for (LL i = 2; i * i &lt;= tmp; ++i) if (tmp % i == 0) { st_a[u].push_back(i); while (tmp % i == 0) tmp /= i; } if (tmp != 1) st_a[u].push_back(tmp); sort(st_a[u].begin(), st_a[u].end()); } /*for (LL u = 1; u &lt;= n; ++u) { for (LL i = 0; i &lt; (LL)st_a[u].size(); ++i) printf(&quot;%d &quot;, st_a[u][i]); puts(&quot;&quot;); }*/ for (LL x, y, i = 1; i &lt; n; ++i) { scanf(&quot;%lld%lld&quot;, &amp;x, &amp;y); G[x].push_back(y), G[y].push_back(x); } dfs(1, 0); cout &lt;&lt; ans; return 0; } /* 5 2 2 2 2 2 1 2 2 3 1 4 4 5 3 2 2 2 1 2 2 3 */]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>GCD</tag>
        <tag>Codeforces</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「poj 3694」Network (边双连通分量缩点+LCA)]]></title>
    <url>%2Fpoj3694%2F</url>
    <content type="text"><![CDATA[poj 3696题意：给出一个无向图，动态加边，动态询问桥的条数。 先用 Tarjan 求出桥的条数并且边双连通分量缩点，变为一棵树，然后树上的边就是桥。发现如果加了一条边$(x,y)$，则树上构成一个环，树上的部分都不再是桥。所以可以将这个环又缩成点。具体实现将所有点并到$LCA(x,y)$处，显然可以并查集轻松维护。也可以不求 $ LCA $，将每个$(x,y)$路径上的点并到他的父亲，一样的效果。 本题还有种解法，即只求出最开始桥的条数，然后将搜索树树剖，将桥边权赋值为1，那么加了一条边$(x,y)$，则树上构成一个环，答案将减去树上$(x,y)$部分的权值，并且将$(x,y)$全部置为 $ 0 $ 知识点： 1、东西多的加后缀不会写错，比如原图后缀_o, 缩点图后缀_ecc2、倍增LCA的深度必须$dep(1)=1$ #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; int kase = 0; namespace flyinthesky { const int MAXN = 100000 + 5, LOGS = 20; struct edge { int v, nxt; } ed_o[200000 * 2 + 5], ed_ecc[200000 * 2 + 5]; int n_o, m_o, en_o, hd_o[MAXN], q; int low_o[MAXN], dfn_o[MAXN], sz_o, bri_o[200000 * 2 + 5]; int siz_ecc, bl_ecc[MAXN]; int en_ecc, hd_ecc[MAXN]; int f_ecc[MAXN], dis_ecc[MAXN], pre_ecc[MAXN][LOGS + 5], ans; // 加后缀不会写错 void ins_o(int u, int v) {ed_o[++en_o] = (edge){v, hd_o[u]}, hd_o[u] = en_o;} void ins_ecc(int u, int v) {ed_ecc[++en_ecc] = (edge){v, hd_ecc[u]}, hd_ecc[u] = en_ecc;} int find_ecc(int x) {return f_ecc[x] == x ? x : f_ecc[x] = find_ecc(f_ecc[x]);} void tarjan_o(int u, int pre) { low_o[u] = dfn_o[u] = ++sz_o; for (int i = hd_o[u]; i &gt;= 0; i = ed_o[i].nxt) { edge &amp;e = ed_o[i]; if (i != (pre ^ 1)) { if (!dfn_o[e.v]) { tarjan_o(e.v, i); // 注意不要写错成 u low_o[u] = min(low_o[u], low_o[e.v]); if (low_o[e.v] &gt; dfn_o[u]) bri_o[i] = bri_o[i ^ 1] = 1, ++ans; } else low_o[u] = min(low_o[u], dfn_o[e.v]); } } } void dfs1_o(int u, int gg) { bl_ecc[u] = gg; for (int i = hd_o[u]; i &gt;= 0; i = ed_o[i].nxt) { edge &amp;e = ed_o[i]; if (!bl_ecc[e.v] &amp;&amp; !bri_o[i]) dfs1_o(e.v, gg); } } void dfs_ecc(int u, int fa) { dis_ecc[u] = dis_ecc[fa] + 1, pre_ecc[u][0] = fa; // dis_ecc[1] 要为 1 for (int i = 1; i &lt;= LOGS; ++i) pre_ecc[u][i] = pre_ecc[pre_ecc[u][i - 1]][i - 1]; for (int i = hd_ecc[u]; i &gt;= 0; i = ed_ecc[i].nxt) { edge &amp;e = ed_ecc[i]; if (e.v != fa) { dfs_ecc(e.v, u); } } } int LCA_ecc(int a, int b) { if (dis_ecc[a] &lt; dis_ecc[b]) swap(a, b); for (int i = LOGS; i &gt;= 0; --i) if (dis_ecc[pre_ecc[a][i]] &gt;= dis_ecc[b]) a = pre_ecc[a][i]; if (a == b) return a; for (int i = LOGS; i &gt;= 0; --i) if (pre_ecc[a][i] != pre_ecc[b][i]) a = pre_ecc[a][i], b = pre_ecc[b][i]; return pre_ecc[a][0]; } void clean() { en_o = -1, ms(hd_o, -1); ms(low_o, 0), ms(dfn_o, 0), sz_o = 0, ms(bri_o, 0); siz_ecc = 0, ms(bl_ecc, 0); en_ecc = -1, ms(hd_ecc, -1); ms(dis_ecc, 0), ms(pre_ecc, 0), ans = 0; } int solve() { printf(&quot;Case %d:\n&quot;, ++kase); clean(); for (int x, y, i = 1; i &lt;= m_o; ++i) scanf(&quot;%d%d&quot;, &amp;x, &amp;y), ins_o(x, y), ins_o(y, x); tarjan_o(1, -1); // tarjan 找桥 for (int i = 1; i &lt;= n_o; ++i) // ecc 给点编号 if (!bl_ecc[i]) dfs1_o(i, ++siz_ecc); for (int u = 1; u &lt;= n_o; ++u) { // ecc 加边 for (int i = hd_o[u]; i &gt;= 0; i = ed_o[i].nxt) { edge &amp;e = ed_o[i]; if (bl_ecc[u] != bl_ecc[e.v]) ins_ecc(bl_ecc[u], bl_ecc[e.v]); // 注意不要写成原来的点 } } dfs_ecc(1, 0); // ecc 上预处理 for (int i = 1; i &lt;= siz_ecc; ++i) f_ecc[i] = i; scanf(&quot;%d&quot;, &amp;q); while (q--) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); int lca = find_ecc(LCA_ecc(find_ecc(bl_ecc[x]), find_ecc(bl_ecc[y]))); int cnt = 0; int now = find_ecc(bl_ecc[x]); while (now != lca) f_ecc[now] = lca, now = find_ecc(pre_ecc[now][0]), ++cnt; now = find_ecc(bl_ecc[y]); while (now != lca) f_ecc[now] = lca, now = find_ecc(pre_ecc[now][0]), ++cnt; ans -= cnt; printf(&quot;%d\n&quot;, ans); } printf(&quot;\n&quot;); return 0; } } int main() { while (scanf(&quot;%d%d&quot;, &amp;flyinthesky::n_o, &amp;flyinthesky::m_o) &amp;&amp; flyinthesky::n_o &amp;&amp; flyinthesky::m_o) flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>倍增</tag>
        <tag>双连通分量</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 2208」「Jsoi2010」连通数(Bitset)]]></title>
    <url>%2Fbzoj2208%2F</url>
    <content type="text"><![CDATA[BZOJ 2208题意：求无向图中每个点能到点的个数。 显然传递闭包模板，这里类似CH2101，这题是无向图而且数据范围小。所以可以尝试暴力。 暴力是$n^3$的，用 $bitset$ 优化即可达到 $\frac {n^3}{32}$ 具体就是将邻接矩阵存在$bitset$中, 枚举每个点$i$，然后找能到$i$的$j$，$i$能到的$j$也能到，所以把$i$的$bitset$并给$j$ 知识点： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;bitset&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { bitset&lt;2005 &gt; bs[2005]; int n; void clean() { } int solve() { clean(); scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) for (int x, j = 1; j &lt;= n; ++j) scanf(&quot;%1d&quot;, &amp;x), bs[i][j] = x; for (int i = 1; i &lt;= n; ++i) bs[i][i] = 1; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) if (bs[j][i]) bs[j] |= bs[i]; int ans = 0; for (int i = 1; i &lt;= n; ++i) ans += bs[i].count(); cout &lt;&lt; ans; return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1912」「Apio2010」巡逻 (树的直径，负权直径)]]></title>
    <url>%2Fbzoj1912%2F</url>
    <content type="text"><![CDATA[BZOJ 1912题意：给你一棵$n$点$n-1$边的树，要从$1$开始出发走遍所有边然后回到$1$，现在你可以加$K(1 \leq K \leq 2)$条边，并且加的边正好走一次，求出最小的路程。 明显如果不加边答案即为$2(n-1)$。考虑加一条边情况：此时加一条边在$(x,y)$之间，相当于使答案少了$dis(x,y)-1$。即只走这条边不用回溯$x,y$之间的边。我们想要答案最小，那么$dis(x,y)$要最大，所以$x,y$是直径的两个端点。 加两条边的情况，可以考虑先将直径加边，然后再将直径上的边删除，然后树变为森林，求每棵树的直径取最大值。但不一定第一条边加在直径最优，这个贪心是错的，但是分还挺多。我们考虑第一条边还是先加直径，但是我们之后将直径上的边权都改为$-1$，然后再对树求一下直径，然后答案减去直径长-1。因为-1相当于还原之前选的直径上的边，即这个位置还是走两次。感觉和Bzoj 1050类似。这里有负权就不能两次搜索找直径了，所以要用DP，DP有点类似点分治。最开始原图还是最好用两次搜索，这样方便找到端点。知识点1、负权时不能用搜两次找直径，要用DP2、想到的做法没有完全落实不要认为是对的，但是迫不得已可以写来骗分 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 100000 + 5; struct edge { int v, w, nxt; } ed[MAXN * 2]; int n, K, en, hd[MAXN], ans; int zj1, zj2, dis[MAXN], hh; void ins(int u, int v, int w) {ed[++en] = (edge){v, w, hd[u]}, hd[u] = en;} void dfs_dis(int u, int fa) { for (int i = hd[u]; i &gt;= 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (e.v != fa) { dis[e.v] = dis[u] + e.w; dfs_dis(e.v, u); } } } int dfs_bj(int u, int fa) { if (u == zj2) return 1; int fl = 0; for (int i = hd[u]; i &gt;= 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (e.v != fa) { int gg = dfs_bj(e.v, u); fl |= gg; if (gg) ed[i].w = ed[i ^ 1].w = -1; } } return fl; } void dfs_dp(int u, int fa) { for (int i = hd[u]; i &gt;= 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (e.v != fa) { dfs_dp(e.v, u); hh = max(hh, dis[e.v] + e.w + dis[u]); dis[u] = max(dis[u], dis[e.v] + e.w); } } } void clean() { en = -1, ms(hd, -1); } int solve() { clean(); scanf(&quot;%d%d&quot;, &amp;n, &amp;K), ans = (n - 1) * 2; for (int x, y, i = 1; i &lt; n; ++i) { scanf(&quot;%d%d&quot;, &amp;x, &amp;y); ins(x, y, 1), ins(y, x, 1); } ms(dis, 0), zj1 = 0, dfs_dis(1, 0); for (int i = 1; i &lt;= n; ++i) if (dis[i] &gt; dis[zj1]) zj1 = i; ms(dis, 0), zj2 = 0, dfs_dis(zj1, 0); for (int i = 1; i &lt;= n; ++i) if (dis[i] &gt; dis[zj2]) zj2 = i; ans = ans - dis[zj2] + 1; if (K == 1) return printf(&quot;%d\n&quot;, ans), 0; dfs_bj(zj1, 0); ms(dis, 0), hh = 0, dfs_dp(1, 0); ans = ans - hh + 1; printf(&quot;%d\n&quot;, ans); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>树的直径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1801」「Ahoi2009」中国象棋 (组合数DP)]]></title>
    <url>%2Fbzoj1801%2F</url>
    <content type="text"><![CDATA[BZOJ 1801题意：在一个$N$行$M$列的棋盘上，让你放若干个炮（可以是$0$个），使得没有一个炮可以攻击到另一个炮，请问有多少种放置方法。一个炮攻击到另一个炮，当且仅当它们在同一行或同一列中，且它们之间恰好有一个棋子。 先是可以发现每行每列最多放两个棋子。然后我们可以暴力剪枝过掉30分。根据暴力思路，我们按行DP，列记录状态。考虑优化，我们可以做一个三进制状压DP，记录每行的状态(放了0个，放了1个，放了2个)来DP。实质上，我们不需要知道具体的棋盘是怎么样的，我们可以像Bzoj 1079那样记录。设$dp(i,j,k)$为前$i$行有$j$列现在有$1$个棋子的，有$k$列现在有$2$个棋子的方案数。这样就非常好转移了，具体看代码转移注释。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;map&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL MO = 9999973, MAXN = 100 + 5; LL n, m, dp[MAXN][MAXN][MAXN]; LL C(LL n) {return n * (n - 1ll) / 2ll % MO;} void clean() { ms(dp, 0); } int solve() { clean(); cin &gt;&gt; n &gt;&gt; m; dp[0][0][0] = 1; for (int i = 0; i &lt; n; ++i) { for (int j = 0; j &lt;= m; ++j) { for (int k = 0; k + j &lt;= m; ++k) { // 1、不放 dp[i + 1][j][k] = (dp[i + 1][j][k] + dp[i][j][k]) % MO; // 2、放一个 // a 放在 0 列 if (m - j - k &gt;= 0) dp[i + 1][j + 1][k] = (dp[i + 1][j + 1][k] + dp[i][j][k] * (m - j - k) % MO) % MO; // b 放在 1 列 dp[i + 1][j - 1][k + 1] = (dp[i + 1][j - 1][k + 1] + dp[i][j][k] * j % MO) % MO; // 3、放两个 // a 放在 0 0 if (m - j - k &gt;= 0) dp[i + 1][j + 2][k] = (dp[i + 1][j + 2][k] + dp[i][j][k] * C(m - j - k) % MO) % MO; // b 放在 1 1 dp[i + 1][j - 2][k + 2] = (dp[i + 1][j - 2][k + 2] + dp[i][j][k] * C(j) % MO) % MO; // c 放在 0 1 if (m - j - k &gt;= 0) dp[i + 1][j][k + 1] = (dp[i + 1][j][k + 1] + dp[i][j][k] * j % MO * (m - j - k) % MO) % MO; } } } LL ans = 0; for (int j = 0; j &lt;= m; ++j) { for (int k = 0; k + j &lt;= m; ++k) { ans = (ans + dp[n][j][k]) % MO; } } cout &lt;&lt; ans; return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>计数DP</tag>
        <tag>Bzoj</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1123」「POI2008」BLO (Tarjan求割点)]]></title>
    <url>%2Fbzoj1123%2F</url>
    <content type="text"><![CDATA[Bzoj 1123题意：Byteotia城市有$n$个towns, $m$条双向roads. 每条road连接 两个不同的towns ,没有重复的road. 所有towns连通。输出$n$个数，代表如果把第$i$个点去掉，将有多少对点不能互通，点对有序。 求出割点，然后对每个割点进行计数，显然如果删去割点，原图变为几个连通块，对于每个联通块都与不在这个连通块的元素不连通，所以求出第一部分的解。然后因为割点父亲的联通块无法通过割点来判，那么减一下算就行。最后割点本身还有算，加上$n-1$ 对于不是割点的，答案为$2(n-1)$ 1、Tarjan 不要将 low dfn 写在外面2、计数题如果说了有序可以想想怎样有序做，不一定非要先求无序再求有序。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 100000 + 5; struct edge { int v, nxt; } ed[1000000 + 5]; int n, m, en, hd[MAXN], sz, dfn[MAXN], low[MAXN], siz[MAXN], iscut[MAXN]; LL ans[MAXN]; void ins(int u, int v) {ed[++en] = (edge){v, hd[u]}, hd[u] = en;} void tarjan(int u, int fa) { int child = 0; dfn[u] = low[u] = ++sz, siz[u] = 1; LL sum = 0ll; for (int i = hd[u]; i &gt;= 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (e.v != fa) { if (!dfn[e.v]) { tarjan(e.v, u); ++child; if (low[e.v] &gt;= dfn[u]) iscut[u] = 1, ans[u] += 1ll * (n - siz[e.v]) * siz[e.v], sum += siz[e.v]; low[u] = min(low[u], low[e.v]); siz[u] += siz[e.v]; } else low[u] = min(low[u], dfn[e.v]); } } if (fa == 0 &amp;&amp; child &lt;= 1) iscut[u] = 0; ans[u] += n - 1ll; ans[u] += 1ll * (sum + 1ll) * (n - sum - 1ll); if (!iscut[u]) ans[u] = 2ll * (n - 1ll); } void clean() { ms(hd, -1), en = -1, sz = 0; ms(dfn, 0), ms(low, 0), ms(ans, 0), ms(iscut, 0); } int solve() { clean(); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int x, y, i = 1; i &lt;= m; ++i) { scanf(&quot;%d%d&quot;, &amp;x, &amp;y); ins(x, y), ins(y, x); } tarjan(1, 0); for (int i = 1; i &lt;= n; ++i) printf(&quot;%lld\n&quot;, ans[i]); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>Tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「poj 3417」Network (树上差分)]]></title>
    <url>%2Fpoj3417%2F</url>
    <content type="text"><![CDATA[poj 3417题意：一棵有$N$个点的树，再往里面加入$M$条新边，现在要破坏其中的两条边，要求一条是原来树中的边，一条是新边，然后使图不连通，求方案的数量。发现加的新边会使树产生环。观察可得一条新边$(x,y)$如果在树上$(u,v)$路径都加一，那么最后如果想使图不连通，则只能删边权为0,1的点，对于边权为0的边能删$m$次，而边权为1的边只能删1次。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 200000 + 5, LOGS = 20; struct edge { int v, nxt; } ed[MAXN * 2]; int n, m, cf[MAXN], pre[MAXN][LOGS + 5], dep[MAXN], en, hd[MAXN]; void ins(int x, int y) {ed[++en] = (edge){y, hd[x]}, hd[x] = en;} void dfs(int u, int fa) { dep[u] = dep[fa] + 1, pre[u][0] = fa; for (int i = 1; i &lt;= LOGS; ++i) pre[u][i] = pre[pre[u][i - 1]][i - 1]; for (int i = hd[u]; i &gt; 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (e.v != fa) dfs(e.v, u); } } int LCA(int a, int b) { if (dep[a] &lt; dep[b]) swap(a, b); for (int i = LOGS; i &gt;= 0; --i) if (dep[pre[a][i]] &gt;= dep[b]) a = pre[a][i]; if (a == b) return a; for (int i = LOGS; i &gt;= 0; --i) if (pre[a][i] != pre[b][i]) a = pre[a][i], b = pre[b][i]; return pre[a][0]; } int ans = 0ll; void dfs2(int u, int fa) { for (int i = hd[u]; i &gt; 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (e.v != fa) dfs2(e.v, u), cf[u] += cf[e.v]; } if (fa != 0) { if (cf[u] == 0) ans += m; if (cf[u] == 1) ++ans; } } void clean() { en = 0, ms(hd, -1), ms(dep, 0), ms(cf, 0); } int solve() { clean(); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int x, y, i = 1; i &lt; n; ++i) { scanf(&quot;%d%d&quot;, &amp;x, &amp;y); ins(x, y), ins(y, x); } dfs(1, 0); for (int x, y, i = 1; i &lt;= m; ++i) { scanf(&quot;%d%d&quot;, &amp;x, &amp;y); if (x == y) continue ; // 注意重边 cf[LCA(x, y)] -= 2, ++cf[x], ++cf[y]; } dfs2(1, 0); printf(&quot;%d\n&quot;, ans); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>差分序列</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1799」「Ahoi2009」同类分布 (数位DP)]]></title>
    <url>%2Fbzoj1799%2F</url>
    <content type="text"><![CDATA[BZOJ 1799题意：给出$a,b$，求出$[a,b]$中各位数字之和能整除原数的数的个数。设$dp(a,i,j)$为前$a$位数字和为$i$，数模上数字和值为$j$的个数。枚举数字和，然后求即可。转移方程 $$dp(a,i,j)+=dp(a-1,i+p,(j+p)\% mod)$$ 其中$mod$为枚举的数字和，$p$为$a$位上枚举填的数。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { LL A, B, len, b[25], MOD, dp[25][170][170], cf[100]; LL dfs(LL a, LL sum, LL gg, LL p, LL limit) { if (a == 0) { if (!sum) return 0ll; if (gg % sum == 0 &amp;&amp; sum == MOD) return 1ll; return 0ll; } if (!limit &amp;&amp; p != -233 &amp;&amp; dp[a][sum][gg % MOD] &gt;= 0) return dp[a][sum][gg % MOD]; LL ed = (limit ? b[a] : 9), ret = 0; for (LL i = 0; i &lt;= ed; ++i) { if (i == 0 &amp;&amp; p == -233) ret += dfs(a - 1, 0, 0, -233, (limit &amp;&amp; (ed == i))); else ret += dfs(a - 1, sum + i, gg + i * cf[a - 1], i, (limit &amp;&amp; (ed == i))); } if (!limit &amp;&amp; p != -233) dp[a][sum][gg % MOD] = ret; return ret; } LL getans(LL x) { LL ret = 0; len = 0; while (x) b[++len] = x % 10, x /= 10; for (MOD = 1; MOD &lt;= 9 * len; ++MOD) { ms(dp, -1); ret += dfs(len, 0, 0, -233, 1); } return ret; } void clean() { } int solve() { clean(); cf[0] = 1ll; for (LL i = 1; i &lt;= 100; ++i) cf[i] = cf[i - 1] * 10ll; cin &gt;&gt; A &gt;&gt; B; cout &lt;&lt; getans(B) - getans(A - 1) &lt;&lt; endl; return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>数位DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1026」「SCOI2009」windy数 (数位DP(模板))]]></title>
    <url>%2Fbzoj1026%2F</url>
    <content type="text"><![CDATA[Bzoj 1026题意：不含前导零且相邻两个数字之差至少为$2$的正整数被称为windy数。 在$A$和$B$之间，包括$A$和$B$，总共有多少个windy数？数位DP模板。设$dp(i, pre)$为第$i$位前面的值为$pre$的windy数的个数。然后一般数位DP用记忆化完成。所以记忆化。基本思想是试填法。具体实现看代码，其中的限制意思是本位上不能填完所有的数，例如最大数字为41002，如果首位填了4，后面第二位只能填0、1，若后面第二位填了1，则后面第三位只能填0。如果第二位填了0，则后面第三位可以填$[0,9]$中任意数字。以此类推。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { int A, B, len, b[20], dp[20][20]; int abss(int x) {return x &gt; 0 ? x : -x;} int dfs(int a, int pre, int limit) { if (a == 0) return 1; // 合法情况 if (pre != -233 &amp;&amp; !limit &amp;&amp; dp[a][pre] &gt;= 0) return dp[a][pre]; //当前不是前导零且没有被限制且已经记忆化搜索过 int ret = 0; int ed = (limit ? b[a] : 9); // 上限 for (int i = 0; i &lt;= ed; ++i) { if (abss(i - pre) &gt;= 2) { int p = i; if (pre == -233 &amp;&amp; i == 0) p = -233; // 前导零 ret += dfs(a - 1, p, (limit &amp;&amp; (i == ed))); } } if (pre != -233 &amp;&amp; !limit) dp[a][pre] = ret; //不是前导零并且没有限制才记忆化 return ret; } int getans(int x) { int tmp = x; len = 0; while (tmp) b[++len] = tmp % 10, tmp /= 10; // 分解数位 ms(dp, -1); return dfs(len, -233, 1); } void clean() { } int solve() { clean(); scanf(&quot;%d%d&quot;, &amp;A, &amp;B); printf(&quot;%d\n&quot;, getans(B) - getans(A - 1)); // 分问题 return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>数位DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1073E(数位DP, 所有数和+状压DP)]]></title>
    <url>%2FCodeforces1073E%2F</url>
    <content type="text"><![CDATA[Codeforces 1073E题意：给你一个范围$[l,r]$，求其中数字数位上最多有$k$个不同的数的和。这个数位DP如果求个数就比较容易，但是这里求和就比较麻烦。先考虑求个数，设$dp(i,st)$为前$i$位的数的集合$st$的个数。注意前导零转移即可。如果要求和，那么填完数对每个数位都要求一下对答案贡献。即如果填了第一位，那么后面填的可行个数将就是第一位上的填数贡献次数。以此类推。具体实现看代码。知识点：1、样例过不了难调，自己做小数据调 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL MO = 998244353; LL l, r, k, dp[20][1050], f[20][1050]; LL len, b[20], cf[30]; LL dfs(LL a, LL st, LL limit, LL p, LL &amp;gx) { if (a == 0ll) return gx = 1, 0; if (p != -233 &amp;&amp; !limit &amp;&amp; dp[a][st] &gt;= 0ll) return gx = f[a][st], dp[a][st]; LL cnt = 0ll; for (LL i = 0ll; i &lt;= 9ll; ++i) if (st &amp; (1ll &lt;&lt; i)) ++cnt; LL ed = (limit ? b[a] : 9ll), ret = 0ll, hh = 0ll; for (LL i = 0ll; i &lt;= ed; ++i) { LL whw = 0ll; if (i == 0 &amp;&amp; p == -233) ret = (ret + dfs(a - 1ll, st, (limit &amp;&amp; (ed == i)), -233, whw)) % MO; else if (st &amp; (1ll &lt;&lt; i)) ret = (ret + dfs(a - 1ll, st, (limit &amp;&amp; (ed == i)), i, whw)) % MO; else if (cnt &lt; k) ret = (ret + dfs(a - 1ll, st | (1ll &lt;&lt; i), (limit &amp;&amp; (ed == i)), i, whw)) % MO; ret = (ret + i * cf[a] % MO * whw % MO), hh = (hh + whw) % MO; } if (p != -233 &amp;&amp; !limit) dp[a][st] = ret, f[a][st] = hh; return gx = hh, ret; } LL getans(LL x) { len = 0ll; while (x) b[++len] = x % 10ll, x /= 10ll; ms(dp, -1ll); return dfs(len, 0ll, 1ll, -233, len); } void clean() { } int solve() { clean(); cf[1] = cf[0] = 1ll; for (LL i = 2; i &lt;= 21; ++i) cf[i] = (cf[i - 1] * 10ll) % MO; scanf(&quot;%I64d%I64d%I64d&quot;, &amp;l, &amp;r, &amp;k); LL rans = getans(r), lans = getans(l - 1); printf(&quot;%I64d\n&quot;, ((rans - lans) % MO + MO) % MO); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>数位DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「poj 1734」Sightseeing trip (Floyd最小环)]]></title>
    <url>%2Fpoj1734%2F</url>
    <content type="text"><![CDATA[poj 1734给定一个无向图，求出节点数至少为$3$的最小环。输出方案 当Floyd中最外层循环到$k$，$dis(i,j)$则代表不经过大于等于$k$编号节点的最短路。 所以最小环我们可以枚举必过某个点的最小环是多少。即考虑过$k$点最小环，且只由不大于等于$k$编号节点的点组成。那么最小环即为 $$\min_{1 \leq i &lt; j &lt; k}(dis(i,j)+a(i,k)+a(k,j))$$ 由于对称性，所以不会影响结果。输出方案即根据DP转移来回溯答案。具体看代码实现。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int INF = 1000000000; int n, m, G[305][305], a[305][305], pre[305][305]; vector&lt;int &gt; path; void getpath(int x, int y) { if (!pre[x][y]) return ; getpath(x, pre[x][y]); path.push_back(pre[x][y]); getpath(pre[x][y], y); } void clean() { for (int i = 0; i &lt;= n; ++i) for (int j = 0; j &lt;= n; ++j) pre[i][j] = 0, a[i][j] = INF; for (int i = 0; i &lt;= n; ++i) a[i][i] = 0; } int solve() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); clean(); for (int x, y, v, i = 1; i &lt;= m; ++i) { scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;v); a[x][y] = a[y][x] = min(a[x][y], v); } memcpy(G, a, sizeof a); int ans = INF; for (int k = 1; k &lt;= n; ++k) { for (int i = 1; i &lt; k; ++i) for (int j = i + 1; j &lt; k; ++j) { if (ans &gt; (LL)G[i][j] + a[i][k] + a[k][j]) { // 3 个数相加 ans = G[i][j] + a[i][k] + a[k][j]; path.clear(); path.push_back(i), getpath(i, j), path.push_back(j), path.push_back(k); } } for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) { if (G[i][j] &gt; G[i][k] + G[k][j]) { G[i][j] = G[i][k] + G[k][j]; pre[i][j] = k; } } } if (ans == INF) return printf(&quot;No solution.\n&quot;), 0; for (int i = 0; i &lt; (int)path.size(); ++i) printf(&quot;%d &quot;, path[i]); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 2200」「Usaco2011 Jan」道路和航线(最短路+DAG图拓扑序转移)]]></title>
    <url>%2Fbzoj2200%2F</url>
    <content type="text"><![CDATA[BZOJ 2200题意：无向图中求$S$出发到每个点的最短路。并且有一些单向边，如果有一条单向边可以从$A_i$到$B_i$，那么保证不可能通过一些双向边和单向边从$B_i$回到$A_i$ 显然最短路模板，但是有负权图并且卡 SPFA。所以我们利用 如果有一条单向边可以从$A_i$到$B_i$，那么保证不可能通过一些双向边和单向边从$B_i$回到$A_i$ 发现这些有向边将无向图分成了几个联通块，即不加入这些有向边，原图为几个连通块。所以我们将联通块缩点，然后就成了 DAG 上的最短路，然后拓扑序来求即可。 具体实现看代码。 知识点：1、负权图转移要注意判 != INF #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 25000 + 5; const LL INF = 4223372036854775808ll; struct edge { int u, v, w; }ed[200000 + 5]; struct data { int u; LL dis; bool operator &lt; (const data &amp;rhs) const {return dis &gt; rhs.dis;} }; int n, m, p, s, f[MAXN], en, ino[MAXN], vis[MAXN]; // f[节点编号], ino[联通块代表编号], vis[节点编号] vector&lt;int &gt; G[MAXN], whw[MAXN]; // G[节点编号][ith]=边编号 LL dis[MAXN]; //dis[节点编号] queue&lt;int &gt; qq; // qq&lt;联通块代表编号&gt; int find(int x) {return x == f[x] ? x : f[x] = find(f[x]);} // find(节点编号) void ins(int x, int y, int v) {ed[++en] = (edge){x, y, v}, G[x].push_back(en);} // ins(节点编号, 节点编号, 值) priority_queue&lt;data &gt; q; // q&lt;信息&gt;[联通块代表编号] void dij(int nx) { for (int i = 0; i &lt; (int)whw[nx].size(); ++i) q.push((data){whw[nx][i], dis[whw[nx][i]]}); while (!q.empty()) { data p = q.top(); q.pop(); if (vis[p.u]) continue ; vis[p.u] = 1; for (int i = 0; i &lt; (int)G[p.u].size(); ++i) { edge &amp;e = ed[G[p.u][i]]; if (dis[e.v] &gt; dis[p.u] + e.w &amp;&amp; dis[p.u] != INF) { // 负权图注意判 != INF dis[e.v] = dis[p.u] + e.w; if (find(e.v) == nx) q.push((data){e.v, dis[e.v]}); } } } for (int i = 0; i &lt; (int)whw[nx].size(); ++i) { // 把边删完 int u = whw[nx][i]; for (int j = 0; j &lt; (int)G[u].size(); ++j) { int v = ed[G[u][j]].v; if (find(v) == nx) continue ; --ino[find(v)]; if (ino[find(v)] == 0) qq.push(find(v)); } } } void clean() { ms(vis, 0), ms(ino, 0), en = 0; } int solve() { clean(); scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;p, &amp;s); for (int i = 0; i &lt;= n; ++i) f[i] = i; for (int x, y, v, i = 1; i &lt;= m; ++i) { scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;v); ins(x, y, v), ins(y, x, v); int hx = find(x), hy = find(y); if (hx != hy) f[hx] = hy; } for (int x, y, v, i = 1; i &lt;= p; ++i) { scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;v), ins(x, y, v); } for (int i = 2 * m + 1; i &lt;= 2 * m + p; ++i) { int hx = find(ed[i].u), hy = find(ed[i].v); if (hx != hy) ++ino[hy]; } for (int i = 1; i &lt;= n; ++i) whw[find(i)].push_back(i); for (int i = 1; i &lt;= n; ++i) dis[i] = INF; dis[s] = 0ll; for (int i = 1; i &lt;= n; ++i) if (find(i) == i &amp;&amp; ino[i] == 0) qq.push(i); while (!qq.empty()) { int p = qq.front(); qq.pop(); dij(p); } for (int i = 1; i &lt;= n; ++i) if (dis[i] == INF) printf(&quot;NO PATH\n&quot;); else printf(&quot;%lld\n&quot;, dis[i]); return 0; } } int main() { flyinthesky::solve(); return 0; } //21:17 - :34 - 20:48 - 20:48 - 20:56 //Start - Finish - Static - Sample - AC /* 4 0 4 3 1 3 5 1 4 4 3 4 6 4 2 6 */]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>最短路</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Hdu 2196」Computer (树形DP(二次扫描换根) / 树的直径)]]></title>
    <url>%2Fhdu2196%2F</url>
    <content type="text"><![CDATA[Hdu 2196题意：给出一棵带边权树，求出每个点的到最远点的距离。 显然的一道无根树DP，所以先DP求一次最远点，然后再看怎么转移。记$maxd(u)$为以$u$为根子树中的节点到根的最远点的距离。这里有一种非常麻烦的情况就是父亲的题目所求答案的这条最长链就在这个分支中。那么我们只能选取一条其他分支的最大答案进行更新。设$dp(u,0/1)$为以$u$为根到$u$点的最远点的距离。直接转移即可。 树直径做法：因为每个点到某个直径端点距离最远，所以求出直径端点再搜一次即可。 知识点1、被自己举了反例的东西一定要记得完全错误再叉！ #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 10000 + 5; int n, maxd[MAXN], cid[MAXN], dp[MAXN][2]; // 0 最远，1 次远 vector&lt;int &gt; G[MAXN], val[MAXN]; void dfs1(int u, int fa) { cid[u] = maxd[u] = 0; for (int i = 0; i &lt; (int)G[u].size(); ++i) { int v = G[u][i]; if (v != fa) { dfs1(v, u); if (maxd[v] + val[u][i] &gt; maxd[u]) { cid[u] = maxd[u]; maxd[u] = maxd[v] + val[u][i]; } else if (maxd[v] + val[u][i] &gt; cid[u]) cid[u] = maxd[v] + val[u][i]; } } } void dfs2(int u, int fa) { for (int i = 0; i &lt; (int)G[u].size(); ++i) { int v = G[u][i]; if (v != fa) { if (val[u][i] + maxd[v] == dp[u][0]) { // 父亲最长距在本孩子 int gg[2]; gg[0] = dp[u][1] + val[u][i], gg[1] = maxd[v]; sort(gg, gg + 2); dp[v][0] = gg[1], dp[v][1] = gg[0]; } else { dp[v][0] = dp[u][0] + val[u][i], dp[v][1] = dp[u][1] + val[u][i]; // 不在一定是上面的u最优 } dfs2(v, u); } } } void clean() { ms(dp, 0); for (LL i = 0; i &lt;= n; ++i) G[i].clear(), val[i].clear(); } int solve() { clean(); for (int p, v, i = 2; i &lt;= n; ++i) { scanf(&quot;%d%d&quot;, &amp;p, &amp;v); G[i].push_back(p), G[p].push_back(i); val[i].push_back(v), val[p].push_back(v); } dfs1(1, 0); dp[1][0] = maxd[1], dp[1][1] = cid[1], dfs2(1, 0); for (int i = 1; i &lt;= n; ++i) printf(&quot;%d\n&quot;, dp[i][0]); return 0; } } int main() { while (scanf(&quot;%d&quot;, &amp;flyinthesky::n) == 1) flyinthesky::solve(); return 0; } /* 9 1 5 2 4 3 1 1 6 5 1 5 2 5 1 7 3 */]]></content>
      <categories>
        <category>Hdu</category>
      </categories>
      <tags>
        <tag>树的直径</tag>
        <tag>树形DP</tag>
        <tag>Hdu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 2726」「SDOI2012」任务安排 (DP 费用提前计算，斜率优化)]]></title>
    <url>%2Fbzoj2726%2F</url>
    <content type="text"><![CDATA[CH 5A01 (简化版)Bzoj 2726 (斜率优化版)题意：见上。很容易想出二维DP，即$dp(i,j)$表示前$i$个任务分了$j$个的最小值。本题没有限制分多少份，所以第二维我们想一想是不是不必要的？删去第二维我们就不能之前前面执行了多少次$S$，那么就算不出来，所以这里有一种方法是将费用提前计算。设$dp(i)$表示前$i$个任务最小值。则$$dp(i)=\min(dp(j)+\sum_{k=1}^i T_k \times \sum_{k=j+1}^i C_k + S \times \sum_{k=j+1}^n C_k)$$注意到后面的$S \times \sum_{k=j+1}^n C_k)$，这个就是将费用提前计算了，因为选择了这样的方式必然会对后面的任务产生这样的贡献，所以可以提前计算。 然后式子显然能斜率优化。但是斜率不单增，在凸壳中二分即可。则Bzoj 2726可解。 知识点：1、DP 费用提前计算2、斜率优化实数会被卡精度，用叉积来判3、二分 //CH 5A01 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 5000 + 5; const LL INF = 2223372036854775808ll; int n, s, T[MAXN], C[MAXN]; LL Tsum[MAXN], Csum[MAXN], dp[MAXN]; void clean() { } int solve() { clean(); scanf(&quot;%d%d&quot;, &amp;n, &amp;s); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d%d&quot;, &amp;T[i], &amp;C[i]); Tsum[0] = Csum[0] = 0; for (int i = 1; i &lt;= n; ++i) Tsum[i] = Tsum[i - 1] + T[i], Csum[i] = Csum[i - 1] + C[i]; for (int i = 0; i &lt;= n; ++i) dp[i] = INF; dp[0] = 0; for (int i = 1; i &lt;= n; ++i) { for (int j = 0; j &lt; i; ++j) { LL tT = Tsum[i]; LL tC = Csum[i] - Csum[j], tC2 = Csum[n] - Csum[j]; dp[i] = min(dp[i], dp[j] + tT * tC + s * tC2); } } cout &lt;&lt; dp[n]; return 0; } } int main() { flyinthesky::solve(); return 0; } //Bzoj 2726 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL MAXN = 300000 + 5; LL n, S, tt[MAXN], cc[MAXN]; LL T[MAXN], C[MAXN], dp[MAXN], que[MAXN], l, r; //db getK(LL a, LL b) {return 1.0 * (dp[a] - dp[b]) / (C[a] - C[b]);} LL fnd(db w) { if (l == r) return l; LL x = 1, y = r; // 只到 r while (x &lt; y) { LL mid = (x + y) &gt;&gt; 1; //if (getK(que[mid], que[mid + 1]) &lt;= w) x = mid + 1; else y = mid; 实数会被卡精度 if (dp[que[mid + 1]] - dp[que[mid]] &lt;= w * (C[que[mid + 1]] - C[que[mid]])) x = mid + 1; else y = mid; } return x; } void clean() { ms(T, 0), ms(C, 0), ms(dp, 0); } int solve() { clean(); scanf(&quot;%lld%lld&quot;, &amp;n, &amp;S); for (LL i = 1; i &lt;= n; ++i) scanf(&quot;%lld%lld&quot;, &amp;tt[i], &amp;cc[i]); for (LL i = 1; i &lt;= n; ++i) C[i] = C[i - 1] + cc[i], T[i] = T[i - 1] + tt[i]; l = r = 1, que[1] = 0; for (LL i = 1; i &lt;= n; ++i) { LL pos = fnd(S + T[i]); dp[i] = dp[que[pos]] - (S + T[i]) * C[que[pos]] + T[i] * C[i] + S * C[n]; //while (l &lt; r &amp;&amp; getK(que[r], que[r - 1]) &gt;= getK(i, que[r])) --r; while (l &lt; r &amp;&amp; (dp[que[r]] - dp[que[r - 1]]) * (C[i] - C[que[r]]) &gt;= (dp[i] - dp[que[r]]) * (C[que[r]] - C[que[r - 1]])) --r; que[++r] = i; } cout &lt;&lt; dp[n]; return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <tags>
        <tag>DP</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「poj 1737」Connected Graph (DP + 组合数, 无向连通有标号图计数)]]></title>
    <url>%2Fpoj1737%2F</url>
    <content type="text"><![CDATA[poj 1737题意：给定$n$，求出$n$个点无向连通有标号图的个数 显然设$dp(i)$为$i$个点的无向连通有标号图的个数。但是并不好直接算出来，所以我们可以先算不连通的，那么相当于求的图是至少有两个连通块。然后我们通过$1$所在的连通分量来划分，即对当前的$dp(i)$, 枚举$1$所在的连通分量的节点个数$j$，显然有 $C^{j-1}_{i-1}$ 种情况。然后另外$i-j$个点任意构成无向图。所以最后的答案 $$ dp(i)=2^{\frac{i(i-1)}{2}} - \sum_{j=1}^{i-1}dp(j) \times C^{j-1}_{i-1} \times 2^{\frac{(i-j)(i-j+1)}{2}}$$ 转移即可。 1、通过$1$（某点）所在的连通分量来划分在组合数学中划分非常好用。 // 无高精度 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { LL n, dp[55]; LL C(LL n, LL m) { LL ans = 1ll; for (LL i = 1ll; i &lt;= n; ++i) ans *= i; for (LL i = 1ll; i &lt;= m; ++i) ans /= i; for (LL i = 1ll; i &lt;= n - m; ++i) ans /= i; return ans; } void clean() { ms(dp, 0); } int solve() { clean(); dp[1] = 1ll; for (LL i = 2; i &lt;= n; ++i) { dp[i] = (1ll &lt;&lt; (i * (i - 1ll) / 2ll)); for (LL j = 1; j &lt; i; ++j) { dp[i] -= dp[j] * C(i - 1ll, j - 1ll) * (1 &lt;&lt; ((i - j) * (i - j - 1) / 2ll)); } } cout &lt;&lt; dp[n] &lt;&lt; endl; return 0; } } int main() { while (scanf(&quot;%lld&quot;, &amp;flyinthesky::n) == 1 &amp;&amp; flyinthesky::n) flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>计数DP</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 559C (DP+组合数经典模型)]]></title>
    <url>%2FCodeforces559C%2F</url>
    <content type="text"><![CDATA[Codeforces 559C题意：给定一个$H \cdot W$的棋盘，棋盘上只有$N$个格子是黑色的，其他格子都是白色的。在棋盘左上角有一个卒，每一步可以向右或者向下移动一格，并且不能移动到黑色格子中。求这个卒从左上角移动到右下角，一共有多少种可能的路线。 刚开始想到本题就是求出过黑点的方案，然后用总方案减一下就好。所以设出了$f(i)$表示前$i$个黑点中途一定走到黑点的方案，因此为了转移的方便，我们将点按$x,y$增序排序。方便起见，将$(1,1),(h,w)$加入黑点。然后转移发现并不好转移。。然后我就设出答案的一个函数$g(i)=C^{x_i-1}_{x_i+y_i-2} - f(i)$表示前$i$个黑点中途一定不走到黑点的方案。 然后对于$f(i)$的转移就可以是$f(i)=g(j) \cdot C^{\Delta x}_{\Delta x+\Delta y}$ 然后可以将两个函数合并成一个函数 $$dp(i)=C^{x_i-1}_{x_i+y_i-2} - dp(j) \cdot C^{\Delta x}_{\Delta x+\Delta y}$$ 然后转移即可。答案为$dp(n)$ 1、定义了$dp$状态或者函数，要将定义写明白，不要自己在心中知道了就行，否则会混乱2、认为错的东西可以捡回来继续探究3、阶乘算 $C$ 要注意 $C$ 中参数取值范围，切忌直接用 $H, W$ 的范围！ #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL MO = 1e9 + 7; struct data { int x, y; bool operator &lt; (const data &amp;rhs) const { return (x == rhs.x) ? y &lt; rhs.y : x &lt; rhs.x; } }pnt[2000 + 5]; int h, w, n; LL fac[300000 + 5], inv_fac[300000 + 5], dp[2000 + 5]; LL ksm(LL a, LL b) { LL bs = a, ans = 1ll; while (b) { if (b &amp; 1ll) ans = (ans * bs) % MO; bs = (bs * bs) % MO; b &gt;&gt;= 1ll; } return ans; } LL C(LL n, LL m) { if (n &lt; 0 || m &lt; 0) return 0ll; if (n &lt; m) return 0ll; LL ans = fac[n]; ans = (ans * inv_fac[m]) % MO; ans = (ans * inv_fac[n - m]) % MO; return ans; } void clean() { ms(dp, 0); } int solve() { clean(); scanf(&quot;%d%d%d&quot;, &amp;h, &amp;w, &amp;n); pnt[n + 1] = (data){1, 1}, pnt[n + 2] = (data){h, w}; for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d%d&quot;, &amp;pnt[i].x, &amp;pnt[i].y); n += 2, sort(pnt + 1, pnt + 1 + n); fac[0] = inv_fac[0] = 1ll; for (int i = 1; i &lt;= 300000; ++i) fac[i] = (fac[i - 1] * i) % MO, inv_fac[i] = (inv_fac[i - 1] * ksm(i, MO - 2)) % MO; // 阶乘要处理到 2 * n, 因为下面会用到 (dx + dy)! for (int i = 1; i &lt;= n; ++i) { dp[i] = C(pnt[i].x + pnt[i].y - 2ll, pnt[i].x - 1ll); for (int j = 2; j &lt; i; ++j) { int dx = pnt[i].x - pnt[j].x, dy = pnt[i].y - pnt[j].y; // dx, dy 本身已经减1，无需再减 dp[i] = (dp[i] - C(dx + dy, dx) * dp[j] % MO + MO) % MO; } } cout &lt;&lt; dp[n]; return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>计数DP</tag>
        <tag>Codeforces</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1009」「HNOI2008」GT考试 (匹配状态DP+KMP+矩阵快速幂)]]></title>
    <url>%2Fbzoj1009%2F</url>
    <content type="text"><![CDATA[Bzoj 1009题意：给定$m$长值域$[0,9]$数列$A_i$，要求构造$n$长值域$[0,9]$数列$X_i$使得$A_i$不是$X_i$的子串，即$X_i$中不出现$A_i$，求方案数。$n \leq 10^9, m \leq 20$ 类似CF 1096D，CF 1015F以及AC自动机的相关方法，我们这里可以定义$dp(i,j)$为构造串$X_i$前$i$个字符与$A_i$匹配了$j$位的方案数。最后答案即为$\sum_{i=0}^{m-1} dp(n,i)$，即不包含完全匹配的串的方案转移方程为(刷表)：$$dp(i+1,x)+=dp(i,j)$$$x$为在当前后面放一个$[0,9]$之间的数后匹配的影响，特别的，如果匹配了$m$位，以后转移都只能从$m$转移而来。这个$x$可用 $KMP$ 预处理。这里$n \leq 10^9$ 显然矩阵优化，构造矩阵即可。注意$j=0$处转移矩阵：$dp(i,0)$一定可以以某个$[0,9]$之间的数转移到$dp(i+1, 1)$，所以在矩阵中设$(0,1)=1$;$dp(i,0)$一定可以有$9$种情况转移到$dp(i+1, 0)$，即仍然不匹配。所以在矩阵中设$(0,0)=1$ 发现一个新的 $Debug$ 方法：过不去样例，可以测测自己写的小数据，这个数据可能非常小，如果程序都过不去的话，那么肯定这里都有问题。就能各个击破，发现 $Bug$。 知识点：1、过不了样例可以测测自己出的小数据 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { LL n, m, p, a[20 + 5], f[20 + 5], whw[20 + 5][10 + 5]; // n 位数. m-&gt;a[maxM], f[maxM], whw[maxM][0~9] struct matrix { LL x, y, a[20 + 5][20 + 5]; matrix(LL _x, LL _y) {x = _x, y = _y, ms(a, 0);} }; matrix mul(matrix a, matrix b) { matrix ret(a.x, b.y); for (LL i = 0; i &lt;= a.x; ++i) { for (LL j = 0; j &lt;= b.y; ++j) { for (LL k = 0; k &lt;= a.y; ++k) { ret.a[i][j] = (ret.a[i][j] + (a.a[i][k] * b.a[k][j]) % p) % p; } } } return ret; } matrix ksm(matrix a, LL b) { matrix bs = a, ans(a.x, a.y); LL fl = 0; while (b) { if (b &amp; 1) { if (!fl) fl = 1, ans = bs; else ans = mul(ans, bs); } bs = mul(bs, bs); b &gt;&gt;= 1; } return ans; } void clean() { ms(whw, 0); } int solve() { clean(); scanf(&quot;%lld%lld%lld&quot;, &amp;n, &amp;m, &amp;p); for (LL i = 1; i &lt;= m; ++i) scanf(&quot;%1lld&quot;, &amp;a[i]); f[1] = f[2] = 1; for (LL i = 2; i &lt;= m; ++i) { LL j = f[i]; while (j &gt; 1 &amp;&amp; a[i] != a[j]) j = f[j]; f[i + 1] = (a[i] == a[j] ? j + 1 : 1); } for (LL i = 1; i &lt;= m; ++i) { for (LL x = 0; x &lt;= 9; ++x) { LL j = i; while (j &gt; 1 &amp;&amp; a[j] != x) j = f[j]; whw[i][x] = (a[j] == x ? j : 0); } } matrix gg(m, m), hh(1, m); gg.a[0][0] = 9; gg.a[0][1] = 1; for (LL i = 1; i &lt; m; ++i) { for (LL x = 0; x &lt;= 9; ++x) { ++gg.a[i][whw[i + 1][x]]; } } ++gg.a[m][m]; // for (LL i = 0; i &lt;= m; ++i, puts(&quot;&quot;))for (LL j = 0; j &lt;= m; ++j) printf(&quot;%d &quot;, gg.a[i][j]); gg = ksm(gg, n); // for (LL i = 0; i &lt;= m; ++i, puts(&quot;&quot;))for (LL j = 0; j &lt;= m; ++j) printf(&quot;%d &quot;, gg.a[i][j]); hh.a[0][0] = 1; hh = mul(hh, gg); // for (LL i = 0; i &lt;= m; ++i, puts(&quot;&quot;))for (LL j = 0; j &lt;= m; ++j) printf(&quot;%d &quot;, hh.a[i][j]); LL ans = 0; for (LL i = 0; i &lt; m; ++i) ans = (ans + hh.a[0][i]) % p; cout &lt;&lt; ans; return 0; } } int main() { flyinthesky::solve(); return 0; } /* 2 2 10000000 11 1 1 10000000 1 */]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>计数DP</tag>
        <tag>Bzoj</tag>
        <tag>KMP</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1015F (差值、匹配状态DP + KMP)]]></title>
    <url>%2FCodeforces1015F%2F</url>
    <content type="text"><![CDATA[Codeforces 1015F题意：给你一个括号序列 $s$ （不一定是常规序列）。 括号序列是仅包含字符(和)的字符串。你的问题是计算长度为 $2n$ 的常规括号序列的数量，而且必须满足给定括号序列$ s$ 是它的子串（连续字符序列）。输出这个数量模 $ 10 ^ 9 + 7$ 的结果。 如果不考虑包含$s$，那么可以设$dp(i,j)$为构造的串前$i$个字符左括号比右括号多多少个(差值，状态冗余处理)的方案，转移非常显然 然后如果要包含子串$s$，就要引入新的维度，我们联想到CF 1096D的做法，那就是匹配状态的引入。所以我们可以设$dp(i,j,k)$为构造的串前$i$个字符左括号比右括号多多少个，并且匹配了$s$的$[1,k]$的方案数。 转移方便则刷表：$$\begin{cases}dp(i+1,j+1,x)+=dp(i,j,k) \\dp(i+1,j-1,x)+=dp(i,j,k)\end{cases}$$前者为在后面插入(，后者为在后面插入)。其中的$x$为加入相应括号后$s$串的匹配状态。类似 KMP，这里如果失配了则需要找到前面最近的候选点，然后再判，所以我们利用类似KMP的方法来求解，当然也可以暴力求，但是感觉没KMP好求。注意当$k=s_{len}$时，我们只从$len$转移到$len$。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL MO = 1000000007; int n, f[205]; int len; char s[205]; // 0 for left, 1 for right LL dp[205][205][205]; void clean() { } int solve() { clean(); scanf(&quot;%d%s&quot;, &amp;n, s + 1); len = strlen(s + 1); f[1] = f[2] = 1; for (int i = 2; i &lt;= n + 1; ++i) { int j = f[i]; while (j &gt; 1 &amp;&amp; s[i] != s[j]) j = f[j]; f[i + 1] = (s[i] == s[j] ? j + 1 : 1); } dp[0][0][0] = 1; for (int i = 0; i &lt;= 2 * n; ++i) { for (int j = 0; j &lt;= i; ++j) { for (int k = 0; k &lt; len; ++k) { int pre = k + 1; // 找候选等于 ) 的 while (pre &gt; 1 &amp;&amp; s[pre] != &#39;)&#39;) pre = f[pre]; if (s[pre] != &#39;)&#39;) --pre; // 找不到 if (j) (dp[i + 1][j - 1][pre] += dp[i][j][k]) %= MO; pre = k + 1; // 找候选等于 ( 的 while (pre &gt; 1 &amp;&amp; s[pre] != &#39;(&#39;) pre = f[pre]; if (s[pre] != &#39;(&#39;) --pre; // 找不到 (dp[i + 1][j + 1][pre] += dp[i][j][k]) %= MO; } dp[i + 1][j + 1][len] += dp[i][j][len]; // 特判 k = len if (j) (dp[i + 1][j - 1][len] += dp[i][j][len]) %= MO; } } printf(&quot;%lld\n&quot;, dp[2 * n][0][len]); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>计数DP</tag>
        <tag>KMP</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 2288」生日礼物 (链表+堆)]]></title>
    <url>%2Fbzoj2288%2F</url>
    <content type="text"><![CDATA[BZOJ 2288题意：给出一个长度为$n$的数列，要求从中取出不超过$m$段连续的数，使其和最大。 首先压缩，将符号相同的压成一个元素，0随意放在任意一块位置，那么序列变为一正一负交错序列。然后考虑没有限制$m$时，选所有正数即可。如果有限制，我们就可以抛弃某些正数或者加入某些负数使得两个正数合成一块(注意头尾的负数不能取)我们发现不管负数正数都只关心他的绝对值然后对于每次操作的点他左右两边的点都是不能取的，所以转化到了Bzoj 1150 链表堆维护即可。注意记录值只需要绝对值，包括之后的任何操作！ #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 100000 + 5; int abss(int x) {return x &gt; 0 ? x : -x;} struct data { int u, val; bool operator &lt; (const data &amp;rhs) const {return val &gt; rhs.val;} }; priority_queue&lt;data &gt; q; int n, m, a[MAXN]; int nn, b[MAXN]; int tot, h, t, l[MAXN], r[MAXN], val[MAXN], vis[MAXN]; void ins(int pos, int v) { ++tot, val[tot] = v; l[r[pos]] = tot; r[tot] = r[pos], l[tot] = pos; r[pos] = tot; } void del(int pos) { vis[pos] = 1; r[l[pos]] = r[pos], l[r[pos]] = l[pos]; } void clean() { ms(vis, 0); tot = 1, h = 0, t = 1; l[t] = h, r[h] = t, val[0] = val[1] = 1000000002; } int solve() { clean(); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i]); nn = -1; int now = 0, tjz = 0, totz = 0; for (int i = 1; i &lt;= n; ++i) { if (i == 1 || a[i] * now &lt; 0) { b[++nn] = now; if (now &gt; 0) ++tjz, totz += now; now = 0; } now += a[i]; } if (now &gt; 0) ++tjz, totz += now; b[++nn] = now; int hh = 1; if (b[1] &lt; 0) ++hh; if (b[nn] &lt; 0) --nn; ins(h, b[hh]), q.push((data){tot, abss(b[hh])}); for (int i = hh + 1; i &lt;= nn; ++i) ins(tot, b[i]), q.push((data){tot, abss(b[i])}); int nd = tjz - m; if (nd &lt;= 0) return cout &lt;&lt; totz &lt;&lt; endl, 0; while (!q.empty()) { data p = q.top(); q.pop(); if (vis[p.u]) continue ; if (val[p.u] &lt; 0 &amp;&amp; ((l[p.u] == h) || (r[p.u] == t))) continue ; totz -= p.val; val[p.u] = abss(val[l[p.u]]) + abss(val[r[p.u]]) - abss(val[p.u]); if (l[p.u] != h || l[p.u] != t) del(l[p.u]); if (r[p.u] != h || r[p.u] != t) del(r[p.u]); q.push((data){p.u, abss(val[p.u])}); --nd; if (!nd) break ; } return cout &lt;&lt; totz &lt;&lt; endl, 0; return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>堆</tag>
        <tag>Bzoj</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「poj 2228」Naptime (环形DP)]]></title>
    <url>%2Fpoj2228%2F</url>
    <content type="text"><![CDATA[poj 2228题意：有一个环，选择一段长度为$n$进行计算。如果第i个时间点选择不睡觉那么就会增加$a_i$。你也可以选择睡觉，第一个时间点不算，睡觉时间至少为$m$。 先考虑线性做法，设$dp(i,j,0/1)$为前$i$个选了$j$个睡觉，$i$不选/选的最大值。转移显然$$\begin{cases}dp(i,j,0)=min(dp(i-1,j,0),dp(i-1,j,1)) \\dp(i,j,1)=min(dp(i-1,j-1,0), dp(i-1,j-1,1)+a_i)\end{cases}$$由于1位置一定不能对答案贡献，所以初值$dp(1, 0, 0)=dp(1, 1, 1)=0$，其他负无穷大答案为$max(dp(n, b, 0), dp(n, b, 1))$如果考虑环上做法，我们之前的做法相当于在$1$和$n$处断开了链，现在要将他强行接上去，我们可以这次强行选择$1,n$睡觉，然后再做一次DP，综合两者答案。所以初值改为$dp(1, 0, 0)=0, dp(1, 1, 1)=a_i$，其他负无穷大答案为$dp(n, b, 1)$综合两者答案即可。注意要用滚动数组。 知识点：1、环形不一定要复制两遍 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL INF = 4223372036854775808ll; int n, b, a[3831]; LL dp[2][3831][2], ans; void clean() { ans = 0ll; for (int i = 0; i &lt;= 1; ++i) for (int j = 0; j &lt;= b; ++j) dp[i][j][0] = dp[i][j][1] = -INF; } int solve() { scanf(&quot;%d%d&quot;, &amp;n, &amp;b); clean(); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i]); int cur = 1; dp[1][0][0] = dp[1][1][1] = 0; for (int i = 2; i &lt;= n; ++i) { cur ^= 1; for (int j = 0; j &lt;= min(i, b); ++j) { dp[cur][j][0] = max(dp[cur ^ 1][j][0], dp[cur ^ 1][j][1]); if (j - 1 &gt;= 0) { dp[cur][j][1] = max(dp[cur ^ 1][j - 1][0], dp[cur ^ 1][j - 1][1] + (LL)a[i]); } } } ans = max(dp[cur][b][0], dp[cur][b][1]); for (int i = 0; i &lt;= 1; ++i) for (int j = 0; j &lt;= b; ++j) dp[i][j][0] = dp[i][j][1] = -INF; cur = 1; dp[1][0][0] = 0, dp[1][1][1] = a[1]; for (int i = 2; i &lt;= n; ++i) { cur ^= 1; for (int j = 0; j &lt;= min(i, b); ++j) { dp[cur][j][0] = max(dp[cur ^ 1][j][0], dp[cur ^ 1][j][1]); if (j - 1 &gt;= 0) { dp[cur][j][1] = max(dp[cur ^ 1][j - 1][0], dp[cur ^ 1][j - 1][1] + (LL)a[i]); } } } ans = max(ans, dp[cur][b][1]); cout &lt;&lt; ans; return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CH 5501」环路运输 (单调队列 + 断环成链)]]></title>
    <url>%2FCH5501%2F</url>
    <content type="text"><![CDATA[CH 5501题意：给定$n$长数列$a$，找出最大的$a_i+a_j+min(|i-j|, n - |i-j|)$ updated on 2019.02.20 $min(|i-j|, n - |i-j|)$也就是逆时针或顺时针从 $i$ 到 $j$ 中较近的一种。所以我们将环断开成一条链，然后在链上就不用讨论$\min$。 假设$i \leq j$则对于原串上$i - j \leq \frac n2$，则$n - (i-j) &gt; i - j$，可以对应于复制串上$i,j$之间传物品对于原串上$i - j \geq \frac n2$，则$n - (i-j) &lt; i - j$，可以对应于复制串上$i,j+n$之间传物品所以直接在复制串上以区间长为$\frac n2$来处理。 对于$i$的答案为$\max(a_i+a_j+i-j)$，将定值$i$的部分提取出$\max$，那么我们只用维护$a_i-i$的最大值。因为是区间移动，所以单调队列维护。 知识点：1、单调队列的写法 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 1000000 + 5; int n, a[MAXN * 2]; int l, r, que[MAXN * 4], ans = 0; void clean() { } int solve() { clean(); scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i]), a[i + n] = a[i]; l = 1, r = 1; for (int i = 1; i &lt;= 2 * n; ++i) { while (l &lt;= r &amp;&amp; que[l] &lt; i - n / 2) ++l; ans = max(ans, i + a[i] + a[que[l]] - que[l]); while (l &lt;= r &amp;&amp; a[que[r]] - que[r] &lt;= a[i] - i) --r; que[++r] = i; } cout &lt;&lt; ans; return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <tags>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CH 5302」金字塔 (区间DP)]]></title>
    <url>%2FCH5302%2F</url>
    <content type="text"><![CDATA[CH 5302题意：见上。容易想到和加分二叉树差不多，但是这里复杂了很多，不是二叉树，而且也不是 DFS 序。观察发现对于一个子树在这个序列中还是连续的一段，并且子树对应区间最前最后两个字符必须相同，等于根节点。所以我们可以设$dp(i,j)$为$[i,j]$的答案。为了让计数不重复，我们分问题分为$[1,k-1]$只有一颗子树，$[k,j]$可以有多棵子树。那么转移$$dp(i,j)=\begin{cases}0, S[i] ≠ S[j]\\\sum\limits_{i+2 \leq k \leq j, S[i]=S[k]} dp(i + 1, k - 1) \cdot dp(k, j), S[i]=S[j]\end{cases}$$记忆化搜索即可。知识点：1、修改状态描述达到计数不重不漏 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 300 + 5; const LL MO = 1000000000ll; char s[MAXN]; int n; LL f[MAXN][MAXN]; LL dp(int l, int r) { if (l == r) return f[l][l] = 1ll; if (r &lt; l) return f[l][r] = 0ll; if (f[l][r] &gt;= 0ll) return f[l][r]; if (s[l] != s[r]) return f[l][r] = 0ll; f[l][r] = 0ll; for (int k = l + 2; k &lt;= r; ++k) if (s[l] == s[k]) { f[l][r] = (f[l][r] + dp(l + 1, k - 1) * dp(k, r) % MO) % MO; } return f[l][r]; } void clean() { ms(f, -1); } int solve() { clean(); scanf(&quot;%s&quot;, s + 1); n = strlen(s + 1); dp(1, n); cout &lt;&lt; f[1][n]; return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <tags>
        <tag>计数DP</tag>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1092F (树形DP(二次扫描换根))]]></title>
    <url>%2FCodeforces1092F%2F</url>
    <content type="text"><![CDATA[Codeforces 1092F题意：给定一棵有$n$个节点的树，给定每个点的点权，每个边的边权是$1$。你可以任选一个点作为$v$点，使得$\sum_{i=1}^n{dist(i,v) \cdot a_i}$最大。输出这个最大值。 二次扫描换根模板题。显然是一个无根树最优化问题，那么逃不了DP。所以就是先随便找一个根DP一次，然后通过 DFS 再将推导出其他的答案。本题显然能进行推导，若$v$是$u$的孩子，则 $$\sum_{i \in 子树u}{dist(i,u) \cdot a_i}=\sum_{i \in 子树v}{(dist(i,v) +1) \cdot a_i}=\sum_{i \in 子树v}{dist(i,v) \cdot a_i+a_i}=\sum_{i \in 子树v}{dist(i,v) \cdot a_i+\sum_{i \in 子树v}a_i}$$ 设$sum(u)=\sum_{i \in 子树u}a_i$，那么$u$可以从$v$推导而来。 对于换根可以利用二次扫描换根知识和推推公式算出最后的答案。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 200000 + 5; int n, a[MAXN]; vector&lt;int &gt; G[MAXN]; LL sum[MAXN], g[MAXN], f[MAXN]; void ins(int x, int y) {G[x].push_back(y);} void dfs1(int u, int fa) { sum[u] = a[u]; for (int i = 0; i &lt; (int)G[u].size(); ++i) { int v = G[u][i]; if (v != fa) dfs1(v, u), sum[u] += sum[v], g[u] += g[v] + sum[v]; } } void dfs2(int u, int fa) { for (int i = 0; i &lt; (int)G[u].size(); ++i) { int v = G[u][i]; if (v != fa) { f[v] = f[u] - sum[v] + (sum[1] - sum[v]); // 前提是已经算出父亲，所以先算再 dfs dfs2(v, u); } } } void clean() { ms(sum, 0), ms(g, 0), ms(f, 0); } int solve() { clean(); scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i]); for (int x, y, i = 1; i &lt; n; ++i) scanf(&quot;%d%d&quot;, &amp;x, &amp;y), ins(x, y), ins(y, x); dfs1(1, 0); f[1] = g[1], dfs2(1, 0); LL ans = 0ll; for (int i = 1; i &lt;= n; ++i) ans = max(ans, f[i]); printf(&quot;%lld\n&quot;, ans); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「poj 3585」 Accumulation Degree(树形DP(二次扫描换根))]]></title>
    <url>%2Fpoj3585%2F</url>
    <content type="text"><![CDATA[poj 3585题意：找一个点使得，使得从这个点出发作为源点，发出的流量最大，输出这个最大的流量。 本题是一个无根树最优化问题。朴素做法可以是枚举每个点当源点然后树形DP。考虑随意找一个点DP后，是否其他点可以由这个答案推导出。设$dp(u)$为以$u$为根子树的最大流量，$f(u)$为整颗树以$u$为根的最大流量。$dp$的方程式略，具体看进阶指南上的。注意叶节点的讨论对于$f$的计算，我们知道了$f(v)$的父亲$f(u)$，就能求出$f(v)$的值 $$f(v)=dp(v)+min(c(x,y), f(u)-min(dp(v), c(x,y)))$$ 注意同样要特判叶节点。 然后最后答案即为$max(f(u))$ 知识点：1、二次扫描换根2、判是不是叶子最好用度数deg来判 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; int T; namespace flyinthesky { const int MAXN = 200000 + 5; struct edge {int v, c, nxt;} ed[MAXN * 2]; int n, en, hd[MAXN]; int dp[MAXN], f[MAXN], deg[MAXN]; void ins(int x, int y, int c) {ed[++en] = (edge){y, c, hd[x]}, hd[x] = en;} void dfs1(int u, int fa) { dp[u] = 0; for (int i = hd[u]; i &gt; 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (e.v != fa) { dfs1(e.v, u); if (deg[e.v] == 1) dp[u] += e.c; else dp[u] += min(dp[e.v], e.c); } } } void dfs2(int u, int fa) { for (int i = hd[u]; i &gt; 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (e.v != fa) { if (deg[u] == 1) f[e.v] = dp[e.v] + e.c; else f[e.v] = dp[e.v] + min(e.c, f[u] - min(dp[e.v], e.c)); dfs2(e.v, u); } } } void clean() { en = 0, ms(hd, -1), ms(deg, 0); } int solve() { clean(); scanf(&quot;%d&quot;, &amp;n); for (int x, y, c, i = 1; i &lt; n; ++i) { scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;c); ins(x, y, c), ins(y, x, c); ++deg[x], ++deg[y]; } dfs1(1, 0); f[1] = dp[1], dfs2(1, 0); int ans = 0; for (int i = 1; i &lt;= n; ++i) ans = max(ans, f[i]); printf(&quot;%d\n&quot;, ans); return 0; } } int main() { scanf(&quot;%d&quot;, &amp;T); while (T--) flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>树形DP</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1999」「Noip2007」树网的核加强版 (树的直径+尺取法)]]></title>
    <url>%2Fbzoj1999%2F</url>
    <content type="text"><![CDATA[BZOJ 1999题意：在直径上找到一个区间使得这个区间上所有点的偏心距最小。 容易想到用单调队列CF 1004E的做法。 这里其实偏心距求个最大值即可，就不用单调队列了，直接尺取。 突然发现这题和CF 1004E是一题。。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 500000 + 5; struct edge { int v, w, nxt; } ed[MAXN * 2]; int n, s, en, hd[MAXN], whw1, whw2, vis[MAXN], cnt; LL dis[MAXN]; void ins(int x, int y, int w) {ed[++en] = (edge){y, w, hd[x]}, hd[x] = en;} void dfs1(int u, int fa) { for (int i = hd[u]; i &gt; 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (e.v != fa) { dis[e.v] = dis[u] + e.w; dfs1(e.v, u); } } } int dfs2(int u, int fa) { if (u == whw2) return vis[u] = 1, true; int fl = 0; for (int i = hd[u]; i &gt; 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (e.v != fa) { fl |= dfs2(e.v, u); if (fl) vis[u] = 1; } } return fl; } LL gg = 0ll; void dfs4(int u, LL D, int fa) { gg = max(gg, D); for (int i = hd[u]; i &gt; 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (e.v != fa &amp;&amp; !vis[e.v]) { dfs4(e.v, D + e.w, u); } } } void dfs3(int u, LL D, int fa) { dis[++cnt] = D; for (int i = hd[u]; i &gt; 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (e.v != fa &amp;&amp; vis[e.v]) { dfs4(e.v, 0, 0); dfs3(e.v, D + e.w, u); } } } void clean() { en = 0, ms(hd, -1), ms(vis, 0); } int solve() { clean(); scanf(&quot;%d%d&quot;, &amp;n, &amp;s); for (int x, y, w, i = 1; i &lt; n; ++i) { scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;w); ins(x, y, w), ins(y, x, w); } ms(dis, 0), dfs1(1, 0); whw1 = 0; for (int i = 1; i &lt;= n; ++i) if (dis[whw1] &lt; dis[i]) whw1 = i; ms(dis, 0), dfs1(whw1, 0); whw2 = 0; for (int i = 1; i &lt;= n; ++i) if (dis[whw2] &lt; dis[i]) whw2 = i; vis[whw1] = 1, dfs2(whw1, 0); ms(dis, 0), cnt = 0, dfs3(whw1, 0, 0); int l = 1; LL ans = 4223372036854775808ll; for (int r = 1; r &lt;= cnt; ++r) { while (l &lt; r &amp;&amp; dis[r] - dis[l] &gt; s) ++l; ans = min(ans, max(dis[l], max(dis[cnt] - dis[r], gg))); } cout &lt;&lt; ans; return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>树的直径</tag>
        <tag>尺取法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「poj 1185」Polygon (区间DP+环形DP)]]></title>
    <url>%2Fpoj1179%2F</url>
    <content type="text"><![CDATA[poj 1185题意：开始时有一个由$n$个顶点构成的多边形。每个顶点被赋予一个整数值，每条边被赋予一个运算符+或*。所有边依次用整数从$1$到$n$编号。游戏第$1$步，将一条边删除，随后$n-1$步按以下方式操作：选择一条边$E$以及由$E$连接着的$2$个顶点$V_1$和$V_2$删除;用一个新的顶点取代边$E$以及由$E$连接着的$2$个顶点$V_1$和$V_2$。将由顶点$V_1$和$V_2$的整数值通过边$E$上的运算得到的结果赋予新顶点;最后，所有边都被删除。得分就是所剩顶点上的整数值。请求出这个最大的得分，以及达到的方式。 环断开一条边以后就成了链，就可以考虑DP了。我们发现简单的区间DP不满足最优子结构。和CF981D差不多，但是肯定可以改改然后还是用DP解。之前那题是改成存在性问题然后再判，这题因为负数不符合最优子结构，所以我们可以存最大值最小值转移就行了。最大值可以从$max+max, max \cdot max$转移，而最小值可以从$min+min, min \cdot min, max \cdot min$得到。因为这些值的绝对值都是最值，所以最小值一定在这些里面。我们断环将环复制一遍接在后面，然后每个位置开始的答案就是$[1,n], [2,n+1],…,[n, n - 1]$ 1、区间DP的阶段是区间长度2、区间DP最好用记忆化搜索写3、数组不要开小了 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 55, INF = 40000; int n, a[MAXN * 2], hh[MAXN * 2], dp[MAXN * 2][MAXN * 2][2]; // dp[0] -&gt; min, dp[1] -&gt; max void clean() { } int solve() { clean(); scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) { char s[5]; scanf(&quot;%s%d&quot;, s, &amp;a[i]); hh[i] = (s[0] == &#39;t&#39; ? 0 : 1); // 0 加 1 乘 a[i + n] = a[i], hh[i + n] = hh[i]; } for (int i = 0; i &lt;= 2 * n + 2; ++i) for (int j = 0; j &lt;= 2 * n + 2; ++j) dp[i][j][0] = INF, dp[i][j][1] = -INF; for (int i = 1; i &lt;= 2 * n; ++i) dp[i][i][0] = dp[i][i][1] = a[i]; for (int len = 2; len &lt;= 2 * n; ++len) { for (int i = 1; i &lt;= 2 * n - len + 1; ++i) { int j = i + len - 1; for (int k = i; k &lt; j; ++k) { int op = hh[k + 1]; if (op == 0) { if (dp[i][k][1] != -INF &amp;&amp; dp[k + 1][j][1] != -INF) dp[i][j][1] = max(dp[i][j][1], dp[i][k][1] + dp[k + 1][j][1]); } if (op == 1) { if (dp[i][k][1] != -INF &amp;&amp; dp[k + 1][j][1] != -INF) dp[i][j][1] = max(dp[i][j][1], dp[i][k][1] * dp[k + 1][j][1]); if (dp[i][k][0] != INF &amp;&amp; dp[k + 1][j][0] != INF) dp[i][j][1] = max(dp[i][j][1], dp[i][k][0] * dp[k + 1][j][0]); } if (op == 0) { if (dp[i][k][0] != INF &amp;&amp; dp[k + 1][j][0] != INF) dp[i][j][0] = min(dp[i][j][0], dp[i][k][0] + dp[k + 1][j][0]); } if (op == 1) { if (dp[i][k][0] != INF &amp;&amp; dp[k + 1][j][0] != INF) dp[i][j][0] = min(dp[i][j][0], dp[i][k][0] * dp[k + 1][j][0]); if (dp[i][k][1] != -INF &amp;&amp; dp[k + 1][j][1] != -INF) dp[i][j][0] = min(dp[i][j][0], dp[i][k][1] * dp[k + 1][j][1]); if (dp[i][k][0] != INF &amp;&amp; dp[k + 1][j][1] != -INF) dp[i][j][0] = min(dp[i][j][0], dp[i][k][0] * dp[k + 1][j][1]); if (dp[i][k][1] != -INF &amp;&amp; dp[k + 1][j][0] != INF) dp[i][j][0] = min(dp[i][j][0], dp[i][k][1] * dp[k + 1][j][0]); } } } } int ans = -INF; for (int i = 1; i &lt;= n; ++i) if (dp[i][i + n - 1][1] &gt; ans) ans = dp[i][i + n - 1][1]; printf(&quot;%d\n&quot;, ans); for (int i = 1; i &lt;= n; ++i) if (dp[i][i + n - 1][1] == ans) printf(&quot;%d &quot;, i); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>区间DP</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 2299」「HAOI2011」 向量 (Gcd+裴蜀定理)]]></title>
    <url>%2Fbzoj2299%2F</url>
    <content type="text"><![CDATA[BZOJ 2299题意：给出向量$(a,b), (a,-b), (-a,b), (-a,-b), (b,a), (b,-a), (-b,a), (-b,-a)$，请你判断是否能拼出向量$(x_0,y_0)$ 观察发现只有$(2a,0), (2b,0), (0,2b), (0,2a), (b,a), (-b,-a), (-a,-b), (a,b)$种向量，并且后面的$4$种每种只会最多用一次。那么可以设方程 $$\begin{cases}2ax+2by=x_0 \\2bx+2ax=y_0\end{cases}$$ 根据裴蜀定理，有解的充要条件是 $$gcd(2a,2b)|x_0 ,gcd(2a,2b)|y_0$$ 对于后面四种向量，由于每种最多用一次，分类讨论使用后再列方程判即可，因为$gcd$负数的绝对值和正数的相同，所以只需要讨论正数的即可。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { LL _a, _b, x, y, d; LL gcd(LL a, LL b) {return b == 0 ? a : gcd(b, a % b);} LL chk(LL x, LL y) {return x % d == 0 &amp;&amp; y % d == 0;} void clean() { } int solve() { clean(); cin &gt;&gt; _a &gt;&gt; _b &gt;&gt; x &gt;&gt; y; d = gcd(2ll * _a, 2ll * _b); if (chk(x, y) || chk(x + _a, y + _b) || chk(x + _b, y + _a) || chk(x + _a + _b, y + _a + _b)) return puts(&quot;Y&quot;), 0; puts(&quot;N&quot;); return 0; } } int main() { int t; scanf(&quot;%d&quot;, &amp;t); while (t--) flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>GCD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1096D (DP)]]></title>
    <url>%2FCodeforces1096D%2F</url>
    <content type="text"><![CDATA[Codeforces 1095F题意：给定字符串$s$，每个位有一个权值，删掉一个位代价为这个权值。请求出最小使得字符串不包含子序列hard的代价。 最优化问题想到DP，并且这题类似于 Bzoj 1030 AC自动机。这里是一个匹配类状态的 DP，设$dp(i,j)$为前$i$位，$j=0$表示没有匹配，$j=[1,3]$表示匹配到了前缀h, ha, har的最小代价。 转移则 dp[0][0] = 0; for (LL j = 0; j &lt; 4; ++j) dp[i][j] = dp[i - 1][j]; for (LL i = 1; i &lt;= n; ++i) { if (s[i] == &#39;h&#39;) { dp[i][0] = dp[i - 1][0] + a[i]; // 将 `h` 删去 dp[i][1] = min(min(dp[i - 1][0], dp[i - 1][1]), dp[i - 1][1] + a[i]); // 不动或者将 `h` 删去 } if (s[i] == &#39;a&#39;) { dp[i][1] = dp[i - 1][1] + a[i]; // 将 `a` 删去 dp[i][2] = min(min(dp[i - 1][1], dp[i - 1][2]), dp[i - 1][2] + a[i]); // 不动或者将 `a` 删去 } if (s[i] == &#39;r&#39;) { dp[i][2] = dp[i - 1][2] + a[i]; // 将 `r` 删去 dp[i][3] = min(min(dp[i - 1][2], dp[i - 1][3]), dp[i - 1][3] + a[i]); // 不动或者将 `r` 删去 } if (s[i] == &#39;d&#39;) { dp[i][3] = dp[i - 1][3] + a[i]; // 将 `d` 删去 } } 其实中间转移不需要dp[i - 1][3], dp[i - 1][3] + a[i]，因为$a_i \geq 0$，所以直接写即可。 知识点：1、匹配类状态的 DP #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { LL n, a[100000 + 5], dp[100000 + 5][5], INF = 4223372036854775808ll; char s[100000 + 5]; void clean() { } int solve() { clean(); cin &gt;&gt; n; scanf(&quot;%s&quot;, s + 1); for (LL i = 1; i &lt;= n; ++i) scanf(&quot;%lld&quot;, &amp;a[i]); for (LL i = 0; i &lt;= n; ++i) for (LL j = 0; j &lt; 5; ++j) dp[i][j] = INF; dp[0][0] = 0; for (LL i = 1; i &lt;= n; ++i) { for (LL j = 0; j &lt; 4; ++j) dp[i][j] = dp[i - 1][j]; if (s[i] == &#39;h&#39;) { dp[i][0] = dp[i - 1][0] + a[i]; //dp[i][1] = min(min(dp[i - 1][0], dp[i - 1][1]), dp[i - 1][1] + a[i]); dp[i][1] = min(dp[i - 1][0], dp[i - 1][1]); } if (s[i] == &#39;a&#39;) { dp[i][1] = dp[i - 1][1] + a[i]; //dp[i][2] = min(min(dp[i - 1][1], dp[i - 1][2]), dp[i - 1][2] + a[i]); dp[i][2] = min(dp[i - 1][1], dp[i - 1][2]); } if (s[i] == &#39;r&#39;) { dp[i][2] = dp[i - 1][2] + a[i]; //dp[i][3] = min(min(dp[i - 1][2], dp[i - 1][3]), dp[i - 1][3] + a[i]); dp[i][3] = min(dp[i - 1][2], dp[i - 1][3]); } if (s[i] == &#39;d&#39;) { dp[i][3] = dp[i - 1][3] + a[i]; } } printf(&quot;%lld&quot;, min(min(dp[n][0], dp[n][1]), min(dp[n][2], dp[n][3]))); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1091D (数学规律 / 组合数学)]]></title>
    <url>%2FCodeforces1091D%2F</url>
    <content type="text"><![CDATA[Codeforces 1091D题意：给定$n$，将$[1,n]$的排列按字典序接成$n \cdot n!$长的序列，求序列中有几个长度为$n$的区间和等于$\frac{n(n-1)}{2}$ 显然这个区间是一个排列。那么我们可以统计每个排列的贡献。对于一个合法的区间，他一定是一个排列的结尾接上一个排列的开头。所以可以将组合问题分解对于一个排列有$n$种分解方法，所以有$n \cdot n!$种方案。但是有不满足的情况，例如$(4, 2)$, $(1, 3, 5)$是不能接一起的。这样两个排列字典序大小不满足。观察发现前面的是一个递减序列，所以我们要将这些递减序列构成的都删掉。选出$i$长递减序列有$C^{i}_{n}$种方法，对于每个递减序列他的第二个部分是随便填的，所以最后答案为 $$n \cdot n! - \sum_{i=0}^n C^i_n \cdot (n-i)!$$ 找规律方法：1、观察样例解释，发现和等于$\frac{n(n-1)}{2}$的有周期性2、打表$4$的答案(顺序打印区间和)，发现确实有周期性，并且发现周期为$n!$3、打表$3,5$的答案，发现答案有递推性4、发现答案一定是两个数相乘，因为周期是$n!$，选择有$n \cdot n!$种，所以两个数中有一个是$n$5、对另一个数分析，观察表可以发现$4$的每个周期都在$3$的基础上加上了$(n-1)!$个答案6、对答案调整分析，上面的还要减一才行7、写出递推式$$f(i)=i \cdot ((i-1)!+f(i-1)-1)$$其中$f(1)=1$ 1、组合\DP常用方法分解问题 //==========================Head files========================== #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;map&gt; #define LL long long #define db double #define mp make_pair #define pr pair&lt;int, int&gt; #define fir first #define sec second #define pb push_back #define ms(i, j) memset(i, j, sizeof i) using namespace std; //==========================Templates========================== inline int read() { int x = 0, f = 1; char c = getchar(); while(c &lt; &#39;0&#39; || c &gt; &#39;9&#39;){if (c == &#39;-&#39;) f = -1; c = getchar();} while(c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;){x = x * 10 + c - &#39;0&#39;; c = getchar();} return x * f; } inline LL readl() { LL x = 0, f = 1; char c = getchar(); while(c &lt; &#39;0&#39; || c &gt; &#39;9&#39;){if (c == &#39;-&#39;) f = -1; c = getchar();} while(c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;){x = x * 10 + c - &#39;0&#39;; c = getchar();} return x * f; } int power(int a, int b) { int ans = 1; while (b) { if(b &amp; 1) ans = ans * a; b &gt;&gt;= 1; a = a * a; } return ans; } int power_mod(int a, int b, int mod) { a %= mod; int ans = 1; while (b) { if(b &amp; 1) ans = (ans * a) % mod; b &gt;&gt;= 1, a = (a * a) % mod; } return ans; } LL powerl(LL a, LL b) { LL ans = 1ll; while (b) { if(b &amp; 1ll) ans = ans * a; b &gt;&gt;= 1ll;a = a * a; } return ans; } LL power_modl(LL a, LL b, LL mod) { a %= mod; LL ans = 1ll; while (b) { if(b &amp; 1ll) ans = (ans * a) % mod; b &gt;&gt;= 1ll, a = (a * a) % mod; } return ans; } LL gcdl(LL a, LL b) {return b == 0 ? a : gcdl(b, a % b);} LL abssl(LL a) {return a &gt; 0 ? a : -a;} int gcd(int a, int b) {return b == 0 ? a : gcd(b, a % b);} int abss(int a) {return a &gt; 0 ? a : -a;} //==========================Main body========================== #define LD &quot;%I64d&quot; #define D &quot;%d&quot; #define pt printf #define sn scanf #define pty printf(&quot;YES\n&quot;) #define ptn printf(&quot;NO\n&quot;) //==========================Code here========================== const LL MO = 998244353; LL n, f[1000000 + 5], fac[1000000 + 5]; int main() { cin &gt;&gt; n; f[1] = 1ll; fac[0] = 1ll; for (LL i = 1ll; i &lt;= n; ++i) fac[i] = (fac[i - 1] * i) % MO; for (LL i = 2ll; i &lt;= n; ++i) { f[i] = ((fac[i - 1] + f[i - 1]) % MO - 1ll + MO) % MO; f[i] = f[i] * i % MO; } cout &lt;&lt; f[n]; return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>计数DP</tag>
        <tag>Codeforces</tag>
        <tag>组合数学</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1056B (剩余系 / 找规律)]]></title>
    <url>%2FCodeforces1056B%2F</url>
    <content type="text"><![CDATA[Codeforces 1056B题意：求$m | (x^2+y^2), 1 \leq x, y \leq n$的$(x,y)$个数。($m \leq 2000, n \leq 10^9$) 其实观察题目样例解释可以发现，互质对只有$(1,2), (1,3), (3, 4)$。其他的都是在$\leq n$范围类的倍数。特殊的$(5,5)$我们也将其列入。观察这些数对都是小于$m$的，不妨将$(5,5)$记为$(0,0)$，这些数对都满足$m | (x^2+y^2), 0 \leq x, y &lt; m$，所以我们可以尝试在$m$范围内枚举这样的数对，然后再统计在$n$范围内的数量即可。 数学方法：$m | (x^2+y^2) \Leftrightarrow (x^2+y^2) \mod m = 0 $那么在$m​$范围类枚举这样的数对，然后在$n​$范围内统计个数即可。 知识点：1、题目中一个数据大一个数据小，肯定要枚举小的那个数据2、找规律依题意，有可能不是 $ O(1) $ 方法。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { LL n, m; LL hh[1005][1005]; LL calc(LL l) {return (n - l) / m + (l &gt; 0);} // 不包含本身所以加上 (l &gt; 0) void clean() { ms(hh, 0); } int solve() { clean(); cin &gt;&gt; n &gt;&gt; m; for (LL i = 0; i &lt; m; ++i) for (LL j = 0; j &lt; m; ++j) if ((i * i + j * j) % m == 0) hh[i][j] = 1; LL ans = 0; for (LL i = 0; i &lt;= min(n, m - 1); ++i) for (LL j = 0; j &lt;= min(n, m - 1); ++j) if (hh[i][j]) ans += calc(i) * calc(j); cout &lt;&lt; ans; return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1095F (贪心 + 并查集)]]></title>
    <url>%2FCodeforces1095F%2F</url>
    <content type="text"><![CDATA[Codeforces 1095F题意：$n$点无向图最开始没有边，加一条边的代价为$A_x+A_y$, $A_i$为点权，现在有$m$个特殊方案$(x,y,w)$使得$x,y$连通，花费$w$。请问使图连通最小费用。 最开始我的思路：考虑没有特殊方案，则就是个合并果子，必须保证每次都将两个连通块，并查集维护。如果有特殊方案，那么每次操作要将两个连通块并起来。将方案按价值增序，那么堆中取出两个元素后和当前方案对比哪个方案连通最优。 其实更容易的：考虑没有特殊方案，可以发现所有点都会连在一个最小价值的点上。如果有，将所有点都会连在一个最小价值的点的操作一起并到特殊方案里排序取最优。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 200000 + 5; struct node { int u; LL w; bool operator &lt; (const node &amp;rhs) const {return w &gt; rhs.w;} }; struct data { int u, v; LL w; bool operator &lt; (const data &amp;rhs) const {return w &lt; rhs.w;} } xw[MAXN]; int n, m, f[MAXN]; LL a[MAXN], ans; priority_queue&lt;node &gt; q; int find(int x) {return x == f[x] ? x : f[x] = find(f[x]);} void clean() { ans = 0ll; } int solve() { clean(); cin &gt;&gt; n &gt;&gt; m; if (n == 1) return printf(&quot;0\n&quot;), 0; for (int i = 1; i &lt;= n; ++i) scanf(&quot;%I64d&quot;, &amp;a[i]), q.push((node){i, a[i]}), f[i] = i; for (int i = 1; i &lt;= m; ++i) { scanf(&quot;%d%d%I64d&quot;, &amp;xw[i].u, &amp;xw[i].v, &amp;xw[i].w); } sort(xw + 1, xw + 1 + m); int xwcur = 1; for (int i = 1; i &lt;= n - 1 &amp;&amp; !q.empty(); ++i) { node p1, p2; if (!q.empty()) p1 = q.top(), q.pop(); while (find(p1.u) != p1.u &amp;&amp; !q.empty()) p1 = q.top(), q.pop(); if (!q.empty()) p2 = q.top(), q.pop(); while ((find(p2.u) != p2.u || find(p2.u) == find(p1.u)) &amp;&amp; !q.empty()) p2 = q.top(), q.pop(); while (xwcur &lt;= m &amp;&amp; find(xw[xwcur].u) == find(xw[xwcur].v)) ++xwcur; if (xwcur &lt;= m &amp;&amp; xw[xwcur].w &lt; p1.w + p2.w) { int x = find(xw[xwcur].u), y = find(xw[xwcur].v); ans += xw[xwcur].w; if (a[x] &lt; a[y]) { f[y] = x; q.push((node){x, a[x]}); } else { f[x] = y; q.push((node){y, a[y]}); } q.push(p1), q.push(p2); } else { int x = find(p1.u), y = find(p2.u); ans += p1.w + p2.w; f[y] = x; q.push((node){x, a[x]}); } } cout &lt;&lt; ans; return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>并查集</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CH 46A」磁力块 (分块 + BFS)]]></title>
    <url>%2FCH46A%2F</url>
    <content type="text"><![CDATA[CH 46A题意：见上。 容易发现可以用BFS从L开始一路下去找能吸附的。关键是怎么找能吸附的，这里有两维$(m \leq p, dis \leq r)$这里可以用平衡树之类的去维护，比较麻烦其实可以用分块来做。将原数组按$m$排序，然后就消除第一维影响然后在块中按$dis$重新排序，然后就能满足块中$dis$单调，对于看作整体的块$m$单调。(分块处理二维的问题)那么我们只需要查询，对于每个$m \leq p$整块，找$dis \leq r$的元素并且标记到当前位置，之后扫描从这里开始(前面都被挖走了)。对于$m$不完全小于$p$的一个不完整块，暴力统计。 这里分块可以简单写：$l,r$表示当前块的开始结束位置，不需要$bl$数组，询问也可以插到 BFS 里写。 知识点：1、注意分块中能不用 stl 就不用，并且查询可以合并到主程序写2、 分块处理二维的问题 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 250000 + 5; struct data { int x, y, m, p; LL r, dis; }pnt[MAXN]; struct node {int p; LL r;}; int tot, x0, y0, pL, rL, n, blolen, maxm[MAXN], vis[MAXN], l[MAXN], r[MAXN]; queue&lt;node &gt; q; bool cmp_m(data a, data b) {return a.m &lt; b.m;} bool cmp_d(data a, data b) {return a.dis &lt; b.dis;} void clean() { tot = 0, ms(maxm, 0), ms(vis, 0); } int solve() { clean(); scanf(&quot;%d%d%d%d%d&quot;, &amp;x0, &amp;y0, &amp;pL, &amp;rL, &amp;n); blolen = (int)sqrt(n); for (int i = 1; i &lt;= n; ++i) { scanf(&quot;%d%d%d%d%lld&quot;, &amp;pnt[i].x, &amp;pnt[i].y, &amp;pnt[i].m, &amp;pnt[i].p, &amp;pnt[i].r); pnt[i].r *= pnt[i].r, pnt[i].dis = 1ll * (pnt[i].x - x0) * (pnt[i].x - x0) + 1ll * (pnt[i].y - y0) * (pnt[i].y - y0); } sort(pnt + 1, pnt + 1 + n, cmp_m); for (int i = 1; i &lt;= n; i += blolen) { l[++tot] = i, r[tot] = min(i + blolen - 1, n); maxm[tot] = pnt[r[tot]].m; sort(pnt + l[tot], pnt + 1 + r[tot], cmp_d); } q.push((node){pL, 1ll * rL * rL}); int ans = -1; while (!q.empty()) { node p = q.front(); q.pop(); ++ans; int i; for (i = 1; i &lt;= tot; ++i) { if (maxm[i] &gt; p.p) { for (int j = l[i]; j &lt;= r[i]; ++j) { if (!vis[j] &amp;&amp; pnt[j].dis &lt;= p.r &amp;&amp; pnt[j].m &lt;= p.p) vis[j] = 1, q.push((node){pnt[j].p, pnt[j].r}); } break ; } else { while (l[i] &lt;= r[i]) { if (pnt[l[i]].dis &lt;= p.r) { if (!vis[l[i]]) q.push((node){pnt[l[i]].p, pnt[l[i]].r}); } else break ; ++l[i]; } } } } printf(&quot;%d\n&quot;, ans); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <tags>
        <tag>分块</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CDQ分治 学习笔记]]></title>
    <url>%2FszCDQ%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[模板及讲解什么是CDQ分治CDQ 分治就是将询问和修改(初值)都离线，然后对其分治的一种方法。具体就是每次将区间一分为二，然后只统计左边修改对右边询问的影响，以此类推。 CDQ分治解决什么问题CDQ 分治一般用来降维。比如有题需要树状数组套平衡树则可以降至只用树状数组解决。CDQ 分治优点是将询问和修改隔离，即转为静态问题，且常数较小。缺点必须离线。CDQ 分治的实现与归并排序类似。 二维偏序例题：Luogu 3374 已知一个数列，你需要进行下面两种操作：1、将某一个数加上$x$2、求区间和 将原数组先改为修改。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;set&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL MAXN = 500000 + 5; struct data { LL pos, tp, x; bool operator &lt; (const data &amp;rhs) { return pos == rhs.pos ? tp &lt; rhs.tp : pos &lt; rhs.pos; // 修改优先于查询 } } cz[MAXN * 4], b[MAXN * 4]; LL n, m, tot, xwtot, ans[MAXN]; void CDQ(LL l, LL r) { if (l &gt;= r) return ; LL M = (l + r) &gt;&gt; 1ll; CDQ(l, M), CDQ(M + 1ll, r); LL t1 = l, t2 = M + 1ll, cnt = 0ll, sum = 0ll; while (t1 &lt;= M &amp;&amp; t2 &lt;= r) { if (cz[t1] &lt; cz[t2]) { // 只处理左边修改 if (cz[t1].tp == 1) sum += cz[t1].x; ++cnt, b[cnt] = cz[t1++]; } else { // 只处理右边询问 if (cz[t2].tp == 2) ans[cz[t2].x] -= sum; if (cz[t2].tp == 3) ans[cz[t2].x] += sum; ++cnt, b[cnt] = cz[t2++]; } } while (t1 &lt;= M) { if (cz[t1].tp == 1) sum += cz[t1].x; ++cnt, b[cnt] = cz[t1++]; } while (t2 &lt;= r) { if (cz[t2].tp == 2) ans[cz[t2].x] -= sum; if (cz[t2].tp == 3) ans[cz[t2].x] += sum; ++cnt, b[cnt] = cz[t2++]; } // 将没有归并完的继续并 for (LL i = l; i &lt;= r; ++i) cz[i] = b[i - l + 1]; } void clean() { tot = xwtot = 0ll; } int solve() { clean(); scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m); for (LL x, i = 1ll; i &lt;= n; ++i) { scanf(&quot;%lld&quot;, &amp;x); cz[++tot] = (data){i, 1ll, x}; // 原数组上的每一位变成区间加操作 } for (LL tp, x, y, i = 1ll; i &lt;= m; ++i) { scanf(&quot;%lld%lld%lld&quot;, &amp;tp, &amp;x, &amp;y); if (tp == 1) { cz[++tot] = (data){x, 1ll, y}; } else { cz[++tot] = (data){x - 1ll, 2ll, ++xwtot}; cz[++tot] = (data){y, 3ll, xwtot}; // 询问区间拆成前缀和相减 } } CDQ(1ll, tot); for (LL i = 1; i &lt;= xwtot; ++i) printf(&quot;%lld\n&quot;, ans[i]); return 0; } } int main() { flyinthesky::solve(); return 0; } 三维偏序例题：Bzoj 3262 给出$n$个三元组$(x_i,y_i,z_i)$，对于每个三元组求有几个三元组$(x_j,y_j,z_j)$满足$x_i \geq x_j, y_i \geq y_j,z_i \geq z_j$ 将第一维排序，然后第二维用 CDQ 分治。第三维再用权值 BIT 来找答案。 注意要去重，因为&gt;=会使得相同的三元组互相影响。 写时注意： 1、根据题目偏序要求定flw[t1].y &lt;= flw[t2].y的比较符2、排序要三维都单调 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;set&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 200000 + 5; struct data { int x, y, z, id, sz; // 三维，flw 哪个位置，有几个数相同(内部大小) bool operator != (const data &amp;rhs) const { return !(x == rhs.x &amp;&amp; y == rhs.y &amp;&amp; z == rhs.z); } } whw[MAXN], flw[MAXN], b[MAXN]; // whw: 输入数组 flw: 去重后数组 b: CDQ辅助数组 int n, k, ans[MAXN], tax[MAXN], sz[MAXN]; // 每个去重后不算内部影响的答案，最后的答案，没有归并之前的大小 int a[MAXN], stp[MAXN], tot; bool cmp(data ra, data rb) { if (ra.x == rb.x) { if (ra.y == rb.y) return ra.z &lt; rb.z; else return ra.y &lt; rb.y; } else return ra.x &lt; rb.x; // 全部都要单调 } int lowbit(int x) {return x &amp; (-x);} void add(int x, int v) { for (int i = x; i &lt;= k; i += lowbit(i)) a[i] += v; } int query(int x) { int ret = 0; for (int i = x; i &gt; 0; i -= lowbit(i)) ret += a[i]; return ret; } void cl(int x) { // 清空当前树状数组 for (int i = x; i &lt;= k; i += lowbit(i)) a[i] = 0; } void CDQ(int l, int r) { int M = (l + r) &gt;&gt; 1; if (l &gt;= r) return ; CDQ(l, M), CDQ(M + 1, r); int t1 = l, t2 = M + 1, cnt = 0; tot = 0; while (t1 &lt;= M &amp;&amp; t2 &lt;= r) { if (flw[t1].y &lt;= flw[t2].y) { // &lt;= add(flw[t1].z, flw[t1].sz), stp[++tot] = flw[t1].z; b[++cnt] = flw[t1++]; // 只处理左边的增加 } else { ans[flw[t2].id] += query(flw[t2].z); b[++cnt] = flw[t2++]; // 只处理右边的查询 } } while (t1 &lt;= M) { b[++cnt] = flw[t1++]; } while (t2 &lt;= r) { ans[flw[t2].id] += query(flw[t2].z); b[++cnt] = flw[t2++]; } for (int i = 1; i &lt;= tot; ++i) cl(stp[i]); // 清空 for (int i = l; i &lt;= r; ++i) flw[i] = b[i - l + 1]; } void clean() { ms(ans, 0), ms(tax, 0), ms(a, 0); whw[0] = (data){0, 0, 0, 0, 0}; whw[n + 1] = (data){0, 0, 0, 0, 0}; } int solve() { scanf(&quot;%d%d&quot;, &amp;n, &amp;k); clean(); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d%d%d&quot;, &amp;whw[i].x, &amp;whw[i].y, &amp;whw[i].z); sort(whw + 1, whw + 1 + n, cmp); tot = 0; int gg = 0; for (int i = 1; i &lt;= n + 1; ++i) { // 去重 if (whw[i] != whw[i - 1]) flw[++tot] = whw[i], sz[tot - 1] = flw[tot - 1].sz = gg, gg = 1, flw[tot].id = tot; else ++gg; } int lstn = n; n = tot - 1; CDQ(1, n); for (int i = 1; i &lt;= n; ++i) ans[i] += sz[i] - 1; for (int i = 1; i &lt;= n; ++i) tax[ans[i]] += sz[i]; for (int i = 0; i &lt; lstn; ++i) printf(&quot;%d\n&quot;, tax[i]); return 0; } } int main() { flyinthesky::solve(); return 0; } 最优化问题斜率优化$x, k$都不单调：Bzoj 1492，Loj 2483 1、注意斜率不存在时INF的正负。2、注意CDQ分治时q[i].id与i的区别]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>CDQ分治</tag>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CH 4302」Interval GCD (树状数组 + 线段树 + GCD更相减损术 + 差分序列)]]></title>
    <url>%2FCH4302%2F</url>
    <content type="text"><![CDATA[CH 4302题意：给出一个$n$长序列，你要支持区间增加和查询区间$gcd$。 显然的线段树，但是区间增加对于$gcd$不好更新$lazy$标记。那么我们只能考虑一下能不能只单点修改，那么我们就想到了差分序列。根据$gcd(a,b)=gcd(a, b-a)$推出$gcd(a,b,c)=gcd(a,b-a,c-b)$然后推广到更多数字可以发现，区间$gcd$值就等于区间第一个数和之后区间的差分序列的$gcd$相等。所以只需要维护差分序列的$gcd$，线段树变为了单点修改区间查$gcd$。 因为要用到原数组，所以开一个 BIT 维护原数组的差分序列即可 知识点：1、pushup不要在叶节点进行。2、$gcd$一般为正数。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;set&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL MAXN = 500000 + 5; LL n, m, qwq[MAXN], bqwq[MAXN]; LL a[MAXN]; LL gcd(LL a, LL b) {return b == 0 ? a : gcd(b, a % b);} LL abss(LL x) {return x &gt; 0 ? x : -x;} LL lowbit(LL x) {return x &amp; (-x);} void add(LL x, LL p) { for (LL i = x; i &lt;= n; i += lowbit(i)) a[i] += p; } LL query(LL x) { LL ret = 0; for (LL i = x; i; i -= lowbit(i)) ret += a[i]; return ret; } #define lc (o &lt;&lt; 1) #define rc (o &lt;&lt; 1 | 1) #define M ((l + r) &gt;&gt; 1) LL gcdv[MAXN * 4]; void pushup(LL o) { gcdv[o] = gcd(gcdv[lc], gcdv[rc]); } void build(LL o, LL l, LL r) { if (l == r) gcdv[o] = bqwq[l]; else { build(lc, l, M), build(rc, M + 1, r); pushup(o); } } void update(LL o, LL l, LL r, LL p, LL v) { if (l == r) {gcdv[o] += v; return ;} // 不要加错了 if (p &lt;= M) update(lc, l, M, p, v); else update(rc, M + 1, r, p, v); pushup(o); } LL queryGCD(LL o, LL l, LL r, LL x, LL y) { if (x &lt;= l &amp;&amp; r &lt;= y) { return gcdv[o]; } LL ret = 0ll; if (x &lt;= M) ret = gcd(ret, queryGCD(lc, l, M, x, y)); if (M &lt; y) ret = gcd(ret, queryGCD(rc, M + 1, r, x, y)); return ret; } void clean() { ms(a, 0), ms(bqwq, 0); } int solve() { clean(); scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m); for (LL i = 1; i &lt;= n; ++i) scanf(&quot;%lld&quot;, &amp;qwq[i]); qwq[0] = 0; for (LL i = 1; i &lt;= n; ++i) bqwq[i] = qwq[i] - qwq[i - 1]; for (LL i = 1; i &lt;= n; ++i) add(i, bqwq[i]); build(1, 1, n + 1); while (m--) { char s[4]; scanf(&quot;%s&quot;, s); if (s[0] == &#39;Q&#39;) { LL x, y; scanf(&quot;%lld%lld&quot;, &amp;x, &amp;y); printf(&quot;%lld\n&quot;, abss(gcd(queryGCD(1, 1, n + 1, x + 1, y), query(x)))); // 注意 abss } else { LL x, y, d; scanf(&quot;%lld%lld%lld&quot;, &amp;x, &amp;y, &amp;d); add(x, d), add(y + 1, -d); update(1, 1, n + 1, x, d), update(1, 1, n + 1, y + 1, -d); } } return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>树状数组</tag>
        <tag>GCD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CH 5105」Cookies (DP + 输出方案)]]></title>
    <url>%2FCH5105%2F</url>
    <content type="text"><![CDATA[CH 5105题意：有$n$个人，每个人有一个$g_i$，现给$n$人分配$m$个饼干(每个人都要有饼干)，对于第$i$个人，比他饼干多的人数记为$a_i$，请最小化$\sum_{i=1}^n a_i g_i$ 容易发现$g_i$大的$a_i$尽可能小，所以$g_i$单调递减时分配的饼干也单调递减。对$g$降序排序后，设$dp(i,j)$为前$i$个人合分$j$块饼干的最小值。则有$$dp(i,j)=min(dp(i,j-i), min_{0 \leq k &lt; i}(dp(k, j - (i - k)) + k \cdot \sum_{x=k+1}^ig(x)))$$ 当第$i$位不填$1$时，前$i$个人分$j$块对应于前$i$个人分$j-i$块，因为每个人少拿一块，相对关系不变否则，枚举前面有几个和它一样的，统计答案。 注意解的输出要按照dp意义来，注意递归输出在本题会好用些。 知识点：1、DP 输出方案要按照dp意义来。并且有时候递归输出方便。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int INF = 1000000000; struct data { int g, id; } c[35]; int n, m, dp[35][5005], pre[35][5005][2], sum[35], ans[35]; bool cmp(data a, data b) {return a.g &gt; b.g;} void print(int x, int y) { if (x == 0 || y == 0) return ; print(pre[x][y][0], pre[x][y][1]); if (pre[x][y][0] == x) { for (int i = 1; i &lt;= x; ++i) ++ans[c[i].id]; } else for (int i = pre[x][y][0] + 1; i &lt;= x; ++i) ans[c[i].id] = 1; } void clean() { ms(pre, -1), ms(ans, 0); } int solve() { clean(); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; c[i].g, c[i].id = i; sort(c + 1, c + 1 + n, cmp); sum[0] = 0; for (int i = 1; i &lt;= n; ++i) sum[i] = sum[i - 1] + c[i].g; for (int i = 0; i &lt;= n; ++i) for (int j = 0; j &lt;= m; ++j) dp[i][j] = INF; dp[0][0] = 0; for (int i = 0; i &lt;= n; ++i) { for (int j = i; j &lt;= m; ++j) { if (dp[i][j - i] &lt; dp[i][j]) dp[i][j] = dp[i][j - i], pre[i][j][0] = i, pre[i][j][1] = j - i; for (int k = 0; k &lt; i; ++k) { if (dp[k][j - (i - k)] + k * (sum[i] - sum[k]) &lt; dp[i][j]) dp[i][j] = dp[k][j - (i - k)] + k * (sum[i] - sum[k]), pre[i][j][0] = k, pre[i][j][1] = j - (i - k); } } } printf(&quot;%d\n&quot;, dp[n][m]); print(n, m); for (int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, ans[i]); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「poj 2182」 Lost Cows (Splay / 树状数组+二分 / 线段树)]]></title>
    <url>%2Fpoj2182%2F</url>
    <content type="text"><![CDATA[「poj 2182」 Lost Cows题意：有$n$头牛，编号为$[1, n]$。 乱序排成一列，已知每头牛前面有多少头牛比它的编号小（从第二头牛开始）。现在要求从前到后，每一头牛的编号。 考虑逆向思考，对于第$n$头牛如果前面有$a_i$头比他小，那他得编号就是$a_i+1$对于第$n-1$头牛类似，只不过有可能编号在之前用过了，也就是在一个集合中找排名为$a_i+1$的数。所以我们要维护一个集合支持删除一个数，查询$rnk$，显然线段树和Splay是可行的。然而这里可以用编码量更小的树状数组+二分。因为正数前缀和有单调性，所以我们将存在和不存在记为一个二进制01序列，然后可以通过前缀和判断当前为是排名多少的。然后就能二分了。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;set&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 8000 + 5; int n, hh[MAXN], a[MAXN]; int lowbit(int x) {return x &amp; (-x);} void add(int x, int val) { for (int i = x; i &lt;= n; i += lowbit(i)) a[i] += val; } int query(int x) { int ret = 0; for (int i = x; i; i -= lowbit(i)) ret += a[i]; return ret; } void clean() { ms(a, 0); } int solve() { clean(); cin &gt;&gt; n; for (int i = 2; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;hh[i]); for (int i = 1; i &lt;= n; ++i) add(i, 1); for (int i = n; i &gt;= 2; --i) { int l = 1, r = n + 1, pos = 0; while (l &lt; r) { int mid = (l + r) &gt;&gt; 1; int res = query(mid); if (res &gt; hh[i] + 1) r = mid; else { if (res == hh[i] + 1) pos = mid, r = mid; else l = mid + 1; } } hh[i] = pos; add(pos, -1); } for (int i = 1; i &lt;= n; ++i) if (query(i)) {hh[1] = i; break ;} for (int i = 1; i &lt;= n; ++i) printf(&quot;%d\n&quot;, hh[i]); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>树状数组</tag>
        <tag>二分</tag>
        <tag>Splay</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CH 4201」楼兰图腾 (树状数组)]]></title>
    <url>%2FCH4201%2F</url>
    <content type="text"><![CDATA[CH 4201题意：给出$n$点个点$(i,y_i)$，若存在三点$(x_1,y_1), (x_2,y_2),(x_3,y_3)$，满足$x_1 &gt; x_2 &gt; x_3, y_1 &gt; y_2, y_3 &gt; y_2$则这三点称为v若存在三点$(x_1,y_1), (x_2,y_2),(x_3,y_3)$，满足$x_1 &gt; x_2 &gt; x_3, y_1 &lt; y_2, y_3 &lt; y_2$则这三点称为^ 请计算v, ^的个数 方法1：根据$y$排序，对于^，每次加入一个点前询问比这个点$y$值小的$[1,x)$和$(x, INF)$的点的个数，答案加上他们的乘积，对于v同理 方法2：根据$x$排序，对于v，对于每个数算出左右比$y$他大的点的个数，答案加上他们的乘积，对于^同理 知识点： // 根据 y 排序 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL MAXN = 200000 + 5; struct data { LL x, y; bool operator &lt; (const data &amp;rhs) const {return y &lt; rhs.y;} } pos[MAXN]; LL n, a[MAXN], ans1, ans2; LL lowbit(LL x) {return x &amp; (-x);} void add(LL p) { for (LL i = p; i &lt;= 200000ll; i += lowbit(i)) ++a[i]; } LL query(LL p) { LL ret = 0ll; for (LL i = p; i; i -= lowbit(i)) ret += a[i]; return ret; } void clean() { } int solve() { clean(); scanf(&quot;%lld&quot;, &amp;n); for (LL i = 1; i &lt;= n; ++i) scanf(&quot;%lld&quot;, &amp;pos[i].y), pos[i].x = i; sort(pos + 1, pos + 1 + n); ans1 = 0ll; ms(a, 0ll); for (LL i = 1; i &lt;= n; ++i) { ans1 += query(pos[i].x - 1ll) * (query(200000ll) - query(pos[i].x)); add(pos[i].x); } ans2 = 0ll; ms(a, 0ll); for (LL i = n; i; --i) { ans2 += query(pos[i].x - 1ll) * (query(200000ll) - query(pos[i].x)); add(pos[i].x); } printf(&quot;%lld %lld\n&quot;, ans2, ans1); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <tags>
        <tag>树状数组</tag>
        <tag>bitset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「poj 1733」Parity game (拆点并查集)]]></title>
    <url>%2Fpoj1733%2F</url>
    <content type="text"><![CDATA[poj 1733有字符串，由$0$和$1$组成，给出几个区间，并且告诉你区间里面$1$的个数的奇偶性，假设前面的话都是对的，问你到哪一句和前面的话矛盾。 这种题肯定想图论问题。对于区间，转化为前缀和相减。那么前缀和奇偶性相不相同就能确定了。若区间为奇数则奇偶性不同，否则奇偶性相同。然后拆点并查集判关系即可。对于区间，转化为前缀和相减 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { struct data { int l, r, x; } opt[5000 + 5]; int m, q, whw[10000 + 5], gg; int f[20000 + 5]; int getRealID(int x) {return lower_bound(whw + 1, whw + 1 + gg, x) - whw;} int find(int x) {return f[x] == x ? x : f[x] = find(f[x]);} void clean() { gg = 0; } int solve() { clean(); scanf(&quot;%d%d&quot;, &amp;m, &amp;q); for (int i = 1; i &lt;= q; ++i) { char s[10]; scanf(&quot;%d%d%s&quot;, &amp;opt[i].l, &amp;opt[i].r, s); if (s[0] == &#39;e&#39;) opt[i].x = 0; else opt[i].x = 1; whw[++gg] = opt[i].l - 1, whw[++gg] = opt[i].r; } sort(whw + 1, whw + 1 + gg), gg = unique(whw + 1, whw + 1 + gg) - whw - 1; for (int i = 0; i &lt;= 20000; ++i) f[i] = i; for (int i = 1; i &lt;= q; ++i) { int x = find(getRealID(opt[i].l - 1)), y = find(getRealID(opt[i].r)); int xn = find(getRealID(opt[i].l - 1) + gg), yn = find(getRealID(opt[i].r) + gg); if (x == y) { // 奇偶性相同 if (opt[i].x == 1) return printf(&quot;%d\n&quot;, i - 1), 0; } else if (x == yn) { if (opt[i].x == 0) return printf(&quot;%d\n&quot;, i - 1), 0; } if (opt[i].x == 0) f[x] = y, f[xn] = yn; else f[x] = yn, f[y] = xn; } printf(&quot;%d\n&quot;, q); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 4195」「Noi2015」程序自动分析 (并查集)]]></title>
    <url>%2Fbzoj4195%2F</url>
    <content type="text"><![CDATA[BZOJ 4195题意：给出$n$组关系，$x_i=x_j$或$x_i≠x_j$，请判断是否能有一种方法满足情况。 想到图论就不难了……显然将等于看作无向边，然后一个联通块的都是相等的。然后再枚举每个不等的二元组，判是否在一个联通块即可。用并查集维护。 注意要离散化。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 1000000 + 5; struct data {int x, y, e;} opt[MAXN]; int q, whw[MAXN * 2], gg, f[MAXN * 2]; int getRealID(int x) {return lower_bound(whw + 1, whw + 1 + gg, x) - whw;} int find(int x) {return x == f[x] ? x : f[x] = find(f[x]);} void clean() { gg = 0; } int solve() { clean(); scanf(&quot;%d&quot;, &amp;q); for (int i = 1; i &lt;= q; ++i) scanf(&quot;%d%d%d&quot;, &amp;opt[i].x, &amp;opt[i].y, &amp;opt[i].e), whw[++gg] = opt[i].x, whw[++gg] = opt[i].y; sort(whw + 1, whw + 1 + gg), gg = unique(whw + 1, whw + 1 + gg) - whw - 1; for (int i = 1; i &lt;= gg; ++i) f[i] = i; for (int i = 1; i &lt;= q; ++i) if (opt[i].e == 1) { int x = find(getRealID(opt[i].x)), y = find(getRealID(opt[i].y)); if (x != y) f[x] = y; } for (int i = 1; i &lt;= gg; ++i) find(i); for (int i = 1; i &lt;= q; ++i) if (opt[i].e == 0) { int x = find(getRealID(opt[i].x)), y = find(getRealID(opt[i].y)); if (x == y) return printf(&quot;NO\n&quot;), 0; } return printf(&quot;YES\n&quot;), 0; return 0; } } int main() { int t; cin &gt;&gt; t; while (t--) flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>Bzoj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1951」「Sdoi2010」古代猪文(Lucas + 中国剩余定理合并 + 欧拉定理)]]></title>
    <url>%2Fbzoj1951%2F</url>
    <content type="text"><![CDATA[BZOJ 1951题意：给定$N,G$, 求$$G^{\sum_{K|N}C^{\frac NK}_{n}} \mod 999911659$$ 根据欧拉定理推论$$a^b \equiv a^{b \mod \varphi(n)} \pmod {n}$$以及$999911659$为质数，可以得到$$G^{\sum_{K|N}C^{\frac NK}_{n} \mod 999911658} \mod 999911659$$那么主要就是求$\sum_{K|N}C^{\frac NK}_{n} \mod 999911658$。这个可以用 Lucas 来解决，但是模数不一定是质数，我们就要想分解因数再合并。 因为$999911658=2 \times 3 \times 4679 \times 35617$，所以我们可以解出答案模$2,3 ,4679, 35617$意义下的$4$个解，记为$a_i$，那么算完后我们通过以下方程组解得$x$即可求出最终结果：$$\begin{cases}x \equiv a_1 \pmod {2} \\x \equiv a_2 \pmod {3} \\x \equiv a_3 \pmod {4679} \\x \equiv a_4 \pmod {35617}\end{cases}$$显然是中国剩余定理，最终解是在模$2 \times 3 \times 4679 \times 35617=999911658$意义下的，所以符合题意。然后再快速幂算出最后答案即可。注意特判$999911659|G$的情况。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { LL N, G; LL p[10] = {0ll, 2ll, 3ll, 4679ll, 35617ll}, jc[10][50000], a[10], mi[10]; // p[ith] = MO, jc[ith][n] = n! % p[ith] LL ksm(LL a, LL b, LL MO) { LL bs = a % MO, ans = 1ll; while (b) { if (b &amp; 1ll) ans = (ans * bs) % MO; bs = (bs * bs) % MO; b &gt;&gt;= 1ll; } return ans; } void exgcd(LL a, LL b, LL &amp;x, LL &amp;y) { if (b == 0ll) { x = 1ll, y = 0ll; return ; } exgcd(b, a % b, x, y); LL tmp = x; x = y, y = tmp - a / b * y; } LL C(LL n, LL m, LL k) { if(n &lt; m) return 0ll; // 不要漏了 LL ans = jc[k][n] * ksm(jc[k][m], p[k] - 2ll, p[k]) % p[k]; return (ans * ksm(jc[k][n - m], p[k] - 2ll, p[k])) % p[k]; } LL lucas(LL n, LL m, LL k) { if (n &lt; m) return 0ll; // 不要漏了 if (m == 0ll) return 1ll; return C(n % p[k], m % p[k], k) * lucas(n / p[k], m / p[k], k) % p[k]; } void clean() { ms(a, 0ll); } int solve() { clean(); cin &gt;&gt; N &gt;&gt; G; if (G % 999911659ll == 0ll) return printf(&quot;0\n&quot;), 0; for (LL j = 1ll; j &lt;= 4ll; ++j) { jc[j][0] = 1ll; for (LL i = 1ll; i &lt;= p[j]; ++i) jc[j][i] = (jc[j][i - 1] * i) % p[j]; } LL test = lucas(15015, 5005, 1); for (LL j = 1ll; j &lt;= 4ll; ++j) { for (LL i = 1ll; i * i &lt;= N; ++i) { if (N % i == 0) { a[j] = (a[j] + lucas(N, i, j)) % p[j]; if (N / i != i) a[j] = (a[j] + lucas(N, N / i, j)) % p[j]; } } } for (LL i = 1ll; i &lt;= 4ll; ++i) mi[i] = p[i]; LL M = 999911658ll, ans = 0ll; for (LL i = 1ll; i &lt;= 4ll; ++i) { LL Mi = M / mi[i], x, y; exgcd(Mi, mi[i], x, y); ans = (ans + (a[i] * Mi % M) * x % M) % M; } cout &lt;&lt; ksm(G, (ans + M) % M, 999911659ll); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>Lucas</tag>
        <tag>中国剩余定理</tag>
        <tag>欧拉定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 2973」石头游戏 (矩阵快速幂)]]></title>
    <url>%2Fbzoj2973%2F</url>
    <content type="text"><![CDATA[bzoj 2973题意：见上。我们考虑一维怎么做，其实二维就可以在一维基础上标号即可。然后对于原题就是一个矩阵转化的过程。根据$T$很大也可以看出。操作序列不一样长可以求个$lcm$然后都等长，因为$lcm(1,2,…,6)=60$，所以不会很大根据转移矩阵构造方法：若状态矩阵中的第 $x$ 个数对下个单位时间状态矩阵的第 $y$ 个数产生影响，则吧转移矩阵的第 $x$ 行第$ y$ 列赋值为适当的系数对于方向的移动，我们让$(x,y)-&gt;(x+dx,y+dy)=1$对于数字的增加，我们让$(0,y)-&gt;(x,y)=x, (x,y)-&gt;(x,y)=1$此时我们就要保证$(0, 0)-&gt;(0, 0)=1$，否则转移就没了对于D，不用额外操作。然后矩阵快速幂求$lcm$的整块即可。不完整的块暴力。知识点：1、根据转移矩阵构造方法：若状态矩阵中的第 $x$ 个数对下个单位时间状态矩阵的第 $y$ 个数产生影响，则吧转移矩阵的第 $x$ 行第$ y$ 列赋值为适当的系数2、矩阵乘法不要写错，快速幂$BS$自乘不要写错3、判==0不要忘了写 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;bitset&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { struct matrix { LL x, y, a[100][100]; void init(LL n, LL m) {x = n, y = m, ms(a, 0ll);} }A[65], tt, f; LL l, n, m, t, act, len[10]; char s[10][10], opt[10][10]; LL gcd(LL a, LL b) {return b == 0ll ? a : gcd(b, a % b);} LL lcm(LL a, LL b) {return a * b / gcd(a, b);} LL getIDByPos(LL x, LL y) {return (x - 1ll) * m + y;} matrix mul(matrix a, matrix b) { matrix ret; ret.init(a.x, b.y); for (LL i = 0ll; i &lt;= a.x; ++i) { for (LL j = 0ll; j &lt;= a.y; ++j) { for (LL k = 0ll; k &lt;= b.x; ++k) ret.a[i][j] += a.a[i][k] * b.a[k][j]; } } return ret; } matrix ksm(matrix a, LL b) { matrix bs = a, ans; int fl = 0ll; while (b) { if (b &amp; 1ll) { if (!fl) fl = 1ll, ans = bs; else ans = mul(ans, bs); } bs = mul(bs, bs); b &gt;&gt;= 1ll; } return ans; } void clean() { } int solve() { clean(); l = 1ll; cin &gt;&gt; n &gt;&gt; m &gt;&gt; t &gt;&gt; act; for (LL i = 1ll; i &lt;= n; ++i) scanf(&quot;%s&quot;, s[i] + 1ll); for (LL i = 0ll; i &lt; act; ++i) scanf(&quot;%s&quot;, opt[i]), len[i] = strlen(opt[i]), l = lcm(l, len[i]); tt.init(n * m, n * m); for (LL i = 0; i &lt;= n * m; ++i) tt.a[i][i] = 1ll; for (LL i = 0ll; i &lt; l; ++i) { A[i].init(n * m, n * m), A[i].a[0][0] = 1ll; for (LL x = 1ll; x &lt;= n; ++x) { for (LL y = 1ll; y &lt;= m; ++y) { char op = opt[s[x][y] - &#39;0&#39;][i % len[s[x][y] - &#39;0&#39;]]; if (op == &#39;N&#39; &amp;&amp; x - 1ll &gt; 0ll) A[i].a[getIDByPos(x, y)][getIDByPos(x - 1ll, y)] = 1ll; if (op == &#39;S&#39; &amp;&amp; x + 1ll &lt;= n) A[i].a[getIDByPos(x, y)][getIDByPos(x + 1ll, y)] = 1ll; if (op == &#39;E&#39; &amp;&amp; y + 1ll &lt;= m) A[i].a[getIDByPos(x, y)][getIDByPos(x, y + 1ll)] = 1ll; if (op == &#39;W&#39; &amp;&amp; y - 1ll &gt; 0ll) A[i].a[getIDByPos(x, y)][getIDByPos(x, y - 1ll)] = 1ll; if (&#39;0&#39; &lt;= op &amp;&amp; op &lt;= &#39;9&#39;) A[i].a[0][getIDByPos(x, y)] = op - &#39;0&#39;, A[i].a[getIDByPos(x, y)][getIDByPos(x, y)] = 1ll; } } tt = mul(tt, A[i]); } tt = ksm(tt, t / l); for (LL i = 0ll; i &lt; t % l; ++i) tt = mul(tt, A[i]); f.init(1ll, m * n), f.a[0][0] = 1ll; f = mul(f, tt); LL maxd = 0; for (LL i = 1ll; i &lt;= n * m; ++i) maxd = max(maxd, f.a[0][i]); cout &lt;&lt; maxd; return 0; } } int main() { flyinthesky::solve(); return 0; } 描述石头游戏在一个 n 行 m 列 (1≤n,m≤8) 的网格上进行，每个格子对应一种操作序列，操作序列至多有10种，分别用0~9这10个数字指明。操作序列是一个长度不超过6且循环执行、每秒执行一个字符的字符串。每秒钟，所有格子同时执行各自操作序列里的下一个字符。序列中的每个字符是以下格式之一：数字0~9：表示拿0~9个石头到该格子。NWSE：表示把这个格子内所有的石头推到相邻的格子，N表示上方，W表示左方，S表示下方，E表示右方。D：表示拿走这个格子的所有石头。给定每种操作序列对应的字符串，以及网格中每个格子对应的操作序列，求石头游戏进行了 t 秒之后，石头最多的格子里有多少个石头。在游戏开始时，网格是空的。输入格式第一行4个整数n, m, t, act。接下来n行，每行m个字符，表示每个格子对应的操作序列。最后act行，每行一个字符串，表示从0开始的每个操作序列。 输出格式一个整数：游戏进行了t秒之后，所有方格中最多的格子有多少个石头。 样例输入1 6 10 30111121EE0样例输出3样例解释这是另一个类似于传送带的结构。左边的设备0间隔地产生石头并向东传送。设备1向右传送，直到设备2。10秒后，总共产生了5个石头，2个在传送带上，3个在最右边。]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>矩阵</tag>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「poj 3696」The Luckiest number (欧拉定理)]]></title>
    <url>%2Fpoj3696%2F</url>
    <content type="text"><![CDATA[poj 3696题意：给定$L$, 求最少几个$8$组成的数是$L$的倍数。对于这个$8$数来说，他的表示方法可以是$\sum^{n-1}_{i=0} 8 \cdot 10^i$。这样明显很不方便，我们想到学数列时的表示方法，$\frac{8(10^x-1)}{9}$。本题就是要求$L|\frac{8(10^x-1)}{9}$的最小$x$解。我们将分数先消掉，得$9L|8(10^x-1)$，然后这个整除式等同于同余式$8(10^x-1) \equiv 0 \pmod {9L}$再进行化简，得$10^x \equiv 1 \pmod {\frac{9L}{gcd(8,9L)}}$ (同余基本性质) 引理: $a^x \equiv 1 \pmod{n}$的最小正整数解为$\varphi(n)$的约数。 具体可以用反证法+设带余除法形式证明。 然后应用在本题就是求出对应的$\varphi$值然后用试除法找每个因子用最开始的同余式判断即可。注意快速幂的取模，由于是模意义下的。 本题数据大要快速乘解决溢出的问题 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; LL kse = 0; namespace flyinthesky { LL L; LL gcd(LL a, LL b) { return b == 0 ? a : gcd(b, a % b); } LL mul(LL a, LL b) { LL bs = a, ans = 0ll; while (b) { if (b &amp; 1ll) ans = (ans + bs) % (L * 9ll); bs = (bs + bs) % (L * 9ll); b &gt;&gt;= 1ll; } return ans; } LL ksm(LL a, LL b) { LL bs = a, ans = 1ll; while (b) { if (b &amp; 1ll) ans = mul(ans, bs); bs = mul(bs, bs); b &gt;&gt;= 1ll; } return ans; } LL getphi(LL x) { LL ans = x; for (LL i = 2ll; i * i &lt;= x; ++i) { if (x % i == 0) { ans = ans / i * (i - 1ll); while (x % i == 0ll) x /= i; } } if (x != 1ll) ans = ans / x * (x - 1ll); return ans; } LL chk(LL x) { LL res = ksm(10ll, x); --res, res = (res + (L * 9ll)) % (L * 9ll); res *= 8ll; res %= (L * 9ll); if (res == 0) return true; return false; } void clean() { } int solve() { clean(); LL phi = getphi(9 * L / gcd(8ll, 9ll * L)); LL ans = 9223372036854775807ll; for (LL i = 1ll; i * i &lt;= phi; ++i) { if (phi % i == 0ll) { if (chk(i)) ans = min(ans, i); if (phi / i != i) { if (chk(phi / i)) ans = min(ans, phi / i); } } } if (ans == 9223372036854775807ll) cout &lt;&lt; &quot;Case &quot; &lt;&lt; ++kse &lt;&lt; &quot;: &quot; &lt;&lt; 0 &lt;&lt; endl; else cout &lt;&lt; &quot;Case &quot; &lt;&lt; ++kse &lt;&lt; &quot;: &quot; &lt;&lt; ans &lt;&lt; endl; return 0; } } int main() { while (scanf(&quot;%lld&quot;, &amp;flyinthesky::L) &amp;&amp; flyinthesky::L) flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>欧拉定理</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1975」「Sdoi2010」魔法猪学院 (A* 求 k 短路)]]></title>
    <url>%2Fbzoj1975%2F</url>
    <content type="text"><![CDATA[BZOJ 1975题意：求有向图中最多的几条路径和小于一个值。很容易想到先求最短路，再求次短路，再求第三短路，然后值一直减下去直到不够为止。所以就是明显的$k$短路模板了。用 Astar 算法可以解决。我们想一个问题，在求最短路中，若不考虑松弛关系，则第$k$次出队的最短路就是$k$短路。所以我们可以 优先队列 BFS，在不超过限定的$k$短路时一直搜。但是这复杂度最坏能到$O(k(n + m)log(n+m))$，直接爆炸我们尝试为BFS增加一个估价函数，即搜到某个点时的实际距离$dis(u)$，估计一下到终点最小走多少距离$g(u)$，$f(u)=dis(u)+g(u)$即为估价函数。我们将这个设为堆的关键字拓展就能减少很多枚举。这就是 Astar 算法Astar 算法就是：有估价，其中估价一定要比实际的更优，其实是一种最优化剪枝 (对未来预测，按最低标准来讲)注意在 Astar 中不用存当前的$dis(u)$，因为这个是被不断更新的，只需要判断不超过限定的$k$短路即可 剪枝：1、设定最大的$k$，所有点只要出队不小于$k$次都剪枝，因为这样到终点一定会超过$k$ #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 5000 + 5; struct data { int u; db opti; bool operator &lt; (const data &amp;rhs) const {return opti &gt; rhs.opti;} }; int n, m, vis[MAXN], ans = 0; db egy, g[MAXN]; vector&lt;int &gt; G[MAXN], FG[MAXN]; vector&lt;db &gt; W[MAXN], FW[MAXN]; priority_queue&lt;data &gt; q; void ins(int u, int v, db w) { G[u].push_back(v), W[u].push_back(w); FG[v].push_back(u), FW[v].push_back(w); } void dij() { // 对反图求最短路 (估价函数 g(x)) for (int i = 0; i &lt;= n; ++i) g[i] = 3e13, vis[i] = 0; g[n] = 0.0, q.push((data){n, 0.0}); while (!q.empty()) { data p = q.top(); q.pop(); if (vis[p.u]) continue ; vis[p.u] = 1; for (int i = 0; i &lt; (int)FG[p.u].size(); ++i) { int v = FG[p.u][i]; db w = FW[p.u][i]; if (g[v] &gt; g[p.u] + w) { g[v] = g[p.u] + w; q.push((data){v, g[v]}); } } } } void Astar(int maxk) { for (int i = 0; i &lt;= n; ++i) vis[i] = 0; q.push((data){1, g[1]}); while (!q.empty()) { data p = q.top(); q.pop(); db dis = p.opti - g[p.u]; // 实际距离 ++vis[p.u]; if (egy &lt; p.opti) continue ; // 不够，剪枝 if (vis[p.u] &gt; maxk) continue ; // 出队次数不小于k剪枝 if (p.u == n) ++ans, egy -= dis; // 减掉 for (int i = 0; i &lt; (int)G[p.u].size(); ++i) { int v = G[p.u][i]; db w = W[p.u][i]; if (vis[v] &lt; maxk) q.push((data){v, dis + w + g[v]}); } } } void clean() { } int solve() { clean(); scanf(&quot;%d%d%lf&quot;, &amp;n, &amp;m, &amp;egy); for (int i = 1; i &lt;= m; ++i) { int u, v; db ei; scanf(&quot;%d%d%lf&quot;, &amp;u, &amp;v, &amp;ei); ins(u, v, ei); } dij(); Astar(egy / g[1]); // maxk 的设定 printf(&quot;%d\n&quot;, ans); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>A*</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「poj 1830」开关问题 (高斯消元解线性 Xor 方程)]]></title>
    <url>%2Fpoj1830%2F</url>
    <content type="text"><![CDATA[poj 1830题意：见上。设$x_i$为$i$开关是否(0/1)操作，$a_{i,j}$为$j$开关操作后是否(1/0)会影响$i$开关 则可以列出线性异或方程组 $$\begin{cases}a_{1,1}x_1 xor a_{1,2}x_2 xor … xor a_{1,n}x_n = st_1 xor ed_1 \\a_{2,1}x_1 xor a_{2,2}x_2 xor … xor a_{2,n}x_n = st_2 xor ed_2 \\\vdots \\a_{n,1}x_1 xor a_{n,2}x_2 xor … xor a_{n,n}x_n = st_n xor ed_n\end{cases}$$ 高斯消元即可。 知识点：1、自由元最后统计 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;bitset&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 35; int n, a[MAXN]; bitset&lt;MAXN&gt; bs[MAXN]; int ksm(int a, int b) { int bs = a, ans = 1; while (b) { if (b &amp; 1) ans *= bs; bs *= bs; b &gt;&gt;= 1; } return ans; } void clean() { } int solve() { clean(); cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i]); for (int x, i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;x), a[i] ^= x; for (int i = 1; i &lt;= n; ++i) bs[i].reset(), bs[i][0] = a[i], bs[i][i] = 1; int x, y; while (scanf(&quot;%d%d&quot;, &amp;x, &amp;y) == 2 &amp;&amp; x &amp;&amp; y) bs[y][x] = 1; int ans = 1, whw = 0; for (int i = 1; i &lt;= n; ++i) { // 每列 if (bs[i][i] == 0) { for (int j = i + 1; j &lt;= n; ++j) if (bs[j][i]) {swap(bs[j], bs[i]); break;} } if (bs[i][0] == 1 &amp;&amp; bs[i].count() == 1) {ans = 0; break ;} if (bs[i][i] == 0) ++whw; for (int j = i + 1; j &lt;= n; ++j) if (bs[j][i]) bs[j] ^= bs[i]; } if (ans == 0) printf(&quot;Oh,it&#39;s impossible~!!\n&quot;); else printf(&quot;%d\n&quot;, ksm(2, whw)); return 0; } } int main() { int k; cin &gt;&gt; k; while (k--) flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>高斯消元</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 981D(存在性DP+位运算性质)]]></title>
    <url>%2FCodeforces981D%2F</url>
    <content type="text"><![CDATA[Codeforces 981D题意：给定$n$个数数列，求将数列分成$k$部分的和按位与的最大值。最开始认为DP但是不符合子结构最优性质……但是我们可以转化为存在性 DP，我们发现题目的所求答案不会大于$2^{50} \times 50$根据位运算性质，我们贪心地，二进制下取高位一定是比取下所有低位的优的，所有我们要不遗余力地尽可能取高位，所以从高位开始枚举检验能不能取。可以用存在性DP来判。具体实现可以看代码实现知识点：1、所有 LL 数都加上 ll 后缀；2、DP 要看满不满足子结构最优性质，不要上来就 DP，可以转成存在性 DP #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;map&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL MAXN = 55ll; LL now, n, k, a[MAXN], sum[MAXN][MAXN], dp[MAXN][MAXN]; LL chk(LL x) { LL gg = now | (1ll &lt;&lt; x); // 1ll! ms(dp, 0ll); for (LL i = 1ll; i &lt;= n; ++i) if ((sum[1ll][i] &amp; gg) == gg) dp[i][1ll] = 1ll; for (LL i = 1ll; i &lt;= n; ++i) { for (LL j = 1ll; j &lt;= i; ++j) { for (LL o = 1ll; o &lt; i; ++o) { if ((sum[i - o + 1ll][i] &amp; gg) == gg) dp[i][j] |= dp[i - o][j - 1ll]; } } } return dp[n][k]; } void clean() { } int solve() { clean(); cin &gt;&gt; n &gt;&gt; k; for (LL i = 1ll; i &lt;= n; ++i) cin &gt;&gt; a[i]; for (LL i = 1ll; i &lt;= n; ++i) { sum[i][0ll] = 0ll; for (LL j = i; j &lt;= n; ++j) sum[i][j] = sum[i][j - 1ll] + a[j]; } now = 0ll; for (LL i = 55ll; i &gt;= 0ll; --i) { if (chk(i)) now |= (1ll &lt;&lt; i); } cout &lt;&lt; now; return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CH 2101」可达性统计 (bitset + 记忆化)]]></title>
    <url>%2FCH2101%2F</url>
    <content type="text"><![CDATA[CH 2101题意：给定一张$n$个点$m$条边的有向无环图，分别统计从每个点出发能够到达的点的数量。 DAG图想到 DP / 拓扑，这里显然 DP，设 $dp(u) $为$u$的可达点二进制集合 (bitset)，则$$dp(u)= x \cup (\bigcup_{(u,v) \in E} dp(v))$$ 答案为$$\sum_{i=1}^n |dp(i)|$$ 记忆化搜索即可，集合用 bitset 维护。 知识点：1、Bitset 运用 (记录状态)2、记忆化搜索无所谓顺序3、记忆化搜索返回值比较大不要用，用其他方法，否则会 MLE4、bitset 一次操作复杂度为 $O(\frac n {32})$ #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;bitset&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 30000 + 5; struct edge { int v, nxt; } ed[MAXN * 2]; int n, m, en, hd[MAXN]; int vis[MAXN]; bitset&lt;30001&gt; bs[MAXN]; queue&lt;int &gt; q; void ins(int u, int v) {ed[++en] = (edge){v, hd[u]}, hd[u] = en;} void dfs(int u) { if (vis[u]) return ; vis[u] = 1; for (int i = hd[u]; i &gt; 0; i = ed[i].nxt) { edge &amp;e = ed[i]; bs[u] |= (dfs(e.v), bs[e.v]); } } void clean() { en = 0, ms(hd, -1), ms(vis, 0); } int solve() { clean(); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int u, v, i = 1; i &lt;= m; ++i) scanf(&quot;%d%d&quot;, &amp;u, &amp;v), ins(u, v); for (int i = 1; i &lt;= n; ++i) bs[i].set(i - 1, 1); for (int i = 1; i &lt;= n; ++i) if (!vis[i]) dfs(i); for (int i = 1; i &lt;= n; ++i) printf(&quot;%d\n&quot;, bs[i].count()); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <tags>
        <tag>计数DP</tag>
        <tag>bitset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高斯消元 学习笔记]]></title>
    <url>%2Fsz%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%2F</url>
    <content type="text"><![CDATA[模板及讲解高斯消元是什么求解多元一次方程组的一个消元方法，主要借助矩阵来完成。 例题Luogu 2455 我们发现给定的方程组解只和系数有关，所以将系数和常数提取出来构造矩阵：例$$\begin{cases}2x+y+z=1\\6x+2y+z=-1\\-2x+2y+z=7\end{cases}$$则构造矩阵：$$\left[ \begin{array}{ccc|c} 2 &amp; 1 &amp; 1&amp;1 \\ 6 &amp; 2 &amp; 1&amp;-1\\ -2&amp;2&amp;1&amp;7 \end{array}\right]$$ 高斯消元的操作有(初等行变换)：1、交换两行。2、将一行用非零数乘。3、将一行的若干倍加到另一行上。 也就是差不多是小学学的加减消元带入消元的操作。 高斯消元目标：将原矩阵转化为一个阶梯形矩阵，即$$\left[ \begin{array}{ccc|c} 2 &amp; 1 &amp; 1&amp;1 \\ 0 &amp; -1&amp; -2&amp;-4\\ 0&amp;0&amp;-4&amp;-4 \end{array}\right]$$将后面的行带入上面的行，可得一个简化阶梯形矩阵$$\left[ \begin{array}{ccc|c} 1 &amp; 0 &amp; 0&amp;-1 \\ 0 &amp; 1&amp; 0&amp;2\\ 0&amp;0&amp;1&amp;1 \end{array}\right]$$直接可以读出每个元素的解。 高斯消元一般步骤：逐步处理每一个$x_i$，将$i$列除了$i$行的其他系数都变为0，即我们可以先保证$i$行$i$列不为0，然后以这一行为基准将其他行$i$位置的系数都变为0。用初等行变换的交换可以满足第一个条件，用初等行变换将一行的若干倍加到另一行上可以做到第二个条件。做完之后只有对角线和常数有值，每一行的常数除以对角线的值即为第$i$个元素的解。 无解情况：系数都为0，常数不为0无穷解情况：系数都为0，常数也为0 两个概念：1、主元：确定唯一的未知量2、自由元：不确定值未知量，对应情况为该行全为0，有无穷解 注意在判这两个之前要先判有没有不是对角线上的系数有值，如果有则这一行不进行检查。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 105; const db eps = 1e-12; int n; db c[MAXN][MAXN], b[MAXN]; // c, b 为消元矩阵 void clean() { ms(b, 0); } int solve() { clean(); scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= n; ++j) scanf(&quot;%lf&quot;, &amp;c[i][j]); scanf(&quot;%lf&quot;, &amp;b[i]); } for (int i = 1; i &lt;= n; ++i) { // 处理 xi[i] 的系数 for (int j = i; j &lt;= n; ++j) { // 从后面没处理的行找 xi[i] 系数不为 0 的行交换 if (fabs(c[j][i]) &gt; eps) { swap(b[i], b[j]); for (int k = 1; k &lt;= n; ++k) swap(c[i][k], c[j][k]); } } if (fabs(c[i][i]) &lt; eps) continue ; // 注意 for (int j = 1; j &lt;= n; ++j) { // 消去其他方程 xi[i] 的系数 if (i == j) continue ; db rat = c[j][i] / c[i][i]; for (int k = 1; k &lt;= n; ++k) c[j][k] -= rat * c[i][k]; b[j] -= rat * b[i]; } } int bj = 1; for (int i = 1; i &lt;= n; ++i) { int fl = 0; for(int j = 1; j &lt;= n; ++j){ if (i != j &amp;&amp; fabs(c[i][j]) &gt; eps) {fl = 1; break ;} } if (fl) continue ; // 必须判 if (fabs(c[i][i]) &lt; eps &amp;&amp; fabs(b[i]) &gt; eps) bj = -1; if (fabs(c[i][i]) &lt; eps &amp;&amp; fabs(b[i]) &lt; eps &amp;&amp; bj != -1) bj = 0; } if (bj != 1) return printf(&quot;%d\n&quot;, bj), 0; for (int i = 1; i &lt;= n; ++i) { if (fabs(b[i] / c[i][i]) &lt; eps) printf(&quot;x%d=0\n&quot;, i); else printf(&quot;x%d=%.2lf\n&quot;, i, b[i] / c[i][i]); } return 0; } } int main() { flyinthesky::solve(); return 0; } 异或方程组高斯消元可以用来解线性的异或方程组，方法与前者类似。 例题：poj 1830 设$x_i$为$i$开关是否(0/1)操作，$a_{i,j}$为$j$开关操作后是否(1/0)会影响$i$开关 则可以列出线性异或方程组 $$\begin{cases}a_{1,1}x_1 xor a_{1,2}x_2 xor … xor a_{1,n}x_n = st_1 xor ed_1 \\a_{2,1}x_1 xor a_{2,2}x_2 xor … xor a_{2,n}x_n = st_2 xor ed_2 \\\vdots \\a_{n,1}x_1 xor a_{n,2}x_2 xor … xor a_{n,n}x_n = st_n xor ed_n\end{cases}$$ 然后对于异或实际上我们也可以进行消元得到简化阶梯形矩阵，并且不需要乘除，因为只有 0 和 1。可以用 bitset 加速运算且代码更简洁高效。 无解即为形如$0 xor 0 xor … xor 0 =1$的，显然不成立。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;bitset&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 35; int n, a[MAXN]; bitset&lt;MAXN&gt; bs[MAXN]; int ksm(int a, int b) { int bs = a, ans = 1; while (b) { if (b &amp; 1) ans *= bs; bs *= bs; b &gt;&gt;= 1; } return ans; } void clean() { } int solve() { clean(); cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i]); for (int x, i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;x), a[i] ^= x; for (int i = 1; i &lt;= n; ++i) bs[i].reset(), bs[i][0] = a[i], bs[i][i] = 1; int x, y; while (scanf(&quot;%d%d&quot;, &amp;x, &amp;y) == 2 &amp;&amp; x &amp;&amp; y) bs[y][x] = 1; int ans = 1, whw = 0; for (int i = 1; i &lt;= n; ++i) { // 每列 if (bs[i][i] == 0) { // 找一个非零的 for (int j = i + 1; j &lt;= n; ++j) if (bs[j][i]) {swap(bs[j], bs[i]); break;} } if (bs[i][0] == 1 &amp;&amp; bs[i].count() == 1) {ans = 0; break ;} // 无解 if (bs[i][i] == 0) ++whw; // 自由元 for (int j = i + 1; j &lt;= n; ++j) if (bs[j][i]) bs[j] ^= bs[i]; } if (ans == 0) printf(&quot;Oh,it&#39;s impossible~!!\n&quot;); else printf(&quot;%d\n&quot;, ksm(2, whw)); return 0; } } int main() { int k; cin &gt;&gt; k; while (k--) flyinthesky::solve(); return 0; } 同余高斯消元模板题：CF 1155E 求解带环期望DP1、CF 24D：列与列之间不满足无后效性 (注意此时高斯消元做成阶梯矩阵即可，不需要简化，简化直接回带) 线性基定义一下内容部分来自 线性基学习笔记 | Menci’s Blog 异或和：设 $S$ 为一无符号整数集（下文中除非特殊说明，集合均指无符号整数集），定义其异或和为$S_1 xor S_2 xor \cdots xor S_{|S|}$。 线性相关：集合中存在一个元素$S_j$，使得集合中其他元素可以通过异或和的方式得到$S_j$，则$S$线性相关。若不存在，则$S$线性无关。 线性基：称集合 $B$ 是集合 $S$ 的线性基，当且仅当： $B$ 线性无关 $B$ 中元素可以通过异或和方式得到$S$中的所有值 线性基性质： $B$ 是极小的满足线性基性质的集合，它的任何真子集都不可能是线性基 $S$ 中的任意元素都可以唯一表示为 $B$ 中若干个元素异或起来的结果。 构造构造出来的线性基相当于于所有插入值高斯消元后的简化阶梯矩阵。 设维护的数的二进制长度为$L$，线性基数组为$a_i(0 \leq i \leq L)$为了保证线性无关，$a_i$的第$i$位若为$1$，则其他线性基上第$i$位都为$0$，并且$a_i$高于$i$位上的值都必须为$0$(否则会影响后面线性基的”其他线性基上第$i$位都为$0$”)。 所以构造方法即为(插入数$t$)：1、将$t$倒序枚举二进制位$i$，然后2、若$t$的$i$位为0，则continue否则： 如果$a_i$不为$0$，则用$a_i$消去$t$的$i$位上的二进制$1$，然后continue 如果$a_i$为$0$，那么$t$就能插进$i$位。但是要先用$[1, i)$的线性基消去$t$的相应位置的$1$，以保证”其他线性基上第$i$位都为$0$”，然后再用得到的线性基消去$[i+1, L]$线性基的$i$位上的$1$，因为一路上我们都将高位消去，所以这里不用担心影响其他位的情况。 例题1 (集合异或和最大)：Luogu 3812 给定$n$个整数（数字可能重复），求在这些数中选取任意个，使得他们的异或和最大。 对于构造的线性基，$a_i$的第$i$位若是$1$，则将答案异或$a_i$，这样一定能得到更大的值，因为这个位置的$1$之后不会再被异或消去，而因为二进制的性质，贪心选取更高位数的$1$，所以将所有线性基异或起来即为答案。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL MAXLEN = 51; LL n, t, a[55]; void clean() { ms(a, 0); } int solve() { clean(); scanf(&quot;%lld&quot;, &amp;n); for (LL o = 1; o &lt;= n; ++o) { scanf(&quot;%lld&quot;, &amp;t); for (LL i = MAXLEN; i &gt;= 0; --i) { // 倒序枚举二进制 if (!((t &gt;&gt; i) &amp; 1)) continue ; // t 当前位不是 1 if (a[i]) t ^= a[i]; // 用 a[i] 消去 t 的 i 位上的 1 else { for (LL j = 1; j &lt; i; ++j) if ((t &gt;&gt; j) &amp; 1) t ^= a[j]; // 用 a[j] 消去 t 低于 i 位上的 1 for (LL j = i + 1; j &lt;= MAXLEN; ++j) if ((a[j] &gt;&gt; i) &amp; 1) a[j] ^= t; // 用 t 消去 a[j] 的 i 位上的 1 a[i] = t; // 插入线性基 break ; } } } LL ans = 0; for (LL i = MAXLEN; i &gt;= 0; --i) ans ^= a[i]; printf(&quot;%lld\n&quot;, ans); return 0; } } int main() { flyinthesky::solve(); return 0; } 例题2 (选出集合不出现异或和等于0)：Bzoj 3105 选出集合不出现异或和等于0即选出数线性无关，所以直接最大到最小贪心即可。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;queue&gt; #include&lt;string&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { int k, a[105], b[105]; int ins(int t) { for (int i = 32; ~i; --i) { if (!(t &amp; (1 &lt;&lt; i))) continue ; if (a[i]) t ^= a[i]; else { for (int j = 0; j &lt; i; ++j) if (t &amp; (1 &lt;&lt; j)) t ^= a[j]; for (int j = i + 1; j &lt;= 32; ++j) if (a[j] &amp; (1 &lt;&lt; j)) a[j] ^= t; a[i] = t; return 1; } } return 0; } void clean() { } int solve() { clean(); cin &gt;&gt; k; for (int i = 1; i &lt;= k; ++i) cin &gt;&gt; b[i]; sort(b + 1, b + 1 + k, greater&lt;int&gt;()); LL ans = 0; for (int i = 1; i &lt;= k; ++i) if (!ins(b[i])) ans += b[i]; cout &lt;&lt; ans; return 0; } } int main() { flyinthesky::solve(); return 0; } 例题3 求集合异或和$k$大 我们考虑将秩编号，那么我们如果求$k$大, 我们就分解$k$的二进制, 然后按照二进制的位置异或秩就是答案，注意0的存在 例题4 求线性基的交 / 并 并很简单，一个插另一个即可 交 例题5 求集合异或和排名 类似例题三的做法，Bzoj 2844 此题还需要去重，我们发现每个数都出现一样的次数$2^{n-|\mathbb{lb}|}$ 证明：假如要考虑异或出一个数$x$，基外选出的数的异或和为$s$，那么还需要$x \mathbb{xor} s$，对于它，基内的线性表示的方法是唯一的。]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>高斯消元</tag>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1013」「JSOI2008」球形空间产生器sphere (高斯消元)]]></title>
    <url>%2Fbzoj1013%2F</url>
    <content type="text"><![CDATA[BZOJ 1013题意：给定$n$维空间一个球面上$n+1$个点的坐标，求球心坐标。提示：球心是到球面上任意一点距离都相等的点。 根据提示，我们设$a_{i,j}$为点$i$的第$j$维坐标，$x_{j}$为球心$j$维坐标，则对于每个点$i$ 有 $$\sum_{j=1}^n (a_{i,j}-x_{j})^2=C$$ 其中$C​$为一个常数。这个方程是二元$n​$次方程，不好解，我们采用邻项相减的方法，使其变为一维以及消除$C​$，则 $$\sum_{j=1}^n(a_{i+1,j}-x_{j})^2 - (a_{i,j}-x_{j})^2=0$$ 化简，将$x_j$移到左边，得 $$\sum_{j=1}^n 2x_j(a_{i,j}-a_{i+1,j})=\sum_{j=1}^n(a_{i,j}^2-a_{i+1,j}^2)$$ 则可以构造矩阵高斯消元。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 15; const db eps = 1e-12; int n; db a[MAXN][MAXN], c[MAXN][MAXN], b[MAXN]; // c, b 为消元矩阵 void clean() { ms(b, 0); } int solve() { clean(); scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n + 1; ++i) for (int j = 1; j &lt;= n; ++j) scanf(&quot;%lf&quot;, &amp;a[i][j]); for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= n; ++j) { c[i][j] = 2.0 * (a[i][j] - a[i + 1][j]); b[i] += a[i][j] * a[i][j] - a[i + 1][j] * a[i + 1][j]; } } for (int i = 1; i &lt;= n; ++i) { // 处理 xi[i] 的系数 for (int j = i; j &lt;= n; ++j) { // 从后面没处理的行找 xi[i] 系数不为 0 的行交换 if (c[j][i] &gt; eps) { swap(b[i], b[j]); for (int k = 1; k &lt;= n; ++k) swap(c[i][k], c[j][k]); } } if (fabs(c[i][i]) &lt; eps) continue ; // 注意 for (int j = 1; j &lt;= n; ++j) { // 消去其他方程 xi[i] 的系数 if (i == j) continue ; db rat = c[j][i] / c[i][i]; for (int k = 1; k &lt;= n; ++k) c[j][k] -= rat * c[i][k]; b[j] -= rat * b[i]; } } for (int i = 1; i &lt; n; ++i) printf(&quot;%.3lf &quot;, b[i] / c[i][i]); printf(&quot;%.3lf\n&quot;, b[n] / c[n][n]); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj 2185(字符串Hash + KMP)]]></title>
    <url>%2Fpoj2185%2F</url>
    <content type="text"><![CDATA[poj 2185题意：求一个大矩阵的循环子矩阵，最后一个子矩阵可以作裁剪。性质1：子矩阵位置在最左上方不会对答案造成影响。性质2：行列上字母分布规律。根据性质2，我们可以将每行 Hash，那么就只剩一行数，做一次 KMP 求最小循环节作为宽列同理作为长乘起来就是答案Hash BASE 选取选大一点，13331 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { int n, m, nxt[10005]; char s[10005][100]; unsigned LL BSE = 13331, hsh[10005]; int getnxt(int len) { nxt[0] = nxt[1] = 0; for (int i = 1; i &lt; len; ++i) { int j = nxt[i]; while (j &amp;&amp; hsh[i] != hsh[j]) j = nxt[j]; nxt[i + 1] = (hsh[i] == hsh[j] ? j + 1 : 0); } return len - nxt[len]; } void clean() { } int solve() { clean(); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 0; i &lt; n; ++i) scanf(&quot;%s&quot;, s[i]); ms(hsh, 0); for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt; m; ++j) hsh[i] = hsh[i] * BSE + s[i][j]; int ans = getnxt(n); ms(hsh, 0); for (int j = 0; j &lt; m; ++j) for (int i = 0; i &lt; n; ++i) hsh[j] = hsh[j] * BSE + s[i][j]; ans *= getnxt(m); printf(&quot;%d\n&quot;, ans); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>字符串Hash</tag>
        <tag>KMP</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CH 1809」匹配统计 (字符串Hash + 二分 / KMP)]]></title>
    <url>%2FCH1809%2F</url>
    <content type="text"><![CDATA[CH 1809题意：求字符串$A$每个后缀与$B$匹配次数。 字符串Hash做法：将$A, B$都Hash，然后枚举$A$的后缀(起始位置)，然后现在关键看$A, B$能最多匹配多少位。那么根据字符串的一类单调性，我们运用二分，固定左端点，二分右端点，然后就能求出。 KMP做法：还不会先空着 qwq 知识点：1、写程序多留点心静态差错要慢要仔细！ 自然溢出 Hash 90分 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { int n, m, q, cnt[200000 + 5]; unsigned LL ha[200000 + 5], hb[200000 + 5], p[200000 + 5], BS = 200; char a[200000 + 5], b[200000 + 5]; unsigned LL getHash(unsigned LL *arr, int l, int r) {return arr[r] - arr[l - 1] * p[r - l + 1];} void clean() { ms(cnt, 0); } int solve() { clean(); scanf(&quot;%d%d%d%s%s&quot;, &amp;n, &amp;m, &amp;q, a + 1, b + 1); ha[0] = hb[0] = 0, p[0] = 1; for (int i = 1; i &lt;= n; ++i) ha[i] = ha[i - 1] * BS + a[i]; for (int i = 1; i &lt;= m; ++i) hb[i] = hb[i - 1] * BS + b[i]; for (int i = 1; i &lt;= max(n, m); ++i) p[i] = p[i - 1] * BS; // cerr &lt;&lt; getHash(ha, 1, 2) &lt;&lt; endl; cerr &lt;&lt; getHash(hb, 1, 2) &lt;&lt; endl; for (int i = 1; i &lt;= n; ++i) { int l = i, r = min(n, i + m - 1) + 1, ans = -1; //if (i == 3) cerr &lt;&lt; &quot;!!!&quot; &lt;&lt; l &lt;&lt; &quot; &quot; &lt;&lt; r &lt;&lt; endl; while (l &lt; r) { int mid = (l + r) &gt;&gt; 1; //if (i == 3) cerr &lt;&lt; &quot;l: &quot; &lt;&lt; l &lt;&lt; &quot; r: &quot; &lt;&lt; r &lt;&lt; &quot; mid: &quot; &lt;&lt; mid &lt;&lt; endl; if (getHash(ha, i, mid) == getHash(hb, 1, mid - i + 1)) ans = mid, l = mid + 1; else r = mid; } //if (i == 3) cerr &lt;&lt; &quot;!!!&quot; &lt;&lt; ans &lt;&lt; endl; if (ans != -1) ++cnt[ans - i + 1]; else ++cnt[0]; } while (q--) { int x; scanf(&quot;%d&quot;, &amp;x); printf(&quot;%d\n&quot;, cnt[x]); } return 0; } } int main() { flyinthesky::solve(); return 0; } 双 Hash 满分 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { int n, m, q, cnt[200000 + 5]; LL ha1[200000 + 5], hb1[200000 + 5], ha2[200000 + 5], hb2[200000 + 5], p1[200000 + 5], p2[200000 + 5], BS = 200, MO1 = 19260817, MO2 = 19660813; char a[200000 + 5], b[200000 + 5]; LL getHash(LL *arr, LL *p, LL mod, int l, int r) {return (arr[r] - arr[l - 1] * p[r - l + 1] % mod + mod) % mod;} void clean() { ms(cnt, 0); } int solve() { clean(); scanf(&quot;%d%d%d%s%s&quot;, &amp;n, &amp;m, &amp;q, a + 1, b + 1); ha1[0] = hb1[0] = 0, p1[0] = 1; ha2[0] = hb2[0] = 0, p2[0] = 1; for (int i = 1; i &lt;= n; ++i) ha1[i] = (ha1[i - 1] * BS + a[i]) % MO1, ha2[i] = (ha2[i - 1] * BS + a[i]) % MO2; for (int i = 1; i &lt;= m; ++i) hb1[i] = (hb1[i - 1] * BS + b[i]) % MO1, hb2[i] = (hb2[i - 1] * BS + b[i]) % MO2; for (int i = 1; i &lt;= max(n, m); ++i) p1[i] = (p1[i - 1] * BS) % MO1, p2[i] = (p2[i - 1] * BS) % MO2; for (int i = 1; i &lt;= n; ++i) { int l = i, r = min(n, i + m - 1) + 1, ans = -1; while (l &lt; r) { int mid = (l + r) &gt;&gt; 1; if ((getHash(ha1, p1, MO1, i, mid) == getHash(hb1, p1, MO1, 1, mid - i + 1)) &amp;&amp; (getHash(ha2, p2, MO2, i, mid) == getHash(hb2, p2, MO2, 1, mid - i + 1))) ans = mid, l = mid + 1; else r = mid; } if (ans != -1) ++cnt[ans - i + 1]; else ++cnt[0]; } while (q--) { int x; scanf(&quot;%d&quot;, &amp;x); printf(&quot;%d\n&quot;, cnt[x]); } return 0; } } int main() { flyinthesky::solve(); return 0; } 描述阿轩在纸上写了两个字符串，分别记为A和B。利用在数据结构与算法课上学到的知识，他很容易地求出了“字符串A从任意位置开始的后缀子串”与“字符串B”匹配的长度。 不过阿轩是一个勤学好问的同学，他向你提出了Q个问题：在每个问题中，他给定你一个整数x，请你告诉他有多少个位置，满足“字符串A从该位置开始的后缀子串”与B匹配的长度恰好为x。 例如：A=aabcde，B=ab，则A有aabcde、abcde、bcde、cde、de、e这6个后缀子串，它们与B=ab的匹配长度分别是1、2、0、0、0、0。因此A有4个位置与B的匹配长度恰好为0，有1个位置的匹配长度恰好为1，有1个位置的匹配长度恰好为2。 输入格式第一行三个整数N,M,Q，表示A串长度、B串长度、问题个数。 第二行是字符串A，第三行是字符串B。 接下来Q行每行1个整数x，表示一个问题。 1&lt;=N,M,Q,x&lt;=200000. 输出格式共Q行，依次表示每个问题的答案。 样例输入6 2 5aabcdeab01234样例输出41100来源北京大学2015年数据结构与算法A期末考试]]></content>
      <tags>
        <tag>字符串Hash</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1500」「NOI2005」维修数列 (Splay维护序列)]]></title>
    <url>%2Fbzoj1500%2F</url>
    <content type="text"><![CDATA[BZOJ 1500题意：请写一个程序，要求维护一个数列，支持以下 $6$ 种操作：请注意，格式栏中的下划线表示实际输入文件中的空格.png) 用 splay 维护序列 (舍弃二叉排序树的左右儿子大小比较)：插入：新建一棵 splay 插到原树上删除：提取区间以后打删除标记，注意卡内存用辣鸡回收优化修改：提取区间以后打标记，注意这里标记都是标时即改翻转：提取区间以后打标记，若有修改标记则无需做任何事情求和：提取区间输出区间和求最长字段和：维护 $ls, rs$分别表示左起最长区间和，右起最长区间和。则可以通过维护得到。 具体看Splay 学习笔记 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 1000000 + 5, INF = 1000000000; int n, m, arr[MAXN]; int ch[MAXN][2], fa[MAXN], siz[MAXN], val[MAXN], ls[MAXN], rs[MAXN], gss[MAXN], sum[MAXN], lazy[MAXN], upd[MAXN], rt, ncnt; char s[10]; queue&lt;int &gt; q; int rel(int x) {return ch[fa[x]][1] == x;} void pushup(int x) { int l = ch[x][0], r = ch[x][1]; siz[x] = siz[l] + siz[r] + 1; ls[x] = max(ls[l], sum[l] + ls[r] + val[x]); rs[x] = max(rs[r], sum[r] + rs[l] + val[x]); sum[x] = sum[l] + sum[r] + val[x]; gss[x] = max(max(gss[l], gss[r]), rs[l] + ls[r] + val[x]); } void pushdown(int x) { int l = ch[x][0], r = ch[x][1]; if (upd[x]) { upd[l] = upd[r] = 1; if (l) val[l] = val[x], sum[l] = val[x] * siz[l], ls[l] = rs[l] = max(sum[l], 0), gss[l] = max(sum[l], val[x]); if (r) val[r] = val[x], sum[r] = val[x] * siz[r], ls[r] = rs[r] = max(sum[r], 0), gss[r] = max(sum[r], val[x]); upd[x] = lazy[x] = 0; } if (lazy[x]) { lazy[l] ^= 1, lazy[r] ^= 1; swap(ch[l][0], ch[l][1]), swap(ch[r][0], ch[r][1]); swap(ls[l], rs[l]), swap(ls[r], rs[r]); lazy[x] = 0; } } void rotate(int x) { pushdown(fa[x]), pushdown(x); int y = fa[x], z = fa[y], k = rel(x), w = ch[x][k ^ 1]; ch[z][rel(y)] = x, fa[x] = z; ch[y][k] = w, fa[w] = y; ch[x][k ^ 1] = y, fa[y] = x; pushup(y), pushup(x); } void splay(int x, int gl = 0) { while (fa[x] != gl) { pushdown(fa[x]), pushdown(x); int y = fa[x], z = fa[y]; if (z != gl) { if (rel(x) == rel(y)) rotate(y); else rotate(x); } rotate(x); } if (!gl) rt = x; } int kth(int k) { int cur = rt; while (1) { pushdown(cur); if (k &lt;= siz[ch[cur][0]]) cur = ch[cur][0]; else if (k &gt; siz[ch[cur][0]] + 1) k -= siz[ch[cur][0]] + 1, cur = ch[cur][1]; else return cur; } } int newNode(int v) { int cur; if (q.empty()) cur = ++ncnt; else cur = q.front(), q.pop(); ch[cur][0] = ch[cur][1] = 0, fa[cur] = 0, siz[cur] = 1, val[cur] = v, ls[cur] = rs[cur] = max(v, 0), gss[cur] = sum[cur] = v, lazy[cur] = upd[cur] = 0; return cur; } int build(int l, int r) { if (l &gt; r) return 0; int mid = (l + r) &gt;&gt; 1, cur = newNode(arr[mid]); if (l == r) return cur; if ((ch[cur][0] = build(l, mid - 1))) fa[ch[cur][0]] = cur; if ((ch[cur][1] = build(mid + 1, r))) fa[ch[cur][1]] = cur; pushup(cur); return cur; } void recycle(int x) { if (ch[x][0]) recycle(ch[x][0]); if (ch[x][1]) recycle(ch[x][1]); q.push(x); } void insert(int x, int gg) { int lb = kth(x + 1), rb = kth(x + 2); splay(lb), splay(rb, lb); fa[gg] = rb, ch[rb][0] = gg; // important pushup(rb), pushup(lb); } void remove(int l, int r) { int lb = kth(l), rb = kth(r + 2); splay(lb), splay(rb, lb); int del = ch[rb][0]; recycle(del), ch[rb][0] = 0; pushup(rb), pushup(lb); } void rev(int l, int r) { int lb = kth(l), rb = kth(r + 2); splay(lb), splay(rb, lb); int gg = ch[rb][0]; if (!upd[gg]) lazy[gg] ^= 1, swap(ch[gg][0], ch[gg][1]), swap(ls[gg], rs[gg]), pushup(rb), pushup(lb); } void update(int l, int r, int v) { int lb = kth(l), rb = kth(r + 2); splay(lb), splay(rb, lb); int gg = ch[rb][0]; upd[gg] = 1, val[gg] = v, sum[gg] = v * siz[gg], ls[gg] = rs[gg] = max(0, sum[gg]), gss[gg] = max(v, sum[gg]); pushup(rb), pushup(lb); } int qsum(int l, int r) { int lb = kth(l), rb = kth(r + 2); splay(lb), splay(rb, lb); return sum[ch[rb][0]]; } int qmax() {return gss[rt];} void clean() { rt = ncnt = 0; ms(ch, 0), ms(fa, 0), ms(siz, 0), ms(val, 0), ms(ls, 0), ms(rs, 0), ms(gss, 0), ms(sum, 0), ms(lazy, 0), ms(upd, 0); gss[0] = val[0] = -INF; } int solve() { clean(); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;arr[i + 1]); arr[1] = arr[n + 2] = -INF, rt = build(1, n + 2); while (m--) { scanf(&quot;%s&quot;, s); if (s[0] == &#39;I&#39;) { // insert int pos, tot; scanf(&quot;%d%d&quot;, &amp;pos, &amp;tot); for (int i = 1; i &lt;= tot; ++i) scanf(&quot;%d&quot;, &amp;arr[i]); insert(pos, build(1, tot)); } if (s[0] == &#39;D&#39;) { // delete int pos, tot; scanf(&quot;%d%d&quot;, &amp;pos, &amp;tot); remove(pos, pos + tot - 1); } if (s[0] == &#39;M&#39; &amp;&amp; s[5] == &#39;S&#39;) { // update int pos, tot, c; scanf(&quot;%d%d%d&quot;, &amp;pos, &amp;tot, &amp;c); update(pos, pos + tot - 1, c); } if (s[0] == &#39;R&#39;) { // rev int pos, tot; scanf(&quot;%d%d&quot;, &amp;pos, &amp;tot); rev(pos, pos + tot - 1); } if (s[0] == &#39;G&#39;) { // qsum int pos, tot; scanf(&quot;%d%d&quot;, &amp;pos, &amp;tot); printf(&quot;%d\n&quot;, qsum(pos, pos + tot - 1)); } if (s[0] == &#39;M&#39; &amp;&amp; s[4] == &#39;S&#39;) { // qmax printf(&quot;%d\n&quot;, qmax()); } } return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>Splay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算几何 学习笔记]]></title>
    <url>%2Fsz%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%2F</url>
    <content type="text"><![CDATA[模板及讲解计算几何大坑 知识点向量点积几何方法：$\vec a \cdot \vec b=|\vec a||\vec b| \cos \theta$坐标系：$\vec a(x_1,y_1), \vec b(x_2,y_2)，​$则$\vec a \cdot \vec b=x_1x_2+y_1y_2​$ 判垂直：$\vec a ⊥ \vec b \Leftrightarrow \vec a \cdot \vec b = \vec 0$ 向量叉积几何方法：$\vec a \times \vec b=|\vec a||\vec b| \sin \theta$坐标系：$\vec a(x_1,y_1), \vec b(x_2,y_2)，$则$\vec a \times \vec b=x_1y_2-x_2y_1$ 判共线：$\vec a ∥ \vec b \Leftrightarrow \vec a \times \vec b = \vec 0$ 向量旋转设$\vec a(x, y)$，逆时针转角为$\theta$，则旋转后的向量为$(x\cos \theta-y \sin \theta, x \sin \theta+y \cos \theta)$ 代码预备 const double eps = 1e-6, pi = acos(-1.0); //Header inline int dcmp(double x) { // 比较大小 if(fabs(x) &lt; eps) return 0; return x &lt; 0 ? -1 : 1; } inline double sqr(double x) { // x 平方 return x * x; } 点 //Point struct Point { // 点 double x, y; Point(double _x = 0, double _y = 0): x(_x), y(_y) {}; inline void in() {scanf(&quot;%lf%lf&quot;,&amp;x, &amp;y);} }; inline Point operator + (Point A, Point B) { return Point(A.x + B.x, A.y + B.y); } inline Point operator - (Point A, Point B) { return Point(A.x - B.x, A.y - B.y); } inline Point operator * (Point A, double p) { return Point(A.x * p, A.y * p); } inline Point operator / (Point A, double p) { // 向量(点)加减乘除 return Point(A.x / p, A.y / p); } inline bool operator &lt; (const Point &amp;a, const Point &amp;b) { // 点位置判断 return a.x &lt; b.x || (a.x == b.x &amp;&amp; a.y &lt; b.y); } inline bool operator == (const Point &amp;a, const Point &amp;b) { // 点是否重合 return !dcmp(a.x - b.x) &amp;&amp; !dcmp(a.y - b.y); } inline double Distance(Point A, Point B) { // 两点距离 return sqrt(sqr(A.x - B.x) + sqr(A.y - B.y)); } inline double Dot(Point A, Point B) { // 点积 return A.x * B.x + A.y * B.y; } inline double Norm(Point A) { return A.x * A.x + A.y * A.y; } inline double Length(Point A) { // 向量模 return sqrt(Dot(A, A)); } inline double GetAngle(Point A,Point B) { // 求向量夹角 return acos(Dot(A, B)) / Length(A) / Length(B); } inline double GetAngle(Point v) { // 极角 return atan2(v.y, v.x); } inline double Cross(Point A, Point B) { // 叉积 return A.x * B.y - A.y * B.x; } inline Point Unit(Point x) { return x / Length(x); } inline Point Normal(Point x) { // 向量的单位法向量 return Point(-x.y, x.x) / Length(x); } inline Point Rotate(Point A, double rad) { // 向量绕起点旋转 return Point(A.x * cos(rad) - A.y * sin(rad), A.x * sin(rad) + A.y * cos(rad)); } inline double Area2(const Point &amp;A, const Point &amp;B, const Point &amp;C) { // 平行四边形面积 return Cross(B - A, C - A); } inline void getLineGeneralEquation(const Point &amp;p1, const Point &amp;p2, double &amp;a, double &amp;b, double &amp;c) { a = p2.y - p1.y; b = p1.x - p2.x; c = -a * p1.x - b * p1.y; } inline Point GetLineIntersection(Point P, Point v, Point Q, Point w) { Point u = P - Q; double t = Cross(w, u) / Cross(v, w); return P + v * t; } inline double DistanceToLine(Point P, Point A, Point B) { Point v1 = B - A, v2 = P - A; return fabs(Cross(v1, v2)) / Length(v1); } inline double DistanceToSegment(Point P, Point A, Point B) { if (A == B)return Length(P-A); Point v1 = B - A,v2 = P - A, v3 = P - B; if (dcmp(Dot(v1, v2)) &lt; 0) return Length(v2); else if (dcmp(Dot(v1, v3)) &gt; 0) return Length(v3); else return fabs(Cross(v1, v2)) / Length(v1); } inline Point GetLineProjection(Point P, Point A, Point B) { Point v = B - A; return A + v * (Dot(v, P - A) / Dot(v, v)); } inline bool OnSegment(Point p, Point a1, Point a2) { if(a1 == p || a2 == p) return 1; return dcmp(Cross(a1 - p, a2 - p)) == 0 &amp;&amp; dcmp(Dot(a1 - p,a2 - p)) &lt; 0; } inline bool SegmentProperIntersection(Point a1, Point a2, Point b1, Point b2) { if (OnSegment(a1, b1, b2) || OnSegment(a2, b1, b2) || OnSegment(b1, a1, a2) || OnSegment(b2, a1, a2)) return 1; double c1 = Cross(a2 - a1, b1 - a1),c2 = Cross(a2 - a1, b2 - a1); double c3 = Cross(b2 - b1, a1 - b1),c4 = Cross(b2 - b1, a2 - b1); return dcmp(c1) * dcmp(c2) &lt; 0 &amp;&amp; dcmp(c3) * dcmp(c4) &lt; 0; } inline double PolygonArea(Point *p, int n) { double area = 0.0; for (int i = 1; i &lt; n - 1; i++) area += Cross(p[i] - p[0], p[i+1] - p[0]); return area / 2.0; } inline Point GetMidPoint(Point A, Point B) { return Point((A.x + B.x) / 2.0, (A.y + B.y) / 2.0); } inline int PointinPolygon(Point p, vector&lt;Point&gt; poly) { int n = poly.size(), flg = 0; for(int i = 0; i &lt; n; i++) { if(OnSegment(p, poly[i], poly[(i + 1)% n])) return -1; int k = dcmp(Cross(poly[(i + 1) % n] - poly[i], p - poly[i])); int d1 = dcmp(poly[i].y - p.y); int d2 = dcmp(poly[(i + 1) % n].y - p.y); if(k &gt; 0 &amp;&amp; d1 &lt;= 0 &amp;&amp; d2 &gt; 0) flg++; if(k &lt; 0 &amp;&amp; d2 &lt;= 0 &amp;&amp; d1 &gt; 0) flg++; } if(flg) return 1; return 0; } 常见题型]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Splay 学习笔记]]></title>
    <url>%2FszSplay%2F</url>
    <content type="text"><![CDATA[模板及讲解SplaySplay 就是平衡树。 Splay 的原理例题 (不涉及区间操作)：Bzoj 3224 需要建立一个虚节点 0 作为初始根，加入一个正无穷和负无穷免除边界困扰。(类似 set) 核心操作： void rotate(int x)：对 $x$ 进行旋转操作 void splay(int x, int gl = 0)：将 $x$ rotate 到 $gl$ 的孩子 辅助操作： bool rel(int x)：返回 $x$ 在 $fa[x]$ 中的左右位置 void pushup(int x)：维护 $x$ 点信息 (更新) 实现操作： void insert(int x)：插入一个值为 $x$ 的节点并转到根 void find(int x)：找一个值为 $x$ 的节点转到根，不存在则返回当前数的前驱或后继 int kth(int k)：找值第 $k$ 大数 int rnk(int x)：值 $x$ 的排名 int pre(int x)：值前驱 int succ(int x)：值后继 void remove(int x)：删除一个值为 $x$ 的节点，若点还存在，转到根 辅助操作实现 bool rel(int x) {return ch[fa[x]][1] == x;} // x 点在父亲点的位置 (x 点是不是父亲点的右孩子) void pushup(int x) {siz[x] = siz[ch[x][0]] + siz[ch[x][1]] + cnt[x];} 核心操作实现rotate： 对 $x$ 进行旋转操作。 Splay使用旋转保持平衡。Splay旋转后，中序遍历和Splay的合法性不变。但是信息要重新合并 图一为原树，图二为旋转完的树。绿边为新增边，红边为删除边，蓝边为存在边。 void rotate(int x) { // 旋转操作 int y = fa[x], z = fa[y], k = rel(x), w = ch[x][k ^ 1]; ch[z][rel(y)] = x, fa[x] = z; // 将爷爷节点与自己相连 ch[y][k] = w, fa[w] = y; // 将自己的孩子给父节点 ch[x][k ^ 1] = y, fa[y] = x; // 将父节点接到自己孩子 pushup(y), pushup(x); // 破坏了结构记得 pushup } splay： 将 $x$ rotate 到 $gl$ 的孩子 将某个点通过 rotate 转到某个点的孩子。容易想到一直 rotate 然后判断，这是单旋splay。但是这样由于一条单链旋转完以后还是单链，会被卡。所以我们尝试优化，如果当前自身点、父亲节点、爷爷节点三点一线，则先选择父亲节点，再选择本节点。 void splay(int x, int gl = 0) { // splay 操作 -&gt; 将 x 节点转到 gl 节点孩子 ，并且可以用作更新信息 while (fa[x] != gl) { // 一直旋转到目标节点的儿子 int y = fa[x], z = fa[y]; if (z != gl) { // 爷爷节点不是目标节点，否则直接旋转 if (rel(x) == rel(y)) rotate(y); else rotate(x); // 自身、父亲、爷爷三点一线，则先旋转父亲节点 } rotate(x); // 旋转自身 } if (!gl) rt = x; // 如果旋转到根则更新 rt } 实现操作实现insert： 插入一个值为 $x$ 的节点并转到根 从根走下去找这个数应该在的位置，然后如果存在则增加计数器，否则新建节点。注意将节点转到根，这样才能更新沿路的信息，并且保证了复杂度。 void insert(int x) { // 插入一个值为 x 的节点并转到根 int cur = rt, p = 0; // cur 当前节点， p 为 cur 父亲 while (cur &amp;&amp; val[cur] != x) p = cur, cur = ch[cur][x &gt; val[cur]]; // 找插入位置 if (cur) ++cnt[cur]; else { // 找到插入位置，如果已经有数则 cnt 加一即可，否则新建节点 cur = ++ncnt; val[cur] = x, fa[cur] = p, ch[cur][0] = ch[cur][1] = 0, cnt[cur] = siz[cur] = 1; ch[p][x &gt; val[p]] = cur; } splay(cur); // splay 到根，以免加入节点后拉出一条链 + 更新信息 } find： 找一个值为 $x$ 的节点转到根，不存在则返回当前数的前驱或后继 从根走下去找这个数应该在的位置，找不到则返回的是前驱或后继。(无法确定，分类讨论即可) void find(int x) { // 找一个值为 x 的节点转到根，不存在则返回当前数的前驱或后继 int cur = rt; while (ch[cur][x &gt; val[cur]] &amp;&amp; val[cur] != x) cur = ch[cur][x &gt; val[cur]]; splay(cur); } kth： 找值第 $k$ 大数 从根走下去找，很经典的问题，注意当前根节点的cnt值 int kth(int k) { // 找值第 k 大数 int cur = rt; while (1) { if (k &lt;= siz[ch[cur][0]]) cur = ch[cur][0]; else if (k &gt; siz[ch[cur][0]] + cnt[cur]) k -= siz[ch[cur][0]] + cnt[cur], cur = ch[cur][1]; else return cur; } } rnk: 值 $x$ 的排名 先将值为 $x$ 的点转到根，根节点的左子树大小即为该值排名，不加一因为有虚节点。 int rnk(int x) { // 值 x 的排名 find(x); // splay 值为 x 的节点到根后左子树的大小即为值 x 排名 return siz[ch[rt][0]]; } pre: 值前驱 先将值为 $x$ 的节点 splay 到根, 再找根左子树最右边的值即为前驱注意不存在 $x$ 值节点时判一下根节点大小 int pre(int x) { // 值前驱 find(x); // 先将值为 x 的节点 splay 到根 if (val[rt] &lt; x) return rt; // 找不到这样的节点则直接返回根 int cur = ch[rt][0]; // 找根左子树最右边的值即为前驱 while (ch[cur][1]) cur = ch[cur][1]; return cur; } succ: 值后继 先将值为 $x$ 的节点 splay 到根, 再找根右子树最左边的值即为后继注意不存在 $x$ 值节点时判一下根节点大小 int succ(int x) { // 值后继 find(x); // 先将值为 x 的节点 splay 到根 if (val[rt] &gt; x) return rt; // 找不到这样的节点则直接返回根 int cur = ch[rt][1]; // 找根右子树最左边的值即为前驱 while (ch[cur][0]) cur = ch[cur][0]; return cur; } remove: 删除一个值为 $x$ 的节点，若点还存在，转到根 将前驱转到根，后继转到根的右孩子，然后删除，如果当前节点次数多于1将他splay到根，否则维护前驱、后继的信息。为什么可以这样做看图即可。 void remove(int x) { // 删除一个值为 x 的节点 int last = pre(x), next = succ(x); splay(last), splay(next, last); // 前驱转到根，后继转到根的右孩子 int del = ch[next][0]; if (cnt[del] &gt; 1) --cnt[del], splay(del); else ch[next][0] = 0, pushup(next), pushup(last); // 记得信息的更新上传 } Bzoj 3224完整代码： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;vector&gt; #include&lt;utility&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 200005, INF = 2000000005; int ch[MAXN][2], fa[MAXN], val[MAXN], cnt[MAXN], siz[MAXN], ncnt, rt, n; // splay 数组，父亲节点，节点值，节点值个数，节点子树大小，节点总数，根 bool rel(int x) {return ch[fa[x]][1] == x;} // x 点在父亲点的位置 (x 点是不是父亲点的右孩子) void pushup(int x) {siz[x] = siz[ch[x][0]] + siz[ch[x][1]] + cnt[x];} void rotate(int x) { // 旋转操作 int y = fa[x], z = fa[y], k = rel(x), w = ch[x][k ^ 1]; ch[z][rel(y)] = x, fa[x] = z; // 将爷爷节点与自己相连 ch[y][k] = w, fa[w] = y; // 将自己的孩子给父节点 ch[x][k ^ 1] = y, fa[y] = x; // 将父节点接到自己孩子 pushup(y), pushup(x); // 破坏了结构记得 pushup } void splay(int x, int gl = 0) { // splay 操作 -&gt; 将 x 节点转到 gl 节点孩子 ，并且可以用作更新信息 while (fa[x] != gl) { // 一直旋转到目标节点的儿子 int y = fa[x], z = fa[y]; if (z != gl) { // 爷爷节点不是目标节点，否则直接旋转 if (rel(x) == rel(y)) rotate(y); else rotate(x); // 自身、父亲、爷爷三点一线，则先旋转父亲节点 } rotate(x); // 旋转自身 } if (!gl) rt = x; // 如果旋转到根则更新 rt } void insert(int x) { // 插入一个值为 x 的节点并转到根 int cur = rt, p = 0; // cur 当前节点， p 为 cur 父亲 while (cur &amp;&amp; val[cur] != x) p = cur, cur = ch[cur][x &gt; val[cur]]; // 找插入位置 if (cur) ++cnt[cur]; else { // 找到插入位置，如果已经有数则 cnt 加一即可，否则新建节点 cur = ++ncnt; val[cur] = x, fa[cur] = p, ch[cur][0] = ch[cur][1] = 0, cnt[cur] = siz[cur] = 1; ch[p][x &gt; val[p]] = cur; } splay(cur); // splay 到根，以免加入节点后拉出一条链 + 更新信息 } void find(int x) { // 找一个值为 x 的节点转到根，不存在则返回当前数的前驱或后继 int cur = rt; while (ch[cur][x &gt; val[cur]] &amp;&amp; val[cur] != x) cur = ch[cur][x &gt; val[cur]]; splay(cur); } int kth(int k) { // 找值第 k 大数 int cur = rt; while (1) { if (k &lt;= siz[ch[cur][0]]) cur = ch[cur][0]; else if (k &gt; siz[ch[cur][0]] + cnt[cur]) k -= siz[ch[cur][0]] + cnt[cur], cur = ch[cur][1]; else return cur; } } int rnk(int x) { // 值 x 的排名 find(x); // splay 值为 x 的节点到根后左子树的大小即为值 x 排名 return siz[ch[rt][0]]; } int pre(int x) { // 值前驱 find(x); // 先将值为 x 的节点 splay 到根 if (val[rt] &lt; x) return rt; // 找不到这样的节点则直接返回根 int cur = ch[rt][0]; // 找根左子树最右边的值即为前驱 while (ch[cur][1]) cur = ch[cur][1]; return cur; } int succ(int x) { // 值后继 find(x); // 先将值为 x 的节点 splay 到根 if (val[rt] &gt; x) return rt; // 找不到这样的节点则直接返回根 int cur = ch[rt][1]; // 找根右子树最左边的值即为前驱 while (ch[cur][0]) cur = ch[cur][0]; return cur; } void remove(int x) { // 删除一个值为 x 的节点 int last = pre(x), next = succ(x); splay(last), splay(next, last); // 前驱转到根，后继转到根的右孩子 int del = ch[next][0]; if (cnt[del] &gt; 1) --cnt[del], splay(del); else ch[next][0] = 0, pushup(next), pushup(last); // 记得信息的更新上传 } void clean() { ms(fa, 0), ms(cnt, 0), ms(val, 0), ms(siz, 0), rt = ncnt = 0; } int solve() { clean(); scanf(&quot;%d&quot;, &amp;n); insert(INF), insert(-INF); // 插入最大最小值 while (n--) { int opt, x; scanf(&quot;%d%d&quot;, &amp;opt, &amp;x); switch (opt) { case 1: insert(x); break ; case 2: remove(x); break ; case 3: printf(&quot;%d\n&quot;, rnk(x)); break ; case 4: printf(&quot;%d\n&quot;, val[kth(x + 1)]); break ; case 5: printf(&quot;%d\n&quot;, val[pre(x)]); break ; case 6: printf(&quot;%d\n&quot;, val[succ(x)]); break ; } } return 0; } } int main() { flyinthesky::solve(); return 0; } 写时注意：1、splay中不要忘记写换根 if (gl == 0) rt = x;2、splay中最后一个rotate(x)写在判断外面3、rotate中rel(x)一定要预处理，因为之后会被改变4、insert中不要忘记转到根，remove中不要忘记转到根+更新信息5、insert 和 find 中while注意判断中的 $val$ 怎么写6、kth中if (k &lt;= siz[ch[cur][0]])的&lt;= Splay 维护区间序列例题：Bzoj 3223 给定$n$长数组$a_i$，$m$次操作翻转区间$[l,r]$$n,m \leq 10^5。$ 本题是维护序列，与上面的不同。我们将序列值存在 $val$ 中，舍弃二叉排序树的性质，保留中序遍历，中序遍历对应原数组，显然 Splay 中 $x$ 点为$[x,x]$，左子树为$[1, x)$，右子树为$(x, n]$，则 Splay 中求得的 $k$ 大值为序列 $k$ 位置的值，区间类似。由于旋转操作不影响中序遍历，所以这样的问题可以用 splay 来完成。我们可以运用线段树中lazy的技巧来做splay的区间信息维护。 标记下放 void pushdown(int x) { if (lazy[x]) swap(ch[x][0], ch[x][1]), lazy[ch[x][0]] ^= 1, lazy[ch[x][1]] ^= 1, lazy[x] = 0; } 选择单点本题不需要，其实序列的单点位置就是第$k$大选择区间将$l-1$大的位置找出来，$r+1$大的位置找出来将$l-1$大的位置转到根，$l-1$大的位置转到根的孩子，则$r+1$大的位置的左孩子是区间$[l,r]$ void rev(int l, int r) { int lb = kth(l), rb = kth(r + 2); // 无穷小虚节点在最前面，所以加一 splay(lb), splay(rb, lb); lazy[ch[rb][0]] ^= 1; } 输出答案由于中序遍历始终有序，直接中序遍历即可 void print(int x) { pushdown(x); if (ch[x][0]) print(ch[x][0]); if (1 &lt;= val[x] &amp;&amp; val[x] &lt;= n) printf(&quot;%d &quot;, val[x]); if (ch[x][1]) print(ch[x][1]); } 标记下放注意事项1、调用rel(x)之前一定要pushdown(x)2、调用ch[x][0/1]之前一定要pushdown(x)3、splay 维护区间不要用 insert建树因为没有二叉排序树性质，无法根据权值大小建树。所以增加一个函数，每次取$mid=\frac{l+r}2$点作根然后遍历两边建点。最后返回根节点的编号 int build(int p, int l, int r) { int mid = (l + r) &gt;&gt; 1; if (l &gt; r) return 0; int cur = ++ncnt; ch[cur][0] = ch[cur][1] = 0, fa[cur] = p, siz[cur] = 1, val[cur] = mid - 1; if (l == r) return cur; ch[cur][0] = build(cur, l, mid - 1), ch[cur][1] = build(cur, mid + 1, r); pushup(cur); return cur; } Bzoj 3223完整代码： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;vector&gt; #include&lt;utility&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 100000 + 5; int n, m; int ch[MAXN][2], val[MAXN], siz[MAXN], fa[MAXN], lazy[MAXN], ncnt, rt; bool rel(int x) {return ch[fa[x]][1] == x;} void pushup(int x) {siz[x] = siz[ch[x][0]] + siz[ch[x][1]] + 1;} void pushdown(int x) {if (lazy[x]) swap(ch[x][0], ch[x][1]), lazy[ch[x][0]] ^= 1, lazy[ch[x][1]] ^= 1, lazy[x] = 0;} void rotate(int x) { pushdown(fa[x]), pushdown(x); int y = fa[x], z = fa[y], k = rel(x), w = ch[x][k ^ 1]; ch[z][rel(y)] = x, fa[x] = z; ch[y][k] = w, fa[w] = y; ch[x][k ^ 1] = y, fa[y] = x; pushup(y), pushup(x); } void splay(int x, int gl = 0) { while (fa[x] != gl) { pushdown(fa[x]); pushdown(x); int y = fa[x], z = fa[y]; if (z != gl) { if (rel(x) == rel(y)) rotate(y); else rotate(x); } rotate(x); } if (gl == 0) rt = x; } int build(int p, int l, int r) { int mid = (l + r) &gt;&gt; 1; if (l &gt; r) return 0; int cur = ++ncnt; ch[cur][0] = ch[cur][1] = 0, fa[cur] = p, siz[cur] = 1, val[cur] = mid - 1; if (l == r) return cur; ch[cur][0] = build(cur, l, mid - 1), ch[cur][1] = build(cur, mid + 1, r); pushup(cur); return cur; } int kth(int k) { int cur = rt; while (1) { pushdown(cur); if (k &lt;= siz[ch[cur][0]]) cur = ch[cur][0]; else if (k &gt; siz[ch[cur][0]] + 1) k -= siz[ch[cur][0]] + 1, cur = ch[cur][1]; else return cur; } } void rev(int l, int r) { int lb = kth(l), rb = kth(r + 2); splay(lb), splay(rb, lb); lazy[ch[rb][0]] ^= 1; } void print(int x) { pushdown(x); if (ch[x][0]) print(ch[x][0]); if (1 &lt;= val[x] &amp;&amp; val[x] &lt;= n) printf(&quot;%d &quot;, val[x]); if (ch[x][1]) print(ch[x][1]); } void clean() { ms(ch, 0), ms(val, 0), ms(siz, 0), ms(fa, 0), ms(lazy, 0), ncnt = rt = 0; } int solve() { clean(); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); //for (int i = 0; i &lt;= n + 1; ++i) insert(i); 维护区间不要用 insert，本题碰巧权值与下标一样 rt = build(0, 1, n + 2); // [1, n + 2] 避免与 0 冲突 while (m--) { int l, r; scanf(&quot;%d%d&quot;, &amp;l, &amp;r); rev(l, r); } print(rt); return 0; } } int main() { flyinthesky::solve(); return 0; } Splay 维护区间序列终极例题Bzoj 1500 请写一个程序，要求维护一个数列，支持以下 $6$ 种操作：请注意，格式栏中的下划线表示实际输入文件中的空格.png) Splay 可以用来维护区间的信息，则可以像线段树一样打标记。上一题只有翻转标记，而这一题多了很多标记 我们维护$sum, ls, rs, gss$分别为区间和、最大前缀和、最大后缀和，最长字段和。标记$lazy, upd$分别为翻转标记和更新标记。 初始化注意字段和一定要选一个元素 val[cur] = v, sum[cur] = v, ls[cur] = rs[cur] = max(0, v), gss[cur] = v, upd[cur] = lazy[cur] = 0; pushup注意 splay 上每个点有 $val$，要记得加上 void pushup(int x) { int l = ch[x][0], r = ch[x][1]; siz[x] = siz[l] + siz[r] + 1; sum[x] = sum[l] + sum[r] + val[x]; ls[x] = max(ls[l], sum[l] + val[x] + ls[r]); rs[x] = max(rs[r], sum[r] + val[x] + rs[l]); gss[x] = max(rs[l] + val[x] + ls[r], max(gss[l], gss[r])); } pushdown注意如果当前又有更新标记又有翻转标记，则只用更新。而翻转需要将ls,rs一同翻转，显然。 void pushdown(int x) { int l = ch[x][0], r = ch[x][1]; if (upd[x]) { if (l) val[l] = val[x], upd[l] = 1, sum[l] = val[x] * siz[l], ls[l] = rs[l] = max(sum[l], 0), gss[l] = max(val[x], sum[l]); if (r) val[r] = val[x], upd[r] = 1, sum[r] = val[x] * siz[r], ls[r] = rs[r] = max(sum[r], 0), gss[r] = max(val[x], sum[r]); upd[x] = lazy[x] = 0; } if (lazy[x]) { lazy[l] ^= 1, lazy[r] ^= 1; swap(ch[l][0], ch[l][1]), swap(ch[r][0], ch[r][1]); swap(ls[l], rs[l]), swap(ls[r], rs[r]); // 注意 lazy[x] = 0; } } 修改操作注意如果翻转时当前有更新标记，则不需要打翻转标记，注意标时即改。 void rev(int l, int r) { int lb = kth(l), rb = kth(r + 2); splay(lb), splay(rb, lb); int gg = ch[rb][0]; if (!upd[gg]) lazy[gg] ^= 1, swap(ch[gg][0], ch[gg][1]), swap(ls[gg], rs[gg]), pushup(rb), pushup(lb); } void update(int l, int r, int v) { int lb = kth(l), rb = kth(r + 2); splay(lb), splay(rb, lb); int gg = ch[rb][0]; upd[gg] = 1, val[gg] = v, sum[gg] = v * siz[gg], ls[gg] = rs[gg] = max(sum[gg], 0), gss[gg] = max(v, sum[gg]); pushup(rb), pushup(lb); } 辣鸡清理本题卡内存，所以要把删除后的节点编号用队列存起来然后之后新建节点时可以用。 void recycle(int x) { // 清理辣鸡 if (ch[x][0]) recycle(ch[x][0]); if (ch[x][1]) recycle(ch[x][1]); q.push(x); } int newNode(int v) { // 新建节点 int cur; if (q.empty()) cur = ++ncnt; else cur = q.front(), q.pop(); ch[cur][0] = ch[cur][1] = 0, fa[cur] = 0, siz[cur] = 1, val[cur] = v, sum[cur] = v, upd[cur] = lazy[cur] = 0, ls[cur] = rs[cur] = max(0, v), gss[cur] = v; return cur; } void remove(int l, int r) { // 删除节点 int lb = kth(l), rb = kth(r + 2); splay(lb), splay(rb, lb); recycle(ch[rb][0]), ch[rb][0] = 0; // 调用 pushup(rb), pushup(lb); } 插入：新建一棵 splay 插到原树上删除：提取区间以后打删除标记，注意卡内存用辣鸡回收优化修改：提取区间以后打标记，注意这里标记都是标时即改翻转：提取区间以后打标记，若有修改标记则无需做任何事情求和：提取区间输出区间和求最长字段和：维护 $ls, rs$分别表示左起最长区间和，右起最长区间和。则可以通过维护得到。 完整代码 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 1000000 + 5, INF = 1000000000; int n, m, arr[MAXN]; int ch[MAXN][2], fa[MAXN], siz[MAXN], val[MAXN], ls[MAXN], rs[MAXN], gss[MAXN], sum[MAXN], lazy[MAXN], upd[MAXN], rt, ncnt; char s[10]; queue&lt;int &gt; q; int rel(int x) {return ch[fa[x]][1] == x;} void pushup(int x) { int l = ch[x][0], r = ch[x][1]; siz[x] = siz[l] + siz[r] + 1; ls[x] = max(ls[l], sum[l] + ls[r] + val[x]); rs[x] = max(rs[r], sum[r] + rs[l] + val[x]); sum[x] = sum[l] + sum[r] + val[x]; gss[x] = max(max(gss[l], gss[r]), rs[l] + ls[r] + val[x]); } void pushdown(int x) { int l = ch[x][0], r = ch[x][1]; if (upd[x]) { upd[l] = upd[r] = 1; if (l) val[l] = val[x], sum[l] = val[x] * siz[l], ls[l] = rs[l] = max(sum[l], 0), gss[l] = max(sum[l], val[x]); if (r) val[r] = val[x], sum[r] = val[x] * siz[r], ls[r] = rs[r] = max(sum[r], 0), gss[r] = max(sum[r], val[x]); upd[x] = lazy[x] = 0; } if (lazy[x]) { lazy[l] ^= 1, lazy[r] ^= 1; swap(ch[l][0], ch[l][1]), swap(ch[r][0], ch[r][1]); swap(ls[l], rs[l]), swap(ls[r], rs[r]); lazy[x] = 0; } } void rotate(int x) { pushdown(fa[x]), pushdown(x); int y = fa[x], z = fa[y], k = rel(x), w = ch[x][k ^ 1]; ch[z][rel(y)] = x, fa[x] = z; ch[y][k] = w, fa[w] = y; ch[x][k ^ 1] = y, fa[y] = x; pushup(y), pushup(x); } void splay(int x, int gl = 0) { while (fa[x] != gl) { pushdown(fa[x]), pushdown(x); int y = fa[x], z = fa[y]; if (z != gl) { if (rel(x) == rel(y)) rotate(y); else rotate(x); } rotate(x); } if (!gl) rt = x; } int kth(int k) { int cur = rt; while (1) { pushdown(cur); if (k &lt;= siz[ch[cur][0]]) cur = ch[cur][0]; else if (k &gt; siz[ch[cur][0]] + 1) k -= siz[ch[cur][0]] + 1, cur = ch[cur][1]; else return cur; } } int newNode(int v) { int cur; if (q.empty()) cur = ++ncnt; else cur = q.front(), q.pop(); ch[cur][0] = ch[cur][1] = 0, fa[cur] = 0, siz[cur] = 1, val[cur] = v, ls[cur] = rs[cur] = max(v, 0), gss[cur] = sum[cur] = v, lazy[cur] = upd[cur] = 0; return cur; } int build(int l, int r) { if (l &gt; r) return 0; int mid = (l + r) &gt;&gt; 1, cur = newNode(arr[mid]); if (l == r) return cur; if ((ch[cur][0] = build(l, mid - 1))) fa[ch[cur][0]] = cur; if ((ch[cur][1] = build(mid + 1, r))) fa[ch[cur][1]] = cur; pushup(cur); return cur; } void recycle(int x) { if (ch[x][0]) recycle(ch[x][0]); if (ch[x][1]) recycle(ch[x][1]); q.push(x); } void insert(int x, int gg) { int lb = kth(x + 1), rb = kth(x + 2); splay(lb), splay(rb, lb); fa[gg] = rb, ch[rb][0] = gg; // important pushup(rb), pushup(lb); } void remove(int l, int r) { int lb = kth(l), rb = kth(r + 2); splay(lb), splay(rb, lb); int del = ch[rb][0]; recycle(del), ch[rb][0] = 0; pushup(rb), pushup(lb); } void rev(int l, int r) { int lb = kth(l), rb = kth(r + 2); splay(lb), splay(rb, lb); int gg = ch[rb][0]; if (!upd[gg]) lazy[gg] ^= 1, swap(ch[gg][0], ch[gg][1]), swap(ls[gg], rs[gg]), pushup(rb), pushup(lb); } void update(int l, int r, int v) { int lb = kth(l), rb = kth(r + 2); splay(lb), splay(rb, lb); int gg = ch[rb][0]; upd[gg] = 1, val[gg] = v, sum[gg] = v * siz[gg], ls[gg] = rs[gg] = max(0, sum[gg]), gss[gg] = max(v, sum[gg]); pushup(rb), pushup(lb); } int qsum(int l, int r) { int lb = kth(l), rb = kth(r + 2); splay(lb), splay(rb, lb); return sum[ch[rb][0]]; } int qmax() {return gss[rt];} void clean() { rt = ncnt = 0; ms(ch, 0), ms(fa, 0), ms(siz, 0), ms(val, 0), ms(ls, 0), ms(rs, 0), ms(gss, 0), ms(sum, 0), ms(lazy, 0), ms(upd, 0); gss[0] = val[0] = -INF; } int solve() { clean(); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;arr[i + 1]); arr[1] = arr[n + 2] = -INF, rt = build(1, n + 2); while (m--) { scanf(&quot;%s&quot;, s); if (s[0] == &#39;I&#39;) { // insert int pos, tot; scanf(&quot;%d%d&quot;, &amp;pos, &amp;tot); for (int i = 1; i &lt;= tot; ++i) scanf(&quot;%d&quot;, &amp;arr[i]); insert(pos, build(1, tot)); } if (s[0] == &#39;D&#39;) { // delete int pos, tot; scanf(&quot;%d%d&quot;, &amp;pos, &amp;tot); remove(pos, pos + tot - 1); } if (s[0] == &#39;M&#39; &amp;&amp; s[5] == &#39;S&#39;) { // update int pos, tot, c; scanf(&quot;%d%d%d&quot;, &amp;pos, &amp;tot, &amp;c); update(pos, pos + tot - 1, c); } if (s[0] == &#39;R&#39;) { // rev int pos, tot; scanf(&quot;%d%d&quot;, &amp;pos, &amp;tot); rev(pos, pos + tot - 1); } if (s[0] == &#39;G&#39;) { // qsum int pos, tot; scanf(&quot;%d%d&quot;, &amp;pos, &amp;tot); printf(&quot;%d\n&quot;, qsum(pos, pos + tot - 1)); } if (s[0] == &#39;M&#39; &amp;&amp; s[4] == &#39;S&#39;) { // qmax printf(&quot;%d\n&quot;, qmax()); } } return 0; } } int main() { flyinthesky::solve(); return 0; } 写时注意：1、检查每个函数是否 pushup、pushdown2、对维护值进行修改等时，对照变量数组列表先数有没有漏，再看标记维护有没有错3、序列区间最好都建在 $[1,n+2]$，避免与$0$冲突，加上虚节点非常有用4、维护序列一定要用$build​$函数 常见题型1、名次树Luogu3765 2、Splay森林Bzoj 2733 3、维护序列Bzoj 1500]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>Splay</tag>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj 3764(Trie维护二进制数+Xor)]]></title>
    <url>%2Fpoj3764%2F</url>
    <content type="text"><![CDATA[poj 3764题意：给定一棵$n$个点的带权无向树，求树上路径异或和的最大值。 利用 Xor 性质，我们发现路径异或和满足容斥 (即$[l,r]$可由$[1,r]，[1, l-1]$得出)那么我们求根到每个点的异或和$d_i$，然后尝试如何异或出一条路径来我们发现任意两个$d_i,d_j$的异或和为某条路径的异或和，且不漏解那么问题转化为求序列$d_i$两两异或最大值。因为 Xor 常用 Trie 维护，所以我们可以运用 Trie 求这个最大值。将所有$d_i$以二进制形式插入 Trie (高位在上，定一个最大位数，不够在前面补0)，边权为二进制位，然后对于每个二进制下的$d_i$在Trie树上走尽量相反的边，因为这样保证异或后大。树上没有最优边那就只能走另一条边。这样下来的路径就是$d_i$与其他$d_j$的最大异或值。$O(n \cdot len)$操作即可，$len$为二进制最大位数。1、Trie 维护二进制 Xor2、路径 - 用根分路径 (答案可以容斥) - 求根到每个点的信息 (类比 LCA 的距离数组) #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 100000 + 5, ML = 50; struct edge { int v, w, nxt; }ed[MAXN * 2]; int n, hd[MAXN], en, sz, ch[MAXN * 55][2], arr[55]; LL d[MAXN], ans; void ins(int u, int v, int w) {ed[++en] = (edge){v, w, hd[u]}, hd[u] = en;} void dfs(int u, int fa) { for (int i = hd[u]; i &gt; 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (e.v != fa) d[e.v] = d[u] ^ e.w, dfs(e.v, u); } } void ins() { int now = 0; for (int i = 1; i &lt;= ML; ++i) { int c = arr[i]; if (!ch[now][c]) ch[now][c] = ++sz; now = ch[now][c]; } } LL chk() { LL ret = 0; int now = 0; for (int i = 1; i &lt;= ML; ++i) { int c = arr[i] ^ 1; if (ch[now][c]) ret += (1ll &lt;&lt; (LL)(ML - i + 1ll - 1ll)), now = ch[now][c]; else now = ch[now][c ^ 1]; } return ret; } void clean() { ms(hd, -1), en = 0; ans = sz = 0, ms(ch, 0); } int solve() { clean(); for (int u, v, w, i = 1; i &lt; n; ++i) scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w), ++u, ++v, ins(u, v, w), ins(v, u, w); d[0] = 0, dfs(1, 0); // for (int i = 1; i &lt;= n; ++i) cerr &lt;&lt; d[i] &lt;&lt; endl; for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= ML; ++j) { int gg = ML - j + 1; arr[j] = (bool)((LL)(1ll &lt;&lt; (gg - 1ll)) &amp; d[i]); } // for (int j = 1; j &lt;= ML; ++j) cerr &lt;&lt; arr[j]; cerr &lt;&lt; endl; ins(); } for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= ML; ++j) { int gg = ML - j + 1; arr[j] = (bool)((LL)(1ll &lt;&lt; (gg - 1ll)) &amp; d[i]); } ans = max(ans, chk()); } printf(&quot;%lld\n&quot;, ans); return 0; } } int main() { while (scanf(&quot;%d&quot;, &amp;flyinthesky::n) == 1) flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>Trie</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 2351」「BeiJing2011」Matrix (二维Hash)]]></title>
    <url>%2Fbzoj2351%2F</url>
    <content type="text"><![CDATA[BZOJ 2351题意：给定$n \times m$大小矩阵，$q$次询问$a \times b$大小矩阵是否是大矩阵的一部分。 给行列分别hash一次，行先hash，然后将hash值再hash一次，即hash列 然后查询子矩阵Hash值直接像二维前缀和一样做即可，类比于一维的 Hash 方法 知识点：1、二维Hash2、Hash值选取3、Hash的方法取决于是否会冲突，这里运用不同模数巧妙解决冲突 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;map&gt; #include&lt;vector&gt; #include&lt;utility&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { int m, n, a, b, q; unsigned LL bs1 = 257, bs2 = 259, hsh[1005][1005], p1[1005], p2[1005], whw[1005][1005]; map&lt;unsigned LL, bool &gt; ma; void clean() { ms(whw, 0), ms(hsh, 0); } int solve() { clean(); scanf(&quot;%d%d%d%d&quot;, &amp;m, &amp;n, &amp;a, &amp;b); for (int i = 1; i &lt;= m; ++i) for (int j = 1; j &lt;= n; ++j) scanf(&quot;%1lld&quot;, &amp;hsh[i][j]), ++hsh[i][j]; scanf(&quot;%d&quot;, &amp;q); if (m &lt; a || n &lt; b) { while (q--) printf(&quot;0\n&quot;); return 0; } for (int i = 1; i &lt;= m; ++i) for (int j = 1; j &lt;= n; ++j) hsh[i][j] += hsh[i - 1][j] * bs1; for (int i = 1; i &lt;= m; ++i) for (int j = 1; j &lt;= n; ++j) hsh[i][j] += hsh[i][j - 1] * bs2; p1[0] = p2[0] = 1; for (int i = 1; i &lt;= 1000; ++i) p1[i] = p1[i - 1] * bs1; for (int i = 1; i &lt;= 1000; ++i) p2[i] = p2[i - 1] * bs2; for (int i = a; i &lt;= m; ++i) for (int j = b; j &lt;= n; ++j) ma[hsh[i][j] - hsh[i - a][j] * p1[a] - hsh[i][j - b] * p2[b] + hsh[i - a][j - b] * p1[a] * p2[b]] = true; while (q--) { for (int i = 1; i &lt;= a; ++i) for (int j = 1; j &lt;= b; ++j) scanf(&quot;%1lld&quot;, &amp;whw[i][j]), ++whw[i][j]; for (int i = 1; i &lt;= a; ++i) for (int j = 1; j &lt;= b; ++j) whw[i][j] += whw[i - 1][j] * bs1; for (int i = 1; i &lt;= a; ++i) for (int j = 1; j &lt;= b; ++j) whw[i][j] += whw[i][j - 1] * bs2; map&lt;unsigned LL, bool &gt;::iterator it = ma.find(whw[a][b]); if (it != ma.end()) { if (it-&gt;second == true) printf(&quot;1\n&quot;); else printf(&quot;0\n&quot;); } else printf(&quot;0\n&quot;); } return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1084CD(DP思想 / 树形DP)]]></title>
    <url>%2FCodeforces1084CD%2F</url>
    <content type="text"><![CDATA[Codeforces 1084C题意：给定一个$n$长小写字母序列，找出只包含a的子序列，满足每两个a之间有b，求方案数。DP思想。从后往前扫，对每个a维护从这个位置开始顺序，这个位置必选的合法序列数量。对于更新，不妨用b将序列分块，每个a只能继承他右边最近的一块的值。然后自身还有一个贡献，累加即可。 Codeforces 1084D题意：树上每个点有正权值$a_i$，每条边有负权值$W$，你可以随意选择一条路径，使得这条路径的总权值最大，要求每个点每条边至多都只能走一次。一开始想得好偏……然而就是个树形DP，设$dp(u)$为$u$子树中的某个点到$u$的路径最长权。则转移为$dp(u)=max(dp(v)-W(u,v)+a_u)$，当且仅当$dp(v)-W(u,v) \leq 0$然后这样最后要统计每个点的$dp$值取个$max$就行了等等，路径不一定是”直”的。所以我们要在DP每个点的过程中合并两条路径来得到”弯”的路径这里弯直的意思是可能存在下面的情况： 1 | 2 | 3 直：1-2-3 1 | / \ 2 3 弯：2-1-3 知识点：1、计数问题逃不了DP、组合数学2、树上最优问题要像到DP，路径不要漏了弯的路径 1093C: #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;bitset&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL MAXN = 100000 + 5, MO = 1e9 + 7; LL n; char s[MAXN]; void clean() { } int solve() { clean(); scanf(&quot;%s&quot;, s + 1ll); n = strlen(s + 1ll); LL ans = 0ll, tot = 0ll, lsttot = 0ll; for (LL i = n; i; --i) { if (s[i] == &#39;a&#39;) ans = (ans + lsttot + 1ll) % MO, tot = (tot + lsttot + 1ll) % MO; else if (s[i] == &#39;b&#39; &amp;&amp; tot) lsttot = (lsttot + tot) % MO, tot = 0ll; } cout &lt;&lt; ans; return 0; } } int main() { flyinthesky::solve(); return 0; } 1093D: #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;bitset&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL MAXN = 300000 + 5; LL ans, n, dp[MAXN], dw[MAXN]; vector&lt;LL &gt; G[MAXN], W[MAXN]; void ins(LL u, LL v, LL w) {G[u].push_back(v), W[u].push_back(w);} void dfs(LL u, LL fa) { dp[u] = dw[u]; LL maxd = 0, cid = 0; for (LL i = 0; i &lt; (LL)G[u].size(); ++i) { LL v = G[u][i], bw = W[u][i]; if (v != fa) { dfs(v, u); if (dp[v] - bw &gt;= 0ll) { dp[u] = max(dp[u], dp[v] - bw + dw[u]); if (dp[v] - bw &gt; maxd) { cid = maxd, maxd = dp[v] - bw; } else if (dp[v] - bw &gt; cid) { cid = dp[v] - bw; } } } } ans = max(ans, dw[u] + cid + maxd);// 合并两条路径 } void clean() { ans = 0ll; } int solve() { clean(); scanf(&quot;%lld&quot;, &amp;n); for (LL i = 1; i &lt;= n; ++i) scanf(&quot;%lld&quot;, &amp;dw[i]); for (LL u, v, w, i = 1; i &lt; n; ++i) { scanf(&quot;%lld%lld%lld&quot;, &amp;u, &amp;v, &amp;w); ins(u, v, w), ins(v, u, w); } dfs(1, 0); for (LL i = 1; i &lt;= n; ++i) ans = max(ans, dp[i]); cout &lt;&lt; ans; return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>Codeforces</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1093CD(二分图染色 + 乘法原理)]]></title>
    <url>%2FCodeforces1093CD%2F</url>
    <content type="text"><![CDATA[Codeforces 1093C题意：给出数列$b_i​$, 已知一个序列$\forall i, a_i+a_{n-i+1}=b_i​$且$a_i \leq a_{i+1}​$，请构造出一个合法$a_i$数列，保证至少有一组解。解：这个保证至少有一组解提示我们要最优化构造。最优就是前面尽可能小，后面尽可能大。所以我们让$a[0]=0, a[n+1]=INF$，然后根据升序约束求出$a[1, n/2]$的值, $a[n/2+1,n]$则为$b[i]-a[i]$ Codeforces 1093D题意：给出$n$点$m$无向边图，请给每个点赋点权$1,2,3$，使得$\forall (u,v) \in E，w_u+w_v$为奇数。求方案数模$998244353$解：对于一条边和要是奇数，那么点权一奇以偶。那么对图二分图染色，不同颜色的点分类赋奇数还是偶数，注意图不连通。最开始我把所有点一起算了贡献，直接爆炸。要分开乘法原理算。 知识点：1093C: #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { LL n, a[200000 + 5], b[200000 + 5]; void clean() { } int solve() { clean(); cin &gt;&gt; n; for (int i = 1; i &lt;= n / 2; ++i) scanf(&quot;%lld&quot;, &amp;b[i]); a[n + 1] = 1e18; a[n + 1] += 100; for (int i = 1; i &lt;= n / 2; ++i) { a[i] = max(a[i - 1], b[i] - a[n - i + 2]); a[n - i + 1] = b[i] - a[i]; } for (int i = 1; i &lt;= n; ++i) printf(&quot;%lld &quot;, a[i]); return 0; } } int main() { flyinthesky::solve(); return 0; } 1093D: #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 300000 + 5, MO = 998244353; vector&lt;int &gt; G[MAXN]; int fl, n, m, en, vis[MAXN], col[MAXN], js[3]; LL whw[MAXN]; void dfs(int u) { if (fl == 1) return ; vis[u] = 1; for (int i = 0; i &lt; (int)G[u].size(); ++i) { int v = G[u][i]; if (col[v] == col[u]) { fl = 1; break ; } if (!vis[v]) { col[v] = (col[u] == 1 ? 2 : 1); ++js[col[v]]; dfs(v); } } } void clean() { fl = en = 0; for (int i = 0; i &lt;= n; ++i) G[i].clear(), vis[i] = col[i] = 0; } int solve() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); clean(); for (int u, v, i = 1; i &lt;= m; ++i) { scanf(&quot;%d%d&quot;, &amp;u, &amp;v); G[u].push_back(v), G[v].push_back(u); } LL ans = 1; for (int u = 1; u &lt;= n; ++u) { if (!vis[u]) { ms(js, 0); js[1] = 1, col[u] = 1, dfs(u); if (fl == 1) return printf(&quot;0\n&quot;), 0; ans = (ans * ((whw[js[1]] + whw[js[2]]) % MO) % MO) % MO; } } printf(&quot;%lld\n&quot;, ans); return 0; } } int main() { flyinthesky::whw[0] = 1; for (int i = 1; i &lt;= 300001; ++i) flyinthesky::whw[i] = (flyinthesky::whw[i - 1] * 2) % flyinthesky::MO; int t; scanf(&quot;%d&quot;, &amp;t); while (t--) flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>计数原理</tag>
        <tag>Codeforces</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1082E(DP / 贪心)]]></title>
    <url>%2FCodeforces1082E%2F</url>
    <content type="text"><![CDATA[Codeforces 1082E题意：给一个长度为$n$的序列，并且确定一个数$c$。你可以任选一个区间$[l,r]$, 对该区间$+k,k$可以为负数，使得最后的$n$个数中，等于$c$的数字的个数最多。问最多有多少个这样的数？ 方法1将所有数减去$c$，则答案就变成最后最多几个0.然后如果是整个区间加减的话答案就是出现次数最多的数的个数。现在是区间，分析一下发现其实和上面类似，只需要考虑一下多余的0怎么处理考虑 22002 这个数据，这个数据如果将2减去则会破坏中间的0，那么如果操作这个区间对答案贡献为 $3-2=1$ 。那么我们发现，算出序列 0 的个数，然后扫一遍这种情况的区间就行了。我们分颜色讨论，一个颜色肯定取的块是连续的(前缀、后缀、中间一段)，那么我们可以像DP求最大字段和一样，如果前面的答案为负了，那么舍弃重新开始。对每个颜色进行这个操作即可。 方法2 知识点：1、数组下标出现负值小心，加上基准值 //方法1 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;vector&gt; #include&lt;utility&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { int n, c, a[500000 + 5], tax[1000000 + 5], bj[1000000 + 5], cnt0; int bs = 500000; void clean() { cnt0 = 0; } int solve() { clean(); cin &gt;&gt; n &gt;&gt; c; for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i]), a[i] -= c, cnt0 += (a[i] == 0); int tot = 0; int ans = cnt0; ms(tax, 0), ms(bj, 0); for (int i = 1; i &lt;= n; ++i) { if (a[i] == 0) ++tot; else { // 统计当前 0 的个数 if (tax[a[i] + bs] &lt;= tot + bj[a[i] + bs]) { // 当前颜色 a[i] ，i 前面的块负了，舍弃 tax[a[i] + bs] = 0; bj[a[i] + bs] = -tot; } ++tax[a[i] + bs]; ans = max(ans, cnt0 + tax[a[i] + bs] - (tot + bj[a[i] + bs])); // 更新答案 } } printf(&quot;%d\n&quot;, ans); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>DP</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1081D(最小瓶颈路+边贡献思想)]]></title>
    <url>%2FCodeforces1081D%2F</url>
    <content type="text"><![CDATA[Codeforces 1081D题意：给定$n$点$m$边无向连通图，一条路径长度定义为其边的最大值，两个点之间的距离为他们之间最短路径长度。现在给$k$个特殊点，请对每个特殊点找到另一个最远的特殊点，输出距离。根据距离的定义，求出原图的最小生成树(最小瓶颈生成树)，树上两点的唯一路径就是两点距离。并且所有两两点之间的距离最大值是某一条边的边权。那么我们根据边权从小到大枚举每条树上的边来判断是否能成为这条边。这条边应该在$k$个点组成的虚树上。但是并不用那么麻烦，对于每条边判断他左边是否有特殊点，右边是否有特殊点，都有这条边才有可能成为这条边，否则不可能有任意一条路径经过该边。根据连通图和相关性质观察发现，最后答案都是一样的。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;map&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 100000 + 5; struct edge { int u, v, w; bool operator &lt; (const edge &amp;rhs) const {return w &lt; rhs.w;} }ed[MAXN]; int n, m, k, sz[MAXN], f[MAXN]; int find(int x) {return f[x] == x ? x : f[x] = find(f[x]);} void clean() { } int solve() { clean(); cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 1; i &lt;= n; ++i) f[i] = i; for (int x, i = 1; i &lt;= k; ++i) scanf(&quot;%d&quot;, &amp;x), sz[x] = 1; for (int i = 1; i &lt;= m; ++i) scanf(&quot;%d%d%d&quot;, &amp;ed[i].u, &amp;ed[i].v, &amp;ed[i].w); sort(ed + 1, ed + 1 + m); int ans = 0; for (int i = 1; i &lt;= m; ++i) { int x = find(ed[i].u), y = find(ed[i].v); if (x != y) { if (sz[x] &amp;&amp; sz[y]) ans = max(ans, ed[i].w); f[y] = x, sz[x] += sz[y]; } } for (int i = 1; i &lt;= k; ++i) printf(&quot;%d &quot;, ans); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1093G (线段树 + 拆绝对值式子 + k维曼哈顿距离)]]></title>
    <url>%2FCodeforces1093G%2F</url>
    <content type="text"><![CDATA[Codeforces 1093G题意)：给你 $n$ 个 $k$ 维的点 $a_{1..n}$，定义两点$(x_1,x_2,\cdots,x_k),(y_1,y_2,\cdots,y_k)$间的曼哈顿距离为 $\sum_{i=1}^k|x_i-y_i|$。你需要执行下面两种操作：$1 i b_1 b_2\cdots b_k$，表示将 $a_i$修改为 $(b_1,b_2,\cdots,b_k)$。$2 l r$，表示询问 $[l,r]$ 内最大的两点间曼哈顿距离，即任取 $x,y\in[l,r]$ 得到的所有曼哈顿距离中的最大值。翻译来自Luogu 对于绝对值式子，不好处理我们作一个变式。考虑二维的情况，设点$(a_1, a_2), (b_1, b_2)$，则根据绝对值函数定义和$x \leq |x|$，有$$|a_1-b_1|+|a_2-b_2| \\= \max (a_1-b_1, b_1-a_1)+ \max (a_2-b_2, b_2-a_2) \\= \max (a_1-b_1+a_2-b_2, a_1-b_1+b_2-a_2, b_1-a_1+a_2-b_2, b_1-a_1+b_2-a_2) \\= \max ((a_1+a_2)-(b_1+b_2), (a_1-a_2)-(b_1-b_2), (-a_1+a_2)-(-b_1+b_2), (-a_1-a_2)-(-b_1-b_2))$$ 观察到符号是+和-的$2^d$种不同组合，所以我们设第$i$个点的第$j$种为$s(i,j)$，那么两点曼哈顿距离最大值就是$$\max_j \max_i(s(i,j)-s(i,j))$$变形得$$\max_j (\max_i(s(i,j))-\min_i(s(i,j)))$$ 那么用线段树维护$\max_is(i,j)$和$\min_is(i,j)$即可。 知识点：以后遇到绝对值$\max \min$式子要尝试拆一下，因为很多这样的式子是不方便直接处理的，要转化一下。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 200000 + 5; const LL INF = 3223372036854775808ll; int n, k, q, inp[10]; LL s[40], retmax[40], retmin[40]; #define M ((l + r) &gt;&gt; 1) #define lc (o &lt;&lt; 1) #define rc (o &lt;&lt; 1 | 1) LL maxv[MAXN * 4][40], minv[MAXN * 4][40]; void pushup(int o) { for (int i = 0; i &lt;= 32; ++i) maxv[o][i] = max(maxv[lc][i], maxv[rc][i]); for (int i = 0; i &lt;= 32; ++i) minv[o][i] = min(minv[lc][i], minv[rc][i]); } void build(int o, int l, int r) { if (l == r) { for (int i = 0; i &lt;= 32; ++i) maxv[o][i] = -INF; for (int i = 0; i &lt;= 32; ++i) minv[o][i] = INF; } else { build(lc, l, M), build(rc, M + 1, r); pushup(o); } } void update(int o, int l, int r, int p) { if (l == r) { for (int i = 0; i &lt;= 32; ++i) maxv[o][i] = s[i]; for (int i = 0; i &lt;= 32; ++i) minv[o][i] = s[i]; return ; } if (p &lt;= M) update(lc, l, M, p); else if (M &lt; p) update(rc, M + 1, r, p); pushup(o); } void query(int o, int l, int r, int x, int y) { if (x &lt;= l &amp;&amp; r &lt;= y) { for (int i = 0; i &lt;= 32; ++i) retmax[i] = max(retmax[i], maxv[o][i]); for (int i = 0; i &lt;= 32; ++i) retmin[i] = min(retmin[i], minv[o][i]); return ; } if (x &lt;= M) query(lc, l, M, x, y); if (M &lt; y) query(rc, M + 1, r, x, y); } void clean() { } int solve() { clean(); scanf(&quot;%d%d&quot;, &amp;n, &amp;k); build(1, 1, n); for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= k; ++j) scanf(&quot;%d&quot;, &amp;inp[j]); ms(s, 0); for (int S = 0; S &lt; (1 &lt;&lt; k); ++S) { for (int j = 1; j &lt;= k; ++j) { s[S] += ((S &amp; (1 &lt;&lt; (j - 1))) ? 1ll : -1ll) * inp[j]; } } update(1, 1, n, i); } scanf(&quot;%d&quot;, &amp;q); while (q--) { int tp; scanf(&quot;%d&quot;, &amp;tp); if (tp == 1) { int x; scanf(&quot;%d&quot;, &amp;x); for (int i = 1; i &lt;= k; ++i) scanf(&quot;%d&quot;, &amp;inp[i]); ms(s, 0); for (int S = 0; S &lt; (1 &lt;&lt; k); ++S) { for (int i = 1; i &lt;= k; ++i) { s[S] += ((S &amp; (1 &lt;&lt; (i - 1))) ? 1ll : -1ll) * inp[i]; } } update(1, 1, n, x); } if (tp == 2) { int l, r; scanf(&quot;%d%d&quot;, &amp;l, &amp;r); for (int S = 0; S &lt; (1 &lt;&lt; k); ++S) retmax[S] = -INF, retmin[S] = INF; query(1, 1, n, l, r); LL ans = 0; for (int i = 1; i &lt; (1 &lt;&lt; k); ++i) ans = max(ans, retmax[i] - retmin[i]); printf(&quot;%lld\n&quot;, ans); } } return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>Codeforces</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1150」「CTSC2007」数据备份Backup (贪心+堆+链表+差分)]]></title>
    <url>%2Fbzoj1150%2F</url>
    <content type="text"><![CDATA[Bzoj 1150题意：见上。很容易发现最优配对一定是相邻的，因为反应序列数据相对关系的是差分序列，所以我们在差分序列上找$k$个最小和不相邻点即为答案。 现在问题就是直接取最小值可能没有取最小值两边的数更优，那么我们可以先取最小值，然后之后考虑怎么反悔。参照低买高卖那题，那题先买，如果后面有更优的，那么在这个基础上继续买卖可以得到最优解。这里先取了最小值，那么如果不优，最小值两边的数一定必取，因为如果只选一边选最小值最优。我们要添加一个元素在中间，使得之后选这个点相当于返回选了两边的数。那么用链表支持这个操作。由于是全局最小值，很容易发现可以用堆来维护最小值，注意堆和链表要同步，相当于映射关系。 注意链表有误，要将第一个点插在 $h$ 后面 1、链表不可达点的赋值2、在分析贪心策略时，运用了渐进思想中的从变量小开始思考3、贪心错误时修改贪心，多分支哈夫曼树解决方法亦如此4、要尽可能将问题转化为数学模型，序列问题 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;vector&gt; #include&lt;utility&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 100000 + 5; struct data { int pos; LL w; bool operator &lt; (const data &amp;rhs) const { return w &gt; rhs.w; } }; int n, k, a[MAXN], d[MAXN]; int tot, l[MAXN * 3], r[MAXN * 3], h, t, vis[MAXN * 3]; LL val[MAXN * 3]; priority_queue&lt;data &gt; q; void ins(int pos, LL v) { ++tot, val[tot] = v, l[tot] = pos, r[tot] = r[pos]; l[r[pos]] = tot; r[pos] = tot; } void del(int pos) { vis[pos] = 1; r[l[pos]] = r[pos], l[r[pos]] = l[pos]; } void clean() { ms(vis, 0); tot = 2, h = 1, t = 2, l[t] = h, r[h] = t; } int solve() { clean(); scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i]); val[0] = val[1] = val[2] = 4223372036854775807ll; for (int i = 1; i &lt; n; ++i) d[i] = a[i + 1] - a[i]; ins(h, d[1]), q.push((data){tot, d[1]}); for (int i = 2; i &lt; n; ++i) ins(2 + i - 1, d[i]), q.push((data){tot, d[i]}); //for (int i = 1; i &lt; n; ++i) ins(2 + i - 1, d[i]), q.push((data){tot, d[i]}); // 这样插有问题 LL ans = 0; int o = 0; while (1) { data p = q.top(); q.pop(); if (vis[p.pos]) continue ; ++o; ans += p.w; val[p.pos] = val[l[p.pos]] + val[r[p.pos]] - val[p.pos]; del(l[p.pos]), del(r[p.pos]); q.push((data){p.pos, val[p.pos]}); if (o &gt;= k) break; } printf(&quot;%lld\n&quot;, ans); return 0; } } int main() { flyinthesky::solve(); return 0; } /* 10 5 1 3 8 11 15 20 25 35 40 58 */]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>堆</tag>
        <tag>贪心</tag>
        <tag>Bzoj</tag>
        <tag>差分序列</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 4407」于神之怒加强版(莫比乌斯反演)]]></title>
    <url>%2Fbzoj4407%2F</url>
    <content type="text"><![CDATA[BZOJ 4407题意：给定$n,m,k$，求$$\sum_{i=1}^n\sum_{j=1}^m \gcd(i,j)^k \mod (10^9+7)$$ 按照套路反演以后得到 $$\sum_{d=1}^n d^k \sum_{i=1}^{\lfloor \frac nd \rfloor} \mu(i) \lfloor \frac n{di} \rfloor \lfloor \frac m{di}\rfloor$$ 此时我们发现可以分块套分块达到复杂度$O(n)$单次询问。但是还是不够，那么继续变形 设$T=di$，则 $$\sum_{T=1}^n \lfloor \frac nT \rfloor \lfloor \frac mT \rfloor \sum_{d|T} d^k \mu(\frac Td)$$ 设$f(T)=\sum_{d|T}d^k \mu(\frac Td)$，发现$d^k$和$\mu(k)$都是积性函数，所以乘积也是积性函数，所以我们可以线性筛$O(n)$算这个积性函数值。 如何线性筛？线性筛积性函数考虑两个第一个是$f(p), p$为质数时的取值怎么$O(1)$算第二个是$f(p^x), p$为质数时的取值怎么$O(1)$算，也就是说我们需要从$f(p^x)$转到$f(p^{x+1})$怎么求 考虑将$T$质因数分解，那么对于每个$p_i$ $$f(p_i^{x_i})=\sum_{d|p_i^{x_i}}d^k\mu(\frac{p_i^{x_i}}d)$$ 因为有$\mu$的存在，只需要考虑$d=p_i^{x_i}$和$d=p_i^{x_i-1}$的情况，则原式化为 $$f(p_i^{x_i})=\mu(p_i) \cdot p_i^{k(x_i-1)} + \mu(1) \cdot p_i^{x_ik}$$ 即 $$f(p_i^{x_i}) = p_i^{x_ik} - p_i^{k(x_i-1)}$$ $$f(p_i^{x_i}) = p_i^{k(x_i-1)}(p_i^k-1)$$ 这个式子可以方便解决$f(p^x), p$为质数时的取值 对于第一个，$f(p)=\mu(1) \cdot p^k + \mu(p) \cdot 1^k=p^k-1$ 那么这样就可以线筛了。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 5000000 + 5; const LL MO = 1000000007; int T, k, cnt, pri[MAXN], vis[MAXN]; LL f[MAXN]; LL ksm(LL a, LL b) { LL bs = a % MO, ans = 1; while (b) { if (b &amp; 1) ans = (ans * bs) % MO; bs = (bs * bs) % MO; b &gt;&gt;= 1; } return ans; } void clean() { } int solve() { scanf(&quot;%d%d&quot;, &amp;T, &amp;k); clean(); cnt = 0, vis[1] = 1, f[1] = 1; for (int i = 2; i &lt;= 5000000; ++i) { if (!vis[i]) pri[++cnt] = i, f[i] = ksm(i, k) - 1; for (int j = 1; j &lt;= cnt &amp;&amp; (LL)i * pri[j] &lt;= 5000000ll; ++j) { vis[i * pri[j]] = 1; if (i % pri[j] == 0) { f[i * pri[j]] = (f[i] * ksm(pri[j], k)) % MO; break ; } f[i * pri[j]] = (f[i] * f[pri[j]]) % MO; } } for (int i = 2; i &lt;= 5000000; ++i) f[i] += f[i - 1]; while (T--) { int n, m; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); if (n &gt; m) swap(n, m); int l = 1; LL ans = 0ll; while (l &lt;= n) { int r = min(n / (n / l), m / (m / l)); ans = (ans + (LL)(n / l) * (m / l) % MO * (f[r] - f[l - 1]) % MO) % MO; l = r + 1; } printf(&quot;%lld\n&quot;, ans); } return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bzoj 2152(点分治)]]></title>
    <url>%2Fbzoj2152%2F</url>
    <content type="text"><![CDATA[Bzoj 2152题意：询问树上距离为$3$的倍数的路径条数。 直接上点分治，算答案的时候用桶存答案，然后乘法原理即可。是 $ k $ 的倍数相当于模 $ k $ 为 $ 0 $ #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 20000 + 5; const int INF = 2147483647; struct edge { int v, w, nxt; }ed[MAXN * 2]; int n, en, hd[MAXN]; int siz[MAXN], vis[MAXN], wt[MAXN], rt, Tsz, tax[5]; LL ans; void ins(int u, int v, int w) {ed[++en] = (edge){v, w, hd[u]}, hd[u] = en;} void getRt(int u, int fa) { wt[u] = 0, siz[u] = 1; for (int i = hd[u]; i &gt; 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (e.v != fa &amp;&amp; !vis[e.v]) getRt(e.v, u), siz[u] += siz[e.v], wt[u] = max(wt[u], siz[e.v]); } wt[u] = max(wt[u], Tsz - siz[u]); if (wt[rt] &gt; wt[u]) rt = u; } void dfsD(int u, int fa, int D) { ++tax[D % 3]; for (int i = hd[u]; i &gt; 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (e.v != fa &amp;&amp; !vis[e.v]) dfsD(e.v, u, D + e.w); } } LL calc(int u, int D) { ms(tax, 0), dfsD(u, 0, D); return (LL)tax[1] * tax[2] * 2 + (LL)tax[0] * tax[0]; } void dfs(int u) { ans += calc(u, 0); vis[u] = 1; for (int i = hd[u]; i &gt; 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (!vis[e.v]) { ans -= calc(e.v, e.w); rt = 0, Tsz = siz[e.v], getRt(e.v, u); dfs(rt); } } } LL gcd(LL a, LL b) {return b == 0 ? a : gcd(b, a % b);} void clean() { ans = en = 0, ms(hd, -1), ms(vis, 0); } int solve() { scanf(&quot;%d&quot;, &amp;n); clean(); for (int u, v, w, i = 1; i &lt; n; ++i) scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w), ins(u, v, w), ins(v, u, w); rt = 0, wt[0] = INF, Tsz = n, getRt(1, 0); dfs(1); LL fm = (LL)n * n; LL g = gcd(ans, fm); fm /= g, ans /= g; printf(&quot;%lld/%lld\n&quot;, ans, fm); return 0; } } int main() { flyinthesky::solve(); return 0; } /* 5 1 2 1 1 3 3 2 4 2 2 5 1 */]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[点分治 学习笔记]]></title>
    <url>%2Fsz%E7%82%B9%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[模板及讲解点分治点分治就是处理树上路径的一个树上分治算法。其基本思路与分治类似。 模板题Poj 1741 给出一颗无根树，求树上距离小于等于 $k$ 的点对(路径)有多少个。$n \leq 10000$ 基本思路点分治基本步骤：1、DFS 每一棵子树 (以重心为根保证复杂度)2、对当前 DFS 的子树进行求值 (calc)3、求值完删除当前重心继续往下 DFS 子树，顺便对子树进行求值后容斥 求值方法 (因题而异，用 Poj 1741 为例)：1、DFS 求出所有连通点到当前子树根的距离2、将距离排序，用两点法等对信息进行处理 点分治核心函数是 calc 代码实现函数 void dfs(int u)：DFS 求解子树，根为 $u$ int calc(int u, int D)：计算以$u$为根子树的答案，$(fa[u], u)$边权为$D$ void dfsD(int u, int D, int fa)：计算以$u$为根子树节点到 $u$ (根)的距离数组，$D，fa$为临时局部变量 void getRt(int u, int fa)：求解以$u$为根的子树的重心 代码 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 10000 + 5; const int INF = 2147483647; struct edge { int v, w, nxt; }ed[MAXN * 2]; int n, k, ans, en, hd[MAXN]; int vis[MAXN], siz[MAXN], rt, wt[MAXN], Tsz; // 访问数组 (点分治中删除的点设为 1)，子树大小，当前根，以 i 为重心的最大深度(用作求重心)，当前树大小 int arr[MAXN], cnt; // 距离数组 arr ，在 dfsD() 和 calc() 中使用 void ins(int u, int v, int w) {ed[++en] = (edge){v, w, hd[u]}, hd[u] = en;} void getRt(int u, int fa) { // 找 u 子树的重心 siz[u] = 1; wt[u] = 0; for (int i = hd[u]; i &gt; 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (e.v != fa &amp;&amp; !vis[e.v]) getRt(e.v, u), siz[u] += siz[e.v], wt[u] = max(wt[u], siz[e.v]); } wt[u] = max(wt[u], Tsz - siz[u]); if(wt[rt] &gt; wt[u]) rt = u; } void dfsD(int u, int D, int fa) { // DFS 求子树到 u (根)的距离数组 arr arr[++cnt] = D; for (int i = hd[u]; i &gt; 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (e.v != fa &amp;&amp; !vis[e.v]) dfsD(e.v, D + e.w, u); } } int calc(int u, int D) { // 计算 u 子树的答案，(fa[u], u) 边权为 D cnt = 0; dfsD(u, D, 0); // 计算 子树到 u (根)的距离数组 arr int l = 1, r = cnt, sum = 0; sort(arr + 1, arr + cnt + 1); for( ; ; ++l) { while (r &amp;&amp; arr[l] + arr[r] &gt; k) --r; if(r &lt; l) break; sum += r - l + 1; } // 两点法求答案 return sum; } void dfs(int u) { // DFS 求解 ans += calc(u, 0); // 求解当前树 vis[u] = 1; // 记录当前删除标记 for (int i = hd[u]; i &gt; 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (!vis[e.v]) { ans -= calc(e.v, e.w); // 容斥，减去无用答案 rt = 0, Tsz = siz[e.v], getRt(e.v, 0); // 找子树的重心作为子树根来进行下一步求解 dfs(rt); } } } void clean() { ans = en = 0, ms(hd, -1), ms(vis, 0), ms(wt, 0); } int solve() { clean(); for (int u, v, w, i = 1; i &lt; n; ++i) scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w), ins(u, v, w), ins(v, u, w); wt[0] = INF, Tsz = n, getRt(1, 0); // 第一次找重心作为根 dfs(rt); printf(&quot;%d\n&quot;, ans - n); // 减去一个点单独成路径 return 0; } } int main() { while(scanf(&quot;%d%d&quot;, &amp;flyinthesky::n, &amp;flyinthesky::k) == 2 &amp;&amp; (flyinthesky::n || flyinthesky::k)) flyinthesky::solve(); return 0; } 例题树上距离为 $ k $ 的点对Luogu 3806 询问树上距离为 $ k $ 的点对是否存在。 解：直接上点分治，算答案的时候用桶存答案，然后乘法原理即可。每次询问做一次点分治或者打表。注意边权为 0 的情况 Ps：CF 161D 数据更强 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 10000 + 5; const int INF = 2147483647; struct edge { int v, w, nxt; }ed[MAXN * 2]; int n, q, k, en, hd[MAXN]; int vis[MAXN], wt[MAXN], Tsz, rt, siz[MAXN]; int cnt, arr[MAXN], tax[10000005], whw[10000005]; LL ans; void ins(int u, int v, int w) {ed[++en] = (edge){v, w, hd[u]}, hd[u] = en;} void getRt(int u, int fa) { wt[u] = 0, siz[u] = 1; for (int i = hd[u]; i &gt; 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (e.v != fa &amp;&amp; !vis[e.v]) getRt(e.v, u), siz[u] += siz[e.v], wt[u] = max(wt[u], siz[e.v]); } wt[u] = max(wt[u], Tsz - siz[u]); if (wt[rt] &gt; wt[u]) rt = u; } void dfsD(int u, int fa, int D) { arr[++cnt] = D; for (int i = hd[u]; i &gt; 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (e.v != fa &amp;&amp; !vis[e.v]) dfsD(e.v, u, D + e.w); } } LL calc(int u, int D) { cnt = 0; dfsD(u, 0, D); LL sum = 0; for (int i = 1; i &lt;= cnt; ++i) ++tax[arr[i]]; for (int i = 1; i &lt;= cnt; ++i) { if (!whw[arr[i]] &amp;&amp; k &gt;= arr[i]) { if (arr[i] == k - arr[i]) sum += tax[arr[i]] * (tax[arr[i]] - 1) / 2; // 写对两两配对不重复的公式 else sum += tax[k - arr[i]] * tax[arr[i]]; whw[arr[i]] = 1, whw[k - arr[i]] = 1; } } for (int i = 1; i &lt;= cnt; ++i) --tax[arr[i]]; for (int i = 1; i &lt;= cnt; ++i) { whw[arr[i]] = 0; if (k &gt;= arr[i]) whw[k - arr[i]] = 0; } return sum; } void dfs(int u) { ans += calc(u, 0); vis[u] = 1; for (int i = hd[u]; i &gt; 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (!vis[e.v]) { ans -= calc(e.v, e.w); rt = 0, Tsz = siz[e.v], getRt(e.v, u); dfs(rt); } } } void clean() { en = 0, ms(hd, -1), ms(tax, 0); } int solve() { scanf(&quot;%d%d&quot;, &amp;n, &amp;q); clean(); for (int u, v, w, i = 1; i &lt; n; ++i) scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w), ins(u, v, w), ins(v, u, w); while (q--) { ans = 0, ms(vis, 0); scanf(&quot;%d&quot;, &amp;k); rt = 0, Tsz = n, wt[0] = INF, getRt(1, 0); dfs(1); printf(&quot;%s\n&quot;, ans &gt; 0 ? &quot;AYE&quot; : &quot;NAY&quot;); } return 0; } } int main() { flyinthesky::solve(); return 0; } /* 5 50 1 2 3 1 3 1 1 4 2 3 5 1 4 2 100 1 2 0 0 */ 树上距离模 $ k $ / 是 $ k $ 的倍数的点对Bzoj 2152 询问树上距离是 $ k $ 的倍数的点对。 解：直接上点分治，算答案的时候用桶存答案，然后乘法原理即可。是 $ k $ 的倍数相当于模$ k $为 $ 0 $ 不用容斥实现的点分治BZOJ 2559 给一棵树，每条边有权。求一条简单路径，权值和等于 $K$，且边的数量最小。 点分治模板题，但是这里维护的是不可加信息，不能用容斥的方法，我们求每个点的值的时候按一定顺序遍历他的儿子，然后将前面的存起来供后面的合并(类似树直径DP)，然后就不用考虑容斥了，都是可行的合并。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 200000 + 5, INF = 0x3f3f3f3f; struct edge { int v, w, nxt; } ed[MAXN * 2]; int n, k, en, hd[MAXN]; int wt[MAXN], siz[MAXN], Tsz, rt; int vis[MAXN]; int ans; int tot, dis[MAXN], bs[MAXN]; void ins(int u, int v, int w) {ed[++en] = (edge){v, w, hd[u]}, hd[u] = en;} void getRt(int u, int fa) { // 找 u 子树的重心 siz[u] = 1, wt[u] = 0; for (int i = hd[u]; i &gt; 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (e.v != fa &amp;&amp; !vis[e.v]) getRt(e.v, u), siz[u] += siz[e.v], wt[u] = max(wt[u], siz[e.v]); } wt[u] = max(wt[u], Tsz - siz[u]); if(wt[rt] &gt; wt[u]) rt = u; } void getD(int u, int fa, int D, int b) { if (D &gt; k) return ; dis[++tot] = D, bs[tot] = b; for (int i = hd[u]; i &gt;= 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (e.v != fa &amp;&amp; !vis[e.v]) getD(e.v, u, D + e.w, b + 1); } } int tax[1000000 + 5]; void calc(int u) { tot = 0, tax[0] = 0; for (int i = hd[u]; i &gt;= 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (!vis[e.v]) { int whw = tot; getD(e.v, u, e.w, 1); for (int j = whw + 1; j &lt;= tot; ++j) ans = min(ans, tax[k - dis[j]] + bs[j]); for (int j = whw + 1; j &lt;= tot; ++j) tax[dis[j]] = min(tax[dis[j]], bs[j]); } } for (int i = 1; i &lt;= tot; ++i) tax[dis[i]] = INF; } void dfs(int u) { vis[u] = 1; calc(u); for (int i = hd[u]; i &gt;= 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (!vis[e.v]) { rt = 0, Tsz = siz[e.v], wt[0] = INF, getRt(e.v, 0); dfs(rt); // rt } } } void clean() { en = -1, ms(hd, -1); ms(wt, 0), ms(siz, 0), ms(vis, 0); ms(tax, 0x3f), ans = INF; } int solve() { clean(); cin &gt;&gt; n &gt;&gt; k; if (k == 0) return printf(&quot;0\n&quot;), 0; for (int x, y, w, i = 1; i &lt; n; ++i) { scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;w); ++x, ++y; ins(x, y, w), ins(y, x, w); } rt = 0, Tsz = n, wt[0] = INF, getRt(1, 0); dfs(rt); if (ans &gt;= n) printf(&quot;-1\n&quot;); else printf(&quot;%d\n&quot;, ans); return 0; } } int main() { flyinthesky::solve(); return 0; } 写时注意：1、找完根后是dfs(rt)而不是dfs(v) 常见题型]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>点分治</tag>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bzoj 3032(中位数+环形均分纸牌)]]></title>
    <url>%2Fbzoj3032%2F</url>
    <content type="text"><![CDATA[bzoj 3032 一行之间交换不会影响这一行的摊点数，列同理。所以行列分开独立处理。 那么现在就是要对行列分别求，最小交换次数使得每个位置摊点数相同。这个很像均分纸牌，我们可以发现就是均分纸牌，而这里加上了环形。 我们可以发现环形均分纸牌中一定有两个人之间没换过纸牌，那么用朴素方法就是枚举这个位置将链断环成链。 我们想一想均分纸牌的本质，就是当前所有数减去平均数之后$[1,i]$的前缀和一定要是0.而现在不是从1开始，经过类似分析和问题有解必然有$[1,n]$的前缀和为0可以发现，我们所求答案就是$$\sum_{i=1}^n |S_i - S_k|$$我们发现这个是中位数的性质公式，则$S_k​$为中位数，免去枚举。 知识点：1、本题分析出独立性后，转化为环形均分纸牌，环形均分纸牌又类比于均分纸牌和中位数。2、LL #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 100000 + 5; int n, m, t, hang[MAXN], lie[MAXN]; int abss(int x) {return x &gt; 0 ? x : -x;} void clean() { ms(hang, 0), ms(lie, 0); } int solve() { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;t); clean(); for (int x, y, i = 1; i &lt;= t; ++i) { scanf(&quot;%d%d&quot;, &amp;x, &amp;y); ++lie[y], ++hang[x]; } LL hangfl = -1, liefl = -1; if (t % n != 0) hangfl = -2; else { for (int i = 1; i &lt;= n; ++i) hang[i] -= t / n; for (int i = 2; i &lt;= n; ++i) hang[i] += hang[i - 1]; sort(hang + 1, hang + 1 + n); int zws = hang[(n + 1) / 2]; hangfl = 0; for (int i = 1; i &lt;= n; ++i) hangfl += abss(hang[i] - zws); } if (t % m != 0) liefl = -2; else { for (int i = 1; i &lt;= m; ++i) lie[i] -= t / m; for (int i = 2; i &lt;= m; ++i) lie[i] += lie[i - 1]; sort(lie + 1, lie + 1 + m); int zws = lie[(m + 1) / 2]; liefl = 0; for (int i = 1; i &lt;= m; ++i) liefl += abss(lie[i] - zws); } if (liefl != -2 &amp;&amp; hangfl != -2) printf(&quot;both %lld\n&quot;, liefl + hangfl); else if (liefl != -2) printf(&quot;column %lld\n&quot;, liefl); else if (hangfl != -2) printf(&quot;row %lld\n&quot;, hangfl); else printf(&quot;impossible\n&quot;); return 0; } } int main() { flyinthesky::solve(); return 0; } 描述TYVJ七夕祭和11区的夏祭的形式很像。矩形的祭典会场由N排M列共计N×M个摊点组成。虽然摊点种类繁多，不过cl只对其中的一部分摊点感兴趣，比如章鱼烧、苹果糖、棉花糖、射的屋……什么的。Vani预先联系了七夕祭的负责人zhq，希望能够通过恰当地布置会场，使得各行中cl感兴趣的摊点数一样多，并且各列中cl感兴趣的摊点数也一样多。 不过zhq告诉Vani，摊点已经随意布置完毕了，如果想满足cl的要求，唯一的调整方式就是交换两个相邻的摊点。两个摊点相邻，当且仅当他们处在同一行或者同一列的相邻位置上。由于zhq率领的TYVJ开发小组成功地扭曲了空间，每一行或每一列的第一个位置和最后一个位置也算作相邻。现在Vani想知道他的两个要求最多能满足多少个。在此前提下，至少需要交换多少次摊点。 输入格式第一行包含三个整数N和M和T。T表示cl对多少个摊点感兴趣。 接下来T行，每行两个整数x, y，表示cl对处在第x行第y列的摊点感兴趣。 输出格式首先输出一个字符串。如果能满足Vani的全部两个要求，输出both；如果通过调整只能使得各行中cl感兴趣的摊点数一样多，输出row；如果只能使各列中cl感兴趣的摊点数一样多，输出column；如果均不能满足，输出impossible。 如果输出的字符串不是impossible， 接下来输出最小交换次数，与字符串之间用一个空格隔开。 样例输入样例输入12 3 41 32 12 22 3 样例输入23 3 31 32 22 3样例输出样例输出1row 1 样例输出2both 2数据范围与约定对于 100% 的数据，1≤N, M≤100000，0≤T≤min(N*M, 100000)，1≤x≤N，1≤y≤M。]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bzoj 2705(欧拉函数)]]></title>
    <url>%2Fbzoj2705%2F</url>
    <content type="text"><![CDATA[BZOJ 2705题意：求$$\sum_{i=1}^n gcd(i,n)$$ 解：$$\sum_{i=1}^n gcd(i,n)=\sum_{d|n} d \sum_{i=1}^n [gcd(i,n)=d]=\sum_{d|n} d \sum_{i=1}^{\lfloor \frac nd \rfloor} [gcd(i,\lfloor \frac nd \rfloor)=1]=\sum_{d|n} d \cdot \varphi(\lfloor \frac nd \rfloor)$$ 枚举$d|n$计算即可。单个$\varphi(n)$可以质因数分解在$O(\sqrt n)$时间求得。 时间复杂度的计算：枚举因数$d|n$: $O(\sqrt n)$求因数的$\varphi(d)$: $O(\sqrt {\sqrt n})$综上复杂度为$O(n^{\frac 34})​$ (刚开始以为这个是$O(n)​$的不敢写就挂了……) 知识点：1、认真算时间复杂度 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { LL n, ans = 0; LL getphi(LL x) { LL ret = x; for (LL i = 2; i * i &lt;= x; ++i) { if (x % i == 0) { ret = ret / i * (i - 1); while (x % i == 0) x /= i; } } if (x != 1) ret = ret / x * (x - 1); return ret; } void clean() { } int solve() { cin &gt;&gt; n; clean(); for (LL i = 1; i * i &lt;= n; ++i) { if (n % i == 0) { ans += getphi(i) * (n / i); if (i != n / i &amp;&amp; n % (n / i) == 0) ans += getphi(n / i) * i; } } cout &lt;&lt; ans &lt;&lt; endl; return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>欧拉函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 2301」「HAOI2011」Problem b(莫比乌斯反演)]]></title>
    <url>%2Fbzoj2301%2F</url>
    <content type="text"><![CDATA[BZOJ 2301题意：给定$a, b, c, d, k$, 求$$\sum_{i=a}^{b} \sum_{j=c}^{d} [\gcd(i,j)=k]$$ (下面默认$n \leq m$, 不满足则交换)解：我们可以将答案分成几个部分求解，然后$ans=f(b,d)-f(a-1,d)-f(b,c-1)+f(a-1,c-1)$依题意设出$f(k)$为$gcd(i,j)=k$的个数$(1 \leq i \leq n, 1 \leq j \leq n)$但是这个并不好求，看见两个求和符号，我们可以想到用莫比乌斯反演来求解。显然用变形后的两个式子，我们就可以设$g(k)$为$k|gcd(i,j)$的个数$(1 \leq i \leq n, 1 \leq j \leq n)$$g(k)$非常好算，$g(k)=\lfloor \frac n{k} \rfloor \lfloor \frac m{k} \rfloor$而显然$g(k)=\sum_{d=1}^{\lfloor \frac nk \rfloor} f(ki)$那么可以莫比乌斯反演$$f(k)=\sum_{d=1}^{\lfloor \frac nk \rfloor} \mu(d) \lfloor \frac n{kd} \rfloor \lfloor \frac m{kd} \rfloor$$换元$\lfloor \frac nk \rfloor$，整除分块即可。 注意有$n,m$的整除分块是取两者最小值，复杂度也是有保证的。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL MAXN = 50000 + 5; LL q, tot, pri[MAXN], vis[MAXN], mu[MAXN]; LL getans(LL n, LL m, LL k) { if (n &gt; m) swap(n, m); n /= k, m /= k; LL l = 1, r, ans = 0ll; while (l &lt;= n) { r = min((n / (n / l)), (m / (m / l))); ans += (n / l) * (m / l) * (mu[r] - mu[l - 1]); l = r + 1ll; } return ans; } void clean() { ms(vis, 0), tot = 0; } int solve() { scanf(&quot;%lld&quot;, &amp;q); clean(); vis[1] = 1, mu[1] = 1; for (LL i = 2; i &lt;= 50000; ++i) { if (!vis[i]) mu[i] = -1, pri[++tot] = i; for (LL j = 1; j &lt;= tot &amp;&amp; i * pri[j] &lt;= 50000; ++j) { vis[i * pri[j]] = 1; if (i % pri[j] == 0) { mu[i * pri[j]] = 0; break; } else mu[i * pri[j]] = -mu[i]; } } //for (LL i = 1; i &lt;= 100; ++i) cerr &lt;&lt; mu[i] &lt;&lt; &quot; &quot;; mu[0] = 0; for (LL i = 1; i &lt;= 50000; ++i) mu[i] += mu[i - 1]; for (LL a, b, c, d, k, i = 1; i &lt;= q; ++i) { scanf(&quot;%lld%lld%lld%lld%lld&quot;, &amp;a, &amp;b, &amp;c, &amp;d, &amp;k); printf(&quot;%lld\n&quot;, getans(b, d, k) - getans(a - 1, d, k) - getans(b, c - 1, k) + getans(a - 1, c - 1, k)); } return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj 2288(状压DP)]]></title>
    <url>%2Fpoj2288%2F</url>
    <content type="text"><![CDATA[poj 2288题意：求一个无向图中的一条哈密顿路，这条路价值最大。价值计数方法为：所有点权+两连续点权积+三连续点构成三角形积 (算法竞赛进阶指南例题) 这种方程的转移能力还是差。。设$dp(S,i,j)$为状态为$S$，最后访问的两个点依次为$i,j$的最大值那么转移就是$dp(S,i,j)=dp(S-k,j,k)+val_i+val_i \cdot val_j$，如果$i,k$连通则加上$val_i \cdot val_j \cdot val_k$这个转移相当于当前路径是$k-&gt;j-&gt;i$，从$(k,j)$转移到$(j,i)$ 初始化$dp(S, i, j) = val_i + val_j + val_i \cdot val_j$，两点连通对答案的贡献然后之后的 DP 都从这些转移过来，记得判无效状态！ 知识点：1、DP检查方法：1、转移是否漏 2、转移是否从无效状态转移 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { LL n, m, val[15], G[15][15], dp[(1 &lt;&lt; 13) + 5][15][15], cnt[(1 &lt;&lt; 13) + 5][15][15]; void clean() { ms(G, 0), ms(dp, 0), ms(cnt, 0); } int solve() { scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m); clean(); for (LL i = 1; i &lt;= n; ++i) scanf(&quot;%lld&quot;, &amp;val[i]); if (n == 1) return printf(&quot;%lld %lld\n&quot;, val[1], 1ll), 0; for (LL a, b, i = 1; i &lt;= m; ++i) { scanf(&quot;%lld%lld&quot;, &amp;a, &amp;b); G[a][b] = G[b][a] = 1; } for (LL u = 1; u &lt;= n; ++u) { for (LL v = 1; v &lt;= n; ++v) if (u != v &amp;&amp; G[u][v]) { dp[(1 &lt;&lt; (u - 1)) + (1 &lt;&lt; (v - 1))][u][v] = val[u] * val[v] + val[u] + val[v]; cnt[(1 &lt;&lt; (u - 1)) + (1 &lt;&lt; (v - 1))][u][v] = 1; //cerr &lt;&lt; &quot;???&quot; &lt;&lt; dp[(1 &lt;&lt; (u - 1)) + (1 &lt;&lt; (v - 1))][u][v] &lt;&lt; &quot; u&quot; &lt;&lt; u &lt;&lt; &quot; v&quot; &lt;&lt; v &lt;&lt; endl; } } for (LL S = 0; S &lt; (1 &lt;&lt; n); ++S) { for (LL i = 1; i &lt;= n; ++i) if (S &amp; (1 &lt;&lt; (i - 1))) { for (LL j = 1; j &lt;= n; ++j) if (i != j &amp;&amp; S &amp; (1 &lt;&lt; (j - 1)) &amp;&amp; G[i][j]) { for (LL k = 1; k &lt;= n; ++k) if (k != i &amp;&amp; k != j &amp;&amp; S &amp; (1 &lt;&lt; (k - 1)) &amp;&amp; G[k][j] &amp;&amp; dp[S ^ (1 &lt;&lt; (i - 1))][j][k] &gt; 0) { LL whw = dp[S ^ (1 &lt;&lt; (i - 1))][j][k] + val[i] + val[i] * val[j] + G[k][i] * val[i] * val[j] * val[k]; if (dp[S][i][j] &lt; whw) { dp[S][i][j] = whw; cnt[S][i][j] = cnt[S ^ (1 &lt;&lt; (i - 1))][j][k]; } else if (dp[S][i][j] == whw) cnt[S][i][j] += cnt[S ^ (1 &lt;&lt; (i - 1))][j][k]; } } } } LL ans1 = 0ll, ans2 = 0ll; for (LL i = 1; i &lt;= n; ++i) for (LL j = 1; j &lt;= n; ++j) { if (dp[(1 &lt;&lt; n) - 1][i][j] &gt; ans1) ans1 = dp[(1 &lt;&lt; n) - 1][i][j], ans2 = cnt[(1 &lt;&lt; n) - 1][i][j]; else if (dp[(1 &lt;&lt; n) - 1][i][j] == ans1) ans2 += cnt[(1 &lt;&lt; n) - 1][i][j]; } printf(&quot;%lld %lld\n&quot;, ans1, ans2 / 2ll); return 0; } } int main() { int q; scanf(&quot;%d&quot;, &amp;q); while (q--) flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>状压DP</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 2165」大楼 (倍增DP+矩阵快速幂)]]></title>
    <url>%2Fbzoj2165%2F</url>
    <content type="text"><![CDATA[Bzoj 2165 本题是个倍增DP，在图上做。这个图给的明显是个分层图，我们逆向运用，分层图转成一个图。然后就可以设$dp(p,i,j)$为坐了$p$次电梯$i$到$j$能到达的最高楼层。则$dp(p,i,j)=max(dp(p/2, i, k)+dp(p / 2, k, j))$那么这是一个倍增DP形式，我们也可以设$2^p$的状态。我们发现邻接矩阵自乘就是这个方程的转移，所以矩阵快速幂上就行如果第一行有一个$\geq m$，那么不用再DP下去然后求答案就贪心像倍增LCA那样补，同时也要一直判断第一行是否有一个$\geq m$，有就说明当前不能乘第一行有一个$\geq m$说明当前已经到达题目要求注意修改矩阵乘法的地方所有值都应该小于$m$ 倍增DP的思想，其实ST表、LCA的pre数组求法都是这种思路。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 105; const LL ZINF = 2000000000000000001ll; int n, cnt; LL m; struct matrix { LL a[MAXN][MAXN]; matrix() {for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) a[i][j] = 0;} void init() {for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) a[i][j] = -ZINF;} }f[MAXN]; matrix mul(matrix a, matrix b) { matrix ret; ret.init(); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) for (int k = 1; k &lt;= n; ++k) ret.a[i][j] = min(m, max(ret.a[i][j], a.a[i][k] + b.a[k][j])); return ret; } int check(matrix a) { for (int i = 1; i &lt;= n; ++i) if (a.a[1][i] &gt;= m) return false; return true; } void clean() { cnt = 1; } int solve() { clean(); scanf(&quot;%d%lld&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) scanf(&quot;%lld&quot;, &amp;f[1].a[i][j]), f[1].a[i][j] = (f[1].a[i][j] ? f[1].a[i][j] : -ZINF); while (1) { matrix tmp = mul(f[cnt], f[cnt]); if (check(tmp)) f[++cnt] = tmp; else break ; } LL ans = 1; matrix whw = f[1]; for (int i = cnt; i &gt; 0; --i) { matrix tmp = mul(whw, f[i]); if (check(tmp)) whw = tmp, ans += (1ll &lt;&lt; (i - 1)); } printf(&quot;%lld\n&quot;, ans + 1); return 0; } } int main() { int T; scanf(&quot;%d&quot;, &amp;T); while (T--) flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>Bzoj</tag>
        <tag>矩阵</tag>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1875」「SDOI2009」HH去散步 (矩阵快速幂+图上DP)]]></title>
    <url>%2Fbzoj1875%2F</url>
    <content type="text"><![CDATA[BZOJ 1875题意：求无权无向图中$A$走$k$步到$B$的路径条数。过程中不能走过刚刚走过的边。 没有后面的条件就是模板题了我们可以先设$dp(i,j)$为走了$i$步到$j$点，而这个没有记录上一条边，就不行了刚开始想在状态记录前驱点，但是似乎不方便进行转移。。那么从边的角度来考虑，设$dp(i,j)$为走了$i$步到第$j$条边终点结束，将无向边变成两条有向边。那么转移$dp(i,j)=\sum dp(i-1,k), k,j$通过某点连接但是这个DP还是会TLE这个DP仔细想想可以满足矩阵乘法的要求，那么矩阵快速幂即可。 其实这里可以将边变成一些点。具体是如果一条边可以通过某个节点到另一条边，这两条边在新图中的点连一条边，这条边不能是一条无向边分化的有向边。那么这里就构造了一个新的图矩阵，这个新图满足了上述条件，在原图中走$k$步相当于在新图中走$k-1$步，那么矩阵快速幂即可。这个新图矩阵和前面的优化一样，所以是本质一样的算法，一个从 优化 DP 角度，一个从 Floyd 角度 知识点：1、前向星存图 $en$ 从 $-1$ 开始2、前向星判合法用 i&gt;=13、图上边 DP4、边转点 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL MO = 45989; const LL MAXN = 125; LL n, m, t, A, B, en, hd[MAXN]; struct edge {LL u, v, nxt;} ed[MAXN * 2]; struct matrix { LL a[MAXN][MAXN]; matrix() {ms(a, 0);} }whw; void ins(LL u, LL v) {ed[++en] = (edge){u, v, hd[u]}, hd[u] = en;} matrix mul(matrix a, matrix b) { matrix ret; for (LL i = 0; i &lt;= en; ++i) for (LL j = 0; j &lt;= en; ++j) for (LL k = 0; k &lt;= en; ++k) ret.a[i][j] = (ret.a[i][j] + (a.a[i][k] * b.a[k][j])) % MO; return ret; } matrix ksm(matrix a, LL b) { matrix ans, bs = a; int fl = 0; while (b) { if (b &amp; 1) { if (fl) ans = mul(ans, bs); else fl = 1, ans = bs; } bs = mul(bs, bs); b &gt;&gt;= 1; } return ans; } void clean() { en = -1, ms(hd, -1); } int solve() { scanf(&quot;%lld%lld%lld%lld%lld&quot;, &amp;n, &amp;m, &amp;t, &amp;A, &amp;B); ++A, ++B; clean(); for (LL u, v, i = 1; i &lt;= m; ++i) scanf(&quot;%lld%lld&quot;, &amp;u, &amp;v), ins(++u, ++v), ins(v, u); for (LL i = 0; i &lt;= en; ++i) for (LL j = 0; j &lt;= en; ++j) if (i != j &amp;&amp; i != (j ^ 1) &amp;&amp; ed[i].v == ed[j].u) whw.a[i][j] = 1; whw = ksm(whw, t - 1ll); LL ans = 0ll; for (LL i = hd[A]; i &gt;= 0; i = ed[i].nxt) { for (LL j = hd[B]; j &gt;= 0; j = ed[j].nxt) { ans = (ans + whw.a[i][j ^ 1]) % MO; } } printf(&quot;%lld\n&quot;, ans); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>计数DP</tag>
        <tag>Bzoj</tag>
        <tag>矩阵</tag>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1706」「usaco2007 Nov」relays 奶牛接力跑 (矩阵快速幂+图上DP+离散化/倍增Floyd)]]></title>
    <url>%2Fbzoj1706%2F</url>
    <content type="text"><![CDATA[BZOJ 1706Luogu P2886无向连通图，求$S$到$E$经过$k$条边的最短路 矩阵经典问题，看这里 图中DP：设$dp(i,x)$为走了$i$步在$x$点位置，则转移$dp(i,x)=\sum dp(i-1, y)+w(y, x)$，其中$(x,y) \in E$同上面不好算。我们定义$dp(k,i,j)$为$i$到$j$经过$k$个点(走$k$步)的最短路。则$$dp(k,i,j)=min(dp(k-1,i,k)+dp(k-1,k,j))$$压掉第一维，则$dp(i,j)=min(dp(i,k)+dp(k,j))$我们发现和上面式子很像，那么我们可以试图修改一下矩阵乘法定义如下 $$C[i,j]=min(A[i,k]+B[k,i])$$ 易推导结合律。可以用矩阵快速幂加速。 其实这也体现出 Floyd 的倍增思想。相当于对一个图做几次 Floyd 就是走了几步。矩阵快速幂就是倍增的过程。这题在图上DP思想实际上就是分层图思想，每一步对应一张新图。与 NOIP2017Day1T3 有点像 知识点：1、图上的 DP2、矩阵快速幂(乘法)运用(修改)3、矩阵快速幂的矩阵大小不要太大，尽可能离散化4、倍增 Floyd 思想。5、矩阵乘法修改后单位矩阵记得改 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 100 + 10; struct matrix { int a[MAXN][MAXN]; matrix() {ms(a, 60);} }whw; int n, k, m, s, e, G[MAXN][MAXN], num[1005], sz; int gt(int x) {return num[x] ? num[x] : num[x] = ++sz;} matrix mul(matrix a, matrix b) { matrix ret; for (int i = 1; i &lt;= sz; ++i) { // A i 行 for (int j = 1; j &lt;= sz; ++j) { // B j 列 for (int l = 1; l &lt;= sz; ++l) { // foreach ret.a[i][j] = min(ret.a[i][j], a.a[i][l] + b.a[l][j]); } } } return ret; } matrix ksm(matrix a, int b) { matrix ans, bs = a; int fl = 0; while (b) { if (b &amp; 1) { if (fl) ans = mul(ans, bs); else fl = 1, ans = bs; } bs = mul(bs, bs); b &gt;&gt;= 1; } return ans; } void clean() { ms(num, 0), sz = 0, ms(G, 0); } int solve() { scanf(&quot;%d%d%d%d&quot;, &amp;k, &amp;m, &amp;s, &amp;e); n = 1000; clean(); for (int w, x, y, i = 1; i &lt;= m; ++i) { scanf(&quot;%d%d%d&quot;, &amp;w, &amp;x, &amp;y); x = gt(x), y = gt(y); whw.a[x][y] = G[x][y] = w; whw.a[y][x] = G[y][x] = w; } whw = ksm(whw, k); printf(&quot;%d\n&quot;, whw.a[gt(s)][gt(e)]); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>Bzoj</tag>
        <tag>最短路</tag>
        <tag>矩阵</tag>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1588」营业额统计 & 「Bzoj 1208」宠物收养所 (set/Splay/链表+离线)]]></title>
    <url>%2Fbzoj1588%261208%2F</url>
    <content type="text"><![CDATA[BZOJ 1588题意：求$\sum_{i=1}^n min_{1 \leq j \leq i}(|a_i-a_j|)$ BZOJ 1208题意：找比某数差别最小的数。 第一个我一开始想写桶然后每次循环 $i$ 桶上下找最近有值，但是绝对被卡。然后发现这个中间的空间都浪费了，其实绝对值差最小(两数差别最小)就是找前驱后继，用 set 维护即可。 这题也是平衡树题，由于查询的东西有限，写 set 记得 1208 要模 链表离线做法：将原数组排序，然后弄成一个链表。记录原数组每个位置的数在现在链表的哪个位置。从后往前扫一遍，类似前面的能找到前驱后继，然后处理完删除本点。 知识点：1、链表判合法要同时判表头表尾1588: #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL ZINF = 100000000000ll; LL n, a[50000]; set&lt;LL &gt; s; void clean() { } int solve() { scanf(&quot;%lld&quot;, &amp;n); for (LL i = 1; i &lt;= n; ++i) scanf(&quot;%lld&quot;, &amp;a[i]); clean(); s.insert(ZINF), s.insert(-ZINF); LL ans = a[1]; s.insert(a[1]); for (LL i = 2; i &lt;= n; ++i) { set&lt;LL &gt;::iterator it1 = s.lower_bound(a[i]); set&lt;LL &gt;::iterator it2 = it1; --it2; LL tmp = ZINF; if (*it1 != ZINF &amp;&amp; *it1 != -ZINF) tmp = min(tmp, *it1 - a[i]); if (*it2 != ZINF &amp;&amp; *it2 != -ZINF) tmp = min(tmp, a[i] - *it2); s.insert(a[i]), ans += tmp; } printf(&quot;%lld\n&quot;, ans); return 0; } } int main() { flyinthesky::solve(); return 0; } 链表： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;utility&gt; #include&lt;set&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 40000; pair&lt;int, int &gt; a[MAXN]; int n, b[MAXN]; int tot, l[MAXN + 5], r[MAXN + 5], val[MAXN + 5], h, t; void ins(int pos, int v) { ++tot, l[tot] = pos, r[tot] = r[pos], val[tot] = v; l[r[pos]] = tot; r[pos] = tot; } void del(int pos) { l[r[pos]] = l[pos], r[l[pos]] = r[pos]; } void clean() { tot = 2, h = 1, t = 2; r[h] = t, l[t] = h; } int solve() { clean(); scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i].fir), a[i].sec = i; int gg = a[1].fir; sort(a + 1, a + 1 + n); for (int i = 1; i &lt;= n; ++i) b[a[i].sec] = i + 2; for (int i = 1; i &lt;= n; ++i) ins(i + 2 - 1, a[i].fir); int ans = 0; for (int i = n; i &gt; 1; --i) { int tmp = 2000000000; if (l[b[i]] != h &amp;&amp; l[b[i]] != t) tmp = min(tmp, abs(val[l[b[i]]] - val[b[i]])); if (r[b[i]] != t &amp;&amp; l[b[i]] != h) tmp = min(tmp, abs(val[r[b[i]]] - val[b[i]])); ans += tmp; del(b[i]); } printf(&quot;%d\n&quot;, ans + gg); return 0; } } int main() { flyinthesky::solve(); return 0; } 1208: #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #include&lt;set&gt; #define LL long long #define db double #define ms(i, j) memset(i, j, sizeof i) using namespace std; namespace flyinthesky { const LL ZINF = 1000000000000ll, MO = 1000000; LL n, ans; set&lt;LL &gt; peo, dg; void clean() { } int solve() { scanf(&quot;%lld&quot;, &amp;n); // %I64d %I64d %I64d %I64d %I64d %I64d %I64d %I64d %I64d clean(); peo.insert(ZINF), peo.insert(-ZINF); dg.insert(ZINF), dg.insert(-ZINF); ans = 0ll; for (LL a, b, i = 1; i &lt;= n; ++i) { // cerr &lt;&lt; &quot;???&quot; &lt;&lt; ans &lt;&lt; endl; scanf(&quot;%lld%lld&quot;, &amp;a, &amp;b); // %I64d %I64d %I64d %I64d %I64d %I64d %I64d %I64d %I64d if (a == 0) { if ((LL)peo.size() &gt; 2ll) { set&lt;LL &gt;::iterator it2, it = peo.lower_bound(b); it2 = it; --it2; LL tmp = ZINF; if (*it != ZINF &amp;&amp; *it != -ZINF) { if (tmp &gt; *it - b) { tmp = *it - b; } } if (*it2 != ZINF &amp;&amp; *it2 != -ZINF) { if (tmp &gt;= b - *it2) { tmp = b - *it2; peo.erase(it2), ans = (ans + tmp) % MO; continue ; } } peo.erase(it), ans = (ans + tmp) % MO; } else dg.insert(b); } else { if ((LL)dg.size() &gt; 2ll) { set&lt;LL &gt;::iterator it2, it = dg.lower_bound(b); it2 = it; --it2; LL tmp = ZINF; //cerr &lt;&lt; &quot;HHH&quot; &lt;&lt; *it &lt;&lt; &quot; &quot; &lt;&lt; *it2 &lt;&lt; endl; if (*it != ZINF &amp;&amp; *it != -ZINF) { if (tmp &gt; *it - b) { tmp = *it - b; } } if (*it2 != ZINF &amp;&amp; *it2 != -ZINF) { if (tmp &gt;= b - *it2) { tmp = b - *it2; dg.erase(it2), ans = (ans + tmp) % MO; continue ; } } dg.erase(it), ans = (ans + tmp) % MO; //cerr &lt;&lt; &quot;FUCK\n&quot;; } else peo.insert(b); } } printf(&quot;%lld\n&quot;, (ans + MO) % MO);// %I64d %I64d %I64d %I64d %I64d %I64d %I64d %I64d %I64d return 0; } }; int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>离线</tag>
        <tag>链表</tag>
        <tag>Splay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单变量微积分 学习笔记]]></title>
    <url>%2Fsz%E5%8D%95%E5%8F%98%E9%87%8F%E5%BE%AE%E7%A7%AF%E5%88%86%2F</url>
    <content type="text"><![CDATA[本文是本网站的总结 微积分定理中值定理中值定理：函数$y=f(x)$满足： $f(x)$在$[a,b]$上连续 $f(x)$在$(a,b)$上可导那么在$(a,b)$上，至少存在一个点$c$，使得$$\begin{equation}f’(c)=\frac{f(b)-f(a)}{b-a}\end{equation}$$或$$\begin{equation}f(b)-f(a)=f’(c)(b-a)\end{equation}$$ 与此相关的是函数的增减性和导数的关系。 极值定理极值定理：若$y=f(x)$在$[a,b]$上有定义且连续，则在$[a,b]$上存在点$c,d$，使得$f(c)\geq f(x)\geq f(d), x \in [a, b]$ 与此相关的是函数的极值和导数的关系。 介值定理介值定理：如果在$[a,b]$上$y=f(x)$有定义且连续，那么函数值都在$f(a)$和$f(b)$之间；也就是说，如果$K$是$f(a)$和$f(b)$之间的任何一个数，那么在$(a,b)$内至少存在一点$c$，使得$f(c)=K$。 与此相关的是函数根存在定理，即勘根定理 隐函数定义如果方程$F(x,y)=0$能确定$y$是$x$的函数，那么称这种方式表示的函数是隐函数。 求导将$y$看成$x$的函数，对整个式子求导即可。例$$x^2+y^2+2x=0$$两边求导，得$$2x+2yy’+2=0$$即$$y’=\frac{-x-1}{y}$$ 求导应用1、对二次曲线方程求导2、对显函数两边求$\log$降幂后求导 高阶导数$$y^{(n)}=(-1)^nn!x^{-(n+1)}$$ 牛顿迭代求根$$x_2=x_1-\frac{f(x_1)}{f’(x_1)}$$如此进行下去直到无定义为止。 微分切线逼近$$\begin{equation}f(x+dx)\cong f(x)+dy\end{equation}$$其中$dy=f’(x)dx$，即$$\begin{equation}f(x+dx)\cong f(x)+f’(x)dx\end{equation}$$ 积分不定积分$$\int f(x)dx=F(x)$$ 幂函数积分：$$\begin{equation}\int x^ndx=\frac{x^{n+1}}{n+1},\quad n\neq -1\end{equation}$$ 复合函数$$\begin{equation}\int [f(x)^n]f’(x)dx=\frac{[f(x)]^{n+1}}{n+1},\quad n\neq -1\end{equation}$$ 运算法则$$\begin{equation}\int cf(x)dx=c\int f(x)dx\end{equation}$$ $$\begin{equation}\int [f(x)+g(x)]dx=\int f(x)dx+\int g(x)dx\end{equation}$$]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>算法笔记</tag>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小表示法 学习笔记]]></title>
    <url>%2Fsz%E6%9C%80%E5%B0%8F%E8%A1%A8%E7%A4%BA%E6%B3%95%2F</url>
    <content type="text"><![CDATA[模板及讲解最小表示法是什么最小表示法就是说我们有一个字符串$S$，然后将其首尾相连之后找到一个$|S|$长的子串使得字典序最小。这个最小表示法可以用来看两个字符串是否同构，也就是两个字符串是否可以通过环变换互相转换。 解法对于环的问题，我们可以断环成链，也就是将序列复制一遍放在后面，然后在$[1,n]$范围内为起点$|S|$长的子串都是环上的某种序列。 如果要判断是否同构，可以将一个字符串 Hash，然后再将断环以后的字符串 Hash，在$[1,n]$范围内找起点为$|S|$长的子串，求出Hash值比较即可。 同构也可以用最小表示法来解。也就是说两个不同字符串，如果他们同构，那么他们一定最小表示法一样。 最小表示法求法O(n^2)最小表示法有个明显的$O(n^2)$做法，即两个指针$i,j$指向$0,1$，然后枚举判断，如果当前某个值$s_{i+k} &gt; s_{j+k}$，那么$i$不那么优，使$i++$，小于情况类似。等于直接$k++$这样在极端情况bbbbba下会退化到$O(n^2)$，我们可以尝试优化。 O(n)我们发现如果存在$s_{i+k} &gt; s_{j+k}$，那么$s[i,i+k]$开头的都不会是最小表示法的开头了。因为$s[i,i+k]=s[j,j+k]$，所以从$s[i,i+k]$开头的串都会经过这里。如$i=1,j=4,k=2$时aacaab此时$s_{i+k} &gt; s_{j+k}$，即aac 小于 aab那么$s[i,i+k]$开头的都会遇到c大于b，然后肯定不是答案 所以当出现这种情况时，直接$i+=k$，小于时类似 例题Bzoj 2882Lougu 求$|S|$的最小表示法。 代码： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { int n, a[300000 + 5]; void clean() { } int solve() { scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; ++i) scanf(&quot;%d&quot;, &amp;a[i]); clean(); int i = 0, j = 1, k = 0; while (i &lt; n &amp;&amp; j &lt; n &amp;&amp; k &lt; n) { int t = a[(i + k) % n] - a[(j + k) % n]; if (!t) ++k; else { if (t &gt; 0) i += k + 1; else j += k + 1; if (i == j) ++j; // 不要同一个比较 k = 0; // 记得清零 } } int gg = min(i, j); for (int i = gg; i &lt;= gg + n - 1; ++i) printf(&quot;%d &quot;, a[i % n]); return 0; } } int main() { flyinthesky::solve(); return 0; } 写时注意： 1、不要忘了清空$k$2、不要忘在$i, j$相同时将$j$移动 Bzoj 1398 求$S，T$是否同构。 用最小表示法或者Hash即可。 常见题型]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>算法笔记</tag>
        <tag>最小表示法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1076E(DFS+离线+线段树)]]></title>
    <url>%2FCodeforces1076D%2F</url>
    <content type="text"><![CDATA[Codeforces 1076E题意：$m$次修改，$(v,k,x)$代表将$v$节点之下$k$层的节点全都加$x$，最后统一查询。即输出每个节点的值。 这题没有修改，并且询问只有最后一个，所以考虑离线。我们发现这题就是子树+层次的题目，那么自然想到 DFS 序 或者 DFS 处理。层次可以存每层DFS序，但是这样做没什么思路，我们不妨纵向看 (BFS 序相同的为序列的一个元素)然后对于子树的问题，DFS子树型，即当前 DFS 只处理当前子树。那么这一种修改操作就是修改当前情况下层次序列$[dep,dep+d]$的值，那么我们修改后继续处理子树。然后如果这个子树全部处理完了，那么我们就回退。这些修改回退操作可以写一个区间修改单点查值的数据结构。显然差分 BIT 好写。但是我这里还是脑残写了个线段树。 知识点：1、层次可以纵向看2、DFS 可以做到只处理当前子树情况 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 300000 + 5; #define lc (o &lt;&lt; 1) #define rc (o &lt;&lt; 1 | 1) #define M ((l + r) &gt;&gt; 1) LL sumv[MAXN * 4], lazy[MAXN * 4]; void pushup(int o) {sumv[o] = sumv[lc] + sumv[rc];} void pushdown(int o, int len) { if (len == 1) return ; if (lazy[o]) { lazy[lc] += lazy[o], lazy[rc] += lazy[o]; sumv[lc] += lazy[o] * (LL)(len - len / 2), sumv[rc] += lazy[o] * (LL)(len / 2); lazy[o] = 0; } } void build(int o, int l, int r) { if (l == r) return ; sumv[o] = 0; build(lc, l, M), build(rc, M + 1, r); pushup(o); } void update(int o, int l, int r, int x, int y, LL v) { pushdown(o, r - l + 1); if (x &lt;= l &amp;&amp; r &lt;= y) { sumv[o] += v * (LL)(r - l + 1); lazy[o] += v; return ; } if (x &lt;= M) update(lc, l, M, x, y, v); if (M &lt; y) update(rc, M + 1, r, x, y, v); pushup(o); } LL query(int o, int l, int r, int p) { pushdown(o, r - l + 1); if (l == r) return sumv[o]; if (p &lt;= M) return query(lc, l, M, p); else return query(rc, M + 1, r, p); } int n, m; vector&lt;int &gt; G[MAXN]; vector&lt;pair&lt;int, int &gt; &gt; lx[MAXN]; LL ans[MAXN]; void dfs(int u, int fa, int dep) { for (int i = 0; i &lt; (int)lx[u].size(); ++i) update(1, 1, n, dep, min(dep + lx[u][i].first, n), (LL)lx[u][i].second); ans[u] = query(1, 1, n, dep); for (int i = 0; i &lt; (int)G[u].size(); ++i) { int v = G[u][i]; if (v != fa) dfs(v, u, dep + 1); } for (int i = 0; i &lt; (int)lx[u].size(); ++i) update(1, 1, n, dep, min(dep + lx[u][i].first, n), (LL)-lx[u][i].second); } void clean() { ms(ans, 0); } int solve() { scanf(&quot;%d&quot;, &amp;n); clean(); for (int x, y, i = 1; i &lt; n; ++i) scanf(&quot;%d%d&quot;, &amp;x, &amp;y), G[x].push_back(y), G[y].push_back(x); build(1, 1, n); scanf(&quot;%d&quot;, &amp;m); for (int v, d, x, i = 1; i &lt;= m; ++i) { scanf(&quot;%d%d%d&quot;, &amp;v, &amp;d, &amp;x); lx[v].push_back(make_pair(d, x)); } dfs(1, 0, 1); for (int i = 1; i &lt;= n; ++i) printf(&quot;%lld &quot;, ans[i]); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>离线</tag>
        <tag>线段树</tag>
        <tag>Codeforces</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[莫比乌斯反演 学习笔记]]></title>
    <url>%2Fsz%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%2F</url>
    <content type="text"><![CDATA[模板及讲解整数分块 求 $\sum_{i=1}^n \lfloor \frac ni \rfloor$。 显然可以暴力$O(n)$求。但是这里可以$O(\sqrt n)$ 求。 结论：对于所有的 $\lfloor \frac ni \rfloor$ 都是一段连续的块，并且块的端点可以被枚举。假设当前在 $i$ 处，那么 $\lfloor \frac ni \rfloor$的最后一个值在$\lfloor \frac{n}{\lfloor \frac ni \rfloor} \rfloor$ 证明：设$\lfloor \frac ni \rfloor = \lfloor \frac n{i’} \rfloor=k$，并且$i’$为最大的位置。设$i+d=i’$，$n=ik+p,n=(i+d)k+p’$可得$p’=p-dk$，则$d_{max}= \lfloor \frac pk \rfloor$那么$i’=i+d_{max}$$$=i+ \left \lfloor \frac pk \right \rfloor=i+\left\lfloor \frac {n\%i}{\left\lfloor \frac ni \right\rfloor} \right\rfloor=\left\lfloor i+ \frac {n\%i}{\left\lfloor \frac ni \right\rfloor} \right\rfloor=\left\lfloor \frac {i \cdot \left\lfloor \frac ni \right\rfloor}{\left\lfloor \frac ni \right\rfloor}+ \left\lfloor \frac {n\%i}{\left\lfloor \frac ni \right\rfloor} \right \rfloor \right\rfloor$$ $$= \left\lfloor \frac {i \cdot \left\lfloor \frac ni \right\rfloor+n-\left\lfloor \frac ni \right\rfloor \cdot i}{\left\lfloor \frac ni \right\rfloor} \right\rfloor= \left\lfloor \frac {n}{\left\lfloor \frac ni \right\rfloor} \right\rfloor$$ 得证。易得$\lfloor \frac ni \rfloor$取值不超过$2\sqrt n$ 个，所以复杂度为$O(\sqrt n)$。 例题：Bzoj 1968 LL l = 1, r, ans = 0ll; while (l &lt;= n) { r = (n / (n / l)); ans += (r - l + 1ll) * (n / l); l = r + 1ll; } Bzoj 1257 给出 $n, k$，求$\sum_{i=1}^n k \mod i$ $k \mod i= k -i \cdot \lfloor \frac ki \rfloor$，则$\sum_{i=1}^n k \mod i= \sum_{i=1}^n k -i \cdot \lfloor \frac ki \rfloor=nk-\sum^{n}_{i=1} i \cdot \lfloor \frac ki \rfloor$ 发现右边是整除分块的形式，所以加一个等差数列求和公式计算即可。注意此题要判断一下$n,k$的大小。复杂度$O(\sqrt n)$ LL ans = 0ll, l = 1, r; if (n &gt; k) ans += (n - k) * k, n = k; ans += n * k; while (l &lt;= n) { r = min(n, (k / (k / l))); ans -= (l + r) * (r - l + 1ll) / 2ll * (k / l); l = r + 1ll; } 此题有升级版,Blog，$T(T \leq 10^6)$组询问$n(n \leq 10^6)$。此时用整除分块会炸。考虑$i \cdot \lfloor \frac ki \rfloor$的意义就是因数和。所以线性筛因数和即可。预处理前缀和后$O(1)$ 处理询问。 线性筛积性函数线性筛积性函数考虑两个第一个是$f(p), p$为质数是的取值怎么$O(1)$算第二个是$f(p^x), p$为质数是的取值怎么$O(1)$算，也就是说我们需要从$f(p^x)$转到$f(p^{x+1})$怎么求 第一个：在某数为质数时需要$O(1)$算出函数值第二个：线性筛是用最小质因数去筛数，所以对于被筛的数在$p|i$时只需要考虑$f(p^x)$转到$f(p^{x+1})$怎么求而$gcd(i,p)=1$时利用积性函数性质进行求解即可。 莫比乌斯函数若 $i=p_1^{a_1}p_2^{a_2}\cdots p_k^{a_k}$，那么有莫比乌斯函数 $$\mu(i)=\begin{cases}1&amp;,i=1 \\(-1)^k&amp;,\forall a_k=1 \\0&amp;,\exists a_k\gt1\end{cases}$$ 性质1、莫比乌斯函数是积性函数 $μ(a)μ(b)=μ(ab),a⊥b$ 运用此性质可以线性筛莫比乌斯函数。 2 $$\sum_{d\mid n}\mu(d) = [n = 1]​$$ 证明：(二项式定理) 设$n$有$k$种因子。则 $$\sum_{d\mid n}\mu(d)=\sum_{i=0}^kC^i_k(-1)^i1^{k-r}=[n=1]$$ 线性筛莫比乌斯函数时间复杂度 $ O(n) $。有更优秀的杜教筛。 mu[1] = 1, vis[1] = 1; // mu[1] = 1 for (int i = 2; i &lt;= n; ++i) { if (!vis[i]) pri[++tot] = i, mu[i] = -1; // 奇数个 mu[i] = -1 for (int j = 1; j &lt;= tot &amp;&amp; (LL)i * (LL)pri[j] &lt;= (LL)n; ++j) { vis[i * pri[j]] = 1; if (i % pri[j] == 0) { mu[i * pri[j]] = 0; // 一个质因子多个 mu[i] = 0 break; } else mu[i * pri[j]] = -mu[i]; // 积性函数 } } 莫比乌斯反演定义$g(n)$和$f(n)$是定义在非负整数集合上的两个函数 1、当$$g(n)=\sum_{d|n}f(d)$$ 那么有莫比乌斯反演 $$f(n)=\sum_{d|n}\mu(d)g(\frac{n}{d})$$ 2、当$g(i)=\sum^{\frac ni}_{d=1}f(d \cdot i)$ 那么有莫比乌斯反演 $$f(i)=\sum_{d=1}^{\frac ni}g(d \cdot i)\mu(d)$$ 证明$$\sum_{d|n}\mu(d)g(\frac{n}{d})=\sum_{d|n}\mu(d)\sum_{i|\frac{n}{d}}f(i)=\sum_{i|n}f(i)\sum_{d|\frac{n}{i}}\mu(d)=f(n)$$ 证明都是用将 $\mu(k)$ 提后然后根据性质1判断。 变形欧拉函数变形$$\varphi(n)=\sum_{i=1}^n[\gcd(i,n)=1]=\sum_{i=1}^n\sum_{k\mid i,k\mid n}\mu(k)=\sum_{k\mid n}\mu(k)\lfloor\frac nk\rfloor$$ 运用求 $\gcd = k$ 的个数例题：Bzoj 2301题意：给定$a, b, c, d, k$, 求$$\sum_{i=a}^{b} \sum_{j=c}^{d} [\gcd(i,j)=k]$$ (下面默认$n \leq m$, 不满足则交换)解：我们可以将答案分成几个部分求解，然后$ans=f(b,d)-f(a-1,d)-f(b,c-1)+f(a-1,c-1)$依题意设出$f(k)$为$gcd(i,j)=k$的个数$(1 \leq i \leq n, 1 \leq j \leq n)$但是这个并不好求，看见两个求和符号，我们可以想到用莫比乌斯反演来求解。显然用变形后的两个式子，我们就可以设$g(k)$为$k|gcd(i,j)$的个数$(1 \leq i \leq n, 1 \leq j \leq n)$$g(k)$非常好算，$g(k)=\lfloor \frac n{k} \rfloor \lfloor \frac m{k} \rfloor$而显然$g(k)=\sum_{d=1}^{\lfloor \frac nk \rfloor} f(ki)$那么可以莫比乌斯反演$$f(k)=\sum_{d=1}^{\lfloor \frac nk \rfloor} \mu(d) \lfloor \frac n{kd} \rfloor \lfloor \frac m{kd} \rfloor$$换元$\lfloor \frac nk \rfloor$，整除分块即可。 注意有$n,m$的整除分块是取两者最小值，复杂度也是有保证的。 求 $\gcd(i,j)$ 的和例题：Bzoj 2005题意：给定$n,m$，求$$\sum_{i=1}^n\sum_{j=1}^m \gcd(i,j)$$ 按照套路反演以后得到 $$\sum_{d=1}^n d \sum_{i=1}^{\lfloor \frac nd \rfloor} \mu(i) \lfloor \frac n{di} \rfloor \lfloor \frac m{di}\rfloor$$ 然后我们设$T=di​$，则 $$\sum_{T=1}^n \lfloor \frac nT \rfloor \lfloor \frac mT \rfloor \sum_{d|T} \mu(d) \lfloor \frac Tk \rfloor$$ 设$h(T)=\sum_{d|T} \mu(d) \lfloor \frac Tk \rfloor$，则可以线性筛。 也可以发现这就是欧拉函数，直接筛欧拉函数即可。 求 $\gcd(i,j)^k$ 的和例题：BZOJ 4407题意：给定$n,m,k$，求$$\sum_{i=1}^n\sum_{j=1}^m \gcd(i,j)^k \mod (10^9+7)$$ 按照套路反演以后得到 $$\sum_{d=1}^n d^k \sum_{i=1}^{\lfloor \frac nd \rfloor} \mu(i) \lfloor \frac n{di} \rfloor \lfloor \frac m{di}\rfloor$$ 此时我们发现可以分块套分块达到复杂度$O(n)$单次询问。但是还是不够，那么继续变形 设$T=di$，则 $$\sum_{T=1}^n \lfloor \frac nT \rfloor \lfloor \frac mT \rfloor \sum_{d|T} d^k \mu(\frac Td)$$ 设$f(T)=\sum_{d|T}d^k \mu(\frac Td)$，发现$d^k$和$\mu(k)$都是积性函数，所以乘积也是积性函数，所以我们可以线性筛$O(n)$算这个积性函数值。 如何线性筛？线性筛积性函数考虑两个第一个是$f(p), p$为质数时的取值怎么$O(1)$算第二个是$f(p^x), p$为质数时的取值怎么$O(1)$算，也就是说我们需要从$f(p^x)$转到$f(p^{x+1})$怎么求 考虑将$T$质因数分解，那么对于每个$p_i$ $$f(p_i^{x_i})=\sum_{d|p_i^{x_i}}d^k\mu(\frac{p_i^{x_i}}d)$$ 因为有$\mu$的存在，只需要考虑$d=p_i^{x_i}$和$d=p_i^{x_i-1}$的情况，则原式化为 $$f(p_i^{x_i})=\mu(p_i) \cdot p_i^{k(x_i-1)} + \mu(1) \cdot p_i^{x_ik}$$ 即 $$f(p_i^{x_i}) = p_i^{x_ik} - p_i^{k(x_i-1)}$$ $$f(p_i^{x_i}) = p_i^{k(x_i-1)}(p_i^k-1)$$ 这个式子可以方便解决$f(p^x), p$为质数时的取值 对于第一个，$f(p)=\mu(1) \cdot p^k + \mu(p) \cdot 1^k=p^k-1$ 那么这样就可以线筛了。 求 $\operatorname{lcm}(i,j)$ 的和例题：BZOJ 2154题意：给定$n, m$，求$$\sum_{i=1}^n \sum_{j=1}^m \operatorname{lcm}(i, j)$$ 化为$\gcd$式子$$\sum_{d=1}^n d \sum_{i=1}^{n}\sum_{j=1}^{m}\frac{ij}{\gcd(i,j)} \\\sum_{d=1}^n d \sum_{i=1}^{\lfloor \frac nd \rfloor}\sum_{j=1}^{\lfloor \frac md \rfloor}ij \cdot [\gcd(i,j)=1]$$设$$f(n,m)=\sum_{i=1}^n \sum_{j=1}^m ij \cdot [\gcd(i,j)=1] \\=\sum_{d=1}^n \sum_{d|i} \sum_{d|j} \mu(d) \cdot d^2 \sum_{i=1}^{\lfloor \frac nd \rfloor}\sum_{j=1}^{\lfloor \frac md \rfloor}ij$$设 (两个等差数列相乘)$$g(n,m)=\sum_{i=1}^n \sum_{j=1}^m ij =\frac{n(n+1)}{2} \times \frac{m(m+1)}{2}$$则$$f(n,m)=\sum_{d=1}^n \mu(d) \cdot d^2 \cdot g(\lfloor \frac nd \rfloor, \lfloor \frac md \rfloor)$$即原式为$$\sum_{d=1}^m d \cdot f(\lfloor \frac nd \rfloor, \lfloor \frac md \rfloor)$$ 计算$f(n,m)$时整除分块，计算答案时整除分块，时间复杂度$O(n+m)$ 求$f(gcd(i,j))$的和例题：BZOJ 3529题意：给定多组$n,m,a$，设$d_1(n)$为$n$约数和，求$$\sum_{i=1}^n \sum_{j=1}^m d_1(\gcd(i, j))$$并且满足$d_1(\gcd(i, j)) \leq a$ 不考虑$a$的限制，枚举约数$$\sum_{d=1}^n \sum_{i=1}^n \sum_{j=1}^m d_1(d)[gcd(i,j)=d])$$发现$d_1(d)$与$i,j$无关，移到前面$$\sum_{d=1}^n d_1(d) \sum_{i=1}^n \sum_{j=1}^m [gcd(i,j)=d])$$将后面用反演套路化简，得$$\sum_{d=1}^n d_1(d) \sum_{k=1}^{\lfloor \frac nd \rfloor} \mu(k) \lfloor \frac n{kd} \rfloor \lfloor \frac m{kd} \rfloor$$设$T=kd$，则$$\sum_{T=1}^n \lfloor \frac nT \rfloor \lfloor \frac mT \rfloor \sum_{d|T}d_1(d) \mu(\frac Td)$$如果没有$a$的限制，则线性筛后面的函数即可。考虑$a$的限制。只有$d_1(x) \leq a$的才会有贡献。所以将$d_1(x)$从小到大排序，将询问离线后按$a$从小到大排序每次按照$a$的单增补齐到$a$，补齐即枚举$x$的倍数进行增加。维护一个单调修改区间查值的数据结构，用树状数组维护之。时间复杂度：$O(n\log ^2 n + q \sqrt n \log n)$ 总结莫比乌斯反演一般是1、两个求和符号2、用反演公式设出与所求的那个函数符合的函数，然后导出基本式子3、用技巧(换元、内层外移、观察、莫比乌斯函数容斥性等)来化简式子4、最后的答案整除分块，必要时将与外层枚举变量无关的式子证明是积性函数来线性筛，无法证明则打表验证，重点关注质数，质数的幂的值 莫比乌斯反演的套路1、换元，比如设$T=kd$2、内层外移 (换元后、枚举约数$\Leftrightarrow$直接枚举)3、设新函数线性筛/反演/处理：比如设$h(T)=\sum_{d|T} \mu(d) \lfloor \frac nk \rfloor$4、观察法：一般是观察$\mu$的取值造成的影响5、化布尔式为$\mu$式子 (例子：$[n=1] \Leftrightarrow \sum_{d|n} \mu(d)$)6、构造$[\gcd(i,j)=k]$反演 Dirichlet 卷积常见的完全积性函数1、$\epsilon(x)$：Dirichlet卷积的乘法单位元，完全积性。$\epsilon(x) = [x = 1]$2、$I(n)$：恒等函数，完全积性。$I(n)=1$3、$id(n)$：单位函数，完全积性。$id(n)=n$4、$id^k(n)$：幂函数，完全积性。$id^k(n)=n^k$ 定义数论函数$f$和$g$的Dirichlet卷积定义为$$(f∗g)(n)=\sum_{d|n}f(d) g(\frac nd)$$ 满足交换律、结合律、分配律，证明此处略去。 性质1、如果 $f$ 和 $g$ 均为积性函数，那么 $f∗g$ 一定也为积性函数。 2、任何数论函数$f$卷上$I$代表$\sum\limits_{d|n} f(d)$，卷上$id$代表$\sum\limits_{d|n} f(d) \cdot \frac di $，$id^k$类似 3、任何数论函数$f$卷上$\epsilon$还是原函数$f$，所以就验证了$\epsilon$是单位元。 4、$\mu * I = \epsilon$ 根据$\sum \limits_{d|n} {\mu(d)} = [n =1]$即可证明。 5、$\varphi * I = id$ 根据$\sum \limits_{d | n} {\varphi(d) = n}$即可证明。 6、$\varphi = id * \mu$ ($\mu$与$\varphi$关系) 由$\varphi * I = id$，两边卷$\mu$$$\varphi * I * \mu = id * \mu$$则$$\varphi = id * \mu$$ 7、$\frac{\varphi(n)}{n} = \sum \limits_{d | n} {\frac{\mu(d)}{d}}$ ($\mu$与$\varphi$关系) 由$\varphi = id * \mu$$$\varphi(n) = \sum \limits_{d | n} {\mu(d) \times \frac{n}{d}}$$将两边同时除以 $n$$$\frac{\varphi(n)}{n} = \sum \limits_{d | n} {\frac{\mu(d)}{d}}$$ 证明莫比乌斯反演根据定义$$f = g * I$$两边卷上$\mu$$$f * \mu = g * I * \mu$$由$\mu * I = \epsilon$$$f * \mu = g * \epsilon \\g = f * \mu$$得证。 杜教筛模板题：Bzoj 3944 杜教筛Sum给定一个正整数$n$，求$$\sum_{i=1}^n \varphi(i) \\\sum_{i=1}^n \mu(i)$$ 设$f$是我们要求前缀和的积性函数，设$S(n)=\sum_{i=1}^n$找一个$g$卷上$f$$$\sum_{i=1}^n (f * g)(n)$$Dirichlet 卷积定义转化$$\sum_{i=1}^n \sum_{d|i} f(d)g(\frac id)$$先枚举$d$$$\sum_{d=1}^n g(d) \sum_{i=1}^{\lfloor \frac nd \rfloor} f(i)$$用$S$改写$$\sum_{d=1}^n g(d)S(\lfloor \frac nd \rfloor)$$考虑 (两个前缀和相减)$$g(1)S(n)=\sum_{i=1}^n(f * g)(n) - \sum_{i=2}^n g(i)S(\lfloor \frac ni \rfloor)$$那么找到一个合适的$g$，能快速求出$f * g$的前缀和，则就能递归+整除分块快速求出$f$的前缀和。 这个算法复杂度$O(n^{\frac 34})$预处理出前$m=n^{\frac 23}$个前缀和，可以使复杂度变为$O(n^{\frac 23})$(这个也不是限定死的，可以尽量往大开) 1、求$\sum\limits_{i=1}^n \varphi(i)$ 由$\varphi * I = id$，得$$\sum_{i=1}^n \varphi(i)=\frac{n(n + 1)}{2}-\sum_{i=2}^n \varphi(\lfloor \frac ni \rfloor)$$ 2、求$\sum\limits_{i=1}^n \mu(i)$ 由$\mu * I = \epsilon$，得$$\sum_{i=1}^n \mu(i)=1-\sum_{i=2}^n \mu(\lfloor \frac ni \rfloor)$$ #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;map&gt; #include&lt;string&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL N = 5000000; int vis[N + 5], pri[400000 + 5], tot; LL mu[N + 5], phi[N + 5]; LL T; map&lt;int, LL &gt; ansphi, ansmu; LL getphi(int n) { if (n &lt;= N) return phi[n]; if (ansphi[n]) return ansphi[n]; LL ret = 1ll * n * (n + 1ll) / 2ll; int l = 2; while (l &lt;= n) { int r = n / (n / l); ret -= 1ll * (r - l + 1ll) * getphi(n / l); if (r == 2147483647) break ; l = r + 1; } return ansphi[n] = ret; } LL getmu(int n) { if (n &lt;= N) return mu[n]; if (ansmu[n]) return ansmu[n]; LL ret = 1ll; // ²»ÊÇ [n=1] int l = 2; while (l &lt;= n) { int r = n / (n / l); ret -= 1ll * (r - l + 1ll) * getmu(n / l); if (r == 2147483647) break ; l = r + 1; } return ansmu[n] = ret; } void init() { ms(vis, 0), ms(pri, 0), tot = 0, ms(mu, 0), ms(phi, 0); mu[1] = 1, phi[1] = 1; for (int i = 2; i &lt;= N; ++i) { if (!vis[i]) pri[++tot] = i, mu[i] = -1, phi[i] = i - 1; for (int j = 1; j &lt;= tot &amp;&amp; 1ll * pri[j] * i &lt;= 1ll * N; ++j) { vis[pri[j] * i] = 1; if (i % pri[j] == 0) { mu[i * pri[j]] = 0; phi[i * pri[j]] = phi[i] * pri[j]; break ; } else mu[i * pri[j]] = mu[i] * mu[pri[j]], phi[i * pri[j]] = phi[i] * phi[pri[j]]; } } for (int i = 2; i &lt;= N; ++i) mu[i] += mu[i - 1], phi[i] += phi[i - 1]; } void clean() { } int solve() { clean(); scanf(&quot;%lld&quot;, &amp;T); while (T--) { LL n; scanf(&quot;%lld&quot;, &amp;n); printf(&quot;%lld %lld\n&quot;, getphi(n), getmu(n)); } return 0; } } int main() { flyinthesky::init(); flyinthesky::solve(); return 0; } 常见题型]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>杜教筛</tag>
        <tag>Dirichlet卷积</tag>
        <tag>算法笔记</tag>
        <tag>整除分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欧拉函数 学习笔记]]></title>
    <url>%2Fsz%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[模板及讲解定义定义 $\varphi(n)$为$[1,n]$与$n$互质的数的个数。 (1) 给出n的唯一分解式 $n = p^{a1}_1p^{a2}_2p^{a3}_3…p^{ak}_k$ , 求出 $1，2，3…，n$ 中与n互素的数的个数 公式(容斥原理)： $$\varphi(n) = \sum_{S\subseteq(p_1,p_2,…p_k)}(-1)^\left|s\right|\frac {n}{\prod_{p_i\subseteq S}p_i}$$可变形为：$$\varphi(n) = n(1-\frac1{p_1})(1-\frac1{p_2})…(1-\frac1{p_k})$$即可在$O(k)$的时间复杂度算出$\varphi(n)$ (2) 不给出唯一分解式求$\varphi(n)$：(Poj 2407) 根据变形的公式，可以枚举所有小于$\sqrt n$的因子，然后之后把他”除干净”(为了提取唯一分解式之中的$p_i$)即可 int phi(int n) { int ans = n;//ans为最后的答案 int m = (int)sqrt(n + 0.5); for (int i = 2; i &lt;= m; i++) if (n % i == 0) { ans = ans / i * (i - 1);//ans初值为n，因为1-(1/p) = (p-1)/p，由变形后公式可得 while (n % i == 0) n /= i;//除干净 } if (n &gt; 1) ans = ans / n * (n - 1); return ans; } 性质1、当$n$为质数时，$\varphi (n)=n-1$2、$\varphi (n)$是积性函数3、若$n=p^k$，则$\varphi(n)=p^k-p^{k-1}=(p-1)p^{k-1}$4、$$n=\sum_{d|n} \varphi(d)$$5、$$\varphi(n)=\sum_{i=1}^n[\gcd(i,n)=1]=\sum_{i=1}^n\sum_{k\mid i,k\mid n}\mu(k)=\sum_{k\mid n}\mu(k)\lfloor\frac nk\rfloor$$6、$p$为质数，$p,i$不互质，$\varphi(p \cdot i)=\varphi(i) \cdot p$ (线性筛)7、小于$n$与$n$互质的数和为$\frac{n \cdot \varphi(n)}{2}$ 线性筛欧拉函数复杂度$O(n)$ phi[1] = 1, vis[1] = 1; for (int i = 2; i &lt;= n; ++i) { if (!vis[i]) pri[++tot] = i, phi[i] = i - 1; for (int j = 1; j &lt;= tot &amp;&amp; (LL)i * (LL)pri[j] &lt;= (LL)n; ++j) { vis[i * pri[j]] = 1; if (i % pri[j] == 0) { phi[i * pri[j]] = phi[i] * pri[j]; break; } else phi[i * pri[j]] = phi[i] * phi[pri[j]]; } } 运用$gcd, lcm$相关求和问题本问题必须$n=m$才行，不相等就必须用莫比乌斯反演。 例题1：Uva 11426题意：求$$\sum_{i=1}^n \sum_{j=i+1}^n gcd(i,j)$$ 解： $$\sum_{i=1}^n \sum_{j=i+1}^n gcd(i,j)=\sum_{i=1}^n \sum_{j=1}^{i-1} gcd(i,j)​$$ $$\sum_{d=1} d\sum_{i=1}^n \sum_{j=1}^{i-1} [gcd(i,j)=d]=\sum_{d=1} d\sum_{i=1}^n \sum_{j=1}^{i-1}[gcd(i,j)=1]=\sum_{d=1} d\sum_{i=1}^{\lfloor \frac nd \rfloor} \sum_{j=1}^{i-1}[gcd(i,j)=1]=\sum_{d=1} d\sum_{i=1}^{\lfloor \frac nd \rfloor} \varphi(i)$$ 设$sum\varphi(k)=\sum_{i=1}^{k} \varphi(i), sumx(k)=\sum_{i=1}^k i$ 则答案为 $$\sum_{d=1}^n d \cdot sum\varphi(\lfloor \frac nd \rfloor)$$ 线性筛欧拉函数，然后整除分块即可。 while (scanf(&quot;%lld&quot;, &amp;n) == 1 &amp;&amp; n) { LL l = 1, r, ans = 0ll; while (l &lt;= n) { r = n / (n / l); ans += sumphi[n / l] * (sumx[r] - sumx[l - 1]); l = r + 1; } printf(&quot;%lld\n&quot;, ans); } 例题1扩展1：Luogu 2398 题意：求$$\sum_{i=1}^n \sum_{j=1}^n gcd(i,j)$$ 解：答案为前面的答案乘二加上$sumx(n)$。因为相当于对称一个答案，然后加上$gcd(i,i)$的答案。 例题1扩展2：Bzoj 2818 题意：求(其中$p_i​$为素数)$$\sum_{i=1}^n \sum_{j=1}^n [gcd(i,j)=p_i]$$ 先求$j \in [1, i-1]$再对称求解。 $$\sum_{p_k} \sum_{i=1}^n \sum_{j=1}^{i-1} [gcd(i,j)=p_k]=\sum_{p_k} \sum_{i=1}^{\lfloor \frac {n}{p_k} \rfloor} \sum_{j=1}^{i-1} [gcd(i,j)=1]=\sum_{p_k} \sum_{i=1}^{\lfloor \frac {n}{p_k} \rfloor} \varphi(\lfloor \frac {n}{p_k} \rfloor)=\sum_{p_k}sum\varphi(\lfloor \frac {n}{p_k} \rfloor)$$ 枚举质数然后直接求即可。 LL ans = 0; for (LL i = 1; i &lt;= tot; ++i) ans += sumphi[n / pri[i]]; printf(&quot;%lld\n&quot;, ans * 2 + tot); 总结 一般满足一点，$n=m$，否则要用莫比乌斯反演去求解； 化简这种式子一般要求$j \in [1,i-1]$，方便提公因数后$\varphi$的转化。若要求全部的，加上对称的答案，然后再加上$gcd(i,i)$这样的答案。 类似莫比乌斯反演，最后的式子可以用整除分块去优化；将判断式修改为$[gcd(i,j)=1]​$方便$\varphi​$的出现 (莫比乌斯反演左边不一定是$gcd​$) 常见题型]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>欧拉函数</tag>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 2018 11月月赛 T3(状压DP+组合数学)]]></title>
    <url>%2FLuogu201811%E6%9C%88%E8%B5%9BT3%2F</url>
    <content type="text"><![CDATA[题意：要从$000…000$变换到$111…111$, 变换过程可以选择一个全$0$子集来改成$1$。然后每次改完出现什么状态如果在给出的状态中，就加上这个权。求所有可能变换的总权。 容易想到$dp(S)$为到$S$状态的总权，则$dp(S)=\sum dp(S-sonS)+num(S) \cdot w(S)$，其中$w$为状态权，$num$为有多少个状态转移到这个状态。枚举子集即可。时间复杂度$O(\sum C^k_n \cdot 2^k)$，由二项式定理，时间复杂度为$O(3^n)$ 上面能拿$ 70 $分。我们想想这个$ dp $其实没必要。我们可以考虑每个状态对答案的贡献。发现每个$1​$数量相等状态其实本质一样。所以我们只需要考虑不同数量$1​$的贡献即可。显然若设$cnt(x)​$为$x​$个$1​$的贡献次数，则 $$cnt(x)=\sum^{i-1}_{i=0} C^i_x cnt(x-i)$$ 然后答案是$ans=\sum cnt(num_1)cnt(num_0)$, $num_x$即为二进制下为$x$的个数。 1、状态转移画成 DAG 更好。状态不画多个点，这样方便找规律。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #define LL long long #define db double #define ms(i, j) memset(i, j, sizeof i) using namespace std; namespace flyinthesky { const LL MO = 998244353; int n, m, st[(1 &lt;&lt; 20) + 5]; LL dp[(1 &lt;&lt; 20) + 5], num[(1 &lt;&lt; 20) + 5]; char s[25]; void clean() { ms(num, 0); } int solve() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); clean(); for (int v, i = 1; i &lt;= m; ++i) { scanf(&quot;%s%d&quot;, s, &amp;v); int tmp = 0; for (int j = 0; j &lt; n; ++j) tmp += (1 &lt;&lt; (n - j - 1)) * (s[j] - &#39;0&#39;); st[tmp] = v; } // for (int i = 0; i &lt; (1 &lt;&lt; n); ++i) cerr &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; st[i] &lt;&lt; endl; dp[0] = st[0], num[0] = 1ll; for (int S = 1; S &lt; (1 &lt;&lt; n); ++S) { for (int i = S; i; i = (i - 1) &amp; S) { dp[S] = (dp[S] + dp[S - i]) % MO; num[S] = (num[S] + num[S - i]) % MO; } dp[S] = (dp[S] + num[S] * st[S]) % MO; } printf(&quot;%lld\n&quot;, dp[(1 &lt;&lt; n) - 1]); return 0; } }; int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>计数DP</tag>
        <tag>状压DP</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1000D(DP+组合数)]]></title>
    <url>%2FCodeforces1000D%2F</url>
    <content type="text"><![CDATA[Codeforces 1000D题意：定义一个序列是“好的”：第一个数字$a_0$为序列长度$+1$。定义一个序列的子序列是“好的”：这个子序列能分割成几个“好的”序列。给出一个序列，求“好的”子序列的数目。 一开始我想把所有这种序列全部求出来然后组合。。具体就是每个点往后面找，用组合数。然后再合并。但是行不通。。这题直接从后面往前面 DP 即可。设$dp(i)$为$[i, n]$“好的”子序列个数。我们这样定下来了左端点，再枚举一个右端点$j$，使当前所有“好的”序列最后一个是$j$，那么和$j$后面已经算完的 DP 值乘起来即可。 可能直接初值$dp(n+1)=1$，转移$dp(i)=dp(j) \times C(j-i-1,a_i)$更好？ 知识点：1、DP 从后往前 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;set&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 1000 + 5; const LL MO = 998244353; int n, a[MAXN]; LL c[MAXN][MAXN], dp[MAXN], suf[MAXN]; void clean() { ms(dp, 0), ms(suf, 0); } int solve() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i]); clean(); for (int i = 0; i &lt;= n; ++i) c[i][0] = c[i][i] = 1; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt; i; ++j) c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % MO; // for (int i = 0; i &lt;= n; ++i, cerr &lt;&lt; endl) // for (int j = 0; j &lt;= i; ++j) cerr &lt;&lt; c[i][j] &lt;&lt; &quot; &quot;; LL ans = 0ll; for (int i = n; i; --i) { if (a[i] &gt; 0 &amp;&amp; i + a[i] &lt;= n) for (int j = i + a[i]; j &lt;= n; ++j) { dp[i] = (dp[i] + (c[j - i - 1][a[i] - 1] * (1ll + suf[j + 1])) % MO) % MO; } suf[i] = (suf[i + 1] + dp[i]) % MO; } cout &lt;&lt; suf[1]; return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>计数DP</tag>
        <tag>Codeforces</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 3991」「SDOI2015」寻宝游戏 (路径并 + 倍增LCA + 虚树)]]></title>
    <url>%2Fbzoj3991%2F</url>
    <content type="text"><![CDATA[BZOJ 3991题意：$n$个点的树，$m$次变动使得某个点有宝物或没宝物，询问每次变动后集齐所有宝物并返回原点的最小距离。转化成有根树，求路径的并。路径并就是 DFS 序下两个点之间的距离和。并且最后一个点和第一个点的距离要贡献。那么这题相当于插入一个点然后找到他 DFS 序前面后面的点加上贡献即可。删除同理。注意如果是插在中间要减掉前面后面的距离，因为这个贡献在点加入后已经不存在了，留下来会重复。对于这个的维护，我们用 set 就行了。set的一个小Trick: set 里加入 $INF$ 和 $-INF$，然后就不用考虑是不是set.begin()或者set.end()了。知识点1、 set 里加入 $INF$ 和 $-INF$，然后就不用考虑是不是set.begin()或者set.end()了2、树上路径 / 边 - 端点LCA相关3、路径并，路径交 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 100000 + 5, LOGS = 20; const LL INF = 10000000; struct edge { int v, w, nxt; } ed[MAXN * 2]; int n, m, en, hd[MAXN], pre[MAXN][25], dfn[MAXN], dep[MAXN], sz, vis[MAXN]; LL dis[MAXN]; struct node { int u; bool operator &lt; (const node &amp;rhs) const {return dfn[u] &lt; dfn[rhs.u];} }; set&lt;node &gt; s; void ins(int u, int v, int w) {ed[++en] = (edge){v, w, hd[u]}, hd[u] = en;} void dfs(int u, int fa) { pre[u][0] = fa, dfn[u] = ++sz, dep[u] = dep[fa] + 1; for (int i = 1; i &lt;= LOGS; ++i) pre[u][i] = pre[pre[u][i - 1]][i - 1]; for (int i = hd[u]; i &gt; 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (e.v != fa) dis[e.v] = dis[u] + (LL)e.w, dfs(e.v, u); } } int LCA(int a, int b) { if (dep[a] &lt; dep[b]) swap(a, b); for (int i = LOGS; i &gt;= 0; i--) if (dep[pre[a][i]] &gt;= dep[b]) a = pre[a][i]; if (a == b) return a; for (int i = LOGS; i &gt;= 0; i--) if (pre[a][i] != pre[b][i]) a = pre[a][i], b = pre[b][i]; return pre[a][0]; } LL dist(int x, int y) {return dis[x] + dis[y] - 2ll * dis[LCA(x, y)];} void clean() { sz = en = 0, ms(hd, -1), ms(vis, 0); } int solve() { clean(); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int x, y, w, i = 1; i &lt; n; ++i) { scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;w); ins(x, y, w), ins(y, x, w); } dfs(1, 0); dfn[n + 1] = -INF, dfn[n + 2] = INF; s.insert((node){n + 1}), s.insert((node){n + 2}); LL ans = 0ll; while (m--) { int t; scanf(&quot;%d&quot;, &amp;t); if (vis[t]) { set&lt;node &gt;::iterator nxt = s.upper_bound((node){t}); set&lt;node &gt;::iterator pre = s.lower_bound((node){t}); // 注意 set 里有 t --pre; int fl = 0; if (pre-&gt;u &lt;= n &amp;&amp; pre-&gt;u != t) { ans -= dist(pre-&gt;u, t); ++fl; } if (nxt-&gt;u &lt;= n) { ans -= dist(nxt-&gt;u, t); ++fl; } if (fl == 2) ans += dist(nxt-&gt;u, pre-&gt;u); s.erase(s.find((node){t})); } else { set&lt;node &gt;::iterator nxt = s.upper_bound((node){t}); set&lt;node &gt;::iterator pre = --nxt; ++nxt; int fl = 0; if (pre-&gt;u &lt;= n &amp;&amp; pre-&gt;u != t) { ans += dist(pre-&gt;u, t); ++fl; } if (nxt-&gt;u &lt;= n) { ans += dist(nxt-&gt;u, t); ++fl; } if (fl == 2) ans -= dist(nxt-&gt;u, pre-&gt;u); s.insert((node){t}); } vis[t] ^= 1; set&lt;node &gt;::iterator it = s.upper_bound((node){n + 1}); set&lt;node &gt;::iterator it2 = s.lower_bound((node){n + 2}); it2--; LL gg = dist(it-&gt;u, it2-&gt;u); printf(&quot;%lld\n&quot;, ans + gg); } return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>STL</tag>
        <tag>倍增</tag>
        <tag>虚树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1304」「CQOI2009」叶子的染色 (树形DP)]]></title>
    <url>%2Fbzoj1304%2F</url>
    <content type="text"><![CDATA[BZOJ 1304题意：见上。 显然随意找一个不是叶子的点当根即可。设$dp(u, 0/1/2)$为$u$点填$0,1$色，不填($2$)的满足最小值。然后转移即可。具体看代码。 怎么那么水的 DP 我没想出来…… #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;set&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 10000 + 5, ZINF = 2000000000; struct edge {int v, nxt; } ed[MAXN * 2]; int m, n, c[MAXN], dp[MAXN][3], en, hd[MAXN]; void ins(int u, int v) {ed[++en] = (edge){v, hd[u]}, hd[u] = en;} void dfs(int u, int fa) { if (u &lt;= n) { dp[u][c[u]] = 1, dp[u][2] = dp[u][c[u] ^ 1] = ZINF; return ; } else dp[u][1] = 1, dp[u][0] = 1, dp[u][2] = 0; for (int i = hd[u]; i &gt; 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (e.v != fa) { dfs(e.v, u); dp[u][0] += min(dp[e.v][0] - 1, dp[e.v][1]); dp[u][1] += min(dp[e.v][1] - 1, dp[e.v][0]); dp[u][2] += min(min(dp[e.v][0], dp[e.v][1]), dp[e.v][2]); } } } void clean() { en = 0, ms(hd, -1); } int solve() { scanf(&quot;%d%d&quot;, &amp;m, &amp;n); if (m == 1) return printf(&quot;1\n&quot;), 0; for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;c[i]); clean(); for (int u, v, i = 1; i &lt; m; ++i) scanf(&quot;%d%d&quot;, &amp;u, &amp;v), ins(u, v), ins(v, u); dfs(n + 1, 0); //cerr &lt;&lt; &quot;???&quot; &lt;&lt; dp[n + 1][0] &lt;&lt; &quot; &quot; &lt;&lt; dp[n + 1][1] &lt;&lt; &quot; &quot; &lt;&lt; dp[n + 1][2] &lt;&lt; endl; printf(&quot;%d\n&quot;, min(min(dp[n + 1][0], dp[n + 1][1]), dp[n + 1][2])); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 2632(0-1BFS + 网格图连边)]]></title>
    <url>%2Floj2632%2F</url>
    <content type="text"><![CDATA[Loj 2632题意：见上 网格图可以连边转图论问题。这里有$(n+1)(m+1)$个点，然后一个/就连这个对角的点，费用为0。还要补充另一个对角连边，费用为1。求$1$到$(n+1)(m+1)$的最短路即可。写$0-1BFS$. 知识点：1、0-1 BFS 写错了 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;map&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { struct edge {int v, w, nxt;} ed[500000 * 2 + 5]; deque&lt;int &gt; q; int n, m, en, hd[300000 + 5], dis[300000 + 5]; char s[505][505]; void ins(int u, int v, int w) {ed[++en] = (edge){v, w, hd[u]}, hd[u] = en;} void bfs() { for (int i = 1; i &lt;= (n + 1) * (m + 1); ++i) dis[i] = 1000000000; q.push_front(1), dis[1] = 0; while (!q.empty()) { int u = q.front(); q.pop_front(); for (int i = hd[u]; i &gt; 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (dis[e.v] &gt; dis[u] + e.w) { dis[e.v] = dis[u] + e.w; if (e.w == 0) q.push_front(e.v); else q.push_back(e.v); } } } } void clean() { en = 0, ms(hd, -1); } int solve() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); if ((n &amp; 1) != (m &amp; 1)) return printf(&quot;NO SOLUTION\n&quot;), 0; clean(); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%s&quot;, s[i] + 1); for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= m; ++j) { if (s[i][j] == &#39;\\&#39;) { ins((i - 1) * (m + 1) + j, i * (m + 1) + j + 1, 0); ins(i * (m + 1) + j + 1, (i - 1) * (m + 1) + j, 0); ins((i - 1) * (m + 1) + j + 1, i * (m + 1) + j, 1); ins(i * (m + 1) + j, (i - 1) * (m + 1) + j + 1, 1); } else { ins((i - 1) * (m + 1) + j, i * (m + 1) + j + 1, 1); ins(i * (m + 1) + j + 1, (i - 1) * (m + 1) + j, 1); ins((i - 1) * (m + 1) + j + 1, i * (m + 1) + j, 0); ins(i * (m + 1) + j, (i - 1) * (m + 1) + j + 1, 0); } } } /*for (int u = 1; u &lt;= (n + 1) * (m + 1); ++u) { cerr &lt;&lt; u &lt;&lt; &quot;: &quot;; for (int i = hd[u]; i &gt; 0; i = ed[i].nxt) { cerr &lt;&lt; ed[i].v &lt;&lt; &quot;(&quot; &lt;&lt; ed[i].w &lt;&lt; &quot;) &quot;; } cerr &lt;&lt; endl; }*/ bfs(); // for (int i = 1; i &lt;= (n + 1) * (m + 1); ++i) cerr &lt;&lt; &quot;???u=&quot; &lt;&lt; i &lt;&lt; &quot;: &quot; &lt;&lt; dis[i] &lt;&lt; endl; cout &lt;&lt; dis[(n + 1) * (m + 1)]; return 0; } } int main() { flyinthesky::solve(); return 0; } /* 3 3 \\\ \// \\/ */]]></content>
      <categories>
        <category>Loj</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>Loj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1068D(DP+前缀和优化)]]></title>
    <url>%2FCodeforces1068D%2F</url>
    <content type="text"><![CDATA[Codeforces 1068E题意：有一个长度为$n$的序列，满足对于所有的$a_x$， 与它相邻的两个元素$a_{x-1}$和$a_{x+1}$中至少有一 一个大于等于它，其中$a_1$和$a_n$当然只有一 个相邻元素，现在这个序列中有些数字被破坏了(标记为$-1$) ,问有多少种合法恢复方案(每个数字$∈[1,200]$) 计数统计方案问题 DP 没跑了。数据范围可以看出DP状态是$O(200n)$级别，我们设$dp(i,j)$为前$i$个数第$i$个数填$j$的方案数。发现无法处理满足条件。我们加一维 0/1 表示当前$i$不满足条件/满足条件。然后分情况讨论：现在在$(i, j)$1、从$dp(i-1,k,0)$转移：(1) 当$k &lt; j$时，$dp(i,j,0)=\sum dp(i-1,k,0)$(2) 当$k &gt; j$时，无满足情况(3) 当$k=j$时，$dp(i,j,1)+=dp(i-1,j,0)$2、从$dp(i-1,k,1)$转移：(1) 当$k &lt; j$时，$dp(i,j,0)=\sum dp(i-1,k,1)$(2) 当$k &gt; j$时，$dp(i,j,1)=\sum dp(i-1,k,1)$(3) 当$k=j$时，$dp(i,j,1)+=dp(i-1,j,1)$上面可以画简图来理解。和CF 1013E类似。 然后预处理$i=1$的值作为初值。对于这些求和，可以用前缀和后缀和优化。 知识点：1、大分类讨论DP，最好用数学那种思维来推公式 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL MO = 998244353; const int MAXN = 100000 + 5; int n, ai[MAXN]; LL dp[3][205][3], pre[205], suf[205]; void clean() { ms(suf, 0), ms(pre, 0), ms(dp, 0); } int solve() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;ai[i]); clean(); int cur = 1; if (ai[1] != -1) dp[cur ^ 1][ai[1]][0] = 1; else for (int i = 1; i &lt;= 200; ++i) dp[cur ^ 1][i][0] = 1; pre[0] = suf[201] = 0; for (int i = 1; i &lt;= 200; ++i) pre[i] = (pre[i - 1] + (dp[cur ^ 1][i][0] + dp[cur ^ 1][i][1]) % MO) % MO; for (int i = 200; i &gt;= 1; --i) suf[i] = (suf[i + 1] + dp[cur ^ 1][i][1]) % MO; for (int i = 2; i &lt;= n; ++i) { if (ai[i] == -1) { for (int j = 1; j &lt;= 200; ++j) { dp[cur][j][0] = pre[j - 1]; dp[cur][j][1] = suf[j + 1]; dp[cur][j][1] = (dp[cur][j][1] + dp[cur ^ 1][j][1]) % MO; dp[cur][j][1] = (dp[cur][j][1] + dp[cur ^ 1][j][0]) % MO; } } else { dp[cur][ai[i]][0] = pre[ai[i] - 1]; dp[cur][ai[i]][1] = suf[ai[i] + 1]; dp[cur][ai[i]][1] = (dp[cur][ai[i]][1] + dp[cur ^ 1][ai[i]][1]) % MO; dp[cur][ai[i]][1] = (dp[cur][ai[i]][1] + dp[cur ^ 1][ai[i]][0]) % MO; } cur ^= 1; pre[0] = suf[201] = 0; for (int j = 1; j &lt;= 200; ++j) pre[j] = (pre[j - 1] + (dp[cur ^ 1][j][0] + dp[cur ^ 1][j][1]) % MO) % MO; for (int j = 200; j &gt;= 1; --j) suf[j] = (suf[j + 1] + dp[cur ^ 1][j][1]) % MO; for (int j = 1; j &lt;= 200; ++j) dp[cur][j][0] = dp[cur][j][1] = 0; } LL ans = 0; if (ai[n] != -1) cout &lt;&lt; dp[cur ^ 1][ai[n]][1]; else { for (int i = 1; i &lt;= 200; ++i) ans = (ans + dp[cur ^ 1][i][1]) % MO; cout &lt;&lt; ans; } return 0; } } int main() { flyinthesky::solve(); return 0; } /* 3 -1 2 2 */]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>计数DP</tag>
        <tag>Codeforces</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1922」「Sdoi2010」大陆争霸 (最短路)]]></title>
    <url>%2Fbzoj1922%2F</url>
    <content type="text"><![CDATA[BZOJ 1922题意：见上有限制最短路维护$d_1i$数组为到达$i$点的最短时间，$d_2i$数组为$i$点能到的最短时间。实际到达时间为$max(d_1i, d_2i)$dij 堆中以$d_1i, d_2i$为序做小根堆，每次取出一个点然后更新连边的$d_1$值，更新他保护点的$d_2$值，注意每个点没有保护才能更新$d_2$值，否则让这个点保护数目减一。知识点1、dij 维护几个数组来求有限制最短路很好用 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 3005; const LL ZINF = 4223372036854775807ll; struct edge {int u, v, w, nxt;} ed[70000 + 5]; struct node { int u; LL dis; bool operator &lt; (const node &amp;b) const {return dis &gt; b.dis;} }; int n, m, en, hd[MAXN], num[MAXN], vis[MAXN]; LL d1[MAXN], d2[MAXN]; vector&lt;int &gt; ptc[MAXN]; priority_queue&lt;node &gt; q; void ins(int u, int v, int w) {ed[++en] = (edge){u, v, w, hd[u]}, hd[u] = en;} void dij() { for (int i = 0; i &lt;= n; ++i) vis[i] = 0, d1[i] = ZINF, d2[i] = 0; d1[1] = d2[1] = 0, q.push((node){1, 0}); while (!q.empty()) { node p = q.top(); q.pop(); if (vis[p.u]) continue ; vis[p.u] = 1; LL rl = max(d1[p.u], d2[p.u]); for (int i = hd[p.u]; i &gt; 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (rl + e.w &lt; d1[e.v]) { d1[e.v] = rl + e.w; LL tmp = max(d1[e.v], d2[e.v]); if (!num[e.v]) q.push((node){e.v, tmp}); } } for (int i = 0; i &lt; (int)ptc[p.u].size(); ++i) { int v = ptc[p.u][i]; d2[v] = max(d2[v], rl), --num[v]; if (!num[v]) q.push((node){v, max(d2[v], d1[v])}); } } } void clean() { en = 0, ms(hd, -1); } int solve() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); clean(); for (int u, v, w, i = 1; i &lt;= m; ++i) scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w), ins(u, v, w); for (int u = 1; u &lt;= n; ++u) { scanf(&quot;%d&quot;, &amp;num[u]); for (int v, i = 1; i &lt;= num[u]; ++i) scanf(&quot;%d&quot;, &amp;v), ptc[v].push_back(u); } dij(); printf(&quot;%lld\n&quot;, max(d1[n], d2[n]));////////////////////////////////// return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1043E(排序+数学+贡献)]]></title>
    <url>%2FCodeforces1043E%2F</url>
    <content type="text"><![CDATA[Codeforces 1043E题意：给出$n$个二元组$(x_i,y_i)$和一个边集$E$，求$\sum min(x_i+y_j, y_i+x_j)$, 其中$(i, j) \notin E$ 拆形如$\sum min(x_i+y_j, y_i+x_j)$的式子，设 $x_i+y_j \leq y_i+x_j$ ，则$x_i-y_i \leq x_j-y_j$，用$xi-yi$排序可以使得当$i \leq j$时$i$贡献$x_i$, $j$贡献$y_j$现在考虑没有边集的情况：所以我们枚举排序后的每个元素，对于他前面的元素，可以用前缀和算贡献；对于后面的元素，可以用后缀和算贡献。所以如果有边集，我们可以枚举这个点的边集然后删除这个点对贡献。输出答案即可 知识点：1、排序来解决一些分类讨论问题($max,min,|x|$)(数学上可能叫分段函数)，用排序谓词来满足单调情况的不等式恒成立($x_i+y_j \leq y_i+x_j$, 用$x_i-y_i$排序当$i \leq j$可以保持这个不等式成立)，要熟悉利用一些公式变形技巧2、特殊化思想：从简单到复杂情况：没有边集怎么做，有了怎么改3、当有顺序困难时，可以考虑一个排序消除顺序困难：NOIP2017Day1T3 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;vector&gt; #define LL long long #define db double #define ms(i, j) memset(i, j, sizeof i) using namespace std; namespace flyinthesky { const int MAXN = 300000 + 5; struct data { LL xi, yi, id; bool operator &lt; (const data &amp;a) const {return xi - yi &lt; a.xi - a.yi;} }p[MAXN]; int n, m, pos[MAXN]; LL pre_xi[MAXN], suf_yi[MAXN], ans[MAXN]; vector&lt;int &gt; G[MAXN]; void clean() { ms(ans, 0); } int solve() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%lld%lld&quot;, &amp;p[i].xi, &amp;p[i].yi), p[i].id = i; for (int u, v, i = 1; i &lt;= m; ++i) scanf(&quot;%d%d&quot;, &amp;u, &amp;v), G[u].push_back(v), G[v].push_back(u); clean(); sort(p + 1, p + 1 + n); //for (int i = 1; i &lt;= n; ++i) cerr &lt;&lt; &quot;???&quot; &lt;&lt; p[i].id &lt;&lt; endl; for (int i = 1; i &lt;= n; ++i) pos[p[i].id] = i; pre_xi[0] = suf_yi[n + 1] = 0; for (int i = 1; i &lt;= n; ++i) pre_xi[i] = pre_xi[i - 1] + p[i].xi; for (int i = n; i; --i) suf_yi[i] = suf_yi[i + 1] + p[i].yi; // for (int i = 1; i &lt;= n; ++i) cerr &lt;&lt; &quot;???&quot; &lt;&lt; pre_xi[i] &lt;&lt; endl; for (int i = 1; i &lt;= n; ++i) { int u = p[i].id; ans[u] = pre_xi[i - 1] + (LL)(i - 1) * p[i].yi; ans[u] += suf_yi[i + 1] + (LL)(n - i) * p[i].xi; for (int j = 0; j &lt; (int)G[u].size(); ++j) { int v = G[u][j]; if (pos[v] &lt; i) { ans[u] -= p[i].yi + p[pos[v]].xi; } else ans[u] -= p[i].xi + p[pos[v]].yi; } } for (int i = 1; i &lt;= n; ++i) printf(&quot;%lld &quot;, ans[i]); return 0; } }; int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>贡献</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1043D(二分+Hash / 尺取)]]></title>
    <url>%2FCodeforces1043D%2F</url>
    <content type="text"><![CDATA[Codeforces 1043D题意：求$m$个$n$长排列串的公共子串个数。 考虑排列，我们可以根据 LCS 转 LIS 排列做法的那种做法来记录一个串在另一个串中的位置。这里采用第一个串来作为标准之后，发现每个串有形如$i,i+1,i+2,i+3,…,i+k$的子串则说明这个子串和标准串是公共串。我们如果能找到所有串都存在这个子串，则说明这个串是一个答案。怎么找呢？我们可以枚举每一个$i \in [1,n]$的数来判断是否存在一个从$i$开始的串是所有串的公共子串。 这里可以用二分法来求，即固定$i$(在前面枚举，类似 CF 1073C)，然后二分右边边界。中间每个串用双 Hash 进行判断是否相等。 或者可以尺取法。计算一个从每一个数开始最多形成的合法$i,i+1,i+2,i+3,…,i+k$子串的长度$len_i$。每个串进行枚举，我们每次尺取一个合法子串$i,i+1,i+2,i+3,…,i+k$，更新$i$的答案，由于是所有串公共的，所以取交集，即用 min。然后最后答案为$\sum^{n}_{i=1} len_i$ 知识点：1、N，M看清楚2、字符串 Hash 同样适用于序列 Hash3、交集：(l max, r min) 并集：(l min, r max)4、排列记录一个数在另一个数的位置：CF 1043D，CF 1073B，LCS 转 LIS5、固定左端点二分区间结束位置：CF 1043D，CF 1073C //尺取法 //==========================Head files========================== #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;map&gt; #define LL long long #define db double #define mp make_pair #define pr pair&lt;int, int&gt; #define fir first #define sec second #define pb push_back #define ms(i, j) memset(i, j, sizeof i) using namespace std; //==========================Templates========================== inline int read() { int x = 0, f = 1; char c = getchar(); while(c &lt; &#39;0&#39; || c &gt; &#39;9&#39;){if (c == &#39;-&#39;) f = -1; c = getchar();} while(c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;){x = x * 10 + c - &#39;0&#39;; c = getchar();} return x * f; } inline LL readl() { LL x = 0, f = 1; char c = getchar(); while(c &lt; &#39;0&#39; || c &gt; &#39;9&#39;){if (c == &#39;-&#39;) f = -1; c = getchar();} while(c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;){x = x * 10 + c - &#39;0&#39;; c = getchar();} return x * f; } int power(int a, int b) { int ans = 1; while (b) { if(b &amp; 1) ans = ans * a; b &gt;&gt;= 1; a = a * a; } return ans; } int power_mod(int a, int b, int mod) { a %= mod; int ans = 1; while (b) { if(b &amp; 1) ans = (ans * a) % mod; b &gt;&gt;= 1, a = (a * a) % mod; } return ans; } LL powerl(LL a, LL b) { LL ans = 1ll; while (b) { if(b &amp; 1ll) ans = ans * a; b &gt;&gt;= 1ll;a = a * a; } return ans; } LL power_modl(LL a, LL b, LL mod) { a %= mod; LL ans = 1ll; while (b) { if(b &amp; 1ll) ans = (ans * a) % mod; b &gt;&gt;= 1ll, a = (a * a) % mod; } return ans; } LL gcdl(LL a, LL b) {return b == 0 ? a : gcdl(b, a % b);} LL abssl(LL a) {return a &gt; 0 ? a : -a;} int gcd(int a, int b) {return b == 0 ? a : gcd(b, a % b);} int abss(int a) {return a &gt; 0 ? a : -a;} //==========================Main body========================== #define LD &quot;%I64d&quot; #define D &quot;%d&quot; #define pt printf #define sn scanf #define pty printf(&quot;YES\n&quot;) #define ptn printf(&quot;NO\n&quot;) //==========================Code here========================== int n, m, ai[15][100005], gg[100005], pos[15][100005], whw[100005]; int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; ++i) for (int j = 1; j &lt;= n; ++j) scanf(&quot;%d&quot;, &amp;ai[i][j]); for (int i = 1; i &lt;= n; ++i) gg[ai[1][i]] = i, whw[i] = n; for (int i = 1; i &lt;= m; ++i) for (int j = 1; j &lt;= n; ++j) pos[i][j] = gg[ai[i][j]]; /*for (int i = 1; i &lt;= m; ++i, cerr &lt;&lt; endl) for (int j = 1; j &lt;= n; ++j) cerr &lt;&lt; pos[i][j] &lt;&lt; &quot; &quot;;*/ //for (int i = 1; i &lt;= n; ++i) cerr &lt;&lt; gg[i] &lt;&lt; &quot; &quot;; for (int i = 1; i &lt;= m; ++i) { int r = 1; for (int l = 1; l &lt;= n; ++l) { if (r &lt; l) ++r; while (r &lt;= n &amp;&amp; pos[i][r + 1] == pos[i][r] + 1) ++r; whw[pos[i][l]] = min(whw[pos[i][l]], pos[i][r]); } } // cerr &lt;&lt; &quot;??&quot; &lt;&lt; endl; // for (int i = 1; i &lt;= n; ++i) cerr &lt;&lt; whw[i] - i + 1 &lt;&lt; &quot; &quot;; LL ans = 0; for (int i = 1; i &lt;= n; ++i) ans += (LL)whw[i] - i + 1; cout &lt;&lt; ans; return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>二分</tag>
        <tag>Hash</tag>
        <tag>尺取法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1072D(贪心)]]></title>
    <url>%2FCodeforces1072D%2F</url>
    <content type="text"><![CDATA[Codeforces 1072D题意：题意给出一个 $ n × n $ 的矩阵，允许修改 $ k $ 次，求一条从$(1,1)$到$(n,n)$的路径。要求字典序最小 先处理每个坐标到起点是否能全改a(DP预处理到当前位置不改能经过多少个a)，能改就当前坐标改a然后就要在这个网格图上每一步都尽可能最小地走到终点。每一步枚举向下走了多少步，然后每次找到最优解标记一下所有最优解的位置，以便下一步找的时候能连起来找到最小的。有点分层图的思想。 知识点：1、算好复杂度再 $DFS$2、只向下 / 向右：(1)横、竖、每一步 (2)划线分层 (3) $DP$3、分层图思想 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;map&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { int n, k, dp[2005][2005], vis[2005][2005]; char s[2005][2005]; void clean() { ms(dp, 0), ms(vis, 0); } int solve() { cin &gt;&gt; n &gt;&gt; k; clean(); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%s&quot;, s[i] + 1); for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= n; ++j) { dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); dp[i][j] += (s[i][j] == &#39;a&#39;); if (i + j - 1 - dp[i][j] &lt;= k) s[i][j] = &#39;a&#39;; } } putchar(s[1][1]), vis[1][1] = 1; for (int i = 3; i &lt;= 2 * n; ++i) { char gg = &#39;z&#39;; for (int j = 1; j &lt; i; ++j) { if (j &gt; n || (i - j) &gt; n) continue ; if (!vis[j][i - j - 1] &amp;&amp; !vis[j - 1][i - j]) continue ; gg = min(gg, s[j][i - j]); } putchar(gg); for (int j = 1; j &lt; i; ++j) { if (j &gt; n || (i - j) &gt; n) continue ; if (!vis[j][i - j - 1] &amp;&amp; !vis[j - 1][i - j]) continue ; if (s[j][i - j] == gg) vis[j][i - j] = 1; } } return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1068E(树的直径 + 树的中心)]]></title>
    <url>%2FCodeforces1068E%2F</url>
    <content type="text"><![CDATA[Codeforces 1068E题意： $1 - multihedgehog$ 满足：是一棵树存在一个中心节点$u$与其它所有点相连包括中心节点在内，至少$4$个节点$2 - multihedgehog$ 刺猬图满足：是一棵树存在一个中心节点$u$与其它所有$1 - multihedgehog$的中心节点相连这个中心节点至少连接$3$个以上的$1 - multihedgehog$$k- multihedgehog$依次类推，给你一棵树，问你它是不是$k- multihedgehog$ 看见样例图第一感觉合法图直径都是等长并且经过最开始的那个根。。并且是直径的中点(直径奇数长图不合法，也就是树的中心)，所以求一下树的直径然后找到中点即可。从起点搜完直径终点后再从起点搜如果搜到终点则返回真，标记这些点，这些点在直径上，然后再枚举找到距离是直径一般而且在直径上的点，这个点就是树的中心。 注意特判问题1一个点的图不合法2直径奇数长不合法3直径不等于 $ 2k $ 不合法 知识点：1、思路写稍微详细一点(check:怎么做)，不要忘记一些判断2、直径的 dfs 想好再写 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;map&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 100000 + 5; int zjlen, ct, st, ed, n, k, dis[MAXN], vis[MAXN]; vector&lt;int&gt; G[MAXN]; void dfs(int u, int fa) { dis[u] = dis[fa] + 1; for (int i = 0; i &lt; (int)G[u].size(); ++i) { int v = G[u][i]; if (v != fa) dfs(v, u); } } int dfs2(int u, int fa) { if (u == ed) {vis[ed] = 1; return true;} for (int i = 0; i &lt; (int)G[u].size(); ++i) { int v = G[u][i]; if (v != fa) { if (dis[v] == dis[u] + 1) { int gg = dfs2(v, u); if (gg) {vis[u] = 1; return true;} } } } return false; } int check(int u, int fa, int dep) { int dg = 0; for (int i = 0; i &lt; (int)G[u].size(); ++i) { int v = G[u][i]; if (v != fa) ++dg; } if (dep == zjlen / 2) { if (dg != 0) return false; return true; } if (dg &lt; 3) return false; for (int i = 0; i &lt; (int)G[u].size(); ++i) { int v = G[u][i]; if (v != fa) { if (!check(v, u, dep + 1)) return false; } } return true; } void clean() { ms(vis, 0), ms(dis, 0); } int solve() { cin &gt;&gt; n &gt;&gt; k; if (n == 1) return printf(&quot;No\n&quot;), 0; clean(); for (int u, v, i = 1; i &lt; n; ++i) scanf(&quot;%d%d&quot;, &amp;u, &amp;v), G[u].push_back(v), G[v].push_back(u); dis[0] = 0, dfs(1, 0); st = 0; for (int i = 1; i &lt;= n; ++i) if (dis[i] &gt; dis[st]) st = i; ms(dis, 0), dfs(st, 0); ed = 0; for (int i = 1; i &lt;= n; ++i) if (dis[i] &gt; dis[ed]) ed = i; zjlen = dis[ed] - 1; if (zjlen % 2 == 1) return printf(&quot;No\n&quot;), 0; if (zjlen / 2 != k) return printf(&quot;No\n&quot;), 0; ct = 0; dfs2(st, 0); for (int i = 1; i &lt;= n; ++i) if (dis[i] - 1 == zjlen / 2 &amp;&amp; vis[i]) {ct = i; break;} if (check(ct, 0, 0)) return printf(&quot;Yes\n&quot;), 0; else return printf(&quot;No\n&quot;), 0; return 0; } } int main() { flyinthesky::solve(); return 0; } /* 7 2 1 2 2 5 2 6 2 7 1 3 1 4 14 3 1 4 2 4 3 4 4 13 10 5 11 5 12 5 14 5 5 13 6 7 8 6 13 6 9 6 */]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>树的直径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 10172(三进制状压DP)]]></title>
    <url>%2Floj10172%2F</url>
    <content type="text"><![CDATA[Loj 10172题意：给出一个矩阵，有一行涂上了已经颜色，有1 2 3三种颜色，求涂完能有多少种方案使得没有两个相邻的格子颜色是相同的。对于$k$行填色的限制，我们不妨把$k$行上下分开做，最后方案数乘一下即可。这个题目是很经典的网格图状压DP，不多说了。关键说说多进制状压的做法。这里先考虑三进制状压：我们相当于把一个整数当做三进制数来看，也就是说$(25)_{10}={221}_3$，我们就维护这个$221$。我们开一个数组sjc[状态][位]=位上的值 (0, 1, 2)，用来找一个状态每一个位上是什么这个数组可以用十进制转三进制的方法求得，具体看代码。然后注意本题要特判$k=1，k=n$，并且只有一行的情况。知识点：1、三进制状态压缩 DP2、数据检查要考虑只有一行一列的情况 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;map&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MO = 1000000; int n, m, k, klne[10], smax, sjz[300][10], st[300], cnt, dp[10000][300]; //sjc[状态][位]=位上的值 (0, 1, 2) //st[index]=可行状态, cnt为大小 //dp[i][j] 为前 i 行，i 行用 st[j]状态的方案数。 bool check(int i, int j) {// st[i] and st[j] for (int o = 1; o &lt;= m; ++o) if (sjz[st[i]][o] == sjz[st[j]][o]) return false; return true; } void clean() { ms(sjz, 0); } int solve() { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k); for (int i = 1; i &lt;= m; ++i) scanf(&quot;%d&quot;, &amp;klne[i]), --klne[i]; for (int i = 2; i &lt;= m; ++i) if (klne[i] == klne[i - 1]) return printf(&quot;0\n&quot;), 0; if (n == 1) return printf(&quot;1\n&quot;), 0; clean(); smax = 1; for (int i = 1; i &lt;= m; ++i) smax *= 3; for (int S = 0; S &lt; smax; ++S) { int tmp = S, ws = 1; while (1) { sjz[S][ws] = tmp % 3; tmp /= 3, ++ws; if (tmp == 0) break ; } }//求 sij 数组 // printf(&quot;smax=%d\n&quot;, smax); // for (int S = 0; S &lt; smax; ++S, puts(&quot;&quot;)) // for (int i = 1; i &lt;= 5; ++i) printf(&quot;%d&quot;, sjz[S][i]); for (int S = 0; S &lt; smax; ++S) { int fl = 0; for (int i = 2; i &lt;= m; ++i) { if (sjz[S][i] == sjz[S][i - 1]) { fl = 1; break; } } if (!fl) st[++cnt] = S; } // for (int j = 1; j &lt;= cnt; ++j, puts(&quot;&quot;)) // for (int i = 1; i &lt;= m; ++i) printf(&quot;%d&quot;, sjz[st[j]][i]); LL ans = 0; if (k != 1) { ms(dp, 0); for (int i = 1; i &lt;= cnt; ++i) { if (k == 2) { int fl = 1; for (int o = 1; o &lt;= m; ++o) if (sjz[st[i]][o] == klne[o]) {fl = 0; break;} if (!fl) continue ; } dp[1][i] = 1; } for (int hi = 1; hi &lt; k; ++hi) { for (int i = 1; i &lt;= cnt; ++i) { // i 行状态 if (hi == k - 1) { int fl = 1; for (int o = 1; o &lt;= m; ++o) if (sjz[st[i]][o] == klne[o]) {fl = 0; break;} if (!fl) continue ; } for (int j = 1; j &lt;= cnt; ++j) { // j 行状态 if (!check(i, j)) continue ; if (dp[hi - 1][j] == 0) continue ; dp[hi][i] = (dp[hi][i] + dp[hi - 1][j]) % MO; } } } for (int i = 1; i &lt;= cnt; ++i) ans = (ans + dp[k - 1][i]) % MO; // for (int i = 1; i &lt;= cnt; ++i) printf(&quot;%d\n&quot;, dp[k - 1][i]); if (k == n) return printf(&quot;%lld\n&quot;, ans), 0; } else ans = 1ll; ms(dp, 0); for (int i = 1; i &lt;= cnt; ++i) { int fl = 1; for (int o = 1; o &lt;= m; ++o) if (sjz[st[i]][o] == klne[o]) {fl = 0; break;} if (!fl) continue ; dp[k + 1][i] = 1; } for (int hi = k + 2; hi &lt;= n; ++hi) { for (int i = 1; i &lt;= cnt; ++i) { // i 行状态 for (int j = 1; j &lt;= cnt; ++j) { // j 行状态 if (!check(i, j)) continue ; if (dp[hi - 1][j] == 0) continue ; dp[hi][i] = (dp[hi][i] + dp[hi - 1][j]) % MO; } } } LL tmp = 0; for (int i = 1; i &lt;= cnt; ++i) tmp = (tmp + dp[n][i]) % MO; printf(&quot;%lld\n&quot;, (ans * tmp) % MO); return 0; } } int main() { flyinthesky::solve(); return 0; } /* 3 3 3 1 2 1 2 2 2 2 3 */]]></content>
      <categories>
        <category>Loj</category>
      </categories>
      <tags>
        <tag>计数DP</tag>
        <tag>计数原理</tag>
        <tag>状压DP</tag>
        <tag>Loj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 2423」「HAOI2010」最长公共子序列 (DP最长公共子序列)]]></title>
    <url>%2Fbzoj2423%2F</url>
    <content type="text"><![CDATA[BZOJ 2423题意：给定两个长度为$n, m$字符串, 求最长公共子序列长度和方案数$\mod 10^{8}$ $n,m\leq 5000$ 第一问太简单不再说，主要看第二问对于第二问，我们当前第一问的 DP 状态是 $ dp(i, j) $ 表示第一个串匹配到 $ i $，第二个串匹配到 $ j $ 的最长公共子序列。然后我们再加一个数组 $ g(i, j) $ 表示第一个串匹配到 $ i $，第二个串匹配到 $ j $ 的最长公共子序列方案数。对于这个数组的转移：当 $ a_i = b_j $ 时，方案数加上$ g(i-1,j-1) $ 如果当前的 DP 值等于 $ dp(i-1, j) $ 或 $ dp(i, j-1) $，那么加上这些方案数否则如果当前的 DP 值等于 $ dp(i-1, j) $ 或 $ dp(i, j-1) $，那么加上这些方案数。但是如果当前还等于 $ dp(i-1, j-1) $，说明 $ a_i , b_j $ 没做贡献，说明两个 LCS 均是从$i-1,j-1$的位置转移而来，减掉$ g(i-1,j-1) $即可。 知识点：1、看限制开数组，不要爆空间2、方案数可以用容斥的方法来求 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;map&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MO = 100000000, MAXN = 5000 + 5; int la, lb, dp[2][MAXN], g[2][MAXN]; char a[MAXN], b[MAXN]; void clean() { ms(dp, 0); } int solve() { scanf(&quot;%s%s&quot;, a + 1, b + 1); clean(); la = strlen(a + 1) - 1, lb = strlen(b + 1) - 1; int cur = 0; for (int i = 0; i &lt;= lb; ++i) g[cur ^ 1][i] = 1; for (int i = 1; i &lt;= la; ++i) { for (int j = 0; j &lt;= lb; ++j) dp[cur][j] = 0, g[cur][j] = 0; g[cur][0] = 1; for (int j = 1; j &lt;= lb; ++j) { dp[cur][j] = max(dp[cur ^ 1][j], dp[cur][j - 1]); if (a[i] == b[j]) { dp[cur][j] = dp[cur ^ 1][j - 1] + 1; g[cur][j] = g[cur ^ 1][j - 1]; if (dp[cur][j] == dp[cur ^ 1][j]) g[cur][j] = (g[cur][j] + g[cur ^ 1][j]) % MO; if (dp[cur][j] == dp[cur][j - 1]) g[cur][j] = (g[cur][j] + g[cur][j - 1]) % MO; } else { if (dp[cur][j] == dp[cur ^ 1][j]) g[cur][j] = (g[cur][j] + g[cur ^ 1][j]) % MO; if (dp[cur][j] == dp[cur][j - 1]) g[cur][j] = (g[cur][j] + g[cur][j - 1]) % MO; if (dp[cur][j] == dp[cur ^ 1][j - 1]) g[cur][j] = (g[cur][j] - g[cur ^ 1][j - 1] + MO) % MO; } } cur ^= 1; } printf(&quot;%d\n%d\n&quot;, dp[cur ^ 1][lb], g[cur ^ 1][lb]); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>计数DP</tag>
        <tag>Bzoj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LCS & LIS 学习笔记]]></title>
    <url>%2FszLISLCS%2F</url>
    <content type="text"><![CDATA[例题及讲解LIS最长上升子序列 (Longest Increasing Subsequence，LIS)，一个数列中最长的单调递增的子序列。 例如 1 2 5 8 8 2 9 的 LIS 为 1 2 5 8 9，长度为 5. 模板题：Hdu 1257 某国发展出一种导弹拦截系统，它的第一发炮弹能够到达任意的高度，以后每一发炮弹都不能超过前一发的高度，给你一个导弹依此飞来的高度序列，请帮助计算一下最少需要多少套拦截系统. $O(n^2)$ DP 解法设 $ dp(i) $ 为前 $ i $ 个数以 $ i $ 结尾的 LIS 长度。 则 $ dp(i) = max(dp(j)+1|1 \leq j &lt; i, a_j &lt; a_i) $， $ a_i $ 为原数列。 初始化 $ dp(i) = 1 $，因为此时为一个数的最长上升子序列 代码(未编译)： for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt; i; ++j) if (a[i] &gt; a[j]) dp[i] = max(dp[i], dp[j] + 1); 注意答案不是 $ dp(n) $，而是 $ max(dp(i)|1 \leq i \leq n) $ 此做法时间复杂度为 $ O(n^2) $. 对于 Hdu 1257 的解法，我们只需要求出序列的最长上升子序列即可，因为有几个上升子序列就说明要开多少套拦截系统。最长上升子序列中必然不可能两个数用一个系统。 $O(nlogn)$ 数据结构优化 DP 解法例题：Hdu 1950 $ T $ 组数据询问，每个询问包含一个 $ n $ 长序列，求 LIS。 ( $ n \leq 40000 $ ) 原状态不能快速求出 LIS，我们试着换状态。 设 $ dp(x) $ 为以 $ x $ 值结尾的 LIS 长度。 则每次顺序扫描，$ dp(a_i) = max(dp(x)|x &lt; a_i) $， $ a_i $ 为原序列 然后，我们观察 $ max(dp(x)|x &lt; a_i) $，发现这个可以开一个数据结构维护 $ a_i $ 的值域来 $ O(logn) $ 求解。 具体解法是，顺序扫描 $ a_i $ ，每次在数据结构中查询值域区间 $ [0, a_i) $ (有可能有的题目值域会出现负数，所有数加上一个大正数即可，适当调整左端点的值)的最大值 $ x $，然后直接转移 $ dp(a_i) = x + 1 $。之后再将数据结构中 $ a_i $ 的位置修改为 $ dp(a_i) $。 参考代码 (使用线段树维护区间最大值)： // 线段树维护区间最大值 int ans = 0; for (int i = 1; i &lt;= n; i++) { dp[a[i]] = query(1, 0, MAXN, 0, a[i]) + 1; ans = max(ans, dp[a[i]]); // 答案是所有的，不是一个 dp 值 update(1, 0, MAXN, a[i], dp[a[i]]); } 此做法时间复杂度为 $ O(nlogn) $. 当然这个做法可以用树状数组来替换，代码会更简洁一些. $O(nlogn)$ 贪心二分做法我们开一个数组 $ b $，当前长度为 $ len $。 然后我们顺序把 $a$ 数组(原序列)的数加入数组 $ b $ 如果当前 $ a_i &gt; b_{len}$，那么直接将 $ a_i $ 插入 $ b $, 即 $ b_{len + 1} = a_i$ 否则在 $ b $ 中找到一个数比 $ a_i $ 刚刚大一点的数，然后将这个位置用 $ a_i $ 替换掉。 此时 $ len $ 是 LCS 的长度。 假如我们有 2 5 4 8 3 4 5 这个序列，那么我们操作是 2 加入 $ b $, 此时 $ b = 2 $5 加入 $ b $, 此时 $ b = 2, 5 $4 加入 $ b $, 此时 $ b = 2, 4 $8 加入 $ b $, 此时 $ b = 2, 4, 8 $3 加入 $ b $, 此时 $ b = 2, 3, 8 $4 加入 $ b $, 此时 $ b = 2, 3, 4 $5 加入 $ b $, 此时 $ b = 2, 3, 4, 5 $ 此时 $ len = 4 $ 为 LIS 长度。 注意 $ b $ 不是 LIS， 为什么是对的呢？ 其实每次操作的 $ len $ 相当于当前找到的 LIS。每次如果当前数 $ a_i $ 比 $ b $ 中所有数都大，那么这个 $ a_i $ 可以对当前答案产生 $ 1 $ 的贡献。反之，就可以将这个数替换掉 $ b $ 中的某个数，使得 $ b $ 中的数保持单调递增但是整体尽量最小，以便于后面的数加入产生贡献。 参考代码 int n, a[40005], b[40005], len; void clean() { ms(b, 0), len = 0; } int solve() { scanf(&quot;%d&quot;, &amp;n); clean(); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i]); b[1] = a[1], len = 1; for (int i = 2; i &lt;= n; ++i) { if (a[i] &gt; b[len]) b[++len] = a[i]; else { int p = upper_bound(b + 1, b + 1 + len, a[i]) - b; // 注意 upper_bound b[p] = a[i]; } } printf(&quot;%d\n&quot;, len); return 0; } 此做法时间复杂度为 $ O(nlogn) $. LCS最长公共子序列 (Longest Common Subsequence，LCS)，即两个或两个以上数列中最长的公共子序列。 例如 1 2 5 8 8 2 9 和 1 3 5 8 9 9 9 的 LCS 为 1 5 8 9 模板题：Hdu 1159 求两个字符串的最长公共子串。 $O(n^2)$ DP 解法设 $ dp(i, j) $ 为第一个序列匹配到 $ i $，第二个序列匹配到 $ j $ 的 LCS 长度。 $ dp(i, j) = dp(i - 1, j - 1) + 1$，当且仅当 $ a_i=b_j $ (两个原序列)$ dp(i, j) = max(dp(i - 1, j), dp(i, j - 1))$，当且仅当 $ a_i \ne b_j $ 代码(未编译)： for (int i = 1; i &lt;= lena; ++i) for (int j = 1; j &lt;= lenb; ++j) { if (a[i] == b[j]) dp[i][j] = dp[i - 1][j - 1] + 1; else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); } 此做法时间复杂度为 $ O(n^2) $. $O(nlogn)$ 解法在所有数不相同或者排列的情况下能够完成 LCS 转化为 LIS 从而 $ O(nlogn) $ 时间复杂度求解，见下面综合中的 LCS 转 LIS。 如果有相同数也可以做，但是非常麻烦。 求 LCS 的方案例题：luogu 2516 对给定的两个字符序列，求出他们最长的公共子序列长度，以及最长公共子序列个数。 第一问就是前面提到的 $ O(n^2) $的算法，主要看第二问 对于第二问，我们当前第一问的 DP 状态是 $ dp(i, j) $ 表示第一个串匹配到 $ i $，第二个串匹配到 $ j $ 的最长公共子序列。 然后我们再加一个数组 $ g(i, j) $ 表示第一个串匹配到 $ i $，第二个串匹配到 $ j $ 的最长公共子序列方案数。 对于这个数组的转移： 当 $ a_i = b_j $ 时，方案数加上$ g(i-1,j-1) $ 如果当前的 DP 值等于 $ dp(i-1, j) $ 或 $ dp(i, j-1) $，那么加上这些方案数，我们发现这个并不会重复 否则如果当前的 DP 值等于 $ dp(i-1, j) $ 或 $ dp(i, j-1) $，那么加上这些方案数。但是如果当前还等于 $ dp(i-1, j-1) $，说明 $ a_i , b_j $ 没做贡献，两个 LCS 均是从$i-1,j-1$的位置转移而来，减掉$ g(i-1,j-1) $即可。 注意开滚动数组，这种题目很容易就 MLE 爆 0 了 这种求方案数的方法很好，利用了一些容斥知识 代码： for (int i = 0; i &lt;= lb; ++i) g[cur ^ 1][i] = 1; //cur 表示滚动数组当前的位置，可以理解为 i。 cur ^ 1 为对称位置，可以理解为 i - 1。 for (int i = 1; i &lt;= la; ++i) { for (int j = 0; j &lt;= lb; ++j) dp[cur][j] = 0, g[cur][j] = 0; g[cur][0] = 1; for (int j = 1; j &lt;= lb; ++j) { dp[cur][j] = max(dp[cur ^ 1][j], dp[cur][j - 1]); if (a[i] == b[j]) { dp[cur][j] = dp[cur ^ 1][j - 1] + 1; g[cur][j] = g[cur ^ 1][j - 1]; if (dp[cur][j] == dp[cur ^ 1][j]) g[cur][j] = (g[cur][j] + g[cur ^ 1][j]) % MO; if (dp[cur][j] == dp[cur][j - 1]) g[cur][j] = (g[cur][j] + g[cur][j - 1]) % MO; } else { if (dp[cur][j] == dp[cur ^ 1][j]) g[cur][j] = (g[cur][j] + g[cur ^ 1][j]) % MO; if (dp[cur][j] == dp[cur][j - 1]) g[cur][j] = (g[cur][j] + g[cur][j - 1]) % MO; if (dp[cur][j] == dp[cur ^ 1][j - 1]) g[cur][j] = (g[cur][j] - g[cur ^ 1][j - 1] + MO) % MO; } } } cur ^= 1; } printf(&quot;%d\n%d\n&quot;, dp[cur ^ 1][lb], g[cur ^ 1][lb]); 综合LIS 转 LCSLIS 问题在数字不重复情况下可以转化为 LCS 问题来求解。 具体方法是把原数组 $ a $ 增序排序后得到 $ b $，然后 $ a, b $ 的 LCS 长度就是原序列 $ a $ 的 LIS 长度。 例如 1 2 5 8 2 9 排序后为 1 2 2 5 8 9，两个序列 LCS 为 1 2 5 8 9 因为 $ LIS $ 是单调递增的，而排序后的数组也是单调递增的，所以两个串的 LCS 就是 LIS。 将问题互化了一下，两个算法都可以 $ O(n^2) $ 完成。可能在有的题目中会用到。 LCS 转 LIS考虑所有数不相同或者排列的情况下能够完成 LCS 转化为 LIS 。 例题：Luogu 1439 给出$1-n$的两个排列$P_1$和$P_2$，求它们的最长公共子序列 这里只有排列，说明了什么？我们可以找到第二个序列每个元素在第一个序列的位置，那么我们用一个 map 来进行映射处理 (也就是找到“第二个序列每个元素在第一个序列的位置”) 例如： 3 4 2 1 5 和 1 3 4 5 2，“第二个序列每个元素在第一个序列的位置”(“对应序列”)序列为 4 1 2 5 3 然后我们可以观察发现 4 1 2 5 3 的 LIS 即为 LCS。 这个结论是正确的。 我们可以想想，“第二个序列每个元素在第一个序列的位置”序列是按照第二个序列的顺序来排的，也就是说这个序列第一个数 4 表示的是第二个序列第一个数在第一个序列的位置，而不是第二个数的。然后我们知道在第一个序列中求得的 LCS 子序列从左到右序号一定是递增的，所以在按第二个序列数排的“对应序列”中找 LIS 就可以找出两个序列的 LCS。因为第二个序列求得的 LCS 子序列从左到右序号也一定是递增的。 就相当于固定了第二个序列中元素的顺序，然后根据第一个序列中元素顺序来求一个交。 代码： for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i]), ma[a[i]] = i;//ma 为 map for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;b[i]); for (int i = 1; i &lt;= n; ++i) b[i] = ma[b[i]]; tax[1] = b[1], len = 1; for (int i = 2; i &lt;= n; ++i) { if (b[i] &gt; tax[len]) tax[++len] = b[i]; else { int p = lower_bound(tax + 1, tax + 1 + len, b[i]) - tax; tax[p] = b[i]; } } printf(&quot;%d\n&quot;, len); 对于有重复数的，我们也能做，但是代码非常复杂。。假如有 1 2 3 1 4 和 2 3 1 1 4，我们将“第二个序列每个元素在第一个序列的位置”(“对应序列”)序列的元素修改为一个集合，即比如第二个序列 1 对应两个位置，为 $(1, 4)$，然后根据这个来得到“对应序列”(上面例子的“对应序列”：2 3 1 4 1 4 5)，拆开集合的大括号继续做即可，注意可能有的数字对于空集的情况，代码太难写也没找到题就放这里读者有兴趣可以写写~ LCIS顾名思义，LCIS 就是最长公共上升子序列。 例题：tyvj 1071 求两个序列的最长公共上升子序列。 我们可以设 $ dp(i, j) $ 为 $ a $ 序列匹配到 $ i $ 位置， $ b $ 序列匹配到 $ j $ 位置，以 $ b_j $ 结尾的 LCIS 参考代码： for (int i = 1; i &lt;= n; ++i) { int k = 0; for (int j = 1; j &lt;= n; ++j) { if (a[i] == b[j]) f[j] = max(f[j], f[k]+1), ans = max(ans, f[j]); else { if (b[j] &lt; a[i] &amp;&amp; f[j] &gt; f[k]) k = j; } } } 一些题目LIS 序列更改问题相关1、例题：[Poj 3666] 给出一个数列$A_i$，求构造$B_i$使得$B_i$单调且$\sum_{i=1}^n |A_i - B_i|$最小, 只需要求出最小值。 2、例题：[Hdu 5256] 求将一个序列改成严格单调的最小次数。 先考虑不严格的情况。答案为$n-LIS$的长度]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1857」「Scoi2010」传送带 (三分套三分)]]></title>
    <url>%2Fbzoj1857%2F</url>
    <content type="text"><![CDATA[BZOJ 1857题意：见上。观察(生活经验)发现，在 $ AB $ 上肯定存在一个点，他左移右移都会增大答案，所以是个单峰函数，同理 $ CD $ 。所以我们写一个三分套三分，即三分完以后再用这个三分结果进行下一个三分操作。 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #define LL long long #define db double #define ms(i, j) memset(i, j, sizeof i) using namespace std; namespace flyinthesky { const db eps = 1e-10; int ax, ay, bx, by, cx, cy, dx, dy, p, q, r; db dist(db xa, db ya, db xb, db yb) {return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));} db calc(db Ux, db Uy, db Dx, db Dy) { db U = dist(ax, ay, Ux, Uy) / (db)p; db D = dist(Dx, Dy, dx, dy) / (db)q; db H = dist(Ux, Uy, Dx, Dy) / (db)r; return U + D + H; } db f(db Ux, db Uy) { db lx_2 = cx, rx_2 = dx; db ly_2 = cy, ry_2 = dy; for (int i = 1; i &lt;= 300; ++i) { db midx_2 = (lx_2 + rx_2) / 2.0; db midy_2 = (ly_2 + ry_2) / 2.0; db mmidx_2 = (midx_2 + rx_2) / 2.0; db mmidy_2 = (midy_2 + ry_2) / 2.0; if (calc(Ux, Uy, midx_2, midy_2) - calc(Ux, Uy, mmidx_2, mmidy_2) &gt; eps) lx_2 = midx_2, ly_2 = midy_2; else rx_2 = mmidx_2, ry_2 = mmidy_2; } return calc(Ux, Uy, lx_2, ly_2); } void clean() { } int solve() { scanf(&quot;%d%d%d%d%d%d%d%d%d%d%d&quot;, &amp;ax, &amp;ay, &amp;bx, &amp;by, &amp;cx, &amp;cy, &amp;dx, &amp;dy, &amp;p, &amp;q, &amp;r); clean(); db lx_1 = ax, rx_1 = bx; db ly_1 = ay, ry_1 = by; for (int i = 1; i &lt;= 300; ++i) { db midx_1 = (lx_1 + rx_1) / 2.0; db midy_1 = (ly_1 + ry_1) / 2.0; db mmidx_1 = (midx_1 + rx_1) / 2.0; db mmidy_1 = (midy_1 + ry_1) / 2.0; if (f(midx_1, midy_1) - f(mmidx_1, mmidy_1) &gt; eps) lx_1 = midx_1, ly_1 = midy_1; else rx_1 = mmidx_1, ry_1 = mmidy_1; } printf(&quot;%.2f\n&quot;, f(lx_1, ly_1)); return 0; } }; int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>三分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1858」「Scoi2010」序列操作 (线段树)]]></title>
    <url>%2Fbzoj1858%2F</url>
    <content type="text"><![CDATA[BZOJ 1858题意：一个$01$序列，序列里面包含了$n$个数，这些数要么是$0$，要么是$1$，现在对于这个序列有五种变换操作和询问操作： $0 a b$ 把$[a, b]$区间内的所有数全变成$0$ $1 a b$ 把$[a, b]$区间内的所有数全变成$1$ $2 a b$ 把$[a, b]$区间内的所有数全部取反，也就是说把所有的$0$变成$1$，把所有的$1$变成$0$ $3 a b$ 询问$[a, b]$区间内总共有多少个$1$ $4 a b$ 询问$[a, b]$区间内最多有多少个连续的$1$ 类似CF 817F，都是要维护$01$序列的区间修改和翻转。这里更为复杂。维护 $sum$：区间和$lsum[0/1]$：左起区间最长$0$串，最长$1$串$rsum[0/1]$：右起区间最长$0$串，最长$1$串$maxsum[0/1]$：区间最长$0$串，最长$1$串$upd$：区间修改$lazy$标记$rev$：区间翻转$lazy$标记 翻转区间时注意$lsum[0]$和$lsum[1]$互换，其他同理。显然正确。 对于询问$4$的处理，我们分成三种情况讨论 1、在左子树2、在右子树3、在中间 注意第三种情况要满足限制$[x,y]$，所以在求值时加上限制。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 100000 + 5; int n, q, a[MAXN]; #define M ((l + r) &gt;&gt; 1) #define lc (o &lt;&lt; 1) #define rc (o &lt;&lt; 1 | 1) int sumv[MAXN * 4], upd[MAXN * 4], rev[MAXN * 4]; int lsum[MAXN * 4][2], rsum[MAXN * 4][2]; int maxsum[MAXN * 4][2]; void pushup(int o, int len) { sumv[o] = sumv[lc] + sumv[rc]; for (int i = 0; i &lt;= 1; ++i) { lsum[o][i] = lsum[lc][i], rsum[o][i] = rsum[rc][i]; if (lsum[lc][i] == len - len / 2) lsum[o][i] += lsum[rc][i]; if (rsum[rc][i] == len / 2) rsum[o][i] += rsum[lc][i]; maxsum[o][i] = max(maxsum[lc][i], maxsum[rc][i]); maxsum[o][i] = max(maxsum[o][i], rsum[lc][i] + lsum[rc][i]); } } void pushdown(int o, int len) { if (len == 1) return ; if (upd[o] != -1) { upd[lc] = upd[rc] = upd[o]; sumv[lc] = (len - len / 2) * upd[lc], sumv[rc] = (len / 2) * upd[rc]; if (upd[o] == 0) { maxsum[lc][0] = lsum[lc][0] = rsum[lc][0] = (len - len / 2); maxsum[lc][1] = lsum[lc][1] = rsum[lc][1] = 0; } else { maxsum[lc][0] = lsum[lc][0] = rsum[lc][0] = 0; maxsum[lc][1] = lsum[lc][1] = rsum[lc][1] = (len - len / 2); } if (upd[o] == 0) { maxsum[rc][0] = lsum[rc][0] = rsum[rc][0] = len / 2; maxsum[rc][1] = lsum[rc][1] = rsum[rc][1] = 0; } else { maxsum[rc][0] = lsum[rc][0] = rsum[rc][0] = 0; maxsum[rc][1] = lsum[rc][1] = rsum[rc][1] = len / 2; } upd[o] = -1, rev[o] = 0; } if (rev[o]) { if (upd[lc] != -1) { upd[lc] ^= 1; sumv[lc] = upd[lc] * (len - len / 2); if (upd[lc] == 0) { maxsum[lc][0] = lsum[lc][0] = rsum[lc][0] = (len - len / 2); maxsum[lc][1] = lsum[lc][1] = rsum[lc][1] = 0; } else { maxsum[lc][0] = lsum[lc][0] = rsum[lc][0] = 0; maxsum[lc][1] = lsum[lc][1] = rsum[lc][1] = (len - len / 2); } } else { rev[lc] ^= 1; sumv[lc] = (len - len / 2) - sumv[lc]; swap(lsum[lc][0], lsum[lc][1]); swap(rsum[lc][0], rsum[lc][1]); swap(maxsum[lc][0], maxsum[lc][1]); } if (upd[rc] != -1) { upd[rc] ^= 1; sumv[rc] = upd[rc] * (len / 2); if (upd[rc] == 0) { maxsum[rc][0] = lsum[rc][0] = rsum[rc][0] = (len / 2); maxsum[rc][1] = lsum[rc][1] = rsum[rc][1] = 0; } else { maxsum[rc][0] = lsum[rc][0] = rsum[rc][0] = 0; maxsum[rc][1] = lsum[rc][1] = rsum[rc][1] = (len / 2); } } else { rev[rc] ^= 1; sumv[rc] = (len / 2) - sumv[rc]; swap(lsum[rc][0], lsum[rc][1]); swap(rsum[rc][0], rsum[rc][1]); swap(maxsum[rc][0], maxsum[rc][1]); } rev[o] = 0; } } void build(int o, int l, int r) { upd[o] = -1, rev[o] = 0; if (l == r) { sumv[o] = a[l]; if (a[l] == 0) { maxsum[o][0] = lsum[o][0] = rsum[o][0] = 1; maxsum[o][1] = lsum[o][1] = rsum[o][1] = 0; } else { maxsum[o][0] = lsum[o][0] = rsum[o][0] = 0; maxsum[o][1] = lsum[o][1] = rsum[o][1] = 1; } } else { build(lc, l, M), build(rc, M + 1, r); pushup(o, r - l + 1); } } void update(int o, int l, int r, int x, int y, int v) { pushdown(o, r - l + 1); if (x &lt;= l &amp;&amp; r &lt;= y) { upd[o] = v, rev[o] = 0; sumv[o] = (r - l + 1) * upd[o]; if (v == 0) { maxsum[o][0] = lsum[o][0] = rsum[o][0] = r - l + 1; maxsum[o][1] = lsum[o][1] = rsum[o][1] = 0; } else { maxsum[o][0] = lsum[o][0] = rsum[o][0] = 0; maxsum[o][1] = lsum[o][1] = rsum[o][1] = r - l + 1; } return ; } if (x &lt;= M) update(lc, l, M, x, y, v); if (M &lt; y) update(rc, M + 1, r, x, y, v); pushup(o, r - l + 1); } void reverse(int o, int l, int r, int x, int y) { pushdown(o, r - l + 1); if (x &lt;= l &amp;&amp; r &lt;= y) { if (upd[o] != -1) { upd[o] ^= 1; sumv[o] = upd[o] * (r - l + 1); if (upd[o] == 0) { maxsum[o][0] = lsum[o][0] = rsum[o][0] = r - l + 1; maxsum[o][1] = lsum[o][1] = rsum[o][1] = 0; } else { maxsum[o][0] = lsum[o][0] = rsum[o][0] = 0; maxsum[o][1] = lsum[o][1] = rsum[o][1] = r - l + 1; } } else { rev[o] ^= 1; sumv[o] = r - l + 1 - sumv[o]; swap(lsum[o][0], lsum[o][1]); swap(rsum[o][0], rsum[o][1]); swap(maxsum[o][0], maxsum[o][1]); } return ; } if (x &lt;= M) reverse(lc, l, M, x, y); if (M &lt; y) reverse(rc, M + 1, r, x, y); pushup(o, r - l + 1); } int query_sum(int o, int l, int r, int x, int y) { pushdown(o, r - l + 1); if (x &lt;= l &amp;&amp; r &lt;= y) { return sumv[o]; } int ret = 0; if (x &lt;= M) ret += query_sum(lc, l, M, x, y); if (M &lt; y) ret += query_sum(rc, M + 1, r, x, y); return ret; } int query_max(int o, int l, int r, int x, int y) { pushdown(o, r - l + 1); if (x &lt;= l &amp;&amp; r &lt;= y) return maxsum[o][1]; int ret = min(M - x + 1, rsum[lc][1]) + min(y - M, lsum[rc][1]); if (x &lt;= M) ret = max(ret, query_max(lc, l, M, x, y)); if (M &lt; y) ret = max(ret, query_max(rc, M + 1, r, x, y)); return ret; } void clean() { } int solve() { clean(); cin &gt;&gt; n &gt;&gt; q; for (int i = 0; i &lt; n; ++i) scanf(&quot;%d&quot;, &amp;a[i]); build(1, 0, n - 1); while (q--) { int tp, x, y; scanf(&quot;%d%d%d&quot;, &amp;tp, &amp;x, &amp;y); if (tp == 0) update(1, 0, n - 1, x, y, 0); if (tp == 1) update(1, 0, n - 1, x, y, 1); if (tp == 2) reverse(1, 0, n - 1, x, y); if (tp == 3) printf(&quot;%d\n&quot;, query_sum(1, 0, n - 1, x, y)); if (tp == 4) printf(&quot;%d\n&quot;, query_max(1, 0, n - 1, x, y)); } return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bzoj 3907(组合数/Catalan数/DP)]]></title>
    <url>%2Fbzoj3907%2F</url>
    <content type="text"><![CDATA[BZOJ 3907题意：见上。注意到$n=m$时是卡特兰数。也可以考虑正方形的时候，可以发现三角形的情况就是正方形的方案数除以正方形边包含的点数。(从简单情况入手)也可以进行 DP，设$dp(i,j)$为$(0,0)$到$(i,j)$的方案数，转移时判一下，懒得写高精用 python TLE到60分…… 我们发现不穿过$y=x$就是不经过$y=x-1$上的点……所以我们从$(-1,0)$开始走，总方案数是$C^{n+1}_{n+m+1}$。然后从出发点向上走的路径条数是$C^{m-1}_{n+m+1}$，向右走的方案与向上走的路径条数关于直线对称，所以最后答案是$C^{n+1}_{n+m+1}-2C^{m-1}_{n+m+1}$ //用阶乘预处理即可……加上高精度]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>计数DP</tag>
        <tag>Bzoj</tag>
        <tag>组合数学</tag>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 821D(网格图缩列缩行+0-1BFS / 最短路)]]></title>
    <url>%2FCodeforces821D%2F</url>
    <content type="text"><![CDATA[Codeforces 821D题意：题意:$n \times m$的地图,有$k$个位置是点亮的,有$4$个移动方向,每次可以移动到相邻的点亮位置,每次站在初始被点亮某个位置,暂时使某行或该某列全部点亮,花费为$1$,下一次使用时,上一次暂时点亮被熄灭.问从$(1,1)$到$(n,m)$的最小花费 这题发现可以直接跑最短路。。每次循环找下一个灯如果相邻费用为0，如果能点亮一列过去费用为1，否则为INF，复杂度有点神奇 可以将行列缩成一个点，因为题目中点亮一次是一行或一列。然后每个灯可以连到周围能到的行列和灯，相应的边权看着办，然后边权只有01，跑0-1BFS。 2018.10.31 upd: 0-1 BFS 不要开vis数组！用dis松弛即可。 知识点1、点拆了数组要开够大小2、不要随便叉自己的想法！3、map.find()用法 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;stack&gt; #include&lt;set&gt; #include&lt;map&gt; #include&lt;queue&gt; #include&lt;climits&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 10000 + 5, INF = 1000000000; struct lt {int r, c;} li[MAXN]; struct edge {int u, v, w, nxt; } ed[10000005]; int n, m, k, en, hd[MAXN * 3], dis[MAXN * 3]; map&lt;pair&lt;int, int&gt;, int &gt; ma; deque&lt;int &gt; q; void ins(int x, int y, int w) {ed[++en] = (edge){x, y, w, hd[x]}, hd[x] = en;} void clean() { en = 0, ms(hd, -1); } int solve() { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k); clean(); for (int i = 1; i &lt;= k; ++i) scanf(&quot;%d%d&quot;, &amp;li[i].r, &amp;li[i].c), ma[make_pair(li[i].r, li[i].c)] = i; for (int i = 1; i &lt;= k; ++i) { int x = li[i].r, y = li[i].c; ins(i, k + x, 1), ins(k + x, i, 0); if (x - 1 &gt; 0) ins(i, k + x - 1, 1), ins(k + x - 1, i, 0); if (x + 1 &lt;= n) ins(i, k + x + 1, 1), ins(k + x + 1, i, 0); ins(i, k + n + y, 1), ins(k + n + y, i, 0); if (y - 1 &gt; 0) ins(i, k + n + y - 1, 1), ins(k + n + y - 1, i, 0); if (y + 1 &lt;= m) ins(i, k + n + y + 1, 1), ins(k + n + y + 1, i, 0); int dx[4] = {1, 0, -1, 0}; int dy[4] = {0, 1, 0, -1}; for (int j = 0; j &lt; 4; ++j) { int tx = dx[j] + x, ty = dy[j] + y; if (tx &gt; 0 &amp;&amp; ty &gt; 0 &amp;&amp; tx &lt;= n &amp;&amp; ty &lt;= m) { map&lt;pair&lt;int, int &gt;, int &gt;::iterator it = ma.find(make_pair(tx, ty)); if (it == ma.end()) continue ; ins(i, it-&gt;second, 0), ins(it-&gt;second, i, 0); } } } for (int i = 0; i &lt;= n + m + k; ++i) dis[i] = INF; dis[1] = 0, q.push_back(1); while (!q.empty()) { int u = q.front(); q.pop_front(); for (int i = hd[u]; i &gt; 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (dis[e.v] &gt; dis[u] + e.w) { dis[e.v] = dis[u] + e.w; if (e.w == 0) q.push_front(e.v); else q.push_back(e.v); } } } int ans = min(dis[k + n], dis[k + n + m]); for (int i = 1; i &lt;= k; ++i) if (li[i].r == n &amp;&amp; li[i].c == m) ans = min(ans, dis[i]); if (ans == INF) cout &lt;&lt; -1; else cout &lt;&lt; ans; return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>Codeforces</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 892E(最小生成树+可撤销并查集+离线)]]></title>
    <url>%2FCodeforces892E%2F</url>
    <content type="text"><![CDATA[Codeforces 892D题意：给出一个$n$个点$m$条边的无向联通图，有$q$个询问每个询问询问一个边集$E_i$，回答这些边能否在同一个最小生成树中 本题又加强我对最小生成树定理的理解…… 首先同一个图最小生成树所有相同边权数量都是一样的，并且在 Kruskal 加边时不同边互相之间独立。也就是说我们可以将每个边权分开来加，并且每种边权都可以被一条不产生环的。关于更多最小生成树的定理，请看Bzoj 1016其实这题和Bzoj 1016有类似的地方。我们将询问离线。按照边权大小从小到大加边。枚举当前边权大小为$w$, 如果在某个询问中有$w$大的边，那么就将这些$w$大的边权加到并查集里看会不会产生环，如果产生环则无解，当然这些边要撤销，用能撤销的并查集。然后每次循环完以后，将当前边权的所有边加入并查集不撤销，继续做。 1、最小生成树的定理要掌握：1切割性质、2回路性质、3相同边权数量相等，4不同边权加入时互相独立，5不产生环的同权值边可以替换边2、调试大代码要用分块调试和输出调试，并且要运用解释数组方法来检查 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;stack&gt; #include&lt;set&gt; #include&lt;queue&gt; #include&lt;climits&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 500000 + 5; struct edge { int u, v, w; bool operator &lt; (const edge &amp;b) const {return w &lt; b.w;} } ed[MAXN], ed2[MAXN]; struct whw {int id, fr, t;}; // id：是哪个询问的。fr，t：在输入边排序后(que)的index范围 struct ask { int id; // 输入边编号 bool operator &lt; (const ask &amp;b) const {return ed[id].w &lt; ed[b.id].w;} }; int n, m, q, ans[MAXN], maxw = 0, f[MAXN], sz[MAXN]; vector&lt;whw &gt; a[MAXN]; // a[权值][index] = 询问中边权为 权值 的边(whw类型) vector&lt;ask &gt; que[MAXN]; // que[输入边index][index] = 输入边排序后边编号(ask类型) stack&lt;pair&lt;int, int &gt; &gt; s; int find(int x) {return x == f[x] ? x : find(f[x]);} //no compress void mg(int a, int b) { int x = a, y = b; if (sz[x] &gt; sz[y]) swap(x, y); f[x] = y, sz[y] += sz[x], s.push(mp(x, y)); } void cc(int tms) { while (tms-- &amp;&amp; !s.empty()) { pair&lt;int, int &gt; p = s.top(); s.pop(); int x = p.fir, y = p.sec; f[x] = x, sz[y] -= sz[x]; } } void clean() { ms(ans, 0); } int solve() { cin &gt;&gt; n &gt;&gt; m; clean(); for (int i = 1; i &lt;= m; ++i) scanf(&quot;%d%d%d&quot;, &amp;ed[i].u, &amp;ed[i].v, &amp;ed[i].w), maxw = max(maxw, ed[i].w), ed2[i] = ed[i]; sort(ed2 + 1, ed2 + 1 + m); cin &gt;&gt; q; for (int i = 1; i &lt;= q; ++i) { int Ki; scanf(&quot;%d&quot;, &amp;Ki); for (int x, j = 1; j &lt;= Ki; ++j) scanf(&quot;%d&quot;, &amp;x), que[i].push_back((ask){x}); sort(que[i].begin(), que[i].end()); int lst = 0; for (int j = 1; j &lt; (int)que[i].size(); ++j) { int id = que[i][j].id, lid = que[i][j - 1].id; if (ed[id].w != ed[lid].w) { a[ed[lid].w].push_back((whw){i, lst, j - 1}); lst = j; } } a[ ed[ que[i][ (int)que[i].size() - 1 ].id ].w ].push_back((whw){i, lst, (int)que[i].size() - 1}); } for (int i = 0; i &lt;= n; ++i) f[i] = i, sz[i] = 1; int now = 1; for (int i = 1; i &lt;= maxw; ++i) { for (int j = 0; j &lt; (int)a[i].size(); ++j) { int fl = 0, tms = 0; whw &amp;ct = a[i][j]; for (int k = ct.fr; k &lt;= ct.t; ++k) { edge &amp;e = ed[que[ct.id][k].id]; int x = find(e.u), y = find(e.v); if (x == y) {fl = 1; break;} else mg(x, y), ++tms; } if (fl) ans[ct.id] = 1; //no cc(tms); } while (ed2[now].w == i) { int x = find(ed2[now].u), y = find(ed2[now].v); if (x != y) mg(x, y); ++now; } } for (int i = 1; i &lt;= q; ++i) printf(&quot;%s&quot;, ans[i] == 1 ? &quot;NO\n&quot; : &quot;YES\n&quot;); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>离线</tag>
        <tag>Codeforces</tag>
        <tag>生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 3508」开灯 (Xor前缀和+BFS+状压DP)]]></title>
    <url>%2Fbzoj3508%2F</url>
    <content type="text"><![CDATA[BZOJ 3508题意：见上。 可以发现这种翻转的题目，如果弄成异或前缀和，那么如果整个序列是0，则灯全灭。我们相当于将给定要亮着的灯当成初始状态，那么目标就是全关。考虑异或前缀和两个1就可以消除，用一个BFS算出每个1和其他1消除的代价。然后之后就是一个两两配对的过程，弄一个状压DP即可。 知识点：1、异或前缀和 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;complex&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { int n, k, m, a[21], b[100], cf[10000 + 5]; int cst[21][21], dp[(1 &lt;&lt; 21) + 5], dis[10000 + 5]; void bfs(int ith) { ms(dis, 0); queue&lt;int &gt; q; q.push(a[ith]); while (!q.empty()) { int u = q.front(); q.pop(); for (int i = 1; i &lt;= m; ++i) { if (u + b[i] &lt;= n &amp;&amp; !dis[u + b[i]]) dis[u + b[i]] = dis[u] + 1, q.push(u + b[i]); if (u - b[i] &gt;= 1 &amp;&amp; !dis[u - b[i]]) dis[u - b[i]] = dis[u] + 1, q.push(u - b[i]); } } for (int i = 1; i &lt;= k; ++i) { if (dis[a[i]] == 0) cst[ith][i] = 0x3f3f3f3f; else cst[ith][i] = dis[a[i]]; } cst[ith][ith] = 0; } void clean() { ms(cst, 0), ms(dp, 0x3f), ms(cf, 0); } int solve() { clean(); cin &gt;&gt; n &gt;&gt; k &gt;&gt; m; ++n; for (int x, i = 1; i &lt;= k; ++i) scanf(&quot;%d&quot;, &amp;x), cf[x] ^= 1, cf[x + 1] ^= 1; for (int i = 1; i &lt;= m; ++i) scanf(&quot;%d&quot;, &amp;b[i]); k = 0; for (int i = 1; i &lt;= n; ++i) if (cf[i]) a[++k] = i; for (int i = 1; i &lt;= k; ++i) bfs(i); dp[0] = 0; for (int S = 0; S &lt; (1 &lt;&lt; k); ++S) { for (int i = 1; i &lt;= k; ++i) { if (S &amp; (1 &lt;&lt; (i - 1))) continue ; for (int j = i + 1; j &lt;= k; ++j) { if ((S &amp; (1 &lt;&lt; (j - 1)))) continue ; dp[S | (1 &lt;&lt; (i - 1)) | (1 &lt;&lt; (j - 1))] = min(dp[S | (1 &lt;&lt; (i - 1)) | (1 &lt;&lt; (j - 1))], dp[S] + cst[i][j]); } break; } } if (dp[(1 &lt;&lt; k) - 1] == 0x3f3f3f3f) cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; dp[(1 &lt;&lt; k) - 1] &lt;&lt; endl; return 0; } } int main() { int T; cin &gt;&gt; T; while (T--) flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>状压DP</tag>
        <tag>BFS</tag>
        <tag>前缀和</tag>
        <tag>Xor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bzoj 3505(GCD+组合数)]]></title>
    <url>%2Fbzoj3505%2F</url>
    <content type="text"><![CDATA[BZOJ 3505题意：见上。先将m++, n++，因为格点数要多一个我们可以先求出所有格点中选3个点的方案，即$C^{3}_{nm}$，然后就只用求出三点共线的三角形个数即可。对于$k=0, k=INF$的三点共线三角形很好求，$C^{3}_{m} \cdot n + C^{3}_{n} \cdot m$对于其他直线，我们可以枚举直线来求。枚举直线相当于枚举两个点。 结论：过$(x_1,y_1)$和$(x_2,y_2)$的直线整数顶点数为$gcd(\Delta x, \Delta y)-1$ 根据这个性质，我们可以快速求解，但是还是要枚举两个点。我们发现过$(0,0)$点的直线可以平移得到其他直线，所以只用枚举一个点即可。 知识点：1、正难则反思想2、枚举直线相当于枚举两个点3、过$(x_1,y_1)$和$(x_2,y_2)$的直线整数顶点数为$gcd(\Delta x, \Delta y)-1$ #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;climits&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { int m, n; LL ans; LL gcd(LL a, LL b) {return b == 0 ? a : gcd(b, a % b);} void clean() {} int solve() { cin &gt;&gt; m &gt;&gt; n; clean(); ++m, ++n; ans = (LL)(m * n) * (LL)(m * n - 1) * (LL)(m * n - 2) / 6ll; ans -= (LL)n * (LL)(n - 1) * (LL)(n - 2) * (LL)m / 6ll; ans -= (LL)m * (LL)(m - 1) * (LL)(m - 2) * (LL)n / 6ll; for (LL x = 1; x &lt; n; ++x) for (LL y = 1; y &lt; m; ++y) { LL whw = gcd(x, y) - 1; if (whw &lt; 0) whw = 0; //cout &lt;&lt; whw &lt;&lt; endl; ans -= whw * (n - x) * (m - y) * 2ll; } cout &lt;&lt; ans; return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>GCD</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 716D(最短路+枚举加边)]]></title>
    <url>%2FCodeforces716D%2F</url>
    <content type="text"><![CDATA[Codeforces 716D题意：$n$个点$0~n-1$和$m$条边的无向图，每条边上有一个正权或0，0可以改成任何正权，求一个方案使得$s$到$t$最短路为$L$.解：考虑将 0 边先全部删除，然后再进行添加。先对原图进行一次最短路，如果此时$s$到$t$最短路小于$L$，显然无解，如果等于则直接输出否则我们开始随意加边，加最小正边权为$1$，注意正边权。然后每次加完边以后做最短路，如果当前最短路小于$L$，则可以直接输出了，但是这条边要改成适当的权来使最短路变为$L$。1、枚举最短路要考虑2/4种情况2、要挖掘题目中所有的限制3、要严格按照做题步骤去想，先写题意，再想题目类型，五大思维方式 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;climits&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 1000 + 5, MAXM = 10000 + 5; struct edge {int u, v, w, nxt;} ed[MAXM * 2]; struct zoe {int s, t;} whw[MAXM]; struct data { int u； LL dis; bool operator &lt; (const data &amp;b) const {return dis &gt; b.dis;} }; priority_queue&lt;data &gt; q; int n, m, L, s, t, en, orz, hd[MAXN], cnt; int vis[MAXN]; LL dis[MAXN]; void ins(int x, int y, int w) {ed[++en] = (edge){x, y, w, hd[x]}, hd[x] = en;} void dij(int ss) { for (int i = 0; i &lt;= n; ++i) vis[i] = 0, dis[i] = LLONG_MAX / 2; dis[ss] = 0, q.push((data){ss, 0}); while (!q.empty()) { data p = q.top(); q.pop(); if (vis[p.u]) continue; vis[p.u] = true; for (int i = hd[p.u]; i &gt; 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (dis[e.v] &gt; dis[p.u] + e.w) { dis[e.v] = dis[p.u] + e.w; q.push((data){e.v, dis[e.v]}); } } } } void pri(int hh) { printf(&quot;YES\n&quot;); for (int i = 1; i &lt;= orz; i += 2) printf(&quot;%d %d %d\n&quot;, ed[i].u, ed[i].v, ed[i].w); for (int i = 1; i &lt; hh; ++i) printf(&quot;%d %d %d\n&quot;, whw[i].s, whw[i].t, 1); dij(s); LL tmp1 = dis[whw[hh].s], tmp2 = dis[whw[hh].t]; dij(t); tmp1 += dis[whw[hh].t], tmp2 += dis[whw[hh].s]; if (hh &gt;= 1) printf(&quot;%d %d %lld\n&quot;, whw[hh].s, whw[hh].t, L - min(tmp1, tmp2)); for (int i = hh + 1; i &lt;= cnt; ++i) printf(&quot;%d %d %lld\n&quot;, whw[i].s, whw[i].t, 10000000000ll); } void clean() { orz = cnt = en = 0, ms(hd, -1); } int solve() { cin &gt;&gt; n &gt;&gt; m &gt;&gt; L &gt;&gt; s &gt;&gt; t; clean(); for (int x, y, w, i = 1; i &lt;= m; ++i) { scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;w); if (w != 0) ins(x, y, w), ins(y, x, w); else whw[++cnt] = (zoe){x, y}; } orz = en; dij(s); if (dis[t] &lt; L) return printf(&quot;NO\n&quot;), 0; if (dis[t] == L) return pri(0), 0; int gg = 0; for (int i = 1; i &lt;= cnt; ++i) { ins(whw[i].s, whw[i].t, 1), ins(whw[i].t, whw[i].s, 1); dij(s); if (dis[t] &lt;= L) {gg = i; break ;} } if (dis[t] &lt;= L) pri(gg); else printf(&quot;NO\n&quot;); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1064D(BFS + 堆 / 0-1BFS / 网格图连边最短路)]]></title>
    <url>%2FCodeforces1064D%2F</url>
    <content type="text"><![CDATA[Codeforces 1064D题意：给定一个$n×m$的网格图，有若干个点不能走，上下走无限制，向左和向右走的次数分别被限制为$x$和$y$，给出起点并询问有多少个点能够到达。 这题刚开始写了个裸 BFS 然后 FST 了。。原因是直接 BFS 加的维限制但是不让 vis 加维会让路被堵住让能到那个点的路径不能到那个点。 本题方法：方法1、在原基础上改。开两个数组分别记录到某个点时左右次数还剩下的最大值，然后 BFS 走时判一下大小。感觉容易 FST方法2、在原基础上改。将队列开为优先队列，然后用 Dij 思想，使得当前枚举的点左次数剩下的最大，相等则右次数剩下的最大，这样来做就不会堵路了，代码为这种方法。方法3、观察到本题左走次数和右走次数分开走没有关系，最后答案交起来即可。所以我们分别建两个图，一个图对于左走边权为1，右走边权为0，另一个图反之。然后跑 Dij 答案求交方法4、观察到本题边权仅有0,1，那么可以使用 0-1 BFS，即如果当前边为 0 ，放在双端队列的front，否则为1则放在双端队列的 back，然后照样 BFS 即可。方法与3类似。 知识点：1、BFS 状态加维，状态也要加维，否则会堵路2、两个 if 不要乱并，特别在有 else 的情况3、0-1 BFS 写法4、BFS 用堆来优化枚举顺序 (Dij)5、网格图可以连边跑最短路什么的6、想过的可能 BUG 不要轻易放过 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #include&lt;set&gt; #include&lt;iostream&gt; #define LL long long #define db double #define mp make_pair #define pr pair&lt;int, int&gt; #define fir first #define sec second #define pb push_back #define ms(i, j) memset(i, j, sizeof i) using namespace std; //==========================Templates========================== inline int read() { int x = 0, f = 1; char c = getchar(); while(c &lt; &#39;0&#39; || c &gt; &#39;9&#39;){if (c == &#39;-&#39;) f = -1; c = getchar();} while(c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;){x = x * 10 + c - &#39;0&#39;; c = getchar();} return x * f; } inline LL readl() { LL x = 0, f = 1; char c = getchar(); while(c &lt; &#39;0&#39; || c &gt; &#39;9&#39;){if (c == &#39;-&#39;) f = -1; c = getchar();} while(c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;){x = x * 10 + c - &#39;0&#39;; c = getchar();} return x * f; } int power(int a, int b) { int ans = 1; while (b) { if(b &amp; 1) ans = ans * a; b &gt;&gt;= 1; a = a * a; } return ans; } int power_mod(int a, int b, int mod) { a %= mod; int ans = 1; while (b) { if(b &amp; 1) ans = (ans * a) % mod; b &gt;&gt;= 1, a = (a * a) % mod; } return ans; } LL powerl(LL a, LL b) { LL ans = 1ll; while (b) { if(b &amp; 1ll) ans = ans * a; b &gt;&gt;= 1ll;a = a * a; } return ans; } LL power_modl(LL a, LL b, LL mod) { a %= mod; LL ans = 1ll; while (b) { if(b &amp; 1ll) ans = (ans * a) % mod; b &gt;&gt;= 1ll, a = (a * a) % mod; } return ans; } LL gcdl(LL a, LL b) {return b == 0 ? a : gcdl(b, a % b);} LL abssl(LL a) {return a &gt; 0 ? a : -a;} int gcd(int a, int b) {return b == 0 ? a : gcd(b, a % b);} int abss(int a) {return a &gt; 0 ? a : -a;} //==========================Main body========================== #define LD &quot;%I64d&quot; #define D &quot;%d&quot; #define pt printf #define sn scanf #define pty printf(&quot;YES\n&quot;) #define ptn printf(&quot;NO\n&quot;) //==========================Code here========================== struct data { int x, y, rmx, rmy; operator &lt; (const data &amp;b) const { if (rmx != b.rmx) return rmx &lt; b.rmx; return rmy &lt; b.rmy; } }; const int dx[4] = {0, 0, 1, -1}; const int dy[4] = {-1, 1, 0, 0}; int n, m, r, c, x, y, vis[2005][2005]; char ma[2005][2005]; priority_queue&lt;data &gt; q; int main() { ms(vis, 0); cin &gt;&gt; n &gt;&gt; m &gt;&gt; r &gt;&gt; c &gt;&gt; x &gt;&gt; y; for (int i = 1; i &lt;= n; i++) scanf(&quot;%s&quot;, ma[i] + 1); vis[r][c] = 1, q.push((data){r, c, x, y}); while (!q.empty()) { data p = q.top(); q.pop(); for (int i = 0; i &lt;= 4; i++) { if (p.rmx == 0 &amp;&amp; dy[i] == -1) continue; if (p.rmy == 0 &amp;&amp; dy[i] == 1) continue; int tx = p.x + dx[i], ty = p.y + dy[i]; if (tx &gt; 0 &amp;&amp; ty &gt; 0 &amp;&amp; tx &lt;= n &amp;&amp; ty &lt;= m &amp;&amp; ma[tx][ty] != &#39;*&#39; &amp;&amp; !vis[tx][ty]) { vis[tx][ty] = 1; if (dy[i] == -1) q.push((data){tx, ty, p.rmx - 1, p.rmy}); else if (dy[i] == 1) q.push((data){tx, ty, p.rmx, p.rmy - 1}); else q.push((data){tx, ty, p.rmx, p.rmy}); } } } int ans = 0; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) if (vis[i][j]) ans++; //for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) printf(&quot;%d%c&quot;, vis[i][j], j == m ? &#39;\n&#39; : &#39; &#39;); cout &lt;&lt; ans; return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>堆</tag>
        <tag>BFS</tag>
        <tag>Codeforces</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 915F(并查集+贡献法)]]></title>
    <url>%2FCodeforces915F%2F</url>
    <content type="text"><![CDATA[Codeforces 915F题意：$n$个点的树，每个点有一个点权$a_i$, 计算树上所有路径的权值的$max(a_i)-min(a_i)$和。 考虑对于每条路径先求$max(a_i)$再求$min(a_i)$，这样就分开成了两个问题。因为是树上计数问题，而且是整棵树的计数问题，所以我们可以想到求每个点对的贡献。现在求最大值，我们将点排序，取最大的点出来，此时它左边点到右边点的路径最大值一定是它。处理完一个以后删掉这个点(删掉这个点的所有连边)，然后继续操作。我们发现连通性可以用并查集维护集合大小。但是这里要删边显然不方便，我们参考星球大战这题将并查集逆向变删除为添加来做就行了。并查集维护集合大小很简单，见代码。 知识点：1、计数问题：DP、组合数、贡献法2、发现自己思路错了要回到本质去看怎么修改，必要时重新梳理思路3、一个思路发现错了不一定就是错的，有可能是自己脑残或者改一下能用4、将式子分裂开求解是非常好用的5、正难则反思想6、转化思想-删除转化为添加7、并查集维护集合大小方法 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;stack&gt; #include&lt;set&gt; #include&lt;map&gt; #include&lt;queue&gt; #include&lt;climits&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; namespace flyinthesky { const int MAXN = 1000000 + 5; vector&lt;int &gt; G[MAXN]; pair&lt;int, int &gt; d[MAXN]; int n, a[MAXN], vis[MAXN], f[MAXN], cnt[MAXN]; LL ans = 0ll; int find(int x) {return x == f[x] ? x : f[x] = find(f[x]);} void mg(int x, int y) {f[y] = x, cnt[x] += cnt[y];}//维护集合大小 void gg() { for (int i = 0; i &lt;= n; i++) f[i] = i, cnt[i] = 1, vis[i] = 1; for (int o = 1; o &lt;= n; o++) { int u = d[o].second, val = d[o].first; vis[u] = 0; for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i]; if (!vis[v]) { int x = find(u), y = find(v); ans += (LL)cnt[x] * (LL)cnt[y] * (LL)val; if (x != y) mg(x, y); } } } } void clean() { } int solve() { scanf(&quot;%d&quot;, &amp;n); clean(); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]), d[i] = make_pair(a[i], i); for (int u, v, i = 1; i &lt; n; i++) scanf(&quot;%d%d&quot;, &amp;u, &amp;v), G[u].push_back(v), G[v].push_back(u); sort(d + 1, d + 1 + n), gg(); for (int i = 1; i &lt;= n; i++) d[i] = make_pair(-a[i], i); sort(d + 1, d + 1 + n), gg(); printf(&quot;%lld\n&quot;, ans); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1059D(数学+二分)]]></title>
    <url>%2FCodeforces1059D%2F</url>
    <content type="text"><![CDATA[Codeforces 1059D题意：给你平面上一些点，你需要找出一个与直线$y=0$相切的圆使得包含所有点。彻头彻尾的数学题……显然如果$y$有正有负就不能构造圆使得与$y=0$相切。考虑二分半径，然后验证答案。观察可得，与直线$y=0$相切的圆圆心一定在$y=b$上，也就是圆的纵坐标我们可以尝试枚举所有点，然后在$y=b$上找到一个范围使得在当前半径下都能覆盖这个点，然后取交集即可。点$(x,y)$范围相当于解圆不等式$(x-a)^2+(y-r)^2 \leq r^2$，我们解得$a=x±\sqrt{2rt-y^2}$，因为这个不等式是关于$a$的一元二次不等式，二次项系数为正，所以我们取$[x-\sqrt{2rt-y^2},x+\sqrt{2rt-y^2}]$，这个就是范围。 注意二分的范围，也就是最大可能半径的计算：考虑极端情况$(-10^7, 1), (10^7, 1)$，我们过这两点作圆，将这两点连线后再与圆心形成三角形，根据$(r-1)^2+(10^7)^2=r^2$，可解得$r=\frac{10^{14}+1}{2}$，那么这个就是最大的半径长。 还有就是注意还有可能圆心在$y=-b$上，类似地特判一下即可。如果开方里面是负的说明当前半径无解 知识点：1、浮点数比较2、二分范围千万不要想当然3、这种几何题和数学相关，也和二分/三分相关 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; #include&lt;queue&gt; #include&lt;climits&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double const LL MAXN = 100000 + 5, LOGS = 17, INF = 300000000000005ll; struct edge {LL u, v, d;}; struct data { LL u, d; bool operator &lt; (const data &amp;b) const {return d &gt; b.d;} }; std::vector&lt;edge &gt; G[MAXN]; std::set&lt;std::pair&lt;LL, LL&gt; &gt; nt; std::priority_queue&lt;data &gt; q; LL n, m, Q, vis[MAXN], dep[MAXN], pre[MAXN][30], h[MAXN], dis[50][MAXN]; void dfs(LL u, LL fa) { dep[u] = dep[fa] + 1, vis[u] = 1, pre[u][0] = fa; for (LL i = 1; i &lt;= LOGS; i++) pre[u][i] = pre[pre[u][i - 1]][i - 1]; for (LL i = 0; i &lt; (LL)G[u].size(); i++) { edge &amp;e = G[u][i]; if (e.v != fa &amp;&amp; !vis[e.v]) { h[e.v] = h[u] + e.d; dfs(e.v, u); if (u &lt; e.v) nt.erase(std::make_pair(u, e.v)); else nt.erase(std::make_pair(e.v, u)); } } } void dij(LL st, LL d[MAXN]) { for (LL i = 0; i &lt;= n; i++) d[i] = INF, vis[i] = 0; d[st] = 0, q.push((data){st, 0}); while (!q.empty()) { data p = q.top(); q.pop(); if (vis[p.u]) continue; vis[p.u] = 1; for (LL i = 0; i &lt; (LL)G[p.u].size(); i++) { edge &amp;e = G[p.u][i]; if (d[e.v] &gt; d[p.u] + e.d) d[e.v] = d[p.u] + e.d, q.push((data){e.v, d[e.v]}); } } } LL LCA(LL a, LL b) { if (dep[a] &lt; dep[b]) std::swap(a, b); for (LL i = LOGS; i &gt;= 0; i--) if (dep[pre[a][i]] &gt;= dep[b]) a = pre[a][i]; if (a == b) return a; for (LL i = LOGS; i &gt;= 0; i--) if (pre[a][i] != pre[b][i]) a = pre[a][i], b = pre[b][i]; return pre[a][0]; } LL getdist(LL u, LL v) {return h[u] + h[v] - 2 * h[LCA(u, v)];} void clean() { ms(h, 0), ms(vis, 0), ms(dep, 0); } int solve() { clean(); for (LL u, v, d, i = 1; i &lt;= m; i++) { scanf(&quot;%lld%lld%lld&quot;, &amp;u, &amp;v, &amp;d); G[u].push_back((edge){u, v, d}), G[v].push_back((edge){v, u, d}); if (u &lt; v) nt.insert(std::make_pair(u, v)); else nt.insert(std::make_pair(v, u)); } dfs(1, 0); //for (LL i = 0; i &lt; (LL)nt.size(); i++) printf(&quot;u=%lld v=%lld d=%lld\n&quot;, nt[i].u, nt[i].v, nt[i].d); LL cnt = 0; for (std::set&lt;std::pair&lt;LL, LL&gt; &gt;::iterator it = nt.begin(); it != nt.end(); it++) { std::pair&lt;LL, LL&gt; e = *it; LL &amp;u = e.first, &amp;v = e.second; //printf(&quot;u=%lld v=%lld d=%lld\n&quot;, nt[i].u, nt[i].v, nt[i].d); if (u &gt; v) continue; dij(u, dis[++cnt]); } //for (LL i = 1; i &lt;= n; i++) for (LL j = 1; j &lt;= n; j++) printf(&quot;i=%lld j=%lld lca=%lld\n&quot;, i, j, LCA(i, j)); scanf(&quot;%lld&quot;, &amp;Q); while (Q--) { LL u, v; scanf(&quot;%lld%lld&quot;, &amp;u, &amp;v); LL ans = getdist(u, v); for (LL i = 1; i &lt;= cnt; i++) { ans = std::min(ans, dis[i][u] + dis[i][v]); } printf(&quot;%lld\n&quot;, ans); } return 0; } int main() { scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>二分</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1053」「HAOI2007」反素数ant (因数个数 + 打表 / DFS)]]></title>
    <url>%2Fbzoj1053%2F</url>
    <content type="text"><![CDATA[Bzoj 1053题意：见上。 本题就是一个打表的典型题。但是打表程序很有学问否则你离开考场都打不完表。最容易想到$O(n \sqrt n)$的暴力，但是对于$2 \times 10^{9}$太慢了。我们可以运用这个定理： 给出n的唯一分解式 $n = p^{a1}_1p^{a2}_2p^{a3}_3…p^{ak}_k$ , 求出 $n$ 的正约数的个数根据乘法原理，$n$ 的正约数的个数为$\prod_{i=1}^{k}(a_i+1)$ 然后就可以打质数表进行分解因数。我们发现一个$2 \times 10^{9}$以内的数字不会有超过$12$个质因子，并且小素因子多一定比大素因子多要优，预处理出前$12$个质数即可。 打完表输出即可。打表直接打出反素数即可，反素数个数很少。 生成器 (500s+​ 能完成)： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;stack&gt; #include&lt;set&gt; #include&lt;queue&gt; #include&lt;climits&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; namespace flyinthesky { LL pri[50] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71}; void clean() { } int solve() { clean(); freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); LL maxn = 0ll; for (LL i = 1ll; i &lt;= 2000000000ll; ++i) { LL tmp = 1ll, whw = i; for (LL j = 0ll; j &lt; 20ll; ++j) { LL gg = 0ll, x = pri[j]; while (whw % x == 0ll) whw /= x, ++gg; tmp *= (gg + 1ll); } if (tmp &gt; maxn) printf(&quot;%lld &quot;, i); maxn = max(tmp, maxn); } printf(&quot;maxn=%lld\n&quot;, maxn); return 0; } } int main() { flyinthesky::solve(); return 0; } 打表： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;stack&gt; #include&lt;set&gt; #include&lt;queue&gt; #include&lt;climits&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; namespace flyinthesky { int atp[500] = {1, 2, 4, 6, 12, 24, 36, 48, 60, 120, 180, 240, 360, 720, 840, 1260, 1680, 2520, 5040, 7560, 10080, 15120, 20160, 25200, 27720, 45360, 50400, 55440, 83160, 110880, 166320, 221760, 277200, 332640, 498960, 554400, 665280, 720720, 1081080, 1441440, 2162160, 2882880, 3603600, 4324320, 6486480, 7207200, 8648640, 10810800, 14414400, 17297280, 21621600, 32432400, 36756720, 43243200, 61261200, 73513440, 110270160, 122522400, 147026880, 183783600, 245044800, 294053760, 367567200, 551350800, 698377680, 735134400, 1102701600, 1396755360, 2000001000}; void clean() { } int solve() { clean(); int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; ; i++) { if (atp[i] &gt; n &amp;&amp; atp[i - 1] &lt;= n) return printf(&quot;%d\n&quot;, atp[i - 1]); } return 0; } } int main() { flyinthesky::solve(); return 0; } 正解DFS剪枝： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL pri[15] = {2, 3, 5, 7, 11, 13, 17, 19, 23}; LL n, ans, ans_ys; void dfs(LL a, LL cur, LL ys, LL lstexp) { if (cur &lt;= n) { if (cur &gt; ans &amp;&amp; ys &gt; ans_ys) ans_ys = ys, ans = cur; if (cur &lt;= ans &amp;&amp; ys &gt;= ans_ys) ans_ys = ys, ans = cur; } if (a &gt; 8) return ; LL bs = 1, hh = 0; for (; cur * bs &lt;= n &amp;&amp; hh &lt;= lstexp; bs *= pri[a], ++hh) { dfs(a + 1, cur * bs, ys * (hh + 1), hh); } } void clean() { ans = 0, ans_ys = 0; } int solve() { clean(); scanf(&quot;%lld&quot;, &amp;n); dfs(0, 1, 1, 1000000000); printf(&quot;%lld\n&quot;, ans); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>DFS</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2017 Day2 T2(状压DP/爆搜)]]></title>
    <url>%2FNOIP2017tgD2T2%2F</url>
    <content type="text"><![CDATA[Loj 2318题意：如上。 70 分暴力：枚举每个点作为起点并加入集合，然后从集合中找点出来拓展节点继续加入集合，然后当图连通以后就更新答案，加上可行性和最优化剪枝。时间复杂度比较高但是能过去，DFS / 搜索 / 枚举不要约束在那个板子上。刚开始我想到是枚举整个图的生成树子集然后枚举起点计数，这样的复杂度太高了，我们调换一下搜索顺序，即先枚举起点后形成生成树子集后计数，这样免去了计数时增加的 $m$(去重以后) 的复杂度。据说爆搜剪枝剪得好能 AC Orz 100 分状压 DP :我们发现暴力的方法很多重复的枚举，所以我们尝试在爆搜中加入 DP 思想。本题 $n$ 小并且 $m$ 可以去重，所以就可以状压 DP 了。设$dp(S)$为当前开通的点的集合的最小代价，转移就枚举每一个在$S$中的点然后再找它的邻接点并且邻接点不在$S$后 DP 转移即可。主体程序很像，但是这个方法节约很多时间。 知识点：1、调换枚举顺序免除一些难处理的2、时间复杂度感觉会炸不一定会炸，大胆写，但也不要 sb，剪枝写上3、DFS 不好搜就按点枚举而不是 DFS，DFS 和搜索还是有区别4、选择转化为添加5、暴搜可以加入 DP 思想，所以 DP - 爆搜 - 记忆化搜索 三者有着密切关系100分： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;climits&gt; #include&lt;stack&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using std::cin; using std::cout; using std::endl; const int MAXN = 15, INF = 1000000000; int n, m, G[MAXN][MAXN], dp[(1 &lt;&lt; 13) + 5], dis[MAXN], ans; void dfs(int S) { //printf(&quot;S=%d\n&quot;, S); for (int u = 1; u &lt;= n; ++u) if ((1 &lt;&lt; (u - 1)) &amp; S) { for (int v = 1; v &lt;= n; ++v) if (((1 &lt;&lt; (v - 1)) &amp; S) == 0) { //printf(&quot;u=%d v=%d\n&quot;, u, v); if (G[u][v] == INF) continue; int st = 1 &lt;&lt; (v - 1); if (dp[S | st] &gt; dp[S] + G[u][v] * (dis[u] + 1)) { dis[v] = dis[u] + 1, dp[S | st] = dp[S] + G[u][v] * (dis[u] + 1); dfs(S | st); } } } } void clean() { ans = INF; for (int i = 0; i &lt;= n; i++) for (int j = 0; j &lt;= n; j++) G[i][j] = INF; } int solve() { clean(); for (int a, b, w, i = 1; i &lt;= m; i++) { scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;w); G[a][b] = std::min(G[a][b], w), G[b][a] = std::min(G[b][a], w); } /*for (int i = 0; i &lt;= n; i++) for (int j = 0; j &lt;= n; j++) printf(&quot;i=%d, j=%d, w=%d\n&quot;, i, j, G[i][j]);*/ for (int i = 1; i &lt;= n; i++) { ms(dis, 0); for (int j = 0; j &lt; (1 &lt;&lt; n); j++) dp[j] = INF; dp[0] = dp[1 &lt;&lt; (i - 1)] = 0; dfs((1 &lt;&lt; (i - 1))); ans = std::min(ans, dp[(1 &lt;&lt; n) - 1]); //for (int j = 0; j &lt; (1 &lt;&lt; n); j++) printf(&quot;i=%d, S=%d, dp=%d\n&quot;, i, j, dp[j]); } printf(&quot;%d\n&quot;, ans); return 0; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m), solve(); return 0; } 70分爆搜： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; #include&lt;queue&gt; #include&lt;climits&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double const int MAXN = 15; int n, m, ans, G[MAXN][MAXN], vis[MAXN], dis[MAXN]; void dfs(int a, int tmp) { if (tmp &gt;= ans) return ; if (a == n + 1) { ans = std::min(tmp, ans); //for (int i = 1; i &lt;= n; i++) printf(&quot;%d%c&quot;, dis[i], (i == n ? &#39;\n&#39; : &#39; &#39;)); return ; } for (int i = 1; i &lt;= n; i++) if (vis[i]) { for (int j = 1; j &lt;= n; j++) if (i != j &amp;&amp; G[i][j] != 1000000000 &amp;&amp; !vis[j]) { vis[j] = true, dis[j] = dis[i] + 1; dfs(a + 1, tmp + dis[j] * G[i][j]); vis[j] = false, dis[j] = 0; } } } void clean() { ans = 1000000000, ms(vis, 0); for (int i = 0; i &lt;= n; i++) for (int j = 0; j &lt;= n; j++) G[i][j] = 1000000000; } int solve() { clean(); for (int x, y, w, i = 1; i &lt;= m; i++) scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;w), G[x][y] = std::min(G[x][y], w), G[y][x] = std::min(G[y][x], w); for (int i = 1; i &lt;= n; i++) vis[i] = true, dis[i] = 0, dfs(2, 0), vis[i] = false; printf(&quot;%d\n&quot;, ans); return 0; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m), solve(); return 0; }]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>状压DP</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2017 Day1 T3(最短路+记忆化搜索/最短路+拓扑排序+DP)]]></title>
    <url>%2FNOIP2017tgD1T3%2F</url>
    <content type="text"><![CDATA[Loj 2316题意：$n$个点，$m$条边的有向图，$1$到$n$最短路为$d$, 求路径长度不超过$d+k$且长度大于等于$d$的路径条数，答案模$p$。本题 30 分做法直接 Dij 转移时顺带记录最短路条数。$dp(u)$为到$u$最短路$1,u$路径条数, $dp(u)=(\sum dp(v)|dis(1, v)+w=dis(1, u)), dp(u)=(dp(v)|dis(1, v)+w≠dis(1, u))$ 考虑 70 分无 0 边，那么我们可以用 30 分做法的 DP 思想来做。这里 $k$ 很小，所以 DP 状态中肯定有一维这个。所以在原基础上加维即可。设$dp(u,j)$为到$u$点$u , n$实际路径长比$u , n$最短路多$j$的路径条数。对于边$(u,v,w)$转移$dp(u,j)=\sum dp(v, j + dis_u - w - dis_{v})。 dis_i$是$(i,n)$最短路，可以记忆化搜索来做。或者如果枚举的顺序就要先更新$dis$ 大的状态，排序以后 DP 即可 然后就是有 0 边了，如果存在一个 0 环，那么这个路径条数将是无限大的，并且记忆化搜索会出现后效性。在记忆化搜索中，如果有一个状态还没有得出值但是被又访问了，那么图中存在 0 环。也可以将 0 边弄出来单独一个图做拓扑排序，用 0 边的拓扑序来更新，如果拓扑图中出现 0 环，那么原图中也有 0 环。 注意初值的问题，如果让$dp(n,0)=1$，最后答案是$\sum_{i=0}^k dp(1, i)$。如果让$dp(n,i)=1,0\leq i \leq k$, 那么最后答案是$dp(1, k)$。 知识点：1、最短路计数思想是 DP 思想2、任何最优化问题/计数问题都可能 DP，只要调换顺序能保证无后效性就能做3、DP 不想考虑顺序可以用记忆化搜索4、图中转移和拓扑序有关5、学一种做法要理解透彻他的思想，Floyd 是一种 DP 思想，本题也是一种 DP 思想6、数据小的要合理利用这个数据 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; #include&lt;queue&gt; #include&lt;climits&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double const int MAXN = 100000 + 5, MAXM = 200000 + 5, INF = 1000000000; struct edge {int v, w, nxt;} ed[MAXM * 2], ED2[MAXM * 2]; struct data {int u, dis; bool operator &lt; (const data &amp;b) const {return dis &gt; b.dis;} }; int n, m, k, p, en, EN2, flag, hd[MAXN], HD2[MAXN], vis[MAXN], dis[MAXN], dp[MAXN][55], ex[MAXN][55]; std::priority_queue&lt;data &gt; q; void ins(int u, int v, int w) {ed[++en] = (edge){v, w, hd[u]}, hd[u] = en;} void INS2(int u, int v, int w) {ED2[++EN2] = (edge){v, w, HD2[u]}, HD2[u] = EN2;} void dij() { for (int i = 0; i &lt;= n; i++) dis[i] = INF; q.push((data){n, 0}), dis[n] = 0; while (!q.empty()) { data b = q.top(); q.pop(); if (vis[b.u]) continue; vis[b.u] = true; for (int i = HD2[b.u]; i &gt; 0; i = ED2[i].nxt) { edge &amp;e = ED2[i]; if (dis[e.v] &gt; dis[b.u] + e.w) dis[e.v] = dis[b.u] + e.w, q.push((data){e.v, dis[e.v]}); } } } int f(int u, int j) { if (ex[u][j]) return flag = 1, -1; if (dp[u][j]) return dp[u][j]; ex[u][j] = 1; for (int i = hd[u]; i &gt; 0; i = ed[i].nxt) { edge &amp;e = ed[i]; int tmp = j + dis[u] - e.w - dis[e.v]; if (tmp &gt;= 0) dp[u][j] = (dp[u][j] + f(e.v, tmp)) % p; } return ex[u][j] = 0, dp[u][j]; } void clean() { flag = en = EN2 = 0, ms(hd, 0), ms(HD2, 0), ms(vis, 0), ms(dp, 0), ms(ex, 0); } int solve() { clean(); scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;k, &amp;p); for (int a, b, c, i = 1; i &lt;= m; i++) scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c), ins(a, b, c), INS2(b, a, c); dij(); //for (int i = 1; i &lt;= n; i++) printf(&quot;%d%c&quot;, dis[i], (i == n ? &#39;\n&#39; : &#39; &#39;)); int ans = 0; dp[n][0] = 1; for (int i = 0; i &lt;= k; i++) ans = (ans + f(1, i)) % p; //for (int i = 0; i &lt;= k; i++) printf(&quot;%d%c&quot;, dp[1][i], (i == k ? &#39;\n&#39; : &#39; &#39;)); if (flag) printf(&quot;-1\n&quot;); else printf(&quot;%d\n&quot;, ans); return 0; } int main() { int T; scanf(&quot;%d&quot;, &amp;T); while (T--) solve(); return 0; }]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>计数DP</tag>
        <tag>最短路</tag>
        <tag>拓扑排序</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1000E(Tarjan缩边-双连通分量+树的直径)]]></title>
    <url>%2FCodeforces1000E%2F</url>
    <content type="text"><![CDATA[Codeforces 1000E题意：一条路径上必经的边为关键边，现在让你找一条路径，使得其关键边最多，输出最多的数量。关键边就是无向图中的桥。而桥两边连的连通分量里面不可能有关键边(桥)，所以用 Tarjan 缩边-双连通分量，步骤与有向图相似。然后缩点后就只需要找一条路径最长了，因为缩点了所以最后出来的图就是一个树，所以求树的直径即可。知识点：1、一样的代码不要复制，手打2、缩点，树剖，单调队列注意前后序号的不同，一定要一个字符一个字符的查3、树的直径就是树中最长路径，长度是树中点对最短距离的最长距离4、无向图 Tarjan 缩连通分量，留下的边是桥 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;climits&gt; #include&lt;stack&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using std::cin; using std::cout; using std::endl; const int MAXN = 300000 + 5; struct edge {int v, nxt;} ed[MAXN * 2], ED2[MAXN * 2]; int n, m, en, EN2, hd[MAXN], HD2[MAXN]; int bcc_tot, bcc_belong[MAXN], sz, dfn[MAXN], low[MAXN]; std::stack&lt;int &gt; s; void ins(int x, int y) {ed[++en] = (edge){y, hd[x]}, hd[x] = en;} void INS2(int x, int y) {ED2[++EN2] = (edge){y, HD2[x]}, HD2[x] = EN2;} void tarjan(int u, int fa) { dfn[u] = low[u] = ++sz, s.push(u); for (int i = hd[u]; i &gt; 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (e.v == fa) continue; if (!dfn[e.v]) tarjan(e.v, u), low[u] = std::min(low[u], low[e.v]); else low[u] = std::min(low[u], dfn[e.v]);//这里最好加上判断是否在栈里，不写也能过 QAQ } if (low[u] == dfn[u]) { int e; bcc_tot++; do { e = s.top(); s.pop(); bcc_belong[e] = bcc_tot; } while (e != u); } } int dis[MAXN]; void dfs(int u, int fa) { dis[u] = dis[fa] + 1; for (int i = HD2[u]; i &gt; 0; i = ED2[i].nxt) { edge &amp;e = ED2[i]; if (e.v != fa) dfs(e.v, u); } } void clean() { en = EN2 = 0; ms(hd, 0), ms(HD2, 0); scc_tot = sz = 0, ms(dfn, 0); } int solve() { clean(); for (int x, y, i = 1; i &lt;= m; i++) scanf(&quot;%d%d&quot;, &amp;x, &amp;y), ins(x, y), ins(y, x); for (int i = 1; i &lt;= n; i++) if (!dfn[i]) tarjan(i, 0); for (int u = 1; u &lt;= n; u++) { for (int i = hd[u]; i &gt; 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (bcc_belong[u] != bcc_belong[e.v]) INS2(bcc_belong[u], bcc_belong[e.v]); } } ms(dis, 0); dfs(1, 0); int S = 1; for (int i = 2; i &lt;= bcc_tot; i++) if (dis[i] &gt; dis[S]) S = i; dfs(S, 0); int T = 1; for (int i = 2; i &lt;= bcc_tot; i++) if (dis[i] &gt; dis[T]) T = i; printf(&quot;%d\n&quot;, dis[T] - 1); return 0; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>Tarjan</tag>
        <tag>树的直径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1005F(最短路树+DFS)]]></title>
    <url>%2FCodeforces1005F%2F</url>
    <content type="text"><![CDATA[Codeforces 1005F题意：给你一个$n$个点$m$条边的无向图，要你选出$n-1$条边。你要在其中找到$k$种方案使得图连通并且 1 点到所有其他点距离之和最短。不足 $k$ 种就输出所有方案。 本题运用了最短路树的知识，最短路树就是一个点到其他点最短路的边组成的树。这个树可能有很多个。构造树的方法就是用最短路算法松弛时如果发现最短路相等，那么这里就有两条边可选进最短路树。这里边权都是1，直接 BFS 。然后 DFS 每个点选一条边进最短路树即可，注意这里可能数组开不下，vector.resize() 就排上用场了。 知识点：1 求最短路树长度相等时不要再入队, 否则计数会有重边2 要记得删除调试输出3 vector.resize() 的绝妙之处 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; #include&lt;queue&gt; #include&lt;climits&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double const int MAXN = 200000 + 5; struct data {int u, dis;}; struct edge {int v, ith, nxt;} ed[MAXN * 2]; int n, m, k, en, hd[MAXN], vis[MAXN], cnt, now[MAXN], fl; std::vector&lt;int &gt; pre[MAXN]; std::vector&lt;int &gt; ans[MAXN]; std::queue&lt;data &gt; q; inline void ins(int x, int y, int ith) { ed[++en] = (edge){y, ith, hd[x]}, hd[x] = en; ed[++en] = (edge){x, ith, hd[y]}, hd[y] = en; } void dfs(int a) { if (fl == 1) return ; if (a == n + 1) { ans[++cnt].resize(m + 1); for (int i = 0; i &lt; m; i++) ans[cnt][i] = now[i + 1]; if (cnt == k) fl = 1; return ; } for (int i = 0; i &lt; (int)pre[a].size(); i++) { int no = pre[a][i]; now[no] = 1, dfs(a + 1), now[no] = 0; if (fl == 1) return ; } } void clean() { en = 0, ms(hd, -1), ms(vis, 0); } int solve() { clean(); for (int a, b, i = 1; i &lt;= m; ++i) scanf(&quot;%d%d&quot;, &amp;a, &amp;b), ins(a, b, i); vis[1] = 1, q.push((data){1, 0}); while (!q.empty()) { data p = q.front(); q.pop(); for (int i = hd[p.u]; i &gt; 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (!vis[e.v]) { pre[e.v].push_back(e.ith); q.push((data){e.v, p.dis + 1}), vis[e.v] = p.dis + 1; } else if (vis[e.v] == p.dis + 1) pre[e.v].push_back(e.ith); } } /*for (int i = 1; i &lt;= n; ++i) { for (int j = 0; j &lt; (int)pre[i].size(); j++) printf(&quot;%d &quot;, pre[i][j]); printf(&quot;\n&quot;); }*/ ms(now, 0); fl = 0, dfs(2); printf(&quot;%d\n&quot;, cnt); for (int i = 1; i &lt;= cnt; ++i) { for (int j = 0; j &lt; m; ++j) printf(&quot;%d&quot;, ans[i][j]); printf(&quot;\n&quot;); } return 0; } int main() { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>最短路</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1051D(状压DP)]]></title>
    <url>%2FCodeforces1051D%2F</url>
    <content type="text"><![CDATA[Codeforces 1051D题意：给一个$2$行$n$列的矩阵填上黑色和白色，求连通块个数为$k$个的填色方案数量。好像这题和之前 edu 一题很像……刚开始可以想到$dp(i,j,k)$为第$i$行第$j$列有$k$个连通分量的方案数，但是转移比较困难，不知道前面那一列的颜色，用包含行的状态也不好进行转移，所以我们要删去行的状态，增加颜色的状态，这里可以利用状压 DP 思想将最后一行状态压起来，问题就基本上能解决了。$dp(j, k, st)$表示前$j$列有$k$个连通分量，$j$列的状态为$st$的方案数，然后转移即可。具体转移看代码即可，太长了……知识点：1、DP 状态如果不方便转移，要想一想为什么不方便转移，是否能增加状态或者排序贪心等。增加状态也不一定只能增加一个，可以增加2个甚至很多个，可以使用状压的方法。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; #include&lt;queue&gt; #include&lt;climits&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double const LL MO = 998244353, MAXN = 2005; const LL st00 = 0, st01 = 1, st10 = 2, st11 = 3; LL n, k, dp[MAXN][MAXN][5]; void clean() { ms(dp, 0); } int solve() { clean(); dp[1][1][st00] = dp[1][1][st11] = dp[1][2][st01] = dp[1][2][st10] = 1; for (LL j = 2; j &lt;= n; j++) { for (LL x = 0; x &lt;= k; x++) { if (x - 2 &gt;= 0) dp[j][x][st01] = (dp[j][x][st01] + dp[j - 1][x - 2][st10]) % MO; if (x - 1 &gt;= 0) dp[j][x][st01] = (dp[j][x][st01] + dp[j - 1][x - 1][st11]) % MO, dp[j][x][st01] = (dp[j][x][st01] + dp[j - 1][x - 1][st00]) % MO; dp[j][x][st01] = (dp[j][x][st01] + dp[j - 1][ x ][st01]) % MO; if (x - 2 &gt;= 0) dp[j][x][st10] = (dp[j][x][st10] + dp[j - 1][x - 2][st01]) % MO; if (x - 1 &gt;= 0) dp[j][x][st10] = (dp[j][x][st10] + dp[j - 1][x - 1][st11]) % MO, dp[j][x][st10] = (dp[j][x][st10] + dp[j - 1][x - 1][st00]) % MO; dp[j][x][st10] = (dp[j][x][st10] + dp[j - 1][ x ][st10]) % MO; dp[j][x][st00] = (dp[j][x][st00] + dp[j - 1][ x ][st10]) % MO; if (x - 1 &gt;= 0) dp[j][x][st00] = (dp[j][x][st00] + dp[j - 1][x - 1][st11]) % MO; dp[j][x][st00] = (dp[j][x][st00] + dp[j - 1][ x ][st01]) % MO; dp[j][x][st00] = (dp[j][x][st00] + dp[j - 1][ x ][st00]) % MO; dp[j][x][st11] = (dp[j][x][st11] + dp[j - 1][ x ][st10]) % MO; if (x - 1 &gt;= 0) dp[j][x][st11] = (dp[j][x][st11] + dp[j - 1][x - 1][st00]) % MO; dp[j][x][st11] = (dp[j][x][st11] + dp[j - 1][ x ][st01]) % MO; dp[j][x][st11] = (dp[j][x][st11] + dp[j - 1][ x ][st11]) % MO; } } printf(&quot;%lld\n&quot;, (dp[n][k][st00] + dp[n][k][st11] + dp[n][k][st01] + dp[n][k][st10]) % MO); return 0; } int main() { scanf(&quot;%lld%lld&quot;, &amp;n, &amp;k), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>计数DP</tag>
        <tag>状压DP</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1051F(最短路+生成树+树图结合)]]></title>
    <url>%2FCodeforces1051F%2F</url>
    <content type="text"><![CDATA[Codeforces 1051F题意：给出一个边比点数多至多$20$条的无向连通图，每条边有一个边权，多次询问两点间最短路。由于特殊条件，我们可以随便建一棵生成树(又称 DFS 树)，然后就会只有最多$20$条边不在树中。对于每个二元组询问$(u,v)$，我们答案有两种情况：1、只走树上的边2、必须经过一条树外的边对于第一个很容易用 LCA 求出来。对于第二个，我们记录这条边的一个顶点$i$，然后用 dij 求出顶点的单源最短路，必走这条边的代价等价于$dis(i,u)+dis(i,v)$，因为这样的路径$(u,v)$就能覆盖这条边。两个情况取最小值即可。知识点：1、这种有特殊性题目可以将图转化为树，noip 货车运输是同样的思想，区别在于本题是随便一个生成树( DFS 树)，而 noip 那题是要最小生成树2、本题也一定程度上与 相同，最短路之后枚举边求解 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; #include&lt;queue&gt; #include&lt;climits&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double const LL MAXN = 100000 + 5, LOGS = 17, INF = 300000000000005ll; struct edge {LL u, v, d;}; struct data { LL u, d; bool operator &lt; (const data &amp;b) const {return d &gt; b.d;} }; std::vector&lt;edge &gt; G[MAXN]; std::set&lt;std::pair&lt;LL, LL&gt; &gt; nt; std::priority_queue&lt;data &gt; q; LL n, m, Q, vis[MAXN], dep[MAXN], pre[MAXN][30], h[MAXN], dis[50][MAXN]; void dfs(LL u, LL fa) { dep[u] = dep[fa] + 1, vis[u] = 1, pre[u][0] = fa; for (LL i = 1; i &lt;= LOGS; i++) pre[u][i] = pre[pre[u][i - 1]][i - 1]; for (LL i = 0; i &lt; (LL)G[u].size(); i++) { edge &amp;e = G[u][i]; if (e.v != fa &amp;&amp; !vis[e.v]) { h[e.v] = h[u] + e.d; dfs(e.v, u); if (u &lt; e.v) nt.erase(std::make_pair(u, e.v)); else nt.erase(std::make_pair(e.v, u)); } } } void dij(LL st, LL d[MAXN]) { for (LL i = 0; i &lt;= n; i++) d[i] = INF, vis[i] = 0; d[st] = 0, q.push((data){st, 0}); while (!q.empty()) { data p = q.top(); q.pop(); if (vis[p.u]) continue; vis[p.u] = 1; for (LL i = 0; i &lt; (LL)G[p.u].size(); i++) { edge &amp;e = G[p.u][i]; if (d[e.v] &gt; d[p.u] + e.d) d[e.v] = d[p.u] + e.d, q.push((data){e.v, d[e.v]}); } } } LL LCA(LL a, LL b) { if (dep[a] &lt; dep[b]) std::swap(a, b); for (LL i = LOGS; i &gt;= 0; i--) if (dep[pre[a][i]] &gt;= dep[b]) a = pre[a][i]; if (a == b) return a; for (LL i = LOGS; i &gt;= 0; i--) if (pre[a][i] != pre[b][i]) a = pre[a][i], b = pre[b][i]; return pre[a][0]; } LL getdist(LL u, LL v) {return h[u] + h[v] - 2 * h[LCA(u, v)];} void clean() { ms(h, 0), ms(vis, 0), ms(dep, 0); } int solve() { clean(); for (LL u, v, d, i = 1; i &lt;= m; i++) { scanf(&quot;%lld%lld%lld&quot;, &amp;u, &amp;v, &amp;d); G[u].push_back((edge){u, v, d}), G[v].push_back((edge){v, u, d}); if (u &lt; v) nt.insert(std::make_pair(u, v)); else nt.insert(std::make_pair(v, u)); } dfs(1, 0); //for (LL i = 0; i &lt; (LL)nt.size(); i++) printf(&quot;u=%lld v=%lld d=%lld\n&quot;, nt[i].u, nt[i].v, nt[i].d); LL cnt = 0; for (std::set&lt;std::pair&lt;LL, LL&gt; &gt;::iterator it = nt.begin(); it != nt.end(); it++) { std::pair&lt;LL, LL&gt; e = *it; LL &amp;u = e.first, &amp;v = e.second; //printf(&quot;u=%lld v=%lld d=%lld\n&quot;, nt[i].u, nt[i].v, nt[i].d); if (u &gt; v) continue; dij(u, dis[++cnt]); } //for (LL i = 1; i &lt;= n; i++) for (LL j = 1; j &lt;= n; j++) printf(&quot;i=%lld j=%lld lca=%lld\n&quot;, i, j, LCA(i, j)); scanf(&quot;%lld&quot;, &amp;Q); while (Q--) { LL u, v; scanf(&quot;%lld%lld&quot;, &amp;u, &amp;v); LL ans = getdist(u, v); for (LL i = 1; i &lt;= cnt; i++) { ans = std::min(ans, dis[i][u] + dis[i][v]); } printf(&quot;%lld\n&quot;, ans); } return 0; } int main() { scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>最短路</tag>
        <tag>生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1047C(数论GCD+质因数+线性筛)]]></title>
    <url>%2FCodeforces1047C%2F</url>
    <content type="text"><![CDATA[Codeforces 1047C题意：给你一个序列，你需要删除其中一些数使得序列GCD比原序列GCD大。将所有数除以 GCD，然后现在对数进行质因数分解，那么每个质因子都可以乘回 原序列GCD 然后比 原序列GCD 大。但是质因数分解这里时间不太够，我们可以线性筛，用质数去找它的倍数，统计一下有几个数在序列中，越多越好，这样删的数就越少(我数论太弱了，筛选都不会，GG知识点：1、线性筛时间复杂度大约$O(nlog(logn))$2、将数字除以 GCD 数很好的思路 //==========================Head files========================== #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;iostream&gt; #define LL long long #define db double #define mp make_pair #define pr pair&lt;int, int&gt; #define fir first #define sec second #define pb push_back #define ms(i, j) memset(i, j, sizeof i) using namespace std; //==========================Templates========================== inline int read() { int x = 0, f = 1; char c = getchar(); while(c &lt; &#39;0&#39; || c &gt; &#39;9&#39;){if (c == &#39;-&#39;) f = -1; c = getchar();} while(c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;){x = x * 10 + c - &#39;0&#39;; c = getchar();} return x * f; } inline LL readl() { LL x = 0, f = 1; char c = getchar(); while(c &lt; &#39;0&#39; || c &gt; &#39;9&#39;){if (c == &#39;-&#39;) f = -1; c = getchar();} while(c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;){x = x * 10 + c - &#39;0&#39;; c = getchar();} return x * f; } int power(int a, int b) { int ans = 1; while (b) { if(b &amp; 1) ans = ans * a; b &gt;&gt;= 1; a = a * a; } return ans; } int power_mod(int a, int b, int mod) { a %= mod; int ans = 1; while (b) { if(b &amp; 1) ans = (ans * a) % mod; b &gt;&gt;= 1, a = (a * a) % mod; } return ans; } LL powerl(LL a, LL b) { LL ans = 1ll; while (b) { if(b &amp; 1ll) ans = ans * a; b &gt;&gt;= 1ll;a = a * a; } return ans; } LL power_modl(LL a, LL b, LL mod) { a %= mod; LL ans = 1ll; while (b) { if(b &amp; 1ll) ans = (ans * a) % mod; b &gt;&gt;= 1ll, a = (a * a) % mod; } return ans; } LL gcdl(LL a, LL b) {return b == 0 ? a : gcdl(b, a % b);} LL abssl(LL a) {return a &gt; 0 ? a : -a;} int gcd(int a, int b) {return b == 0 ? a : gcd(b, a % b);} int abss(int a) {return a &gt; 0 ? a : -a;} //==========================Main body========================== #define LD &quot;%I64d&quot; #define D &quot;%d&quot; #define pt printf #define sn scanf #define pty printf(&quot;YES\n&quot;) #define ptn printf(&quot;NO\n&quot;) //==========================Code here========================== LL n, a[300000 + 5]; LL fac[15000000 + 5], vis[15000000 + 5], g = 0ll, mks = 0ll; int main() { ms(fac, 0), ms(vis, 0); cin &gt;&gt; n; for (LL i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;a[i]), g = gcdl(a[i], g); for (LL i = 1; i &lt;= n; i++) a[i] /= g, fac[a[i]]++, mks = max(mks, a[i]); LL ans = 0; for (LL i = 2; i &lt;= mks; i++) { LL tmp = 0ll; if (!vis[i]) for (LL j = i; j &lt;= mks; j += i) { vis[j] = 1, tmp += fac[j]; } ans = max(ans, tmp); } if (ans == 0) cout &lt;&lt; -1; else cout &lt;&lt; n - ans; return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>GCD</tag>
        <tag>Codeforces</tag>
        <tag>数学</tag>
        <tag>线性筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1042F(贪心+合并思想)]]></title>
    <url>%2FCodeforces1042F%2F</url>
    <content type="text"><![CDATA[Codeforces 1042F题意：无向无根树$n$个点，要将树叶分成集合，使得每个集合中任意两个叶子距离小于等于$k$，问能最少分成几个集合？题目是最优化问题。所以我们可以考虑贪心 / DP 等方法。本题要将无根树转化成有根树。之前做过一题不会把1当做根，这题如果用1会出问题(1可能是叶子)，具体看样例2。所以我们要选一个不是叶子的点作为根即可。知道这个然后就是(下文来自此处，侵删)对于每一个儿子，保存最大距离的叶子(合并思想)，然后排序之后，找到一个$R​$使得$[1,R]​$可以在一个集合内(集合中任意两个数大小不大于$k​$求法)。然后将$[R+1,son]$内的点都各自成立一个集合。然后这个节点作为儿子的返回值为R点的$dis+1$。(感性理解一下，集合中任意两个数大小大于$k$，不能并到其他集合了) 本题几个要点:1、根的选取 2、最长距离才有用 3、集合中任意两个数大小小于$k$求法知识点：1、集合中任意两个数大小不大于$k$，那么可以排序然后如果存在$a_{i-1}+a_i \leq k$，那么$i$是一个临界点，左边的(包含临界点)任意两个数大小小于$k$，右边反之。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;climits&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double const int MAXN = 1000000 + 5; struct edge { int v, nxt; }ed[MAXN * 2]; int rt, n, k, hd[MAXN], deg[MAXN], en, ans; void ins(int x, int y) { ed[++en] = (edge){y, hd[x]}, hd[x] = en; ed[++en] = (edge){x, hd[y]}, hd[y] = en; deg[x]++, deg[y]++; } int dfs(int u, int fa) { std::vector&lt;int &gt; vec; for (int i = hd[u]; i &gt; 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (e.v != fa) vec.push_back(dfs(e.v, u) + 1); } if (vec.empty()) return 0; std::sort(vec.begin(), vec.end()); int sz = (int)vec.size() - 1; for (; sz &gt;= 1; ) { if (vec[sz - 1] + vec[sz] &lt;= k) break; sz--, ans++; } return vec[sz]; } void clean() { ms(deg, 0), ms(hd, 0), en = 0; } int solve() { clean(); for (int x, y, i = 1; i &lt; n; i++) scanf(&quot;%d%d&quot;, &amp;x, &amp;y), ins(x, y); for (int i = 1; i &lt;= n; i++) if (deg[i] &gt; 1) rt = i; dfs(rt, 0); printf(&quot;%d\n&quot;, ans + 1); return 0; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;k), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>Codeforces</tag>
        <tag>合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1042D(权值树状数组+前缀和/非旋Treap+前缀和)]]></title>
    <url>%2FCodeforces1042D%2F</url>
    <content type="text"><![CDATA[Codeforces 1042D题意：给出一个序列，求出有多少个区间满足区间和小于$t$。解：先处理前缀和$pre$，对于题目$pre_r-pre_l &lt; t$成立即可。移项$pre_r-t &lt; pre_l$，那么只需要检查$[1,i)$中的$pre_i$有多少个大于$pre_r-t$即可，右边不取因为前缀和的定义。这里方便没有将$l$写作$l-1$。可以取反做，也可以正着做。然后就是求$[1,i)$有多少个大于$x$的数了。这个如果直接维护序列下标很难求，我们可以用树状数组维护值域，然后询问区间和就行了，但是要离散化。这题也可以维护下标，用一个平衡树求 $rk$ 即可。知识点：对于区间维护，可以有两种形式1、维护序列下标2、维护值域对于这个区间比某数大的，要想到在值域开线段树/树状数组 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const LL MAXN = 200000 + 5; struct Treap *null, *pit, *root;//自建的null节点，内存池指针 struct Treap { LL key, val, s;//键值(满足排序二叉树性质)，附加值(满足堆性质)，以本节点为根的子树大小 Treap *lc, *rc;//Treap 左右结点 Treap() {}; void init(LL key) {this-&gt;key = key, val = rand(), lc = rc = null, s = 1;}//初始化 void maintain() {s = lc-&gt;s + rc-&gt;s + 1;}//更新，维护以本节点为根的子树大小 }pool[MAXN];//内存池 Treap* newNode(LL key) { pit-&gt;init(key); return pit++; } Treap* merge(Treap *a, Treap *b) {//合并两棵Treap，所有key(a)&lt;key(b)才能合并，为了满足排序二叉树性质 if (a == null) return b; if (b == null) return a; if (a-&gt;val &lt; b-&gt;val) { a-&gt;rc = merge(a-&gt;rc, b), a-&gt;maintain(); //a小自然a要在b的上面，满足堆性质 return a; } if (a-&gt;val &gt;= b-&gt;val) { b-&gt;lc = merge(a, b-&gt;lc), b-&gt;maintain(); //a大自然a要在b的下面，满足堆性质 return b; } } void split_v(Treap *o, LL v, Treap *&amp;x, Treap *&amp;y) {//用权值分开一棵Treap，分开的第一棵根为x，第二棵根为y。x，y可以称为左右子树“下一个”位置，也就是如果还有满足左边的，就放在x或者y的位置 if (o == null) x = y = null; else { if (o-&gt;key &lt;= v) { x = o, split_v(o-&gt;rc, v, o-&gt;rc, y);//x = o说明o左边全部放进x，递归右子树 } else y = o, split_v(o-&gt;lc, v, x, o-&gt;lc); o-&gt;maintain(); } } void split_k(Treap *o, LL k, Treap *&amp;x, Treap *&amp;y) {//按前k个分配分开一棵Treap，分开的第一棵根为x，第二棵根为y。x，y可以称为左右子树“下一个”位置，也就是如果还有满足左边的，就放在x或者y的位置 if (o == null) x = y = null; else { if (k &lt;= o-&gt;lc-&gt;s) { y = o, split_k(o-&gt;lc, k, x, o-&gt;lc);//y = o说明o右边全部放进y，递归左子树 } else x = o, split_k(o-&gt;rc, k - o-&gt;lc-&gt;s - 1, o-&gt;rc, y); o-&gt;maintain(); } } void insert(LL v) {//插入一个数 Treap *a, *b; split_v(root, v, a, b); root = merge(merge(a, newNode(v)), b); } void del(LL v) {//删除一个数 Treap *a, *b; split_v(root, v, a, b); Treap *c, *d; split_v(a, v - 1, c, d); d = merge(d-&gt;lc, d-&gt;rc); a = merge(c, d), root = merge(a, b); } LL kth(LL k) {//查询排名为k的数 Treap *a, *b; split_k(root, k - 1, a, b); Treap *c, *d; split_k(b, 1, c, d); LL ret = c-&gt;key; b = merge(c, d), root = merge(a, b); return ret; } LL rk(LL x) {//查询x的排名 Treap *a, *b; split_v(root, x, a, b); LL ret = a-&gt;s; root = merge(a, b); return ret; } LL pre(LL x) {//求x的前驱 Treap *a, *b; split_v(root, x - 1, a, b); Treap *c, *d; split_k(a, a-&gt;s - 1, c, d); LL ret = d-&gt;key; a = merge(c, d), root = merge(a, b); return ret; } LL succ(LL x) {//求x的后继 Treap *a, *b; split_v(root, x, a, b); Treap *c, *d; split_k(b, 1, c, d); LL ret = c-&gt;key; b = merge(c, d), root = merge(a, b); return ret; } void initTreap() { srand(19660813);//置随机数种子 pit = pool;//指针指向内存池 null = newNode(0), null-&gt;s = 0;//初始化自建的null节点 root = null;//初始化树根 } LL n, t, pr[200000 + 5]; void clean() {} void solve() { clean(); initTreap(); scanf(&quot;%lld%lld&quot;, &amp;n, &amp;t); pr[0] = 0; insert(pr[0]); LL ans = 0; for (LL x, i = 1; i &lt;= n; i++) { scanf(&quot;%lld&quot;, &amp;x), pr[i] = pr[i - 1] + x; ans += rk(pr[i] - t); insert(pr[i]); } printf(&quot;%lld\n&quot;, 1ll * n * (n + 1) / 2 - ans); } int main() { solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>Codeforces</tag>
        <tag>前缀和</tag>
        <tag>Treap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1433」「ZJOI2009」假期的宿舍 (二分图最大匹配)]]></title>
    <url>%2Fbzoj1433%2F</url>
    <content type="text"><![CDATA[BZOJ 1433题意：见上。本题很容易看出是一个二分图最大匹配的题目。将左边点抽象化为人，右边为床，边就是分配。然后分类讨论一下连边情况，最后看二分图最大匹配是否等于要安排的人即可。知识点：1、初始化数组要全部初始化，输入数组也要初始化2、赋值时考虑是否会覆盖之前的值 #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;climits&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define ULL unsigned long long #define db double const int MAXN = 55; int n, a[MAXN], b[MAXN], ma[MAXN][MAXN], lk[MAXN], vis[MAXN], cnt; bool hungary(int u) { for (int v = 1; v &lt;= n; v++) if (ma[u][v]) { if (vis[v] != cnt) { vis[v] = cnt; if (!lk[v] || hungary(lk[v])) { lk[v] = u; return true; } } } return false; } void clean() { ms(ma, 0), ms(lk, 0), ms(vis, 0); } int solve() { clean(); int ans = 0, tot = 0; for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]), tot += (!a[i]); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;b[i]), tot += (a[i] == 1 &amp;&amp; b[i] == 0); for (int i = 1; i &lt;= n; i++) for (int x, j = 1; j &lt;= n; j++) { scanf(&quot;%d&quot;, &amp;x); if (i == j &amp;&amp; a[i] == 1 &amp;&amp; b[i] == 0) {ma[i][j] = 1; continue;} if (a[j] == 1) ma[i][j] = x; } for (int i = 1; i &lt;= n; i++) if ((!a[i]) || (a[i] == 1 &amp;&amp; b[i] == 0)) ans += hungary(cnt = i); if (ans == tot) printf(&quot;^_^\n&quot;); else printf(&quot;T_T\n&quot;); return 0; } int main() { int T; scanf(&quot;%d&quot;, &amp;T); while (T--) scanf(&quot;%d&quot;, &amp;n), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1880」「Sdoi2009」Elaxia的路线 (最短路+枚举/最短路图+拓扑排序+DP)]]></title>
    <url>%2Fbzoj1880%2F</url>
    <content type="text"><![CDATA[BZOJ 1880题意：求出$s_1$到$t_1$的最短路径与$s_2$到$t_2$的最短路径的最长公共长度是多少。解：我们求出四个点出发的单源最短路，然后枚举一条路径$(i,j)$，判断这条路径是否在两条最短路上，用公式算出公共长度，然后更新答案即可。Hack，枚举的路径不一定在两条最短路径的公共路径上，必须要先预处理出每个点是否在公共路径上，因为每次枚举的最短路径端点都要在公共路径上。知识点：本题运用了最短路加枚举，与CF 544D思路类似。 最短路图+拓扑排序+DP 做法：最短路图：所有$dis(s,i)+dis(j,t)=dis(s,t)$的边$(i,j)$组成的 DAG 图将$s_1$到$t_1$最短路图求出来并且和$s_2$到$t_2$的最短路径求交，然后在 DAG 图上按照拓扑序求最长路。 #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;climits&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define ULL unsigned long long #define db double const int MAXN = 1505, INF = 1000000000, Z = 1, F = 0; struct edge { int v, w, nxt; }ed[2250000 + 5]; int en, hd[MAXN]; struct data { int u, dis; bool operator &lt; (const data &amp;b) const {return dis &gt; b.dis;} }; int n, m, s[2], t[2], dis[2][2][MAXN], vis[MAXN], whw[MAXN]; std::priority_queue&lt;data &gt; q; inline void ins(int x, int y, int w) { ed[++en] = (edge){y, w, hd[x]}, hd[x] = en; ed[++en] = (edge){x, w, hd[y]}, hd[y] = en; } void dij(int Ty, int zf) { ms(vis, 0); if (zf == Z) q.push((data){s[Ty], 0}), dis[Ty][zf][s[Ty]] = 0; else q.push((data){t[Ty], 0}), dis[Ty][zf][t[Ty]] = 0; while (!q.empty()) { data p = q.top(); q.pop(); if (vis[p.u]) continue; vis[p.u] = 1; for (int i = hd[p.u]; i &gt; 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (dis[Ty][zf][e.v] &gt; dis[Ty][zf][p.u] + e.w) { dis[Ty][zf][e.v] = dis[Ty][zf][p.u] + e.w; q.push((data){e.v, dis[Ty][zf][e.v]}); } } } } void clean() { ms(whw, 0), ms(hd, -1); for (int i = 0; i &lt; 2; i++) for (int j = 0; j &lt;= n; j++) dis[i][0][j] = dis[i][1][j] = INF; } int solve() { clean(); for (int x, y, w, i = 1; i &lt;= m; i++) scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;w), ins(x, y, w); dij(0, Z), dij(1, Z), dij(0, F), dij(1, F); for (int u = 1; u &lt;= n; u++) { for (int i = hd[u]; i &gt; 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (dis[0][Z][u] + e.w + dis[0][F][e.v] == dis[0][Z][t[0]] &amp;&amp; dis[1][Z][u] + e.w + dis[1][F][e.v] == dis[1][Z][t[1]]) whw[u] = whw[e.v] = 1; if (dis[0][Z][u] + e.w + dis[0][F][e.v] == dis[0][Z][t[0]] &amp;&amp; dis[1][Z][e.v] + e.w + dis[1][F][u] == dis[1][Z][t[1]]) whw[u] = whw[e.v] = 1; } } int ans = 0; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { if (!whw[i] || !whw[j]) continue;//不在公共路径 int &amp;t1 = t[0], &amp;t2 = t[1]; //1 int gg = dis[0][Z][t1] - dis[0][Z][i] - dis[0][F][j]; if ((dis[0][Z][t1] == dis[0][Z][i] + gg + dis[0][F][j]) &amp;&amp; (dis[1][Z][t2] == dis[1][Z][i] + gg + dis[1][F][j]) &amp;&amp; (gg &gt; ans)) ans = gg; //2 gg = dis[0][Z][t1] - dis[0][Z][i] - dis[0][F][j]; if ((dis[0][Z][t1] == dis[0][Z][i] + gg + dis[0][F][j]) &amp;&amp; (dis[1][Z][t2] == dis[1][Z][j] + gg + dis[1][F][i]) &amp;&amp; (gg &gt; ans)) ans = gg; } } printf(&quot;%d\n&quot;, ans); return 0; } int main() { scanf(&quot;%d%d%d%d%d%d&quot;, &amp;n, &amp;m, &amp;s[0], &amp;t[0], &amp;s[1], &amp;t[1]), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>Bzoj</tag>
        <tag>最短路</tag>
        <tag>枚举</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu 1119(Floyd方程理解)]]></title>
    <url>%2FLuogu1119%2F</url>
    <content type="text"><![CDATA[1119 灾后重建解：对于 Floyd 的方程式$dp(k, i, j)$是只有前$k$个点中$i$到$j$的最短路径，对于转移, 路径$(i,j)$有过$k$点或者不过$k$两种状态。然后滚动数组得到普遍的那个方程。对于这题因为$t_i$单调递增，并且询问$t$也单调递增，所以每次相当于加入一些点。Floyd 的方程就能完成这一点。每次更新到只有前$k$个点即可，这$k$个点都是重建完的。答案就是$ma_{ij}$，并且起点终点重建完了。 知识点： Floyd 的方程式$dp(k, i, j)$是只有前$k$个点中$i$到$j$的最短路径此题与CF 1037D都采用了将第一层循环灵活运用的方法。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double const int MAXN = 200 + 5, INF = 1000000000; int n, m, ti[MAXN], ma[MAXN][MAXN], Q; void floyd(int k) { for (int i = 0; i &lt;= n; i++) for (int j = 0; j &lt;= n; j++) if (i != j &amp;&amp; i != k &amp;&amp; k != j) ma[i][j] = std::min(ma[i][j], ma[i][k] + ma[k][j]); } void clean() { for (int i = 0; i &lt;= n + 1; i++) ti[i] = INF; for (int i = 0; i &lt;= n + 1; i++) for (int j = 0; j &lt;= n + 1; j++) ma[i][j] = INF; } int solve() { clean(); for (int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;ti[i]); for (int x, y, w, i = 1; i &lt;= m; i++) scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;w), ma[x][y] = ma[y][x] = w; scanf(&quot;%d&quot;, &amp;Q); int now = 0; while (Q--) { int x, y, t; scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;t); while (ti[now] &lt;= t) { floyd(now), now++; } //printf(&quot;now = %d, ma[x][y] = %d\n&quot;, now, ma[x][y]); if (ti[x] &gt; t || ti[y] &gt; t || ma[x][y] == INF) {printf(&quot;-1\n&quot;); continue; } printf(&quot;%d\n&quot;, ma[x][y]); } return 0; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m), solve(); return 0; }]]></content>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1028E(模拟)]]></title>
    <url>%2FCodeforces1028E%2F</url>
    <content type="text"><![CDATA[Codeforces 1028E题意：给你一个环$b$，要你构造一个环$a$，满足$a_i \% a_{i + 1}=b_i$ 设$max(b)=mks$，要找到一个数$i$使得$b_i=mks$并且$b_{i-1} &lt; b_i$然后让$a_i=b_i$，然后后面的就按照$a_i=b_{i+1}+b_i$来算。对于前面的约束也很清楚了，否则余数不对。然后就是注意无解当且仅当所有数相同并且不是$0$。然后还要对$0$作出特判。1、所有数都是$0$，直接输出$n$个相同数即可2、如果当前$b_i=0​$并且$a_i=mks​$，那么$a_i​$要乘$2​$，否则无法通过下面数据 5 0 0 0 100 0 #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define ULL unsigned long long #define db double LL n, b[200000 + 5], a[200000 + 5], pos = 1, flag = true, mks; void clean() { } int solve() { clean(); for (LL i = 1; i &lt;= n; i++) { scanf(&quot;%lld&quot;, &amp;b[i]); if (b[pos] &lt; b[i]) pos = i; if (i != 1 &amp;&amp; b[i] != b[i - 1]) flag = false; } if (flag &amp;&amp; b[1] &gt; 0) return printf(&quot;NO\n&quot;), 0;// mks = b[pos]; for (LL i = 1; i &lt;= n; i++) { LL now; if (i - 1 &lt;= 0) now = n; else now = i - 1; if (b[i] != b[now] &amp;&amp; b[i] == mks) { pos = i; break; } } a[pos] = b[pos]; if (a[pos] == 0) { printf(&quot;YES\n&quot;); for (LL i = 1; i &lt;= n; i++) printf(&quot;%lld &quot;, 233ll); return 0; }//0 LL cnt = 1; while (cnt &lt;= n - 1) { LL now; if (pos - 1 &lt;= 0) now = n; else now = pos - 1; a[now] = a[pos] + b[now]; if (b[now] == 0 &amp;&amp; a[now] == mks) a[now] *= 2ll;//0 cnt++, pos = now; } printf(&quot;YES\n&quot;); for (LL i = 1; i &lt;= n; i++) printf(&quot;%lld &quot;, a[i]); return 0; } int main() { scanf(&quot;%lld&quot;, &amp;n), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1027E(DP+乘法原理)]]></title>
    <url>%2FCodeforces1027E%2F</url>
    <content type="text"><![CDATA[Codeforces 1027E题意：给出一个正方形，要求在每个位置涂上黑/白色，要求满足：任意相邻的两行，其颜色要么完全相同，要么完全相反。任意相邻的两列，其颜色也要么相同要么完全相反。且这个矩形中，不存在任意一个大小大于等于$k$的同色矩形。 对于”满足：任意相邻的两行，其颜色要么完全相同，要么完全相反。任意相邻的两列，其颜色也要么相同要么完全相反。”，也就是说只要确定正方形一行一列，整个正方形都被确定。那么我们设确定的行的黑白情况是$a_i$, 列是$b_i$，对于$(i,j)$的颜色即为$a_i xor b_i$那么我们就考虑如何满足不存在任意一个大小大于等于$k$的同色矩形。显然就是$a_i$最大连续的一段和$b_i$最大连续的一段的乘积不能大小大于等于$k$。那么我们用 DP 求出序列上最大连续的一段为$x$的方案数就可以用乘法原理做了。但是发现这个状态并不容易求，那么我们就求序列上最大连续的一段小于等于$x$的方方案，对于等于，就是$dp(i)-dp(i-1)$算出来。所以设$dp(i,j)$为前$i$个数最大连续的一段为$j$的方案数。那么$dp(i,j)=dp(i-k,j), 1 \leq k \leq min(i,j)$然后统计答案就可以了。 知识点：要善于发掘题目条件对解题的限制 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double const LL MAXN = 505, MO = 998244353; LL n, K, dp[MAXN][MAXN], ans[MAXN]; void clean() { } int solve() { clean(); for (LL i = 1; i &lt;= n; i++) { dp[i][0] = 1; for (LL j = 1; j &lt;= n; j++) for (LL k = 1; k &lt;= std::min(i, j); k++) dp[i][j] = (dp[i][j] + dp[i][j - k]) % MO; } for (LL i = 1; i &lt;= n; i++) ans[i] = (dp[i][n] - dp[i - 1][n] + MO) % MO; LL ret = 0; for (LL i = 1; i &lt;= n; i++) for (LL j = 1; j &lt;= n; j++) if (i * j &lt; K) ret = (ret + (ans[i] * ans[j]) % MO) % MO; printf(&quot;%lld\n&quot;, (ret * 2ll) % MO); return 0; } int main() { scanf(&quot;%lld%lld&quot;, &amp;n, &amp;K), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>计数DP</tag>
        <tag>计数原理</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1037E(类似拓扑排序)]]></title>
    <url>%2FCodeforces1037E%2F</url>
    <content type="text"><![CDATA[Codeforces 1037E题意：有$n$个人，$m$天，每天晚上都会有一次聚会，一个人会参加一场聚会当且仅当聚会里有至少$k$个人是他的朋友。每天早上都会有一对人成为好朋友，问每天晚上最多能有多少人参加聚会。朋友关系不满足传递性。相当于有$n$个点，进行$m$次加边操作，每次操作后附加一个询问，问最大点集的大小，使得点集中每个点的度数均大于等于$k$ 本题还是逆向思维比较容易。我们先思考所有边加入的答案。对于一些点他的度数如果不足$k$那就肯定不能够成为点集元素，删掉他，并且删掉他所连的边。直到没有这样的点为止。剩余的点即为答案。然后就是删边。如果该边已经被删除，那么这条边对之前的答案没有任何影响，直接输出上一个的答案即可。否则就删掉这条边并让边的两个点度数都减一，如果有度数不足$k$的就继续删并且删掉他所连的边直到没有这样的点为止。剩余的点即为答案。之后都是类推。对于判断有度数不足$k$要用dg(u)+1==k来判断，否则可能多次记录答案导致错误 知识点：1、正难则反2、从简单情况到复杂情况的思路 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double const int MAXN = 200000 + 5; struct edge {int nxt, u, v, no;} ed[MAXN * 2]; int n, m, k, ans[MAXN], vis[MAXN]; int en, hd[MAXN * 2], dg[MAXN]; std::queue&lt;int &gt; q; inline void ins(int x, int y, int no) { ed[++en] = (edge){hd[x], x, y, no}, hd[x] = en, dg[x]++; ed[++en] = (edge){hd[y], y, x, no}, hd[y] = en, dg[y]++; } void clean() { ms(dg, 0), ms(hd, -1), ms(vis, 0); } int solve() { clean(); for (int x, y, i = 1; i &lt;= m; i++) scanf(&quot;%d%d&quot;, &amp;x, &amp;y), ins(x, y, i); ans[m + 1] = n; for (int i = 1; i &lt;= n; i++) if (dg[i] &lt; k) q.push(i), ans[m + 1]--; while (!q.empty()) { int u = q.front(); q.pop(); for (int i = hd[u]; i &gt; 0; i = ed[i].nxt) { edge &amp;e = ed[i]; vis[e.no] = 1, dg[e.v]--; if (dg[e.v] + 1 == k) q.push(e.v), ans[m + 1]--; } } for (int i = m; i &gt;= 2; i--) { ans[i] = ans[i + 1]; if (vis[i]) continue; edge &amp;e = ed[i * 2]; vis[e.no] = 1, dg[e.v]--, dg[e.u]--; if (dg[e.u] + 1 == k) q.push(e.u), ans[i]--; if (dg[e.v] + 1 == k) q.push(e.v), ans[i]--; while (!q.empty()) { int u = q.front(); q.pop(); for (int j = hd[u]; j &gt; 0; j = ed[j].nxt) { edge &amp;e = ed[j]; if (vis[e.no]) continue; vis[e.no] = 1, dg[e.v]--; if (dg[e.v] + 1 == k) q.push(e.v), ans[i]--; } } } for (int i = 2; i &lt;= m + 1; i++) printf(&quot;%d\n&quot;, ans[i]); return 0; } int main() { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1017D(暴力+状压)]]></title>
    <url>%2FCodeforces1017D%2F</url>
    <content type="text"><![CDATA[Codeforces 1017D题意：给你$n,m,q$，表示在这一组数据中所有的$01$串长度均为$n$，然后给你一个含有$m$个元素的multiset，之后有$q$次询问。每次询问会给你一个$01$串$t$和一个给定常数$k$，让你输出串$t$和multiset里面多少个元素的$Wu$值不超过$k$。对于$Wu$值的定义：如果两个$01$串$s$和$t$在位置$i$上满足s[i]=t[i]，那么加上$w[i]$，处理完$s$和$t$的所有$n$位之后的结果即为这两个$01$串的$Wu$值。 发现本题有$n$和$k$小，那么从这两个下手。$2^n≈4000$很小，我们可以将二进制数两两求$Wu$值之后$O(1)$查询。然后因为$k=100$, 那么我们再开一个二维数组记录某个二进制数能与multiset里面的元素组成某值的个数。这个状态非常好用。 知识点：1、这种题目数据范围小是突破点。2、写完程序要核对自己想的复杂度和实现是否有差异。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;bitset&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double int n, m, q, wi[20], bs[500000 + 5], whw[20], gg[5005][1205], tax[5005], xmx[5005]; void clean() { ms(xmx, 0), ms(tax, 0), ms(bs, 0); } int solve() { clean(); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;wi[i]); whw[0] = 1; for (int i = 1; i &lt;= 13; i++) whw[i] = whw[i - 1] * 2; char s[20]; for (int len, i = 1; i &lt;= m; i++) { scanf(&quot;%s&quot;, s); len = strlen(s); for (int j = len - 1; j &gt;= 0; j--) bs[i] += whw[len - 1 - j] * (s[j] - &#39;0&#39;); tax[bs[i]]++; }//mn std::bitset&lt;20 &gt; bs; for (int i = 0; i &lt; (1 &lt;&lt; n); i++) { bs = i; for (int j = 0; j &lt; n; j++) if (!bs[j]) xmx[i] += wi[n - j]; }//n2^n for (int x = 0; x &lt; (1 &lt;&lt; n); x++) for (int y = 0; y &lt; (1 &lt;&lt; n); y++) gg[x][xmx[x ^ y]] += tax[y]; //2^{2n}，对于x^y就是将两个位置上不同的位转为1，因为上面预处理的 xmx 是以位为 0 来加权，方便了后面这里不用取反 while (q--) { int k; scanf(&quot;%s%d&quot;, s, &amp;k); int now = 0, len = strlen(s), ans = 0; for (int j = len - 1; j &gt;= 0; j--) now += whw[len - 1 - j] * (s[j] - &#39;0&#39;); for (int i = 0; i &lt;= k; i++) ans += gg[now][i];//gg[状态][值]=个数 比 gg[状态][状态]=值 好很多，从 2^n 到 k printf(&quot;%d\n&quot;, ans); }//q(n+k) return 0; } int main() { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;q), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>状压</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1004E(树的直径+单调队列滑动窗口)]]></title>
    <url>%2FCodeforces1004E%2F</url>
    <content type="text"><![CDATA[Codeforces 1004E题意：一棵$n$个点的树，你需要选出一条不超过$k$长度的链，使得其他所有点到链上的最短距离的最长距离最短。 这个有点像二分，但是并不好做。我们想到树的直径的性质，一棵树以直径中心为根子树深度最小。考虑边权全是1的情况，选择的链一定在直径中间$k$长度的链。根据一棵树以直径中心为根子树深度最小性质很好证明。现在有边权，那么就要找一个加权的直径，并且链也不在中间了。但是还在直径上。我们预处理出以下的信息： $d1(u)$，直径上第$u$个点到左端点的距离$d2(u)$，直径上第$u$个点的枝叶最长深度距离$dl$，直径的带权长$a(i)$，直径上的点从左到右的序号 求直径两遍 BFS，然后用 Dinic 分层图思想找出直径上的点。即找到一个任意点的最远点之后，找这个最远点的最远点时候顺便对于每个点分层，然后再从这个最远点往回一层一层地走必然能找到直径。对于$d1​$，顺便求出即可。$d2​$，DFS 求每个直径点往下枝叶最大深度即可，注意不要走到直径上。 然后对于最后的答案就化作：$ans=min(max(d1(max(i - k + 1, 0)), dl - d1(i), d2(i), d2(i-1),……,d2(i-k+1)))$对于后面的$d2$，就是一个滑动窗口最大值，用单调队列维护即可。 知识点：1 树上的这些最优化问题和直径、重心、二分、DP有关。2 单调队列很容易写错，是检查重点3 从简单到复杂，从极端到一般的思维方法很重要 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double const int MAXN = 100000 + 5; struct edge {int nxt, v, wi;} ed[MAXN * 2]; int n, k, dl, que[MAXN * 2], l, r; int en, hd[MAXN], dis[MAXN], vis[MAXN], a[MAXN], cnt, d2[MAXN], d1[MAXN]; std::queue&lt;int &gt; q; std::queue&lt;std::pair&lt;int, int &gt; &gt; Q; inline void ins(int x, int y, int w) { ed[++en] = (edge){hd[x], y, w}, hd[x] = en; ed[++en] = (edge){hd[y], x, w}, hd[y] = en; } void dfs(int u, int pa, int dep, int &amp;sor) { d2[sor] = std::max(d2[sor], dep); for (int i = hd[u]; i &gt; 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (e.v != pa &amp;&amp; !vis[e.v]) dfs(e.v, u, dep + e.wi, sor); } } void clean() { en = 0, ms(hd, -1); } int solve() { clean(); for (int u, v, d, i = 1; i &lt; n; i++) scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;d), ins(u, v, d); ms(dis, 0), q.push(1); while (!q.empty()) { int u = q.front(); q.pop(); for (int i = hd[u]; i &gt; 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (!dis[e.v] &amp;&amp; e.v != 1) dis[e.v] = dis[u] + e.wi, q.push(e.v); } } int x = 1; for (int i = 2; i &lt;= n; i++) if (dis[i] &gt; dis[x]) x = i; ms(dis, 0), vis[x] = 1, Q.push(std::make_pair(x, 1)); while (!Q.empty()) { std::pair&lt;int, int &gt; p = Q.front(); Q.pop(); int u = p.first, no = p.second; for (int i = hd[u]; i &gt; 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (!dis[e.v] &amp;&amp; e.v != x) vis[e.v] = no + 1, dis[e.v] = dis[u] + e.wi, Q.push(std::make_pair(e.v, no + 1)); } } x = 1; for (int i = 2; i &lt;= n; i++) if (dis[i] &gt; dis[x]) x = i; dl = dis[x], k = std::min(k, vis[x]); int rm = vis[x], now = x; a[++cnt] = x; while (rm &gt; 1) { for (int i = hd[now]; i &gt; 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (vis[e.v] == rm - 1) { now = e.v, rm--, a[++cnt] = now, d1[cnt] = d1[cnt - 1] + e.wi; break; } } } ms(vis, 0); for (int i = 1; i &lt;= cnt; i++) vis[a[i]] = 1; for (int i = 1; i &lt;= cnt; i++) dfs(a[i], 0, 0, i); int ans = 1000000000, l = 1, r = 0; for (int i = 1; i &lt;= cnt; i++) { while (l &lt;= r &amp;&amp; que[l] &lt; i - k + 1) l++; ans = std::min(ans, std::max(std::max(d2[que[l]], d1[std::max(i - k + 1, 0)]), dl - d1[i])); while (l &lt;= r &amp;&amp; d2[i] &gt;= d2[que[r]]) r--; que[++r] = i; } printf(&quot;%d\n&quot;, ans); return 0; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;k), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>树的直径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1037D(BFS序)]]></title>
    <url>%2FCodeforces1037D%2F</url>
    <content type="text"><![CDATA[Codeforces 1037D题意：给出一棵树以及一个序列，问这个序列是否可能是原树的 BFS 序。考虑 BFS 分层，然后每次读进来数判断一下是否能接上。看代码即可。注意 BFS 序要按顺序，比如上一层在前面入队的是1，那么遍历这一层时一定是1的所有孩子在前面 本题结合了 BFS 序，对于 BFS 不一定要用队列，可以边处理边 BFS 一层。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double const int MAXN = 200000 + 5, ZINF = 1000000000; int n, bfn[MAXN], vis[MAXN], sz; std::vector&lt;int &gt; G[MAXN]; std::multiset&lt;int &gt; s; void clean() { sz = 0, ms(bfn, 0), ms(vis, 0); } int solve() { clean(); for (int x, y, i = 1; i &lt; n; i++) scanf(&quot;%d%d&quot;, &amp;x, &amp;y), G[x].push_back(y), G[y].push_back(x); vis[1] = 1, s.insert(0); for (int a, i = 1; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;a); if (!vis[a]) return printf(&quot;No\n&quot;), 0; if (bfn[a] != *s.begin()) return printf(&quot;No\n&quot;), 0; sz++; for (int i = 0; i &lt; (int)G[a].size(); i++) { int v = G[a][i]; if (!vis[v]) vis[v] = 1, bfn[v] = sz, s.insert(sz); } s.erase(s.find(bfn[a])); } printf(&quot;Yes\n&quot;); return 0; } int main() { scanf(&quot;%d&quot;, &amp;n), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1057」「ZJOI2007」棋盘制作 (DP悬线法/单调栈)]]></title>
    <url>%2Fbzoj1057%2F</url>
    <content type="text"><![CDATA[Bzoj 1057题意：在一个大矩阵中找出一个黑白相间最大的正方形和最大的矩形。DP悬线法解：求最大正方形可以用DP，而矩形就要悬线法(正方形也可以这样求)。预处理$l,r$数组为当前行左右最远能到达的合法格。然后每次查询看能否合并上一行的状态，处理$up$数组为往上最远能到达的合法格。转移方法和DP差不多。正方形取两个最小值的平方，长方形直接乘即可。单调栈解：先来考虑 Poj 2559 的做法：将所有高度依次加入单调栈，若出现破坏单增情况，则弹出栈直到满足为止。弹出过程中顺便记录以当前弹出高度为高，累加弹出宽度为宽求答案。最后将新的宽度+高度加入单调栈。注意最后剩余情况，直接在后面加一个高度为 0 的即可。(具体看算法竞赛进阶指南) 然后本题矩形考虑行列分开处理，对每个位置的数求出列上最高可达点，然后对于每行来说就是做 Poj 2559 的事情。所以直接每行做一次。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;bitset&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double const int MAXN = 2000 + 5; int n, m, a[MAXN][MAXN], up[MAXN][MAXN], l[MAXN][MAXN], r[MAXN][MAXN]; void clean() { ms(l, 0), ms(r, 0); } int solve() { clean(); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) scanf(&quot;%d&quot;, &amp;a[i][j]), up[i][j] = 1, l[i][j] = r[i][j] = j; for (int i = 1; i &lt;= n; i++) { l[i][0] = 1, r[i][m] = m; for (int j = 2; j &lt;= m; j++) if (a[i][j] != a[i][j - 1]) l[i][j] = l[i][j - 1]; for (int j = m - 1; j; j--) if (a[i][j] != a[i][j + 1]) r[i][j] = r[i][j + 1]; } /*for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) printf(&quot;i=%d j=%d l=%d\n&quot;, i, j, r[i][j]);*/ int ans1 = 0, ans2 = 0; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) { if (i != 1 &amp;&amp; a[i][j] != a[i - 1][j]) l[i][j] = std::max(l[i][j], l[i - 1][j]), r[i][j] = std::min(r[i][j], r[i - 1][j]), up[i][j] = up[i - 1][j] + 1; int a = r[i][j] - l[i][j] + 1, b = std::min(a, up[i][j]); ans1 = std::max(ans1, b * b), ans2 = std::max(ans2, a * up[i][j]); } printf(&quot;%d\n%d\n&quot;, ans1, ans2); return 0; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m), solve(); return 0; } 单调栈 Luogu 4147 参考： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;vector&gt; #include&lt;utility&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 1005; int n, m, whw[MAXN][MAXN], s[MAXN], top, w[MAXN]; char ma[MAXN][MAXN]; void clean() { ms(whw, 0); } int solve() { clean(); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) { char ch = getchar(); while (ch != &#39;F&#39; &amp;&amp; ch != &#39;R&#39;) ch = getchar(); ma[i][j] = ch; } for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) if (ma[i][j] != &#39;R&#39;) whw[i][j] = whw[i - 1][j] + 1; int ans = 0; for (int i = 1; i &lt;= n; ++i) { top = 0; for (int j = 1; j &lt;= m + 1; ++j) { if (s[top] &lt;= whw[i][j]) s[++top] = whw[i][j], w[top] = 1; else { int tmp = 0; while (top &amp;&amp; s[top] &gt; whw[i][j]) tmp += w[top], ans = max(ans, tmp * s[top]), --top; w[++top] = tmp + 1, s[top] = whw[i][j]; } } } printf(&quot;%d\n&quot;, ans * 3); return 0; } } int main() { flyinthesky::solve(); return 0; } /* 3 3 F F R R F F F F F */]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>Bzoj</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1899」「Zjoi2004」Lunch 午餐 (贪心+DP)]]></title>
    <url>%2Fbzoj1899%2F</url>
    <content type="text"><![CDATA[BZOJ 1899题意：见上。本题无法直接 DP，所以我们想到贪心方案，吃饭慢的排前面打饭，按照这个方法来进行排序后就可以DP了。可以设$dp(i,j)$为前$i$个人在1号打饭花了$j$时间的最小吃饭时间。转移：$i$安排到1号：$dp(i,j)=max(dp(i-1,j-a_i),j+b_i)$$i$安排到2号：$dp(i,j)=max(dp(i-1,j),sum_i-j+b_i)$其中$sum_i=\sum_{j=1}^ia_j$初值$dp(0,0)=0$，其他为$INF$知识点：这种无法直接DP也无法直接贪心的题目可以贪心后DP做，并且如果DP的维度太大需要根据性质尝试合并维度或者删除维度。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;bitset&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double const int MAXN = 200 + 5, INF_ = 1000000000; struct data { int a, b; }pp[MAXN]; int n, dp[MAXN][MAXN * MAXN], sum[MAXN]; bool cmp(const data &amp;x, const data &amp;y) {return x.b &gt; y.b;} void clean() { sum[0] = 0; } int solve() { clean(); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d%d&quot;, &amp;pp[i].a, &amp;pp[i].b); std::sort(pp + 1, pp + 1 + n, cmp); for (int i = 1; i &lt;= n; i++) sum[i] = sum[i - 1] + pp[i].a; for (int i = 0; i &lt;= n; i++) for (int j = 0; j &lt;= sum[n]; j++) dp[i][j] = INF_; dp[0][0] = 0; int ans = INF_; for (int i = 1; i &lt;= n; i++) { for (int j = 0; j &lt;= sum[i]; j++) { if (j &gt;= pp[i].a) dp[i][j] = std::min(dp[i][j], std::max(dp[i - 1][j - pp[i].a], j + pp[i].b)); dp[i][j] = std::min(dp[i][j], std::max(dp[i - 1][j], sum[i] - j + pp[i].b)); if (i == n) ans = std::min(ans, dp[i][j]); } } printf(&quot;%d\n&quot;, ans); return 0; } int main() { scanf(&quot;%d&quot;, &amp;n), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>DP</tag>
        <tag>Bzoj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1217」「HNOI2003」消防局的设立 (贪心/树形DP)]]></title>
    <url>%2Fbzoj1217%2F</url>
    <content type="text"><![CDATA[BZOJ 1217给你一棵树，上面可以放置一些点可以使距离其2的点染色，求最少放置点染色方案。 贪心做法：对于一个点，如果他的爷爷没有放置点，就放在爷爷上。因为这样可以最优，爷爷放点之后兼顾本节点、父亲节点、兄弟节点。 DP做法： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double const int MAXN = 2000 + 10; struct node { int d, no; node () {d = 0;} bool operator &lt; (const node &amp;b) const { return d &gt; b.d; } }nd[MAXN]; int n, ans = 0, f[MAXN], whw[MAXN];//whw记录离其最近的点的距离 void clean() { } int solve() { clean(); nd[1].no = 1, whw[1] = whw[0] = n, f[1] = 0; for (int i = 2; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;f[i]), nd[i].d = nd[f[i]].d + 1, nd[i].no = i, whw[i] = n; std::sort(nd + 1, nd + 1 + n); for (int i = 1; i &lt;= n; i++) { int u = nd[i].no, v = f[u], w = f[f[u]]; whw[u] = std::min(std::min(whw[v] + 1, whw[w] + 2), whw[u]); if (whw[u] &gt; 2) ans++, whw[w] = 0, whw[f[w]] = std::min(whw[f[w]], 1), whw[f[f[w]]] = std::min(whw[f[f[w]]], 2); } printf(&quot;%d\n&quot;, ans); return 0; } int main() { scanf(&quot;%d&quot;, &amp;n), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>Bzoj</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 998D(打表找规律)]]></title>
    <url>%2FCodeforces998D%2F</url>
    <content type="text"><![CDATA[Codeforces 998D题意：有$1,5,10,50$四种数字，问用$n$个数字，能构成多少个不同的数字? 打表，发现11项后面的数成等差数列，那么直接前面11项打表，后面用等差数列公式算即可。附打表程序 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double const LL whw[20] = {0, 4, 10, 20, 35, 56, 83, 116, 155, 198, 244, 292}; LL n; void clean() { } int solve() { clean(); if (n &lt;= 11ll) printf(&quot;%lld\n&quot;, whw[n]); else printf(&quot;%lld\n&quot;, whw[11ll] + (n - 11ll) * 49ll); return 0; } int main() { scanf(&quot;%lld&quot;, &amp;n), solve(); return 0; } 打表程序： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double int n, h[10], ans, vis[10000005], lstans; int gg[5] = {0, 1, 5, 10, 50}; void dfs(int a, int rm, int tot) { if (rm == 0 &amp;&amp; !vis[tot]) { ans++, vis[tot] = 1; return ; } if (a &gt;= 5) return ; for (int i = 0; i &lt;= rm; i++) dfs(a + 1, rm - i, tot + gg[a] * i); } void clean() { lstans = ans, ms(vis, 0), ms(h, 0), ans = 0; } int solve() { clean(); dfs(1, n, 0); printf(&quot;n=%d, ans=%d, cha=%d\n&quot;, n, ans, ans - lstans); //printf(&quot;%d, &quot;, ans); return 0; } int main() { for (n = 1; n &lt;= 20; n++) solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1011D(交互)]]></title>
    <url>%2FCodeforces1011D%2F</url>
    <content type="text"><![CDATA[Codeforces 1011D题意：有一个数字要猜，假设为$x$；给计算机的数假设为$y$，会得到以下三种回答：若 $x&lt;y$，回答 $−1$；若 $x=y$，回答$0$；若 $x&gt;y$，回答 $1$； 但是，现在计算机坏了，对于某些询问会“说谎”；所谓“说谎”就是该回答 $−1$ 的回答了$1$ ；反之，该回答 $1$ 的回答了 $−1$。 抽象为 $01$ 字符串，$0101$ 表示第 $1$ 、$3$ 次询问计算机会“说谎”；若询问的次数大于了 $4$，就会循环；即第 $5、7$ 次会“说谎”。 (hack点) 现在，给这个 $01$ 串的长度 $n$，以及 $x$ 的最大范围 $m$(即 $x≤mx≤m$)。 还要求询问次数最多不超过 $60$ 次。 考虑到$n$只有$30$，所以前$n$次询问$1$骗取 $01$字符串，即询问$1$若回答不是$0$，则都应该是$1$，但是如果是$-1$，则说明当前说谎，记录一下。然后之后二分询问就好，注意若询问的次数大于了$n$，就会循环，Hack点 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using std::cout; using std::cin; using std::endl; int m, n, a[100]; void clean() { } int solve() { clean(); cin &gt;&gt; m &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { cout &lt;&lt; 1 &lt;&lt; endl; int whw; cin &gt;&gt; whw; if (whw == 0) { cout &lt;&lt; 1 &lt;&lt; endl; exit(0); } else a[i] = (whw == 1 ? 0 : 1); } int l = 1, r = m + 1; int i = 1; while (l &lt;= r) { //printf(&quot;i=%d, a[i]=%d\n&quot;,i, a[i]); int mid = (l + r) &gt;&gt; 1; cout &lt;&lt; mid &lt;&lt; endl; int whw; cin &gt;&gt; whw; if (whw == 0) { cout &lt;&lt; mid &lt;&lt; endl; exit(0); } if (a[i]) whw = (whw == -1 ? 1 : -1); if (whw == 1) { l = mid + 1; } else r = mid; i++; if (i &gt; n) i = 1; } exit(0); return 0; } int main() { solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>交互</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 544D(BFS最短路+枚举)]]></title>
    <url>%2FCodeforces544D%2F</url>
    <content type="text"><![CDATA[Codeforces 544D题意：给出$n$个点，$m$条边权为$1$的无向边，破坏最多的道路，使得从$s_1$到$t_1,s_2$到$t_2$的距离不超过$l_1,l_2$ 对于$s_1$到$t_1$，最优肯定取最短路，2同理。但是这两条路径可能重复更优，也就是说1取最短路而2可以在$l$范围之内不取最短路而使用1的某些边来减少边数的增加所以我们枚举路径$(i,j)$，取每个起点终点经过这条路径的长度最短的。4种情况。最后取反答案即可。记得可能两条路径没有重合部分，直接赋值$dis(s_1,t_1)+dis(s_2,t_2)$ 知识点：本题与CF 954D类似，都是求完最短路之后枚举边/路径来算答案。对于权为$1$的图，可以用 BFS $O(n^2)$求多源最短路。而不是用Floyd $O(n^3)$的算法(或者$O(n(n+m)logn)=O(n^2+mnlogn)$)本题将删除化为选择。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double const int MAXN = 3000 + 5, INF = 100000000; struct node{int u, d;}; int n, m, s1, t1, l1, s2, t2, l2, vis[MAXN], dis[MAXN][MAXN]; std::vector&lt;int &gt; G[MAXN]; std::queue&lt;node &gt; q; inline void ins(int x, int y) {G[x].push_back(y), G[y].push_back(x);} void clean() { for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) dis[i][j] = INF; } int solve() { clean(); for (int a, b, i = 1; i &lt;= m; i++) scanf(&quot;%d%d&quot;, &amp;a, &amp;b), ins(a, b); scanf(&quot;%d%d%d%d%d%d&quot;, &amp;s1, &amp;t1, &amp;l1, &amp;s2, &amp;t2, &amp;l2); for (int st = 1; st &lt;= n; st++) { for (int i = 1; i &lt;= n; i++) vis[i] = 0; q.push((node){st, 0}), vis[st] = 1, dis[st][st] = 0; while (!q.empty()) { node p = q.front(); q.pop(); for (int i = 0; i &lt; (int)G[p.u].size(); i++) { int v = G[p.u][i]; if (!vis[v]) dis[st][v] = p.d + 1, vis[v] = 1, q.push((node){v, p.d + 1}); } } } if (dis[s1][t1] &gt; l1 || dis[s2][t2] &gt; l2) return printf(&quot;-1\n&quot;), 0; int ans = dis[s1][t1] + dis[s2][t2]; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { if (dis[s1][i] + dis[i][j] + dis[j][t1] &lt;= l1 &amp;&amp; dis[s2][i] + dis[i][j] + dis[j][t2] &lt;= l2) ans = std::min(ans, dis[s1][i] + dis[i][j] + dis[j][t1] + dis[s2][i] + dis[j][t2]); if (dis[s1][j] + dis[i][j] + dis[i][t1] &lt;= l1 &amp;&amp; dis[s2][i] + dis[i][j] + dis[j][t2] &lt;= l2) ans = std::min(ans, dis[s1][j] + dis[i][j] + dis[i][t1] + dis[s2][i] + dis[j][t2]); if (dis[s1][i] + dis[i][j] + dis[j][t1] &lt;= l1 &amp;&amp; dis[s2][j] + dis[i][j] + dis[i][t2] &lt;= l2) ans = std::min(ans, dis[s1][i] + dis[i][j] + dis[j][t1] + dis[s2][j] + dis[i][t2]); if (dis[s1][j] + dis[i][j] + dis[i][t1] &lt;= l1 &amp;&amp; dis[s2][j] + dis[i][j] + dis[i][t2] &lt;= l2) ans = std::min(ans, dis[s1][j] + dis[i][j] + dis[i][t1] + dis[s2][j] + dis[i][t2]); } } printf(&quot;%d\n&quot;, m - ans); return 0; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>Codeforces</tag>
        <tag>最短路</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 489D(枚举+组合数)]]></title>
    <url>%2FCodeforces489D%2F</url>
    <content type="text"><![CDATA[Codeforces 489D题意：给出$n$点，$m$条有向边，问有多少个如下图的菱形一个菱形有两条路径组成，如果我们找到$u$到$v$的不同路径数量，就可以用$C_n^2$来计算有几个菱形了。枚举这样的三元组来找路径 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double const int MAXN = 3000 + 5; std::vector&lt;int &gt; G[MAXN]; int n, m; LL whw[MAXN][MAXN]; void clean() { ms(whw, 0); } int solve() { clean(); for (int a, b, i = 1; i &lt;= m; i++) scanf(&quot;%d%d&quot;, &amp;a, &amp;b), G[a].push_back(b); for (int u = 1; u &lt;= n; u++) { for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i]; for (int j = 0; j &lt; (int)G[v].size(); j++) { int w = G[v][j]; whw[u][w]++; } } } LL ans = 0; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) if (i != j) { ans += whw[i][j] * (whw[i][j] - 1) / 2; } } printf(&quot;%lld\n&quot;, ans); return 0; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>组合数学</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 500D(期望+组合数+树边贡献DFS)]]></title>
    <url>%2FCodeforces500D%2F</url>
    <content type="text"><![CDATA[Codeforces 500D题意：给一棵有$n$个节点的树，有$q$次操作，每次操作将改变某条边边权，问改变后，从$n$个点中等概率任取三点，将这三点用最短路连接起来的距离和$d(a,b)+d(a,c)+d(b,c)$的数学期望值。 树上计数一般这种整棵树计数的就是边点贡献。这里明显边贡献。算出每条边每次要计算几次即可。因为维修道路并不会影响这些次数。对于一条边，他左边有$x$个点，右边则有$n-x$个点，记为$y$。那么通过这条边的方案数(左边选2个，右边选1个或者反之)为$yC^2_x+xC^2_y$，化简后得$(n-x)(n-2)x$，就可以这样每个点计算然后除以$C_n^3$即可。或者直接除，化简得$\frac{6(n-x)x}{n(n-1)}$，然后只要每个点记录$6(n-x)x$，然后询问时除以$n(n-1)$即可。 知识点：树上整棵数计数/最优值等路径覆盖问题和边贡献有关。本题与CF 701思想类似。如果写暴力直接枚举三元组然后 LCA 求两点距离统计即可，复杂度$O(n^3logn)$ #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double const LL MAXN = 100000 + 5; struct edge { LL v, w, no; }ed[MAXN * 2ll]; LL n, q, en, siz[MAXN], tms[MAXN], ans; std::vector&lt;LL &gt; G[MAXN]; inline void ins(LL x, LL y, LL w, LL no) { ed[++en] = (edge){y, w, no}, G[x].push_back(en); ed[++en] = (edge){x, w, no}, G[y].push_back(en); } void dfs(LL u, LL pa) { siz[u] = 1ll; for (LL i = 0ll; i &lt; (LL)G[u].size(); i++) { edge &amp;e = ed[G[u][i]]; if (e.v != pa) dfs(e.v, u), tms[e.no] += 6ll * (n - siz[e.v]) * siz[e.v], siz[u] += siz[e.v]; } } void clean() { ms(tms, 0ll), ans = en = 0ll; } int solve() { clean(); for (LL a, b, l, i = 1ll; i &lt; n; i++) scanf(&quot;%lld%lld%lld&quot;, &amp;a, &amp;b, &amp;l), ins(a, b, l, i); dfs(1ll, 0ll); for (LL i = 1ll; i &lt; n; i++) ans += tms[i] * ed[i * 2ll].w; scanf(&quot;%lld&quot;, &amp;q); while (q--) { LL r, w; scanf(&quot;%lld%lld&quot;, &amp;r, &amp;w); ans -= tms[r] * ed[r * 2ll].w, ed[r * 2ll].w = w, ans += tms[r] * ed[r * 2ll].w; printf(&quot;%.8f\n&quot;, (db)ans / (db)n / (db)(n - 1ll)); } return 0; } int main() { scanf(&quot;%lld&quot;, &amp;n), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>组合数学</tag>
        <tag>DFS</tag>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 545E(最短路修改松弛+贪心)]]></title>
    <url>%2FCodeforces545E%2F</url>
    <content type="text"><![CDATA[Codeforces 545E题意：给定一个无向图和一个点$u$，找出若干条边组成一个子树，要求这个子树中$u$到其他个点的最短距离与在原图中的相等，并且要求子树所有边的权重之和最小，求出最小值并输出子树的边号。修改版dij。在最短路的时候，每个点存它被松弛的那条边，这条边尽量在保证最短路的情况下最小。因为这样就能使边能够更加合理利用，贪心思想。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double const LL MAXN = 300000 + 5, INF = 4411686018427387900; struct edge { LL v, wi; }ed[MAXN * 2]; struct node { LL u, d; bool operator &lt; (const node &amp;b) const { return d &gt; b.d; } }; LL n, m, en, st, dis[MAXN], vis[MAXN]; std::pair&lt;LL, LL &gt; bst[MAXN]; std::vector&lt;LL &gt; G[MAXN]; std::priority_queue&lt;node &gt; q; inline void ins(LL u, LL v, LL w) { ed[++en] = (edge){v, w}, G[u].push_back(en); ed[++en] = (edge){u, w}, G[v].push_back(en); } void dij(LL s) { for (LL i = 0; i &lt;= n; i++) vis[i] = 0, dis[i] = bst[i].first = INF; dis[s] = 0, q.push((node){s, 0}); while (!q.empty()) { node p = q.top(); q.pop(); if (vis[p.u]) continue; vis[p.u] = 1; for (LL i = 0; i &lt; (LL)G[p.u].size(); i++) { edge &amp;e = ed[G[p.u][i]]; if (dis[e.v] &gt; dis[p.u] + e.wi) dis[e.v] = dis[p.u] + e.wi, bst[e.v].first = e.wi, bst[e.v].second = G[p.u][i], q.push((node){e.v, dis[e.v]}); else if (dis[e.v] == dis[p.u] + e.wi &amp;&amp; e.wi &lt; bst[e.v].first) bst[e.v].first = e.wi, bst[e.v].second = G[p.u][i]; } } } void clean() { en = 0; } int solve() { clean(); for (LL u, v, w, i = 1; i &lt;= m; i++) scanf(&quot;%lld%lld%lld&quot;, &amp;u, &amp;v, &amp;w), ins(u, v, w); scanf(&quot;%lld&quot;, &amp;st); dij(st); LL ans1 = 0; for (LL i = 1; i &lt;= n; i++) if (i != st) ans1 += bst[i].first; printf(&quot;%lld\n&quot;, ans1); for (LL i = 1; i &lt;= n; i++) if (i != st) printf(&quot;%lld &quot;, (bst[i].second + 1) / 2); return 0; } int main() { scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>Codeforces</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 711D(DFS找有向环+组合数)]]></title>
    <url>%2FCodeforces711D%2F</url>
    <content type="text"><![CDATA[Codeforces 711D题意：给一个图，$n$个点$n$条边，可以让任意几条边方向取反，问有多少种方案使得图中没有环。对于一个环，要使得它环被破坏，那么必须取反环上的一些边，不能不反或者全反，否则新的环将出现。因为图中给出$i-&gt;a_i$边的图每个点出度至多为1，所以没有大环包含小环的情况，也没有取反一条边后形成新环的可能，因为路径$u-&gt;v$如果取反一条边后形成新环，则$u-&gt;v$一定存在，与出度至多为1矛盾。所以每个环对答案的贡献为$2^{k_i}-2$, $k_i$为环$i$的大小。不在任何环上的点指出的边可以任意取反或不取反，对环的构成无影响。根据乘法原理，得到最终答案为$2^{n-\sum_{i=1}^{siz}k_i}\prod_{i=1}^{siz}(2^{k_i}-2)$，$siz$为环的总个数知识点：1、DFS 开一个 cnt 数组辅助求解有向环2、图中给出$i-&gt;a_i$边的图每个点出度至多为1，所以没有大环包含小环的情况。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double const LL MAXN = 200000 + 5, MO = 1e9 + 7; LL n, a[MAXN], vis[MAXN], cnt[MAXN], ans, siz, k[MAXN]; LL poww(LL a, LL b) { LL bs = a, ret = 1; while (b) { if (b &amp; 1) ret = (ret * bs) % MO; bs = (bs * bs) % MO, b &gt;&gt;= 1; } return ret; } void dfs(LL u, LL src, LL d) { cnt[u] = d, vis[u] = src; if (!vis[a[u]]) dfs(a[u], src, d + 1); else if (vis[a[u]] == src) { k[++siz] = cnt[u] - cnt[a[u]] + 1; ans = (ans * (poww(2ll, k[siz]) - 2ll)) % MO; } } void clean() { siz = 0, ans = 1, ms(vis, 0); } int solve() { clean(); for (LL i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;a[i]); for (LL i = 1; i &lt;= n; i++) if (!vis[i]) dfs(i, i, 0ll); LL sum = 0ll; for (LL i = 1; i &lt;= siz; i++) sum += k[i]; ans = (ans * poww(2ll, n - sum)) % MO; printf(&quot;%lld\n&quot;, ans); return 0; } int main() { scanf(&quot;%lld&quot;, &amp;n), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>计数原理</tag>
        <tag>Codeforces</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 740D(二分+树上差分)]]></title>
    <url>%2FCodeforces740D%2F</url>
    <content type="text"><![CDATA[Codeforces 740D题意：给出一棵有根树，树上每个点、每条边都有一个权值。现在给出“控制”的定义：对一个点$u$，设点$v$在其子树上，则称$u$控制$v$。要求求出每个点控制了多少个点 我们从根向下 DFS。对于一个点，他上面距离他点权长的点都是控制这个点的。只要找到这个临界点即可。由于树边权为正，所以边权前缀和为单调序列，用二分找。用倍增也行。然后这一段就+1，树上差分即可。 知识点：1、一定要在纸上写思路！不管多简单的题目，只要是这种 50 行以上的2、不要看错题目！仔细看，有必要将简要题意写下来！3、正数前缀和-单调性-二分 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const LL MAXN = 200000 + 5; LL n, a[MAXN], c[MAXN], cf[MAXN], fa[MAXN]; vector&lt;LL&gt; G[MAXN]; vector&lt;pair&lt;LL, LL &gt; &gt; dis; inline void ins(LL x, LL y) {G[x].push_back(y);} void dfs1(LL u, LL pa, LL cst) { cf[u]++; fa[u] = pa; LL tmp = cst - a[u]; vector&lt;pair&lt;LL, LL &gt; &gt;::iterator it = lower_bound(dis.begin(), dis.end(), make_pair(tmp, 0ll)); LL p = it - dis.begin(); p--; if (p &gt;= 0ll) cf[dis[p].second]--; dis.push_back(make_pair(cst, u)); for (LL i = 0ll; i &lt; (LL)G[u].size(); i++) { LL v = G[u][i]; if (v != pa) dfs1(v, u, cst + c[v]); } dis.pop_back(); } void dfs2(LL u, LL pa) { for (LL i = 0ll; i &lt; (LL)G[u].size(); i++) { LL v = G[u][i]; if (v != pa) dfs2(v, u), cf[u] += cf[v]; } } void clean() { ms(cf, 0); } int solve() { clean(); for (LL i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;a[i]); for (LL p, w, i = 2; i &lt;= n; i++) scanf(&quot;%lld%lld&quot;, &amp;p, &amp;w), ins(p, i), c[i] = w; dfs1(1, 0, 0); dfs2(1, 0); for (LL i = 1; i &lt;= n; i++) printf(&quot;%lld &quot;, cf[i] - 1); return 0; } int main() { scanf(&quot;%lld&quot;, &amp;n), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>二分</tag>
        <tag>差分序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 918D(博弈论+DAG图DP)]]></title>
    <url>%2FCodeforces918D%2F</url>
    <content type="text"><![CDATA[Codeforces 918D题意：一个 DAG 图，边权是小写字母，两人玩游戏，他们起点分别是$i$和$j$节点，每次可以沿出边方向移动一格，前提是该边的字母大于等于上一轮移动经过的边的字母，不能移动的就输，问所有$i$和$j$为起点结果谁能赢。 设$dp(t,i,j)$为当前限制字母$t$下，先手在$i$, 后手在$j$时先手是否获胜。那么直接记忆化搜索转移即可，注意交替先后手，如果当前后手无法移动则当前先手获胜。 知识点：博弈 DP 核心为先手后手状态 + 交替先手后手求解。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 100 + 5; int n, m, dp[30][MAXN][MAXN], ma[MAXN][MAXN]; int dfs(int t, int x, int y) { if (dp[t][x][y] &gt;= 0) return dp[t][x][y]; for (int i = 1; i &lt;= n; i++) if (ma[x][i] &gt;= 0 &amp;&amp; ma[x][i] &gt;= t &amp;&amp; !dfs(ma[x][i], y, i)) return dp[t][x][y] = 1; return dp[t][x][y] = 0; } void clean() { ms(ma, -1), ms(dp, -1); } int solve() { clean(); char s[5]; for (int x, y, i = 1; i &lt;= m; i++) scanf(&quot;%d%d%s&quot;, &amp;x, &amp;y, s), ma[x][y] = s[0] - &#39;a&#39;; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) dp[0][i][j] = dfs(0, i, j); for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) if (dp[0][i][j]) printf(&quot;A&quot;); else printf(&quot;B&quot;); puts(&quot;&quot;); } return 0; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>Codeforces</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 954D(最短路)]]></title>
    <url>%2FCodeforces954D%2F</url>
    <content type="text"><![CDATA[Codeforces 954D题意：$n$个顶点$m$条边的无向图，现要求添加一条边并且不改变$st$的最短路，问有多少种可行的情况 对于两个点之间加一条边，$dis(s,i)+1+dis(j,t)$和$dis(t,i)+1+dis(j,s)$都不能比最短路短，否则这条路径就成为了最短路。所以预处理$s,t$到每个点的最短路，然后$O(n^2)$枚举$dis(s,i)+1+dis(j,t)$和$dis(t,i)+1+dis(j,s)$都大于等于最短路的边(点对)。 知识点：本题运用了最短路更新的三角不等式的性质，本题加边不能破坏原有的三角不等式性质，否则这条路径就是最短路了，充分运用了最短路的性质，与树的直径证明很像。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 1000 + 10, INF = 1000000000; struct node { int dis, u; bool operator &lt; (const node &amp;b) const { return dis &gt; b.dis; } }; int n, m, s, t, dis[2][MAXN], vis[MAXN], ma[MAXN][MAXN]; vector&lt;int&gt; G[MAXN]; priority_queue&lt;node&gt; q; inline void ins(int x, int y) {G[x].push_back(y), G[y].push_back(x), ma[x][y] = ma[y][x] = 1;} void dij(int TP, int sr) { for (int i = 0; i &lt;= n; i++) vis[i] = 0, dis[TP][i] = INF; dis[TP][sr] = 0, q.push((node){0, sr}); while (!q.empty()) { node p = q.top(); q.pop(); if (vis[p.u]) continue; vis[p.u] = 1; for (int i = 0; i &lt; (int)G[p.u].size(); i++) { int v = G[p.u][i]; if (dis[TP][v] &gt; dis[TP][p.u] + 1) dis[TP][v] = dis[TP][p.u] + 1, q.push((node){dis[TP][v], v}); } } } void clean() { ms(ma, 0); } int solve() { clean(); for (int x, y, i = 1; i &lt;= m; i++) scanf(&quot;%d%d&quot;, &amp;x, &amp;y), ins(x, y); dij(0, s), dij(1, t); int ans = 0; for (int i = 1; i &lt;= n; i++) for (int j = i + 1; j &lt;= n; j++) if (!ma[i][j]) { int tmp = min(dis[0][i] + dis[1][j] + 1, dis[1][i] + dis[0][j] + 1); if (tmp &gt;= dis[0][t]) ans++; } printf(&quot;%d\n&quot;, ans); return 0; } int main() { scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;s, &amp;t), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 920E(BFS+链表优化)]]></title>
    <url>%2FCodeforces920E%2F</url>
    <content type="text"><![CDATA[Codeforces 920E题意：给你一个无向图，求它补图的连通分量个数以及所有连通分量的大小，升序输出。 这题也就只能 BFS 暴力了，最开始将所有点放进一个数组，然后每次从里面拿一个出来 BFS 扩展，然后每一层扩展到的点实际上是不可达的，要把没有扩展到的点加进队列，并且在数组中删除。这样找出来就是一个联通分量了。但是数组要支持删除很慢，我们就用链表来做。 知识点：链表让数组支持$O(1)$删除，BFS取没有扩展的点加入队列的思想很好。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 200000 + 5; int n, m, l[MAXN], r[MAXN], vis[MAXN]; vector&lt;int&gt; G[MAXN], ans; queue&lt;int&gt; q; inline void ins(int x, int y) {G[x].push_back(y), G[y].push_back(x);} inline void del(int x) {r[l[x]] = r[x], l[r[x]] = l[x];} void bfs(int s) { int sz = 0; q.push(s), vis[s] = s; while (!q.empty()) { sz++; int u = q.front(); q.pop(); for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i]; if (vis[v] != u) vis[v] = u; } for (int i = r[0]; i != -1; i = r[i]) if (i != s &amp;&amp; vis[i] != u) q.push(i), del(i); } ans.push_back(sz); } void clean() { ms(vis, 0); } int solve() { clean(); for (int x, y, i = 1; i &lt;= m; i++) scanf(&quot;%d%d&quot;, &amp;x, &amp;y), ins(x, y); for (int i = 1; i &lt;= n; i++) l[i] = i - 1, r[i - 1] = i; l[0] = -1, r[n] = -1; for (int i = r[0]; i != -1; i = r[i]) bfs(i), del(i); sort(ans.begin(), ans.end()); printf(&quot;%d\n&quot;, (int)ans.size()); for (int i = 0; i &lt; (int)ans.size(); i++) printf(&quot;%d &quot;, ans[i]); return 0; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>Codeforces</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 999E(DFS+Tarjan缩点)]]></title>
    <url>%2FCodeforces999E%2F</url>
    <content type="text"><![CDATA[Codeforces 999E题意：给你$n$个点，$m$条边，以及一个初始点$s$，问你至少还需要增加多少条边，使得初始点$s$与剩下其他的所有点都连通。 由于图中可能有环，并且一个环其中一点能到达首都则其他点都可以到达。所以用 Tarjan 对原图缩点然后变成一个 DAG 图。之后统计入度为 0 的点即可，但是要小心从首都出发的链，将这些链先标记，然后每次查找到入度为 0 的点 DFS 看这个点所在链是否全部标记，没有全部标记就可以连一条边到首都。DFS 必要的标记还是要打上qwq，不然 TLE 到死啊 知识点：1 Tarjan小心新图原图区别 2 DFS 必要的标记还是要打上qwq #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;stack&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 5000 + 5; int n, m, st; vector&lt;int&gt; G[MAXN], R[MAXN]; int sz, scc_siz, scc_bl[MAXN], dfn[MAXN], low[MAXN], vis[MAXN]; stack&lt;int&gt; s; int ino[MAXN], okv[MAXN]; inline void ins(int x, int y) {G[x].push_back(y);} inline void Rins(int x, int y) {R[x].push_back(y), ino[y]++;} void tarjan(int u) { low[u] = dfn[u] = ++sz, vis[u] = -1, s.push(u); for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i]; if (!vis[v]) tarjan(v), low[u] = min(low[u], low[v]); else if (vis[v] == -1) low[u] = min(low[u], dfn[v]); } if (low[u] == dfn[u]) { int e; scc_siz++; do { e = s.top(); s.pop(); scc_bl[e] = scc_siz, vis[e] = 1; } while (e != u); } } void dfs1(int u) { okv[u] = 1; for (int i = 0; i &lt; (int)R[u].size(); i++) if (!okv[u]) dfs1(R[u][i]); //必要的标记判断还是写上qwq } int dfs2(int u) { int ret = okv[u]; if (!okv[u]) return 0; //必要的标记判断还是写上qwq for (int i = 0; i &lt; (int)R[u].size(); i++) { int v = R[u][i]; if (!okv[v]) return 0; //必要的标记判断还是写上qwq ret &amp;= dfs2(v); } okv[u] = 1; return ret; } void clean() { ms(ino, 0), ms(vis, 0), ms(okv, 0), sz = scc_siz = 0; } int solve() { clean(); for (int x, y, i = 1; i &lt;= m; i++) scanf(&quot;%d%d&quot;, &amp;x, &amp;y), ins(x, y); for (int i = 1; i &lt;= n; i++) if (!vis[i]) tarjan(i); for (int u = 1; u &lt;= n; u++) { for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i]; if (scc_bl[u] != scc_bl[v]) Rins(scc_bl[u], scc_bl[v]); } } dfs1(scc_bl[st]); int ans = 0; for (int u = 1; u &lt;= scc_siz; u++) if (u != scc_bl[st] &amp;&amp; ino[u] == 0 &amp;&amp; !dfs2(u)) ans++; printf(&quot;%d\n&quot;, ans); return 0; } int main() { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;st), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>Tarjan</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 杂题选做]]></title>
    <url>%2FCF%E6%9D%82%E9%A2%98%E9%80%89%E5%81%9A%2F</url>
    <content type="text"><![CDATA[第一题 789CCF 789C题意：求满足题意最大的子段和。解：对每个$i$存$a_i - a_{i+1}$，然后对于题目-1的限制，序列是正负正负或者负正负正的。最大的子段和可以想到DP做，所以预处理两个正负正负，负正负正的数组，在上面做字段和DP即可。子段和DP最优解在每一步取。$dp(i)=max(dp(i-1)+c, 0)$有负数的情况，没有就直接$dp(i)=max(dp(i-1)+c, c)$，最后的$dp(n)$不是答案，注意知识点：写题目一定要把题意抽象化完再做代码： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;map&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 100000 + 5; LL n, a[MAXN], b[MAXN], oddz[MAXN], evenz[MAXN]; LL abss(LL x) {return x &gt; 0 ? x : -x;} void clean() { } int solve() { clean(); for (LL i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;a[i]); for (LL i = 1; i &lt; n; i++) b[i] = abss(a[i] - a[i + 1]); for (LL i = 1; i &lt;= n; i++) oddz[i] = evenz[i] = b[i]; for (LL i = 2; i &lt;= n; i += 2) oddz[i] *= -1; for (LL i = 1; i &lt;= n; i += 2) evenz[i] *= -1; LL sum = 0, mks = -4223372036854775807ll; for (LL i = 1; i &lt; n; i++) sum = max(sum + oddz[i], 0ll), mks = max(mks, sum); sum = 0; for (LL i = 1; i &lt; n; i++) sum = max(sum + evenz[i], 0ll), mks = max(mks, sum); printf(&quot;%lld\n&quot;, mks); return 0; } int main() { scanf(&quot;%lld&quot;, &amp;n), solve(); return 0; } 第二题 913CCF 913C题意：给你$n$瓶柠檬水，给你相对应的每瓶的价格，每瓶的体积分别对应$2^{i−1}$升，给你要买的体积，求出要买的最低价格解： 我们可以发现相邻瓶的体积是二倍的关系，可以利用这一点，处理出每个体积对应的最低价格，直接扫一遍即可。然后买体积最大的最划算。所以像倍增一样尽可能买体积大的，不够就多买。知识点：$2^{i}$就要想到一些性质。代码： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;map&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const LL MAXN = 30 + 5; LL n, L, ci[MAXN]; void clean() { } int solve() { clean(); for (LL i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;ci[i]); for (LL i = 2; i &lt;= n; i++) if (ci[i - 1] * 2 &lt; ci[i]) ci[i] = ci[i - 1] * 2; LL ans = 9223372036854775807ll, sum = 0; for (LL i = n; i; i--) { LL nd = L / (1 &lt;&lt; (i - 1)); L -= nd * (1 &lt;&lt; (i - 1)), sum += nd * ci[i]; ans = min(ans, sum + (L &gt; 0) * ci[i]); } printf(&quot;%lld\n&quot;, ans); return 0; } int main() { scanf(&quot;%lld%lld&quot;, &amp;n, &amp;L), solve(); return 0; } 第三题 814C题意：给你一个长度为$n$的字符串，然后给你$q$个询问，$m$和字符$c$，代表任意修改$m$个字符为$c$后，连续的$c$最长是多长。解：最优化可以想到 DP 。本题其实相当于选择一个最大的区间使得区间内修改后能全部是$c$。所以可以设$dp(i,j)$为$[i,j]$修改最少次数。但是这里讲一种尺取法，尺取法就是有两个指针$l,r$, 先向右扩展$r$，然后判断$l,r$是否符合条件，如果不符合就把$l$向右扩展，然后得到一个合法区间，取最大值即可。知识点：抽象题目，简化题目。本题可以抽象为 $q$个询问，在长度为$n$的序列中找到一个最长区间$[i,j]$使得这个区间$m+g=j-i+1, g$为区间内数为$c$的个数。代码： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;map&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 1500 + 5; int n, q; char s[MAXN]; void clean() { } int solve() { clean(); scanf(&quot;%s%d&quot;, s + 1, &amp;q); char ch[10]; for (int i = 1; i &lt;= q; i++) { int m; scanf(&quot;%d%s&quot;, &amp;m, ch); char c = ch[0]; int l = 1, r, len = 0, ans = 0; for (r = 1; r &lt;= n; r++) { if (s[r] != c) len++; if (len &gt; m) { if (s[l] != c) len--; l++; } ans = max(ans, r - l + 1); } printf(&quot;%d\n&quot;, ans); } return 0; } int main() { scanf(&quot;%d&quot;, &amp;n), solve(); return 0; } 第四题 777C题意：给出$n \cdot m$的矩阵，$k$次查询，如果第$l$行到$r$行至少有一列是非递减的，则输出Yes，否则输出No解：这题时间复杂度有点迷……原矩阵中每一段非递减序列都看作一条线段，询问也看作线段，即转化为线段包含问题。只要有线段包含了询问线段，就可以输出Yes。我们记录每一行开始最长的非递减序列，然后进行去重操作，如果之前的线段包括了这条，这条就可以删去。并且按照行来做，只能前面的包含后面的线段，因为开始位置在递增。然后对于询问直接找就行。优化是如果当前所有线段长度没有询问线段长，就直接输出No。极端数据应该会出一个递减序列来卡。知识点：时间复杂度这种很迷的直接写就OK代码： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 100000 + 5; vector&lt;int&gt; G[MAXN]; int tot, n, m, q, dp[MAXN], mks; set&lt;int&gt; s; pair&lt;int, int &gt; p[MAXN]; void clean() { mks = 0, tot = 0, ms(dp, 0); } int solve() { clean(); int x; for (int j = 1; j &lt;= m; j++) G[0].push_back(0); for (int i = 1; i &lt;= n; i++) { G[i].push_back(0); for (int j = 1; j &lt;= m; j++) scanf(&quot;%d&quot;, &amp;x), G[i].push_back(x); } for (int j = 1; j &lt;= m; j++) { int lst = 1, tmp = 1; for (int i = 2; i &lt;= n; i++) { if (G[i][j] &lt; G[i - 1][j]) { dp[lst] = max(dp[lst], tmp); tmp = 1, lst = i; continue; } tmp++; } dp[lst] = max(dp[lst], tmp); } for (int whw, i = 1; i &lt;= n; i++) { whw = dp[i] + i - 1; mks = max(mks, dp[i]); if (s.lower_bound(whw) != s.end()) { } else s.insert(whw), p[++tot] = make_pair(i, i + dp[i] - 1); } scanf(&quot;%d&quot;, &amp;q); while (q--) { int f = 0, l, r; scanf(&quot;%d%d&quot;, &amp;l, &amp;r); if (r - l + 1 &gt; mks) { printf(&quot;No\n&quot;); continue; } for (int i = 1; p[i].first &lt;= l; i++) { if (p[i].second &gt;= r) { printf(&quot;Yes\n&quot;), f = 1; break; } } if (!f) printf(&quot;No\n&quot;); } return 0; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m), solve(); return 0; } 第五题 764C题意：给出一个无根加权树，求出一个点使得这个点为根时每个子树颜色相同。解：预处理每一个点(包括自己)相连的点颜色总数。然后如果图中每个点相连的点颜色总数不超过2，那么有一个颜色总数为2的点必然会与其他所有颜色总数为2的点相连。枚举一下是否有这样的点即可。如果超过2，那么树中只能有一个超过2的点，并且这个点与其他所有颜色总数为2的点连通。判断一下即可。知识点：本题与CF 796C相似，都是找点判断信息(度数等)，然后利用信息来解题代码： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 100000 + 5; int n, c[MAXN], df[MAXN], tax[MAXN]; vector&lt;int&gt; G[MAXN]; void ins(int x, int y) {G[x].push_back(y), G[y].push_back(x);} void clean() { ms(tax, 0), ms(df, 0); } int solve() { clean(); for (int x, y, i = 1; i &lt; n; i++) scanf(&quot;%d%d&quot;, &amp;x, &amp;y), ins(x, y); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;c[i]); int f = 0; for (int i = 1; i &lt; n; i++) if (c[i] != c[i + 1]) f = 1; if (!f) return printf(&quot;YES\n1\n&quot;), 0; for (int i = 1; i &lt;= n; i++) { tax[c[i]] = 1, df[i]++; for (int j = 0; j &lt; (int)G[i].size(); j++) { int v = G[i][j]; if (!tax[c[v]]) df[i]++; tax[c[v]] = 1; } for (int j = 0; j &lt; (int)G[i].size(); j++) { int v = G[i][j]; tax[c[v]] = 0; } tax[c[i]] = 0; } int h2 = 0, mks = 0, pos; for (int i = 1; i &lt;= n; i++) { if (df[i] == 2) h2++; if (mks &lt;= df[i]) { if (mks &gt; 2) return printf(&quot;NO\n&quot;), 0; mks = df[i], pos = i; } } if (mks &gt; 2) { int cnt = 0; for (int j = 0; j &lt; (int)G[pos].size(); j++) { int v = G[pos][j]; if (df[v] == 2) cnt++; } if (cnt == h2) return printf(&quot;YES\n%d\n&quot;, pos), 0; else return printf(&quot;NO\n&quot;), 0; } else { for (int u = 1; u &lt;= n; u++) if (df[u] == 2) { int cnt = 1; for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i]; if (df[v] == 2) cnt++; } if (cnt == h2) return printf(&quot;YES\n%d\n&quot;, u), 0; } } return printf(&quot;NO\n&quot;), 0; return 0; } int main() { scanf(&quot;%d&quot;, &amp;n), solve(); return 0; } 第六题 608CCF 608C题意：有$n$个灯塔，每个灯塔有属性（坐标，向左的照射范围），所有灯塔坐标两两不同。我们从右往左，对于每个灯塔，其所照射到的所有灯塔都被认定为被破坏。 我们现在可以在所有灯塔的右边，布置一个新的灯塔，位置和范围任意定。 问是否有一种布置灯塔的方案，可以使得被破坏的灯塔数尽可能少，并输出最少破坏的灯塔数。解：题意中布置一个新的灯塔可以让右边任意连续灯塔破坏。相当于使得第$i$个灯塔，作为没被破坏的最后一个灯塔。 我们这样就可以DP了，每个灯塔可以从他前面攻击范围之外第一个转移。攻击范围之外第一个可以二分得到。知识点：这种题目抽象化之后要往能否转移方向去思考。比如本题设置$dp(i)$为第$i$个灯塔，作为没被破坏的最后一个灯塔, 之前所有存在灯塔最大值。代码： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 100000 + 5; int n, dp[MAXN]; pair&lt;int, int &gt; p[MAXN]; void clean() { } int solve() { clean(); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d%d&quot;, &amp;p[i].first, &amp;p[i].second); sort(p + 1, p + 1 + n); int ans = 1000000000; for (int i = 1; i &lt;= n; i++) { int pos = lower_bound(p + 1, p + 1 + n, make_pair(p[i].first - p[i].second, -1)) - p - 1; dp[i] = dp[pos] + 1; ans = min(ans, n - dp[i]); } printf(&quot;%d\n&quot;, ans); return 0; } int main() { scanf(&quot;%d&quot;, &amp;n), solve(); return 0; } 第七题 602CCF 602C题意：给你一个无向图有一些边，火车可以开在这些边上，而公交车可以开在补图的边上。求一个最优方案使得火车和公交车从1到$n$时间最短。在同一时刻火车和公交车不能在一个点上。解：这是一个完全图、补图问题，边$1-n$一定存在。所以只要看是火车存在还是公交车存在这条边就可以了，之后就 BFS 一个最短路即可。知识点：要善于挖掘题目的信息，比如此题如果没有了补图，则本题变为了完全不同的题目。并且数据范围小也是一个重要信息。代码： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 400 + 5; struct node { int u, len; }; int n, m, ma[MAXN][MAXN], k, vis[MAXN]; queue&lt;node&gt; q; void ins(int x, int y) {ma[x][y] = ma[y][x] = 1;} void clean() { ms(vis, 0), ms(ma, 0); } int solve() { clean(); for (int x, y, i = 1; i &lt;= m; i++) scanf(&quot;%d%d&quot;, &amp;x, &amp;y), ins(x, y); if (ma[1][n] == 1) k = 1; else k = 0; vis[1] = 1, q.push((node){1, 0}); while (!q.empty()) { node &amp;p = q.front(); q.pop(); if (p.u == n) return printf(&quot;%d\n&quot;, max(1, p.len)), 0; for (int i = 1; i &lt;= n; i++) if ((ma[p.u][i] ^ k) == 1) { if (!vis[i]) vis[i] = 1, q.push((node){i, p.len + 1}); } } printf(&quot;-1\n&quot;); return 0; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m), solve(); return 0; } 第八题 552CCF 552C题意：要用质量为$w^0,w^1,w^2……,w^{100}$的砝码各$1$个称出重量$m$，砝码可以放在天平左边也可以放在右边。问是否可以称出。解：$w \leq 3$时可以表示所有的数$m$。将$m$用$w$进制表示，如果该位不是$0,1$和$w-1$则无解。如果是$w-1$，则这一位的砝码必须加在物体这边，要让当前的$m$加一。知识点：这种用幂的东西分一个数的和进制有关。代码： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; int w, m; void clean() { } int solve() { clean(); if (w &lt;= 3) return printf(&quot;YES\n&quot;), 0; while (m) { int tmp = m % w; m /= w; if (tmp == w - 1) m++; if (tmp != w - 1 &amp;&amp; tmp != 1 &amp;&amp; tmp != 0) return printf(&quot;NO\n&quot;), 0; } printf(&quot;YES\n&quot;); return 0; } int main() { scanf(&quot;%d%d&quot;, &amp;w, &amp;m), solve(); return 0; } 第九题 567CCF 567C题意：给你一个序列,求序列中长度为$3$的公比为$k$的子序列的个数.解：三点问题必然枚举中间点$i$，然后只需要找左边$i/k$的个数和右边$ik$的个数，乘法原理即可。注意$i$必须整除$k$才能进行操作。查询方法对每一个权值开vector存权值单调地出现位置，然后要查询一个区间权值出现次数直接在这个vector里二分区间左右端点相减即可。对于开不下，因为总数小，开个map压第一维。知识点：运用了CF510D的map压第一维。CF987C三点枚举中间点。bzoj 2724记录每种颜色出现的位置单调放在vector里，查询区间的长度即为颜色出现次数。代码： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;map&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const LL MAXN = 200000 + 5; LL n, k, a[MAXN], ans; map&lt;LL, vector&lt;LL &gt; &gt; ma; LL getNum(LL x, LL l, LL r) { return upper_bound(ma[x].begin(), ma[x].end(), r) - upper_bound(ma[x].begin(), ma[x].end(), l - 1); } void clean() { } int solve() { clean(); for (LL i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;a[i]), ma[a[i]].push_back(i); ans = 0; for (LL i = 2; i &lt; n; i++) { if (a[i] % k) continue; LL q = getNum(a[i] / k, 1, i - 1), h = getNum(a[i] * k, i + 1, n); ans += q * h; } printf(&quot;%lld\n&quot;, ans); return 0; } int main() { scanf(&quot;%lld%lld&quot;, &amp;n, &amp;k), solve(); return 0; } 第十题 711CCF 711C题意：给你一列$n$棵树。给你$m$种颜色，这一列树中有些已经被涂好颜色了，但有些没有涂颜色。现在要给这些没有涂颜色的树上色，对于第$i$颗树，要涂第$j$种颜色，需要消耗$p_{ij}$的颜料。定义这一列树的美丽值为连续相同颜色段的段数。问使得美丽值为$k$的所需消耗的颜料的最小值。解：刚开始想了区间DP，状态太暴力了。整区间询问的题目就不用区间DP了，直接上最简单的DP即可。设$dp(i,j,k)$为前$i$棵树美丽值为$j$，$i$位置涂了$k$颜色的最小值那么当$a_i≠0$时 ($u≠k，1 \leq u \leq m$)$$dp(i,j,k)=min(dp(i -1,j,k),dp(i-1,j-1,u))$$当$a_i=0$时 ($u≠k，1 \leq u \leq m$)$$dp(i,j,k)=min(dp(i -1,j,k),dp(i-1,j-1,u))+p_{ik}$$初始化所有状态设为$∞$，然后特殊值当$a_1≠0$时，$dp(1,1,a_1)=0$。当$a_1=0$时，$dp(1,1,k)=p_{1k} (1 \leq k \leq m)$然后转移即可。知识点：整区间询问的题目就不用区间DP了，直接上最简单的DP即可。代码： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;map&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const LL MAXN = 100 + 5, INF = 4223372036854775807ll; LL n, m, q, a[MAXN], dp[MAXN][MAXN][MAXN], p[MAXN][MAXN]; void clean() { for (LL i = 0; i &lt;= 101; i++) for (LL j = 0; j &lt;= 101; j++) for (LL k = 0; k &lt;= 101; k++) dp[i][j][k] = INF; } int solve() { clean(); for (LL i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;a[i]); for (LL i = 1; i &lt;= n; i++) for (LL j = 1; j &lt;= m; j++) scanf(&quot;%lld&quot;, &amp;p[i][j]); if (a[1] != 0) dp[1][1][a[1]] = 0; else { for (LL k = 1; k &lt;= m; k++) dp[1][1][k] = p[1][k]; } for (LL i = 2; i &lt;= n; i++) { for (LL j = 1; j &lt;= i; j++) { for (LL k = 1; k &lt;= m; k++) { if (a[i] == 0) { dp[i][j][k] = dp[i - 1][j][k] + p[i][k]; for (LL u = 1; u &lt;= m; u++) if (u != k) { dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j - 1][u] + p[i][k]); } } else { if (k != a[i]) continue; dp[i][j][k] = dp[i - 1][j][k]; for (LL u = 1; u &lt;= m; u++) if (u != k) { dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j - 1][u]); } } } } } LL ans = INF; for (LL i = 1; i &lt;= m; i++) ans = min(ans, dp[n][q][i]); if (ans == INF) printf(&quot;-1\n&quot;); else printf(&quot;%lld\n&quot;, ans); return 0; } int main() { scanf(&quot;%lld%lld%lld&quot;, &amp;n, &amp;m, &amp;q), solve(); return 0; } 第十一题 761CCF 761C题意：有$n$个串，每个串有$m$个字符，可以由数字，小写字母，和三个符号组成，现在要在这$n$个串中每个串找出一个字符组成一个密码，这密码要求至少要有一个数字，一个字母和一个特殊字符，一开始每个字符串都指在第一个字符，每次移动可以往两边移动，也就是说可以往左右两边移动，要求所得到的密码移动的次数最少。解：贪心枚举做法：枚举每个串转到字母、数字、符号的最小花费，然后最后$n^3$综合一下解即可。DP做法，设$dp(i,j,k,u)$为前$i$行状态为$(j,k,u)$(字母、数字、符号)的最小花费，则直接转移即可。知识点：能暴力枚举的题目千万别上DP，耗时耗力，最优化问题不过就是1暴力2DP3贪心，想一想即可代码： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;map&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 50 + 5, INF = 1000000000; int n, m, dp[MAXN][2][2][2], whw[MAXN][3]; char s[MAXN][MAXN]; void clean() { for (int i = 0; i &lt;= 51; i++) for (int j = 0; j &lt; 2; j++) for (int k = 0; k &lt; 2; k++) for (int u = 0; u &lt; 2; u++) dp[i][j][k][u] = INF; for (int i = 0; i &lt;= 51; i++) for (int j = 0; j &lt; 3; j++) whw[i][j] = INF; } int solve() { clean(); for (int i = 1; i &lt;= n; i++) scanf(&quot;%s&quot;, s[i] + 1); dp[0][0][0][0] = 0; int hf = 0, h0 = 0, ha = 0; for (int i = 1; i &lt;= n; i++) { if (s[i][1] == &#39;#&#39; || s[i][1] == &#39;*&#39; || s[i][1] == &#39;&amp;&#39;) hf = 1; if (&#39;0&#39; &lt;= s[i][1] &amp;&amp; s[i][1] &lt;= &#39;9&#39;) h0 = 1; if (&#39;a&#39; &lt;= s[i][1] &amp;&amp; s[i][1] &lt;= &#39;z&#39;) ha = 1; dp[i][hf][h0][ha] = 0; } for (int i = 1; i &lt;= n; i++) { int nowl = m, nowr = 2, cnt = 1; while (nowl &gt;= nowr) { if (whw[i][0] == INF &amp;&amp; (s[i][nowl] == &#39;#&#39; || s[i][nowl] == &#39;*&#39; || s[i][nowl] == &#39;&amp;&#39;)) whw[i][0] = cnt; if (whw[i][1] == INF &amp;&amp; &#39;0&#39; &lt;= s[i][nowl] &amp;&amp; s[i][nowl] &lt;= &#39;9&#39;) whw[i][1] = cnt; if (whw[i][2] == INF &amp;&amp; &#39;a&#39; &lt;= s[i][nowl] &amp;&amp; s[i][nowl] &lt;= &#39;z&#39;) whw[i][2] = cnt; if (whw[i][0] == INF &amp;&amp; (s[i][nowr] == &#39;#&#39; || s[i][nowr] == &#39;*&#39; || s[i][nowr] == &#39;&amp;&#39;)) whw[i][0] = cnt; if (whw[i][1] == INF &amp;&amp; &#39;0&#39; &lt;= s[i][nowr] &amp;&amp; s[i][nowr] &lt;= &#39;9&#39;) whw[i][1] = cnt; if (whw[i][2] == INF &amp;&amp; &#39;a&#39; &lt;= s[i][nowr] &amp;&amp; s[i][nowr] &lt;= &#39;z&#39;) whw[i][2] = cnt; cnt++, nowl--, nowr++; } } int ans = INF; for (int i = 1; i &lt;= n; i++) for (int j = 0; j &lt; 2; j++) for (int k = 0; k &lt; 2; k++) for (int u = 0; u &lt; 2; u++) { dp[i][j][k][u] = min(dp[i][j][k][u], dp[i - 1][j][k][u]); if (j) dp[i][j][k][u] = min(dp[i][j][k][u], dp[i - 1][0][k][u] + whw[i][0] * ((s[i][1] == &#39;#&#39; || s[i][1] == &#39;*&#39; || s[i][1] == &#39;&amp;&#39;) ^ 1)); if (k) dp[i][j][k][u] = min(dp[i][j][k][u], dp[i - 1][j][0][u] + whw[i][1] * ((&#39;0&#39; &lt;= s[i][1] &amp;&amp; s[i][1] &lt;= &#39;9&#39;) ^ 1)); if (u) dp[i][j][k][u] = min(dp[i][j][k][u], dp[i - 1][j][k][0] + whw[i][2] * ((&#39;a&#39; &lt;= s[i][1] &amp;&amp; s[i][1] &lt;= &#39;z&#39;) ^ 1)); ans = min(dp[i][1][1][1], ans); } printf(&quot;%d\n&quot;, ans); return 0; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m), solve(); return 0; } 第十一题 750CCF 750C题意：每个人都有一个$rating$，是一个整数，可以是负数以及$0$，$div1$高于$1900$分 $div2$低于$1899$。有个人参加了$n$场，比赛，但是只记得每一场是$div$几，以及每一场赛后的$rating$的变化量，请问他现在最高可能多少分，如果不可能有符合的情况 输出$Impossible$，如果可以无限大分数，输出$Infinity$解：本题可以用二分解决。但是这里可以用另一种方法，设当前最开始的$rating=x$, 那么如果出现了一场$div1$，那么他的当前$rating$一定大于$1900$，所以$x + sum \geq 1900$，推导一下就可以是$x \geq 1900 - sum$，$div2$同理。这样可以一步步用区间逼近答案。知识点：这种题目要求只输出一个答案这样的符合二分条件的题目，要想到二分答案。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;map&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int INF = 200000000; int sum = 0, n, c, d, l, r; void clean() { } int solve() { clean(); scanf(&quot;%d&quot;, &amp;n); l = -INF, r = INF; for (int i = 1; i &lt;= n; i++) { scanf(&quot;%d%d&quot;, &amp;c, &amp;d); if (d == 1) l = max(l, 1900 - sum); if (d == 2) r = min(r, 1899 - sum); sum += c; } if (l &gt; r) printf(&quot;Impossible&quot;); else { if (r == INF) printf(&quot;Infinity&quot;); else printf(&quot;%d\n&quot;, sum + r); } return 0; } int main() { solve(); return 0; } 第十二题 740CCF 740C题意：题目的要求是构造出一个长度为$ n $的数列, 构造条件是在接下来给出的$ m$ 个子区间中, 要求每一个子区间的$mex$值最大, 然后在这$ m$ 个子区间产生的$mex$值中取最小的输出, 并且输出构造出来的序列解：永远不会的构造题qwq。。答案就是最小区间长$d$。然后构造一个序列使得每个最小区间都能取到$[0,d-1]$，就是一个$0,1,2,……,d-1,0,1,2,……,d-1$的形式知识点：代码： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;map&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; int n, m, l, r, ans; void clean() { } int solve() { clean(); scanf(&quot;%d%d&quot;, &amp;l, &amp;r), ans = r - l + 1; for (int i = 2; i &lt;= m; i++) scanf(&quot;%d%d&quot;, &amp;l, &amp;r), ans = min(ans, r - l + 1); printf(&quot;%d\n&quot;, ans); for (int i = 0; i &lt; n; i++) printf(&quot;%d &quot;, i % ans); return 0; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m), solve(); return 0; } 第十三题 373CCF 373C题意：有$n$个袋鼠每个袋鼠的口袋里可以放一只体重小于其体重的小于它二分之一重量的袋鼠现在将一些袋鼠放进其它的袋鼠口袋里问最多能见到多少袋鼠。解：贪心，每个小袋鼠找能装下他的最小袋鼠。代码： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double int n, a[500000 + 5]; void clean() { } int solve() { clean(); scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]); std::sort(a + 1, a + 1 + n); int ans = n; for (int i = n / 2; i; i--) { if (ans == i) break; if (a[ans] &gt;= 2 * a[i]) ans--; } printf(&quot;%d\n&quot;, ans); return 0; } int main() { solve(); return 0; } 第十四题 379CCF 379C题意：给你一个序列，然后序列每个数必须要大于等于自己现在的数并且不能和其他数一样解：排序之后贪心从小到大赋值即可。代码： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double LL n, ans[300000 + 5]; std::pair&lt;LL, LL &gt; a[300000 + 5]; inline LL max(LL a, LL b) {return a &gt; b ? a : b;} inline LL min(LL a, LL b) {return a &lt; b ? a : b;} void clean() { } int solve() { clean(); scanf(&quot;%lld&quot;, &amp;n); for (LL i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;a[i].first), a[i].second = i; std::sort(a + 1, a + 1 + n); LL tot = 1, co = 1, lst = 0; for (LL i = 1; i &lt;= n; i++) { if (a[i].first == a[i - 1].first) co++; else tot = lst + 1, co = 1; lst = ans[a[i].second] = max(a[i].first, tot) + co - 1; } for (LL i = 1; i &lt;= n; i++) printf(&quot;%lld &quot;, ans[i]); return 0; } int main() { solve(); return 0; } 第十五题 712CCF 712C题意：给你一个长度为$x$的等边三角形，每一秒你能修改一条边的长度，要你修改到长度为$y$的等边三角形，要求修改过程中保证它是一个三角形。解：从$y$倒推到$x$, 每次将最小边修改为当前最大边，即$c=a+b-1$知识点：正难则反代码： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double inline int max(int a, int b) {return a &gt; b ? a : b;} inline int min(int a, int b) {return a &lt; b ? a : b;} int x, y; void clean() { } int solve() { clean(); scanf(&quot;%d%d&quot;, &amp;x, &amp;y); int a[10]; a[0] = a[1] = a[2] = y; int tms = 0; while (1) { std::sort(a, a + 3); if (a[0] &gt;= x &amp;&amp; a[1] &gt;= x &amp;&amp; a[2] &gt;= x) break; a[0] = a[1] + a[2] - 1, tms++; } printf(&quot;%d\n&quot;, tms); return 0; } int main() { solve(); return 0; } 第十六题 1025C (交换题)CF 1025C题意：给出一个01字符串，你可以在任意位置分开字符串，然后将两段字符串翻转后相连，问最长能得到的交替字符串长。解：将字符串首尾相接，每次切是相当于翻转了环，环内各元素连接并没发生变化，所以在环中找最长交替字符串长就行。直接拼接一个相同字符串在后面，然后求最长交替字符串长即可，用 DP 扫一遍。注意答案不能超过原长度，取$min$ //==========================Head files========================== #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #include&lt;set&gt; #include&lt;iostream&gt; #define LL long long #define db double #define mp make_pair #define pr pair&lt;int, int&gt; #define fir first #define sec second #define pb push_back #define ms(i, j) memset(i, j, sizeof i) using namespace std; //==========================Templates========================== inline int read() { int x = 0, f = 1; char c = getchar(); while(c &lt; &#39;0&#39; || c &gt; &#39;9&#39;){if (c == &#39;-&#39;) f = -1; c = getchar();} while(c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;){x = x * 10 + c - &#39;0&#39;; c = getchar();} return x * f; } inline LL readl() { LL x = 0, f = 1; char c = getchar(); while(c &lt; &#39;0&#39; || c &gt; &#39;9&#39;){if (c == &#39;-&#39;) f = -1; c = getchar();} while(c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;){x = x * 10 + c - &#39;0&#39;; c = getchar();} return x * f; } int power(int a, int b) { int ans = 1; while (b) { if(b &amp; 1) ans = ans * a; b &gt;&gt;= 1; a = a * a; } return ans; } int power_mod(int a, int b, int mod) { a %= mod; int ans = 1; while (b) { if(b &amp; 1) ans = (ans * a) % mod; b &gt;&gt;= 1, a = (a * a) % mod; } return ans; } LL powerl(LL a, LL b) { LL ans = 1ll; while (b) { if(b &amp; 1ll) ans = ans * a; b &gt;&gt;= 1ll;a = a * a; } return ans; } LL power_modl(LL a, LL b, LL mod) { a %= mod; LL ans = 1ll; while (b) { if(b &amp; 1ll) ans = (ans * a) % mod; b &gt;&gt;= 1ll, a = (a * a) % mod; } return ans; } LL gcdl(LL a, LL b) {return b == 0 ? a : gcdl(b, a % b);} LL abssl(LL a) {return a &gt; 0 ? a : -a;} int gcd(int a, int b) {return b == 0 ? a : gcd(b, a % b);} int abss(int a) {return a &gt; 0 ? a : -a;} //==========================Main body========================== #define LD &quot;%I64d&quot; #define D &quot;%d&quot; #define pt printf #define sn scanf #define pty printf(&quot;YES\n&quot;) #define ptn printf(&quot;NO\n&quot;) inline int read(); inline LL readl(); int power(int a, int b); int power_mod(int a, int b, int mod); int gcd(int a, int b); int abssl(int a); LL powerl(LL a, LL b); LL power_modl(LL a, LL b, LL mod); LL gcdl(LL a, LL b); LL abssl(LL a); //==========================Code here========================== char s[100000 + 5]; int gg[200000 + 5]; int main() { cin &gt;&gt; (s + 1); int n = strlen(s + 1); for (int i = 1; i &lt;= n; i++) { gg[i] = gg[i + n] = (s[i] == &#39;b&#39; ? 1 : 0); } int lst = 0, tot = 0, ans = 0; gg[0] = -1; for (int i = 1; i &lt;= 2 * n; i++) { if (lst != gg[i]) lst = gg[i], tot++; else { tot = 1; } ans = max(ans, tot); } printf(&quot;%d\n&quot;, min(ans, n)); return 0; } 第十六题 873BCF 873B题意：求一个01字符串中01数量相同最长的子串。解：将0看作-1然后做前缀和，前缀和相同的位置进行更新。代码： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;map&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double int n; char s[100000 + 5]; std::map&lt;int, int &gt; m; void clean() { } int solve() { clean(); scanf(&quot;%d%s&quot;, &amp;n, s + 1); int qzh = 0, ans = 0; m[0] = 1; for (int i = 1; i &lt;= n; i++) { qzh += (s[i] == &#39;0&#39; ? -1 : 1); if (m[qzh]) ans = std::max(ans, i - m[qzh] + 1); else m[qzh] = i + 1; } printf(&quot;%d\n&quot;, ans); return 0; } int main() { solve(); return 0; } 第十八题 1016DCF 1016D题意：输入$n，m$，表示一个矩阵的行数和列数，然后给出矩阵的每行每列的异或值，问是否存在这样的矩阵，存在输出YES并随便输出一个符合条件的矩阵，否则输出NO解：好水啊，矩阵$n-1$行$m-1$列全填0，然后每一行最后一个填$a_i$, 最后一行前面的填$b_i$，最重要的是$(n,m)$填什么。将最后一行前$m-1$个$b_i$异或和求出该数填什么。然后用上面的$a_i$异或和验证答案，不相同则无解。知识点：a^x=b中 x=b^a对于样例的输出构造： YES 0 0 2 5 3 15 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double const int MAXN = 100 + 5; int n, m; int a[MAXN], b[MAXN], xa = 0, xb = 0; void clean() { } int solve() { clean(); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]), xa ^= (i != n ? a[i] : 0); for (int i = 1; i &lt;= m; i++) scanf(&quot;%d&quot;, &amp;b[i]), xb ^= (i != m ? b[i] : 0); int whw = a[n] ^ xb; if ((whw ^ xa) != b[m]) return printf(&quot;NO\n&quot;), 0; printf(&quot;YES\n&quot;); for (int i = 1; i &lt; n; i++) { for (int j = 1; j &lt; m; j++) printf(&quot;0 &quot;); printf(&quot;%d\n&quot;, a[i]); } for (int i = 1; i &lt; m; i++) printf(&quot;%d &quot;, b[i]); printf(&quot;%d\n&quot;, whw); return 0; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m), solve(); return 0; } 第十九题 988DCF 988D题意：找最长的序列,使得该序列的任意两个值的差是$2$的倍数. 输出长度,并输出元素解：只有3/2/1三种可能。枚举3的情况，2的情况，没有输出1。代码： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double std::set&lt;int &gt; s; int n, a[200000 + 5], maxd, mind; void clean() { maxd = -1000000000, mind = 1000000000; } int solve() { clean(); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]), mind = std::min(mind, a[i]), maxd = std::max(maxd, a[i]), s.insert(a[i]); for (int i = 1; i &lt;= n; i++) { for (int j = 0; ; j++) { int d = (1 &lt;&lt; j), lt = a[i] - d, rt = a[i] + d; if (lt &lt; mind || rt &gt; maxd) break; if (s.count(lt) &amp;&amp; s.count(rt)) { printf(&quot;3\n%d %d %d\n&quot;, lt, a[i], rt); return 0; } } } for (int i = 1; i &lt;= n; i++) { for (int j = 0; ; j++) { int d = (1 &lt;&lt; j), rt = a[i] + d; if (rt &gt; maxd) break; if (s.count(rt)) { printf(&quot;2\n%d %d\n&quot;, a[i], rt); return 0; } } } printf(&quot;1\n%d\n&quot;, a[1]); return 0; } int main() { scanf(&quot;%d&quot;, &amp;n), solve(); return 0; } 第二十题 1027CCF 1027C题意：给你$n$个边长，让你从中找出四个构成一个矩形，使得该矩形的周长的平方除以面积的值最小。解：相邻的两种边长里一定有最优解。证明：原式即为$\frac{(a+b)^2}{ab}$，转化为$\frac{a^2+ab+b^2}{ab}=\frac{a^2+b^2}{ab}+2$，那么就让$\frac{a^2+b^2}{ab}$最小即可，注意到这是一个加的形式，且这个值为定值，根据均值不等式，$\frac{a^2}{ab}= \frac{b^2}{ab}$时有和最小值，即$a=b$时。所以相邻的两种边长里一定有最优解。知识点：注意自己代码实现不要超过预期的复杂度了。求最小最大的和/积为定值数学问题可以想到均值不等式。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double int n, a[1000000 + 5], tax[1000000 + 5], gg[1000000 + 5], tot; db mks; int ans1, ans2; inline db cal(int a_1, int a_2) { return (db)(2 * (a_1 + a_2)) * (db)(2 * (a_1 + a_2)) / ((db)a_1 * (db)a_2); } void clean() { } int solve() { clean(); scanf(&quot;%d&quot;, &amp;n); tot = 0; for (int i = 1; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;a[i]), tax[a[i]]++; if (tax[a[i]] == 4) { printf(&quot;%d %d %d %d\n&quot;, a[i], a[i], a[i], a[i]); for (int j = 1; j &lt;= i; j++) tax[a[j]] = 0; for (int j = i + 1; j &lt;= n; j++) scanf(&quot;%d&quot;, &amp;a[i]); return 0; } } std::sort(a + 1, a + 1 + n); for (int i = 1; i &lt;= n; i++) if (tax[a[i]] &gt;= 2) gg[++tot] = a[i], tax[a[i]] = 0; int z1 = gg[1], z2 = gg[2]; mks = cal(z1, z2), ans1 = z1, ans2 = z2; for (int i = 3; i &lt;= tot; i++) { z1 = z2, z2 = gg[i]; db tmp = cal(z1, z2); if (mks - tmp &gt;= 1e-12) mks = tmp, ans1 = z1, ans2 = z2; } printf(&quot;%d %d %d %d\n&quot;, ans1, ans1, ans2, ans2); for (int i = 1; i &lt;= n; i++) tax[a[i]] = 0; return 0; } int main() { int T; scanf(&quot;%d&quot;, &amp;T); while (T--) solve(); return 0; } 第二十一题 1008CCF 1008C题意：给你一个序列，你可以生成这个序列的任意一个排列，对于某个排列，如果这个排列上某个位置的值大于原序列的值，那么就会产生1的贡献，问你最大能有多少贡献。解：multiset 记录一下当前可选的值，线性扫一遍找比这个值大一点的数，找到后删除答案加一。代码： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double int n, a[100000 + 5]; std::multiset&lt;int &gt; s; void clean() { } int solve() { clean(); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]), s.insert(a[i]); int ans = 0; for (int i = 1; i &lt;= n; i++) { std::multiset&lt;int &gt;::iterator it = s.upper_bound(a[i]); if (it != s.end()) ans++, s.erase(it); } printf(&quot;%d\n&quot;, ans); return 0; } int main() { scanf(&quot;%d&quot;, &amp;n), solve(); return 0; } 第二十二题 977ECF 977E题意：在一个无向图中找只有一个圈的环的个数。解：只有一个圈的环里的点一定度数都为2, 知道这个DFS一下就行了。这题也可以用并查集把连通性求出来再存起来检查联通块里点度数都为2。知识点：只有一个圈的环里的点一定度数都为2 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double const int MAXN = 200000 + 5; int fl, n, m, ans, deg[MAXN], vis[MAXN]; std::vector&lt;int &gt; G[MAXN]; inline void ins(int a, int b) {G[a].push_back(b), G[b].push_back(a), deg[b]++, deg[a]++;} void dfs(int u) { if (deg[u] != 2) fl = 0; for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i]; if (!vis[v]) vis[v] = 1, dfs(v); } } void clean() { ms(vis, 0), ms(deg, 0), ans = 0; } int solve() { clean(); for (int a, b, i = 1; i &lt;= m; i++) scanf(&quot;%d%d&quot;, &amp;a, &amp;b), ins(a, b); for (int i = 1; i &lt;= n; i++) if (!vis[i]) fl = 1, dfs(i), ans += fl; printf(&quot;%d\n&quot;, ans); return 0; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m), solve(); return 0; } 第二十三题 1005DCF 1005D题意：给你一个字符串,然后让你尽可能多的去分解这个字符串 使得每一个分解出来的子串的和都是3的倍数解：如果当前一个数已经是3的倍数，直接切开单独成立，这样是最优的否则比较两个数，如果这两个数的和是3的倍数就切开考虑三个数的情况，前两个数的的余数可以是${2,2}，{1，1}$，第三个数余数可以是$1,2$，对于这三个数考虑所有情况都能找到3的倍数的段，所以枚举的时候只需要往后枚举至多3次即可。知识点：对于这种倍数的题目，多想想余数/数字上的规律代码： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;map&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double char s[200000 + 5]; void clean() {} int solve() { clean(); int ans = 0, sum = 0, js = 0, n = strlen(s + 1); for (int i = 1; i &lt;= n; i++) { sum = (sum + s[i] - &#39;0&#39;) % 3, js++; if ((s[i] - &#39;0&#39;) % 3 == 0) {ans++, sum = 0, js = 0; continue;} if (sum == 0) {ans++, sum = 0, js = 0; continue;} if (js == 3) {ans++, sum = 0, js = 0; continue;} } printf(&quot;%d\n&quot;, ans); return 0; } int main() { scanf(&quot;%s&quot;, s + 1), solve(); return 0; } 第二十四题 999DCF 999D题意：要求改变一个数组,使得模$m$后,结果为$0,1,2,3,…,m-1$都是$n/m$个,每次操作可以选择一个数$+1$,问至少执行多少次,并输出最终的数组解：把多余的余数的位置拿出来放进set进行增加。枚举余数，如果余数少了，就在set里找严格比他小的那个余数，然后增加即可，要记得删除这个元素。找不到就找最大的余数增加。知识点：STL 的题目复杂点的应该写清楚再写代码emm，不要老是换数据结构set.begin()是set的最小元素。本题充分利用负数避免重载运算符。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;set&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double LL n, m, a[200000 + 6], b[200000 + 6], tax[200000 + 6]; std::set&lt;std::pair&lt;LL, LL&gt; &gt; s; void clean() { ms(tax, 0ll); } int solve() { clean(); for (LL i = 1ll; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;a[i]), b[i] = a[i] % m; for (LL i = 1ll; i &lt;= n; i++) { tax[b[i]]++; if (tax[b[i]] &gt; n / m) s.insert(std::make_pair(-b[i], i)), tax[b[i]]--; } LL ans = 0ll; for (LL i = 0ll; i &lt; m; i++) { while (tax[i] &lt; n / m) { std::set&lt;std::pair&lt;LL, LL&gt; &gt;::iterator it = s.upper_bound(std::make_pair(-i, 0ll)); if (it != s.end()) a[(*it).second] += i - (-(*it).first), tax[i]++, ans += i - (-(*it).first), s.erase(it); else { std::set&lt;std::pair&lt;LL, LL&gt; &gt;::iterator it = s.begin(); if (it != s.end()) a[(*it).second] += m - (-(*it).first) + i, tax[i]++, ans += m - (-(*it).first) + i, s.erase(it); } } } printf(&quot;%lld\n&quot;, ans); for (LL i = 1; i &lt;= n; i++) printf(&quot;%lld &quot;, a[i]); return 0; } int main() { scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m), solve(); return 0; } 第二十五题 1029DCF 1029D题意：给你$n$个数求两两拼接后能被$k$整除的数。解：$O(n^2)$会超时。对于题目条件就是$(a \cdot 10^{len_b}+b) \% k=0$即$(a, b)$合法。那么我们移项，得$(a \cdot 10^{len_b}) \% k=(k-b \%k) \% k$，那么我们可以把左边存进 map 里然后每次循环右边即可。放进去把所有可能的长度都放进去，一共有 10 个。查询就查询当前长度是否存在前缀$a$。要小心自己和自己组合的情况。知识点：余数整除等问题与数学数论密切相关，模的式子什么的可以进行转换(移项等)代码： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;map&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL unsigned long long #define db double LL n, k, a[200000 + 5], sm[20]; std::map&lt;LL, LL &gt; ma[20]; void clean() { } int solve() { clean(); for (LL i = 1; i &lt;= n; i++) scanf(&quot;%llu&quot;, &amp;a[i]); sm[0] = 1; for (LL i = 1; i &lt;= 12; i++) sm[i] = 10ll * sm[i - 1]; for (LL i = 1; i &lt;= n; i++) for (LL ws = 1; ws &lt;= 10; ws++) ma[ws][(a[i] * sm[ws]) % k]++; LL ans = 0; for (LL i = 1; i &lt;= n; i++) { LL ws = 0ll, tmp = a[i]; do {ws++, tmp /= 10;} while (tmp); ans += ma[ws][(k - a[i] % k) % k]; if (((a[i] * sm[ws]) % k + a[i]) % k == 0) ans--;//自己和自己组合的情况 } printf(&quot;%llu\n&quot;, ans); return 0; } int main() { scanf(&quot;%llu%llu&quot;, &amp;n, &amp;k), solve(); return 0; } 第二十六题 152CCF 152C题意：给出$n$个长度为$m$的字符串，任意两个字符串可以交换前$k$个字符，交换后字符串变成新的字符串，问最后能产生多少个不同的字符串解：对于两个串使用$(i,j,k),(i,j,k-1)$可以交换$k$位置的字符串，所以原题转化为求每个位置能改到多少种字符串，乘法原理即可。知识点：这种直观上不能扫描的都会有结论。或者结论可以辅助扫描。 #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define ULL unsigned long long #define db double LL n, m, ans; char s[105][105]; std::set&lt;char &gt; st; void clean() { } int solve() { clean(); ans = 1ll; for (LL i = 1; i &lt;= n; i++) scanf(&quot;%s&quot;, s[i] + 1); for (LL j = 1; j &lt;= m; j++) { st.clear(); for (LL i = 1; i &lt;= n; i++) st.insert(s[i][j]); ans = (ans * (LL)st.size()) % 1000000007; } printf(&quot;%lld\n&quot;, ans); return 0; } int main() { scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m), solve(); return 0; } 第二十七题 825ECF 825E题意：给你一个DAG，你要为每个点编号1-n使得每条边$(u,v)$编号$u$比$v$小解：DAG很容易想到拓扑排序，然后每次拓扑排序将拓扑出来的点标号，由于字典序最小，队列换成优先队列。但是这样有问题了，会WA6，原因是如果原图有两个点12和15并且12前面所有点入点为0，并且15连向12，那么此时会将15编号为12，但实际上可能可以将12编号为13，然后15编号为12。我们过早地把15编号导致不是字典序最小。但是我们发现倒过来做就是对的了。将图反向做拓扑排序，维护大根堆，然后从n开始往下编号。知识点：这种位置的题目肯定没那么容易被模板 * 过，应该会有一些坑点。很像CF 1064D #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;climits&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #include&lt;stack&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 100000 + 5; struct edge {int v, nxt;} ed[MAXN * 2]; int n, m, en, hd[MAXN], ino[MAXN], ans[MAXN]; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q; void ins(int x, int y) {ed[++en] = (edge){y, hd[x]}, hd[x] = en, ++ino[y];} void clean() { en = 0, ms(hd, -1), ms(ino, 0), ms(ans, 0); } int solve() { cin &gt;&gt; n &gt;&gt; m; clean(); for (int u, v, i = 1; i &lt;= m; ++i) scanf(&quot;%d%d&quot;, &amp;u, &amp;v), ins(u, v); for (int i = 1; i &lt;= n; ++i) if (ino[i] == 0) q.push(i); int now = 0; while (!q.empty()) { int p = q.top(); q.pop(); ans[p] = ++now; for (int i = hd[p]; i &gt; 0; i = ed[i].nxt) { edge &amp;e = ed[i]; --ino[e.v]; if (ino[e.v] == 0) q.push(e.v); } } for (int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, ans[i]); return 0; } } int main() { flyinthesky::solve(); return 0; } 第二十八题 525CCF 525C题意：给你$n$个棒子，每个棒子可以最多减$1$，请将这些棒子组成矩形，使得矩形面积总和最大。排序后从大到小贪心，因为棒子可以减一，所以大的可以减成小的，所以如果存在一个$x,x+1$，则可以有一个边为$x$。知识点：1、贪心思想 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;set&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { LL n, l[100000 + 5]; void clean() { } int solve() { clean(); cin &gt;&gt; n; for (LL i = 1; i &lt;= n; ++i) scanf(&quot;%lld&quot;, &amp;l[i]); sort(l + 1, l + 1 + n); LL mul = 1ll, tot = 0ll, ans = 0ll; for (LL i = n; i &gt;= 1ll; --i) { if (l[i] - l[i - 1ll] &lt;= 1ll) { mul *= l[i - 1ll], --i, tot += 2ll; } if (tot == 4ll) ans += mul, mul = 1ll, tot = 0ll; } cout &lt;&lt; ans; return 0; } } int main() { flyinthesky::solve(); return 0; } 第二十九题 991CCF 991C题意：两个人吃糖，A每天吃$k$颗糖，B每天吃剩余糖的$10\%$向下取整。A每天先吃，B后吃。问$k$至少为多少，能保证A总共吃的糖大于总量的一半。玄学，直接暴力复杂度不高，套个二分。注意奇偶性，n/10不要写成(int)(n*0.1) #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { LL n; bool chk(LL k) { LL tot = 0ll, tmp = n; while (tmp) { if (tmp &gt;= k) tot += k, tmp -= k; else tot += tmp, tmp = 0; if (tmp &gt;= 10) tmp -= tmp / 10; } return tot &gt;= (n + 1) / 2; } void clean() { } int solve() { clean(); cin &gt;&gt; n; LL l = 1, r = n + 1, ans; while (l &lt; r) { LL mid = (l + r) &gt;&gt; 1; if (chk(mid)) ans = r = mid; else l = mid + 1; } cout &lt;&lt; ans; return 0; } } int main() { flyinthesky::solve(); return 0; } 第三十题 985CCF 985C题意：需要造$n$个桶，每个桶需要$k$个木板，任意两个桶之间容积（一个桶中最短的木板的高度）的差距不能超过$l$，然后给你$nk$个木板，第$i$个木板的长度为$a_i$，问能否造出符合条件的$n$个桶，如果能的话问这$n$个桶的容积之和最大是多少，如果不能的话就输出$0$。解：根据短板效应，本题的限制因数在最小的那一块板和容积的差值。那么我们可以找到最后一个位置使得$a_p-a_l \leq l$，那么$[1, p]$之间的板子都能作为每个桶的容积(其实只有最小的那一块板影响最后的答案)。假设当前我们取了一个$x$, 那么我们尽可能地让这个$x$影响尽可能小的板，但是不能用光$[1,p]$之间的板。这样就可以扫描贪心了。注意判无解即为$p &lt; n$ #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { LL n, k, l, a[100000 + 5]; void clean() { } int solve() { clean(); cin &gt;&gt; n &gt;&gt; k &gt;&gt; l; for (LL i = 1; i &lt;= n * k; ++i) scanf(&quot;%lld&quot;, &amp;a[i]); sort(a + 1, a + 1 + n * k); if (a[n] - a[1] &gt; l) return printf(&quot;0\n&quot;), 0; LL pos = upper_bound(a + 1, a + 1 + n * k, a[1] + l) - a; LL ans = 0, whw = 0; for (LL i = 1; i &lt;= n; ++i) { ans += a[++whw]; for (LL j = 1; j &lt; k; ++j) { if (pos - whw - 1 &gt; n - i) ++whw; else break ; } } cout &lt;&lt; ans; return 0; } } int main() { flyinthesky::solve(); return 0; } 第三十一题 1092D1CF 1092D1题意：给你$n$个位置墙的高度，现在你有$2×1 $砖块，你可以竖直或者水平放置, 问你是否可以使得所有位置高度一样解：显然每个位置都更新到最大值。可以发现如果相邻的两个的差能被2整除即可通过加2达到同一高度然后再一起加到最大值。所以用栈维护。本题可以拓展为给定一个$01$串，求翻转任意两个相邻两个位置的01，能否使串全为0/1。做法相同，这种消除类似括号的要想到用栈来维护。 知识点：这种消除类似括号的要想到用栈来维护。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { int n, a[200000 + 5], top, st[200000 + 5]; void clean() { top = 0; } int solve() { clean(); scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i]); for (int i = 1; i &lt;= n; ++i) { if (!top) st[++top] = a[i]; else { if ((st[top] - a[i]) % 2 == 0) --top; else st[++top] = a[i]; } } if (top &lt;= 1) printf(&quot;YES\n&quot;); else printf(&quot;NO\n&quot;); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>计数原理</tag>
        <tag>贪心</tag>
        <tag>DP</tag>
        <tag>BFS</tag>
        <tag>枚举</tag>
        <tag>尺取法</tag>
        <tag>数学</tag>
        <tag>构造</tag>
        <tag>Xor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 459E(加边DP)]]></title>
    <url>%2FCodeforces459E%2F</url>
    <content type="text"><![CDATA[Codeforces 459E题意：一个有向图，找出一条最长的路径，这条路径上的每条边权重都严格递增，问最长的长度是多少？ 这题要求每条边权重都严格递增，那么直接把所有边权存起来按照大小排序，之后每种边权进行加边，就可以做 DP 了，因为排序保证了每条边权重都严格递增，只需要 DP 算出最优解即可。 本题求边权严格递增的路径，把边按照大小排序，把选择化为添加边，和CF 841D异曲同工。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;map&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 300000 + 5; int n, m, dp[MAXN], tmp[MAXN]; vector&lt;pair&lt;int, int &gt; &gt; ed[MAXN]; void clean() { } int solve() { clean(); for (int u, v, w, i = 1; i &lt;= m; i++) scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w), ed[w].push_back(make_pair(u, v)); for (int i = 1; i &lt;= 100000; i++) { if ((int)ed[i].size() == 0) continue; for (int j = 0; j &lt; (int)ed[i].size(); j++) { int u = ed[i][j].first, v = ed[i][j].second; tmp[v] = 0; } for (int j = 0; j &lt; (int)ed[i].size(); j++) { int u = ed[i][j].first, v = ed[i][j].second; tmp[v] = max(dp[u] + 1, tmp[v]); } for (int j = 0; j &lt; (int)ed[i].size(); j++) { int u = ed[i][j].first, v = ed[i][j].second; dp[v] = max(dp[v], tmp[v]); } } int ans = 0; for (int i = 1; i &lt;= n; i++) ans = max(ans, dp[i]); printf(&quot;%d\n&quot;, ans); return 0; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 518D(概率期望DP)]]></title>
    <url>%2FCodeforces518D%2F</url>
    <content type="text"><![CDATA[Codeforces 518D题意：有$n$个人，每秒有$p$的概率有一个人进电梯，问$t$秒后电梯里的人数的期望。 设$dp(i,j)$为前$i$秒进$j$个人的概率。则$$dp(i,j)=dp(i - 1, j - 1) \cdot p + dp(i - 1, j) \cdot (1 - p)$$但是如果$j=n$，则$$dp(i,j)=dp(i - 1, j - 1) \cdot p + dp(i - 1, j)$$因为这样可以继承之前的值。如果没有人数限制，就可以设$dp(i, 0/1)$表示前$i$秒进的/没进的人数期望值。因为这样设会无法处理人数限制的情况 知识点：期望DP不一定DP方程要设期望，也可以设概率。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;map&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 2000 + 5; int n, t; db p, dp[MAXN][MAXN]; void clean() { } int solve() { clean(); dp[0][0] = 1.0; for (int i = 1; i &lt;= t; i++) { for (int j = 0; j &lt;= n; j++) { if (j != n) dp[i][j] = dp[i - 1][j - 1] * p + dp[i - 1][j] * (1.0 - p); else dp[i][j] = dp[i - 1][j - 1] * p + dp[i - 1][j]; } } db ans = 0; for (int j = 1; j &lt;= n; j++) ans += dp[t][j] * j; printf(&quot;%.8f\n&quot;, ans); return 0; } int main() { scanf(&quot;%d%lf%d&quot;, &amp;n, &amp;p, &amp;t), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>概率DP</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 527D(贪心+数学)]]></title>
    <url>%2FCodeforces527D%2F</url>
    <content type="text"><![CDATA[Codeforces 527D题意：给一些点坐标$x_i$，每个点都有一个权值$w_i$，求最大的子集大小，该集合中任意两点满足$|x_i - x_j| \geq w_i + w_j$ 考虑按照$x_i$升序遍历，则式子$|x_i - x_j| \geq w_i + w_j$可以拆成$x_i - x_j \geq w_i + w_j$，一样的移项，得$x_i - w_i \geq w_j + x_j$，然而做到这里我还是不会qwq。。 观察式子可以发现我们只用维护$x_i - w_i, x_i + w_i$，数形结合，$x_i - w_i, x_i + w_i$代表了一个长$2w_i$，以$x_i$为中点的线段。 然后考虑$x_i - w_i \geq w_j + x_j$和$x_j - w_j \geq w_k + x_k$，则$x_i - w_i + x_j - w_j \geq w_j + x_j + w_k + x_k$那么$x_i-w_j \geq 2w_j+w_k+x_k$，可以得到$x_i-w_j \geq w_k+x_k$这样说明如果$i,j$满足条件，$j,k$满足条件，则$i,k$也满足条件。 那么现在满足条件在数轴上表示为每个点代表线段不相交。那么贪心选最多不相交区间即可。 知识点：绝对值方程可以拆，拆出来的数相同放一边，式子多数形结合，比如本题“$x_i - w_i, x_i + w_i$代表了一个长$2w_i$，以$x_i$为中点的线段。”就是一个很好的方法。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;map&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; int n; pair&lt;int, int &gt; seg[200000 + 5]; bool cmp(pair&lt;int, int &gt; &amp;a, pair&lt;int, int &gt; &amp;b) { if (a.second == b.second) return a.first &lt; b.first; return a.second &lt; b.second; } void clean() { } int solve() { clean(); for (int x, w, i = 1; i &lt;= n; i++) scanf(&quot;%d%d&quot;, &amp;x, &amp;w), seg[i].first = x - w, seg[i].second = x + w; sort(seg + 1, seg + 1 + n, cmp); int ans = 1, t = seg[1].second; for (int i = 2; i &lt;= n; i++) { if (seg[i].first &gt;= t) { ans++, t = seg[i].second; } } printf(&quot;%d\n&quot;, ans); return 0; } int main() { scanf(&quot;%d&quot;, &amp;n), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>Codeforces</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 510D(DP+GCD)]]></title>
    <url>%2FCodeforces510D%2F</url>
    <content type="text"><![CDATA[Codeforces 510D题意：给出$n$张卡上有数字$l_i$，每张卡可以用无限次，每种卡需要$c_i$的花费，问最少用多少花费，能够组成所有的自然数。 能组成所有的数字则这些选的数字$gcd$为1。CF 1011E可以由拼数想到gcd，那么这题也一样。显然得出以上的结论。那么这样的话，我们只需要用最少的钱找出几个数$gcd=1$即可。我们可以设$dp(i)$为$gcd=i$时最小花费，初始值为$dp(0)=0$，因为$0$与任何数$gcd$等于任何数。不能将所有$l_i$直接加进来，考虑重复的$l_i$。转移方程即为$dp(i)=dp(j)+c_x$，并且能有一个数$x$使得$gcd=j$可以转移到$gcd=i$。但是数据很大开不了数组啊，由于总数小，就可以用map。 知识点：超限但是总数小：vector-&gt;二维数组压第二维，map-&gt;一维数组压第一维拼数问题和 $ gcd $ 有关系 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;map&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; pair&lt;int, int &gt; cd[305]; map&lt;int, int &gt; dp; int n; int gcd(int a, int b) {return b == 0 ? a : gcd(b, a % b);} void clean() { } int solve() { clean(); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;cd[i].first); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;cd[i].second); dp[0] = 0; //l[i] 可能重复不能全部直接 dp[cd[i].first] = cd[i].second 会把最优解换掉 for (int i = 1; i &lt;= n; i++) { int &amp;x = cd[i].first, &amp;c = cd[i].second; for (map&lt;int, int &gt;::iterator it = dp.begin(); it != dp.end(); it++) { int y = it-&gt;first; int g = gcd(x, y); if (dp.find(g) == dp.end()) dp[g] = dp[y] + c; else if (dp[g] &gt; dp[y] + c) dp[g] = dp[y] + c; } } if (dp.find(1) != dp.end()) printf(&quot;%d\n&quot;, dp[1]); else printf(&quot;%d\n&quot;, -1); return 0; } int main() { scanf(&quot;%d&quot;, &amp;n), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>GCD</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1020C(枚举+STL)]]></title>
    <url>%2FCodeforces1020C%2F</url>
    <content type="text"><![CDATA[Codeforces 1020C题意：$n, m$代表选民和党派下面$n$个选民, $p_i$是他原本打算投的人, $c_i$是你花费这么多可以让他投你, 求最少花费 因为这题最大的麻烦之处就是如果把别的党派的弄到1去，别的党派会少1票，而1党派会多1票，形成了2的差。并且党派初始最大的可能有很多个，难以判断党派1要有多少票。所以我们可以枚举党派1得的票，相当于枚举一个标准值，让1党派必须达到这个标准值。这与二分判定有类似的地方，我们只需要考虑1党派每种票数的最优解即可对于处理党派票数，如果其他党派有不小于1党派的，切掉最小的那几个直到其他党派能够比1党派票数小。这个可以用multiset来维护。 知识点：对于这种无法确定个数的题目，不要乱贪心DP，可以枚举一个标准值，然后让无法确定个数变为能够确定个数，从而解决问题 //==========================Head files========================== #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #include&lt;set&gt; #include&lt;iostream&gt; #define LL long long #define db double #define mp make_pair #define pr pair&lt;int, int&gt; #define fir first #define sec second #define pb push_back #define ms(i, j) memset(i, j, sizeof i) using namespace std; //==========================Templates========================== inline int read() { int x = 0, f = 1; char c = getchar(); while(c &lt; &#39;0&#39; || c &gt; &#39;9&#39;){if (c == &#39;-&#39;) f = -1; c = getchar();} while(c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;){x = x * 10 + c - &#39;0&#39;; c = getchar();} return x * f; } inline LL readl() { LL x = 0, f = 1; char c = getchar(); while(c &lt; &#39;0&#39; || c &gt; &#39;9&#39;){if (c == &#39;-&#39;) f = -1; c = getchar();} while(c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;){x = x * 10 + c - &#39;0&#39;; c = getchar();} return x * f; } inline int power(int a, int b) { int ans = 1; while (b) { if(b &amp; 1) {ans = ans * a; --b;} b &gt;&gt;= 1;a = a * a; } return ans; } inline int power_mod(int a, int b, int mod) { a %= mod; int ans = 1; while (b) { if(b &amp; 1) {ans = ans * a % mod; --b;} b &gt;&gt;= 1, a = a * a % mod; } return ans; } LL gcdl(LL a, LL b) {return b == 0 ? a : gcdl(b, a % b);} LL abssl(LL a) {return a &gt; 0 ? a : -a;} int gcd(int a, int b) {return b == 0 ? a : gcd(b, a % b);} int abss(int a) {return a &gt; 0 ? a : -a;} //==========================Main body========================== #define LD &quot;%I64d&quot; #define D &quot;%d&quot; #define pt printf #define sn scanf #define pty printf(&quot;YES\n&quot;) #define ptn printf(&quot;NO\n&quot;) inline int read(); inline LL readl(); inline int power(int a, int b); inline int power_mod(int a, int b, int mod); LL gcdl(LL a, LL b); LL abssl(LL a); int gcd(int a, int b); int abssl(int a); //==========================Code here========================== LL ans, n, m, pi[3005], ci[3005]; multiset&lt;LL&gt; s, tmp[3005]; LL pro(LL d) { LL tot = 0, cc = (int)tmp[1].size(); s.clear(); for (LL i = 1; i &lt;= n; i++) if (pi[i] != 1) s.insert(ci[i]); for (LL i = 2; i &lt;= m; i++) if ((int)tmp[i].size() &gt;= d) { LL cnt = (int)tmp[i].size(); for (multiset&lt;LL&gt;::iterator it = tmp[i].begin(); it != tmp[i].end(); it++) { if (cnt &lt; d) break; tot += *it, cnt--, cc++; s.erase(s.find(*it)); } } if (cc &gt; d) return 9223372036854775807ll; for (multiset&lt;LL&gt;::iterator it = s.begin(); it != s.end(); it++) { if (cc &gt;= d) break; tot += *it, cc++; } return tot; } int main() { cin &gt;&gt; n &gt;&gt; m; for (LL i = 1; i &lt;= n; i++) cin &gt;&gt; pi[i] &gt;&gt; ci[i]; ans = 9223372036854775807ll; for (LL i = 1; i &lt;= n; i++) tmp[pi[i]].insert(ci[i]); for (LL i = 1; i &lt;= n; i++) ans = min(ans, pro(i)); cout &lt;&lt; ans; return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>枚举</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 463D(DAG 图最长路)]]></title>
    <url>%2FCodeforces463D%2F</url>
    <content type="text"><![CDATA[Codeforces 463D题意：求$k$个序列的最长公共序列长度。 如果是两个序列，则为经典 DP 问题。对于最长与 DP ，可以联想到 DAG 图最长路。对于每个序列，如果一个数在另一个数前面，并且每个序列都存在这样的关系，就在他们之间连上有向边，显然是一个 DAG 图，然后求一个 DAG 图最长路长度+1即为答案。 本题采用了 DAG 图最长路模型，其核心为 DP 与 最长。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 1000 + 5; int n, k, ma[MAXN][MAXN], tmp[MAXN], ino[MAXN], dp[MAXN], ans = 0; vector&lt;int&gt; G[MAXN]; int DP(int u) { if (dp[u] != 0) return dp[u]; for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i]; dp[u] = max(dp[u], DP(v) + 1); ans = max(ans, dp[u]); } return dp[u]; } void clean() { ms(ino, 0); } int solve() { clean(); for (int i = 1; i &lt;= k; i++) { for (int j = 1; j &lt;= n; j++) scanf(&quot;%d&quot;, &amp;tmp[j]); for (int j = 1; j &lt;= n; j++) for (int k = j + 1; k &lt;= n; k++) ma[tmp[j]][tmp[k]]++; } for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) if (ma[i][j] == k) G[i].push_back(j), ino[j]++; for (int i = 1; i &lt;= n; i++) dp[i] = 0; for (int i = 1; i &lt;= n; i++) if (!ino[i]) DP(i); printf(&quot;%d\n&quot;, ans + 1); return 0; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;k), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 588E(倍增+归并排序合并链信息)]]></title>
    <url>%2FCodeforces588E%2F</url>
    <content type="text"><![CDATA[Codeforces 588E题意：给一棵树$n$个点，再给$m$个人，$m$个人所在的点同时每个人都有一个编号$i$，你的任务就是找到$uv$这条路的前$k$个人，输出其编号。 直接倍增，每个倍增记录$i$点到$2^j$个祖先的前10最小的点，然后合并信息即可。如何合并信息呢？我们让两个数组都为有序的，用归并排序实现$O(20)$合并。 注意卡常题, 代码中标注了卡常的地方 知识点：链合并这种思想非常方便对于查询。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; inline int read() { int x = 0, f = 1; char c = getchar(); while(c &lt; &#39;0&#39; || c &gt; &#39;9&#39;){if (c == &#39;-&#39;) f = -1; c = getchar();} while(c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;){x = x * 10 + c - &#39;0&#39;; c = getchar();} return x * f; }//1快读 const int MAXN = 100000 + 10, LOGS = 20; struct myVec { int n, a[30];//2不用vector myVec() {n = 0, ms(a, 0);} void ins(int x) {a[++n] = x;} }; myVec merge(myVec &amp;a, myVec &amp;b) { myVec ans; int u = a.n, v = b.n; int i = 1, j = 1; while (i &lt;= u &amp;&amp; j &lt;= v) { if (a.a[i] &lt; b.a[j]) { ans.ins(a.a[i]), i++; } else if (a.a[i] &gt; b.a[j]) { ans.ins(b.a[j]), j++; } else ans.ins(a.a[i]), i++, j++; } while (i &lt;= u) { if (ans.a[ans.n - 1] == a.a[i]) i++; else ans.ins(a.a[i]), i++; } while (j &lt;= v) { if (ans.a[ans.n - 1] == b.a[j]) j++; else ans.ins(b.a[j]), j++; }//3去重不用unique if (ans.n &gt; 10) ans.n = 10; return ans; } int n, m, q, dep[MAXN], pre[MAXN][LOGS + 5]; vector&lt;int&gt; G[MAXN]; myVec c[MAXN], tax[MAXN][LOGS + 5]; inline void ins(int x, int y) {G[x].push_back(y), G[y].push_back(x);} void dfs(int u, int pa) { dep[u] = dep[pa] + 1, pre[u][0] = pa, tax[u][0] = merge(c[u], c[pa]); for (int i = 1; i &lt;= LOGS; i++) pre[u][i] = pre[pre[u][i - 1]][i - 1]; for (int i = 1; i &lt;= LOGS; i++) tax[u][i] = merge(tax[u][i - 1], tax[pre[u][i - 1]][i - 1]); for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i]; if (v != pa) dfs(v, u); } } int LCA(int a, int b) { if (dep[a] &lt; dep[b]) swap(a, b); for (int i = LOGS; i &gt;= 0; i--) if (dep[pre[a][i]] &gt;= dep[b]) a = pre[a][i]; if (a == b) return a; for (int i = LOGS; i &gt;= 0; i--) if (pre[a][i] != pre[b][i]) a = pre[a][i], b = pre[b][i]; return pre[a][0]; } void pro(int u, int v, int a) { int lca = LCA(u, v); myVec ans = merge(c[u], c[v]); ans = merge(ans, c[lca]); for (int i = LOGS; i &gt;= 0; i--) if (dep[pre[u][i]] &gt;= dep[lca]) ans = merge(ans, tax[u][i]), u = pre[u][i]; for (int i = LOGS; i &gt;= 0; i--) if (dep[pre[v][i]] &gt;= dep[lca]) ans = merge(ans, tax[v][i]), v = pre[v][i]; printf(&quot;%d &quot;, min(a, ans.n)); for (int i = 1; i &lt;= min(a, ans.n); i++) printf(&quot;%d &quot;, ans.a[i]); puts(&quot;&quot;); } void clean() { dep[0] = 0; } int solve() { clean(); for (int x, y, i = 1; i &lt; n; i++) x = read(), y = read(), ins(x, y); for (int gg, i = 1; i &lt;= m; i++) { gg = read(); if (c[gg].n != 10) c[gg].ins(i); } dfs(1, 0); for (int i = 1; i &lt;= q; i++) { int v = read(), u = read(), a = read(); pro(v, u, a); } return 0; } int main() { n = read(), m = read(), q = read(), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>合并</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 734E(DFS缩点+树的直径)]]></title>
    <url>%2FCodeforces734E%2F</url>
    <content type="text"><![CDATA[Codeforces 734E题意：有一棵树被黑白染色，同色的为一个联通块，每次可以让一个联通块变色，然后和周围颜色相同的联通块组成大的联通块，求最少多少次能让所有联通块变为同色 联通块直接 DFS 缩点, 然后新图变为黑白相间的树。考虑树的直径有下列性质： 以树的直径中点上的一点为根，将这颗无根树转化为有根树的话，这样做会使树的深度最小，且为树的直径的一半（向上取整）(因为如果有一个叶子节点比直径更深的话，那么就可以构成一个更长的直径，与假设矛盾。) 所以答案是$(d+1)/2$, $d$为直径长。因为按照树的直径中点为根，每次操作直径中点改变颜色，改变$(d+1)/2$次就能改为同色。画图理解。 不要犯了老错误, CF 909E就误以为0点只有一层而错误。此题因为没有考虑到“一个联通块变色，然后和周围颜色相同的联通块组成大的联通块”，以为比较黑白联通块个数，造成了错误。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 200000 + 5; vector&lt;int&gt; G[MAXN], G2[MAXN]; int n, col[MAXN], bl[MAXN], sz, vis[MAXN], dis[MAXN]; queue&lt;int&gt; q; void ins(int x, int y) {G[x].push_back(y), G[y].push_back(x);} void ins2(int x, int y) {G2[x].push_back(y), G2[y].push_back(x);} void dfs(int u, int pa, int cha) { bl[u] = cha; for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i]; if (v != pa) { if (col[v] != col[u]) dfs(v, u, ++sz); else dfs(v, u, cha); } } } void clean() { ms(vis, 0), sz = 0; } int solve() { clean(); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;col[i]); for (int x, y, i = 1; i &lt; n; i++) scanf(&quot;%d%d&quot;, &amp;x, &amp;y), ins(x, y); dfs(1, 0, ++sz); for (int u = 1; u &lt;= n; u++) { for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i]; ins2(bl[u], bl[v]); } } q.push(1), vis[1] = 1, dis[1] = 0; int mks = 0, pos = 1; while (!q.empty()) { int u = q.front(); q.pop(); for (int i = 0; i &lt; (int)G2[u].size(); i++) { int v = G2[u][i]; if (!vis[v]) { vis[v] = 1, dis[v] = dis[u] + 1, q.push(v); if (dis[v] &gt; mks) mks = dis[v], pos = v; } } } ms(vis, 0); q.push(pos), vis[pos] = 1, dis[pos] = 0, mks = 0; while (!q.empty()) { int u = q.front(); q.pop(); for (int i = 0; i &lt; (int)G2[u].size(); i++) { int v = G2[u][i]; if (!vis[v]) { vis[v] = 1, dis[v] = dis[u] + 1, q.push(v); if (dis[v] &gt; mks) mks = dis[v]; } } } printf(&quot;%d\n&quot;, (mks + 1) / 2); return 0; } int main() { scanf(&quot;%d&quot;, &amp;n), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>树的直径</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 600E(莫队+DFS序 / 树上启发式合并)]]></title>
    <url>%2FCodeforces600E%2F</url>
    <content type="text"><![CDATA[Codeforces 600E题意：一棵树$n$个节点，已知点权$ci \leq n$，根为1 对于每个节点，求出对应子树中，出现次数最多（或之一）的点权的和 这题询问子树可以用 DFS 序，然后在 DFS 序上维护出现次数最多（或之一）的点权的和即可。可以使用莫队对每个子树进行维护。开数组col1 每种颜色出现的次数col2 每种次数的答案然后更新即可，具体看代码的adjustAdd扩充当前区间，和adjustSub缩小当前区间 知识点：莫队的扩充区间放在缩小区间前可以避免出现某些问题 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const LL MAXN = 100000 + 5; LL bl[MAXN], blolen; struct query { LL l, r, id; bool operator &lt; (const query &amp;b) const { if (bl[l] == bl[b.l]) return r &lt; b.r; return bl[l] &lt; bl[b.l]; } }q[MAXN]; LL n, c[MAXN], sz, dfn[MAXN], col1[MAXN], col2[MAXN], nl, nr, mks, ans[MAXN]; vector&lt;LL&gt; G[MAXN]; void ins(LL x, LL y) {G[x].push_back(y), G[y].push_back(x);} void dfs(LL u, LL pa) { q[u].l = ++sz, dfn[sz] = u, q[u].id = u; for (LL i = 0; i &lt; (LL)G[u].size(); i++) { LL v = G[u][i]; if (v != pa) dfs(v, u); } q[u].r = sz; } //col1: 每种颜色出现的次数; col2: 每种次数的答案 void adjustAdd(LL x) { x = dfn[x]; col1[c[x]]++; col2[col1[c[x]] - 1] -= c[x]; col2[col1[c[x]]] += c[x]; if (col1[c[x]] &gt; mks) mks = col1[c[x]]; } void adjustSub(LL x) { x = dfn[x]; col1[c[x]]--; col2[col1[c[x]] + 1] -= c[x]; col2[col1[c[x]]] += c[x]; if (col2[col1[c[x]] + 1] == 0 &amp;&amp; mks == col1[c[x]] + 1) mks--; } void clean() { ms(col1, 0), ms(col2, 0), sz = 0; } int solve() { clean(); blolen = sqrt(n); for (LL i = 1; i &lt;= n; i++) scanf(&quot;%I64d&quot;, &amp;c[i]), bl[i] = (i - 1) / blolen + 1; for (LL x, y, i = 1; i &lt; n; i++) scanf(&quot;%I64d%I64d&quot;, &amp;x, &amp;y), ins(x, y); dfs(1, 0); sort(q + 1, q + 1 + n); nl = 1, nr = 0, mks = 1; for (LL i = 1; i &lt;= n; i++) { while (nr &lt; q[i].r) adjustAdd(nr + 1), nr++; while (nl &gt; q[i].l) adjustAdd(nl - 1), nl--; while (nl &lt; q[i].l) adjustSub(nl), nl++; while (nr &gt; q[i].r) adjustSub(nr), nr--; ans[q[i].id] = col2[mks]; } for (LL i = 1; i &lt;= n; i++) printf(&quot;%I64d &quot;, ans[i]); return 0; } int main() { scanf(&quot;%I64d&quot;, &amp;n), solve(); return 0; } dsu on tree #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;queue&gt; #include&lt;string&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 100000 + 5; int n, c[MAXN], idx, dfn[MAXN], siz[MAXN], son[MAXN], ll[MAXN], rr[MAXN], tax[MAXN], maxd; LL cnt, ans[MAXN]; vector&lt;int &gt; G[MAXN]; void ins(int x, int y) {G[x].push_back(y);} void add(int x) {if (++tax[x] &gt; maxd) maxd = tax[x], cnt = x; else if (tax[x] == maxd) cnt += x;} void del(int x) {--tax[x];} void dfs_pre(int u, int fa) { ll[u] = ++idx, siz[u] = 1, dfn[idx] = u, son[u] = -1; for (int i = 0; i &lt; (int)G[u].size(); ++i) { int v = G[u][i]; if (v != fa) { dfs_pre(v, u); if (son[u] == -1 || siz[v] &gt; siz[son[u]]) son[u] = v; siz[u] += siz[v]; } } rr[u] = idx; } void dfs_dsu(int u, int fa, int kp) { for (int i = 0; i &lt; (int)G[u].size(); ++i) { int v = G[u][i]; if (v != fa &amp;&amp; v != son[u]) dfs_dsu(v, u, 0); } // 轻儿子先处理，不保留 if (son[u] != -1) dfs_dsu(son[u], u, 1); // 处理重儿子，保留 for (int o = 0; o &lt; (int)G[u].size(); ++o) { int v = G[u][o]; if (v != fa &amp;&amp; v != son[u]) for (int i = ll[v]; i &lt;= rr[v]; ++i) add(c[dfn[i]]); // 暴力轻儿子 } add(c[u]); ans[u] = cnt; // 统计答案 if (!kp) {for (int i = ll[u]; i &lt;= rr[u]; ++i) del(c[dfn[i]]); cnt = maxd = 0;} // 删除 } void clean() {} int solve() { clean(); cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;c[i]); for (int x, y, i = 1; i &lt; n; ++i) { scanf(&quot;%d%d&quot;, &amp;x, &amp;y); ins(x, y), ins(y, x); } dfs_pre(1, 0); dfs_dsu(1, 0, 0); for (int i = 1; i &lt;= n; ++i) printf(&quot;%lld &quot;, ans[i]); return 0; } } int main() { flyinthesky::solve(); return 0; } /* */]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>树上启发式合并</tag>
        <tag>DFS</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 609E(最小生成树+倍增)]]></title>
    <url>%2FCodeforces609E%2F</url>
    <content type="text"><![CDATA[Codeforces 609E题意：询问一个图包含某条边的最小生成树。对每条边进行询问。 先求出最小生成树，然后对于在最小生成树的边直接输出最小生成树的最优值，否则，考虑将这条边$(u, v)$加入最小生成树，则必然会产生环，其中环为最小生成树上$u$到$v$以及边$(u, v)$，我们要在$u$到$v$找权最大的边删除。使用倍增就能够完成。用 LCA 爬即可。 本题思路与次小生成树思路类似。 知识点：1、记得开LL2、分段调试后一定要静态查错 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const LL MAXN = 200000 + 5, LOGS = 20; LL dep[MAXN], pre[MAXN][LOGS + 5], mks[MAXN][LOGS + 5]; LL n, m, en2, f[MAXN], ve[MAXN]; vector&lt;LL&gt; G2[MAXN]; struct edge { LL u, v, w, no; bool operator &lt; (const edge &amp;b) const { return w &lt; b.w; } }ed[MAXN]; struct edge2 { LL v, w; }ed2[MAXN * 2]; bool cmp(edge a, edge b) {return a.no &lt; b.no;} LL find(LL x) {return x == f[x] ? x : f[x] = find(f[x]);} inline void ins(LL x, LL y, LL w) { ed2[++en2] = (edge2){y, w}, G2[x].push_back(en2); ed2[++en2] = (edge2){x, w}, G2[y].push_back(en2); } void dfs(LL u, LL fa, LL w) { pre[u][0] = fa, dep[u] = dep[fa] + 1; for (LL i = 1; i &lt;= LOGS; i++) pre[u][i] = pre[pre[u][i - 1]][i - 1]; mks[u][0] = w; for (LL i = 1; i &lt;= LOGS; i++) mks[u][i] = max(mks[u][i - 1], mks[pre[u][i - 1]][i - 1]); for (LL i = 0; i &lt; (LL)G2[u].size(); i++) { edge2 &amp;e = ed2[G2[u][i]]; if (e.v != fa) dfs(e.v, u, e.w); } } LL lca(LL a, LL b) { if (dep[a] &lt; dep[b]) swap(a, b); for (LL i = LOGS; i &gt;= 0; i--) if (dep[pre[a][i]] &gt;= dep[b]) a = pre[a][i]; if (a == b) return a; for (LL i = LOGS; i &gt;= 0; i--) if (pre[a][i] != pre[b][i]) a = pre[a][i], b = pre[b][i]; return pre[a][0]; } LL getMax(LL u, LL v) { LL LCA = lca(u, v), ret = 0; for (LL i = LOGS; i &gt;= 0; i--) if (dep[pre[u][i]] &gt;= dep[LCA]) ret = max(mks[u][i], ret), u = pre[u][i]; for (LL i = LOGS; i &gt;= 0; i--) if (dep[pre[v][i]] &gt;= dep[LCA]) ret = max(mks[v][i], ret), v = pre[v][i]; return ret; } void clean() { ms(dep, 0), ms(mks, 0), ms(ve, 0), en2 = 0; } int solve() { clean(); for (LL i = 1; i &lt;= n; i++) f[i] = i; for (LL i = 1; i &lt;= m; i++) scanf(&quot;%I64d%I64d%I64d&quot;, &amp;ed[i].u, &amp;ed[i].v, &amp;ed[i].w), ed[i].no = i; sort(ed + 1, ed + 1 + m); LL tot = 0, ans = 0; for (LL i = 1; i &lt;= m; i++) { LL x = find(ed[i].u), y = find(ed[i].v); if (x != y) f[x] = y, tot++, ans += ed[i].w, ins(ed[i].u, ed[i].v, ed[i].w), ve[ed[i].no] = 1; if (tot &gt;= n - 1) break; } dfs(1, 0, 0); sort(ed + 1, ed + 1 + m, cmp); for (LL i = 1; i &lt;= m; i++) { if (ve[i]) printf(&quot;%I64d\n&quot;, ans); else { LL whw = getMax(ed[i].u, ed[i].v); printf(&quot;%I64d\n&quot;, ans + ed[i].w - whw); } } return 0; } int main() { scanf(&quot;%I64d%I64d&quot;, &amp;n, &amp;m), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>生成树</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 907E(状压DP)]]></title>
    <url>%2FCodeforces907E%2F</url>
    <content type="text"><![CDATA[Codeforces 907E题意：给一个连通有向图，每次选出一个点，这个点所连的所有点就可以成为一个团(完全图，即每两个顶点直接有一条边)，求最少选几个点使得整个图成为一个团，输出方案。 题目数据范围提示是状压DP或者搜索。这里明显是状压DP。设$dp(S)$为当前团的节点状态，$st_i$为这个点连通点的状态，则$$dp(S|st_i)=min(dp(s)+1)$$输出方案，如果当前DP更新了，就把前驱记录，然后最后输出即可。 如果原图已经是团，则直接输出0 知识点：数据范围小：状压、暴力DFS团=完全图，即每两个顶点直接有一条边 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; int n, m, st[30], dp[(1 &lt;&lt; 22) + 10], pre1[(1 &lt;&lt; 22) + 10], pre2[(1 &lt;&lt; 22) + 10]; inline void ins(int x, int y) { st[x] += (1 &lt;&lt; (y - 1)), st[y] += (1 &lt;&lt; (x - 1)); } void clean() { ms(st, 0); for (int S = 0; S &lt;= (1 &lt;&lt; n); S++) dp[S] = 100000000, pre1[S] = pre2[S] = 0; } int solve() { clean(); for (int u, v, i = 1; i &lt;= m; i++) scanf(&quot;%d%d&quot;, &amp;u, &amp;v), ins(u, v); for (int i = 1; i &lt;= n; i++) st[i] += (1 &lt;&lt; (i - 1)); int fl = 0; for (int i = 1; i &lt;= n; i++) { if (st[i] != (1 &lt;&lt; n) - 1) fl = 1; dp[st[i]] = 1, pre1[st[i]] = i; } if (!fl) return printf(&quot;0\n&quot;); for (int S = 0; S &lt; (1 &lt;&lt; n); S++) { for (int i = 1; i &lt;= n; i++) if (S &amp; (1 &lt;&lt; (i - 1))) { if (dp[S] + 1 &lt; dp[S | st[i]]) { dp[S | st[i]] = dp[S] + 1; pre1[S | st[i]] = i, pre2[S | st[i]] = S; } } } printf(&quot;%d\n&quot;, dp[(1 &lt;&lt; n) - 1]); for (int S = (1 &lt;&lt; n) - 1; S; S = pre2[S]) printf(&quot;%d &quot;, pre1[S]); return 0; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>计数DP</tag>
        <tag>状压DP</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 570D(DFS序)]]></title>
    <url>%2FCodeforces570D%2F</url>
    <content type="text"><![CDATA[Codeforces 570D题意：一棵树根为1，告诉你每个点上的字母。问$v$节点子树（包括$v$节点）在第$h$行的所有节点的字母能否组成回文串。 为什么这题卡常啊……子树问题考虑 DFS 序，这里因为和深度有关就分层处理。每一层建 vector 存这层每个字母在 DFS 序中的位置，因为按照 DFS 序存，vector 内部有序，所以每次查询在 vector 二分一个子树区间统计个数，能否组成回文当且仅当出现奇数次字母小于等于1知识点：分层用 vector 处理。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 500000 + 5; int n, q, ll[MAXN], rr[MAXN], sz, dep[MAXN]; char s[MAXN]; vector&lt;int&gt; G[MAXN], whw[MAXN][30]; inline void ins(int x, int y) { G[x].push_back(y), G[y].push_back(x); } void dfs(int u, int pa) { dep[u] = dep[pa] + 1, sz++, ll[u] = sz; whw[dep[u]][s[u] - &#39;a&#39;].push_back(sz); for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i]; if (v != pa) dfs(v, u); } rr[u] = sz; } void clean() { ms(dep, 0), sz = 0; } int solve() { clean(); for (int p, i = 2; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;p), ins(i, p); scanf(&quot;%s&quot;, s + 1); dfs(1, 0); while (q--) { int u, h; scanf(&quot;%d%d&quot;, &amp;u, &amp;h); int cnt = 0; for (int i = 0; i &lt; 26; i++) { int hh = upper_bound(whw[h][i].begin(), whw[h][i].end(), rr[u]) - upper_bound(whw[h][i].begin(), whw[h][i].end(), ll[u] - 1); if (hh % 2) cnt++; if (cnt &gt; 1) break; } if (cnt == 1 || cnt == 0) printf(&quot;Yes\n&quot;); else printf(&quot;No\n&quot;); } return 0; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;q), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 686D(树的重心+DFS)]]></title>
    <url>%2FCodeforces686D%2F</url>
    <content type="text"><![CDATA[Codeforces 686D题意：给一棵树求每个子树的重心。 几个定理： 1把两个树通过一条边相连得到一个新的树，那么新的树的重心在连接原来两个树的重心的路径上。2把一个树添加或删除一个叶子，那么它的重心最多只移动一条边的距离3去掉任意一个重心后，生成的各个块的节点数的最大值一定小于等于原树的节点数除以2。4以一棵树的重心为根的子树的节点个数，一定大于等于该树节点总数的一半。5在一棵树的所有子树中，找到某一子树，使得其节点数恰好大于等于原树节点总数一半，那么该子树的根一定是一个重心。(如果该节点不是重心，也就是把它去掉后产生的连通块中至少有一个节点个数大于原树节点个数的一半。) 这里用定理1、3 对于当前一个子树求重心，他的重心在他的最大子树的重心和子树的根的路径上(定理1)。所以 DFS 即可。判断路径上是否是重心：判断整个子树在当前枚举位置断开，生成的两个块的节点数的最大值是否小于等于原树的节点数除以2(定理3) Codeforces Submission #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; int n, q, ans[300000 + 5], siz[300000 + 5], fa[300000 + 5]; vector&lt;int&gt; G[300000 + 5]; inline void ins(int x, int y) {G[x].push_back(y), G[y].push_back(x);} void dfs(int u, int pa) { int whw = -1, pos = u; fa[u] = pa, siz[u] = 1, ans[u] = u; for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i]; if (v != pa) { dfs(v, u); siz[u] += siz[v]; if (whw &lt; siz[v]) whw = siz[v], pos = v; } } ans[u] = ans[pos]; while (ans[u] != u &amp;&amp; siz[u] - siz[ans[u]] &gt; siz[u] / 2) ans[u] = fa[ans[u]]; //去掉任意一个重心后，生成的各个块的节点数的最大值一定小于等于原树的节点数除以2 } void clean() { ms(siz, 0); } int solve() { clean(); for (int p, i = 2; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;p), ins(i, p); dfs(1, 0); while (q--) { int a; scanf(&quot;%d&quot;, &amp;a); printf(&quot;%d\n&quot;, ans[a]); } return 0; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;q), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>DFS</tag>
        <tag>树的重心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 701E(DFS)]]></title>
    <url>%2FCodeforces701E%2F</url>
    <content type="text"><![CDATA[Codeforces 701E题意：有$n$个城市，有$2k$个学校在城市中，要对这$2k$个学校进行连边，使得所有连出来的边的和最大，每条边边权为$1$ 考虑每条边对答案的贡献。对于一条边，因为要最大化和，所以他左边的学校一定要连到右边的学校，所以每条边的贡献是$min(left, right)$，$left$是左边的学校个数，$right=2k-left$。DFS 处理即可，随意定一个根都行。 知识点：对于这种路径覆盖，树上计数的题目，多想想边点对答案的贡献。Codeforces Submission #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; vector&lt;LL&gt; G[200000 + 5]; LL n, k, ai[200000 + 5], ans; inline void ins(LL x, LL y) { G[x].push_back(y), G[y].push_back(x); } int dfs(LL u, LL pa) { LL siz = ai[u]; for (LL i = 0; i &lt; (LL)G[u].size(); i++) { LL v = G[u][i]; if (v != pa) { LL tmp = dfs(v, u); siz += tmp; ans += min(tmp, 2ll * k - tmp); } } return siz; } void clean() { ans = 0, ms(ai, 0); } int solve() { clean(); for (LL u, i = 1; i &lt;= 2 * k; i++) scanf(&quot;%lld&quot;, &amp;u), ai[u] = 1; for (LL x, y, i = 1; i &lt; n; i++) scanf(&quot;%lld%lld&quot;, &amp;x, &amp;y), ins(x, y); dfs(1, 0); printf(&quot;%lld\n&quot;, ans); return 0; } int main() { scanf(&quot;%lld%lld&quot;, &amp;n, &amp;k), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 796D(BFS)]]></title>
    <url>%2FCodeforces796D%2F</url>
    <content type="text"><![CDATA[Codeforces 796D题意：有一些特殊点，要求所有点距离特殊点的距离不能超过$k$，问你最多能去掉几条边。 考虑多源 BFS ，将每个特殊点初始加入 BFS 队列。由于 BFS 特殊性质，步长为1的 BFS 找到的都是最短路径。所以每个点第一次被找到都是离特殊点的最短距离。所以如果当前一条边，点已经被访问，且这条边还没被访问，这条边可以被删除。 知识点：这道题的多源 BFS思路类似CF 987D，都是多源然后找其他点。并且这道题不仅仅可以对点进行标记，也可以对边进行标记，与欧拉回路的寻找类似。DFS 和 BFS 慎重选择，步长为1的 BFS 有最短路的特性 Codeforces Submission #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 300000 + 5; vector&lt;int&gt; G[MAXN]; vector&lt;int&gt; bh[MAXN]; queue&lt;int&gt; q; int n, k, d, vis[MAXN], ans, whw[MAXN], ve[MAXN]; inline void ins(int id, int x, int y) { G[x].push_back(y), G[y].push_back(x); bh[x].push_back(id), bh[y].push_back(id); } void clean() { ans = 0, ms(ve, 0), ms(vis, 0); } int solve() { clean(); scanf(&quot;%d%d%d&quot;, &amp;n, &amp;k, &amp;d); for (int x, i = 1; i &lt;= k; i++) scanf(&quot;%d&quot;, &amp;x), q.push(x), vis[x] = 1; for (int u, v, i = 1; i &lt; n; i++) scanf(&quot;%d%d&quot;, &amp;u, &amp;v), ins(i, u, v); while (!q.empty()) { int u = q.front(); q.pop(); for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i]; if (!vis[v]) vis[v] = 1, q.push(v); else { if (!ve[bh[u][i]]) whw[++ans] = bh[u][i]; } ve[bh[u][i]] = 1; } } printf(&quot;%d\n&quot;, ans); for (int i = 1; i &lt;= ans; i++) printf(&quot;%d &quot;, whw[i]); return 0; } int main() { solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 987F(DFS+二进制)]]></title>
    <url>%2FCodeforces987F%2F</url>
    <content type="text"><![CDATA[Codeforces 987F题意：给定一个大小为$m$的集合，每一个数都在$[0 ,2^n−1]$，如果两个数$x,y$满足x&amp;y=0就连一条无向边，问这$m$个数连成的图有多少个连通分量。 对于一个数，它$n​$位取反的二进制数上删除一些1都可以和这个数连边。所以我们就 DFS 枚举每个数取反之后删掉哪些1，如果又找到另一个集合中的数就做一样的操作。一次 DFS 就相当于找一个连通分量。 知识点：二进制问题，可以取反等操作来简化问题，并且连通分量可以用 DFS 进行求解。 Codeforces Submission #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; int n, m, vis[(1 &lt;&lt; 22) + 10], whw[(1 &lt;&lt; 22) + 10]; void dfs(int x) { if (vis[x]) return ; vis[x] = 1; if (whw[x]) dfs((1 &lt;&lt; n) - 1 - x); for (int i = 0; i &lt; n; i++) { if ((1 &lt;&lt; i) &amp; x) { dfs(x ^ (1 &lt;&lt; i)); } } } void clean() { ms(vis, 0), ms(whw, 0); } int solve() { clean(); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int a, i = 1; i &lt;= m; i++) scanf(&quot;%d&quot;, &amp;a), whw[a] = 1; if (whw[(1 &lt;&lt; n)]) return printf(&quot;1\n&quot;), 0; int ans = 0; for (int i = 0; i &lt;= (1 &lt;&lt; n); i++) { if (!whw[i] || vis[i]) continue; dfs((1 &lt;&lt; n) - 1 - i); ans++; } printf(&quot;%d\n&quot;, ans); return 0; } int main() { solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 987D(BFS)]]></title>
    <url>%2FCodeforces987D%2F</url>
    <content type="text"><![CDATA[Codeforces 987D题意：给你$n$个点$m$条边，$k$种货物，和一个$s$，之后让你从每个点开始走，收集到$s$种货物的最短路径长度。 因为$k$小只有$100$，所以我们直接把货物种类相同的用一个 vector 存起来，然后每次 BFS 每一种货物找他们到每个点的最短距离。每个点存每种货物到这个点的最短距离。之后询问排序这些距离取最小的$s$个即可。 知识点：数据小，就可以对着这个东西乱搞(暴力啊，存下来开桶什么的) Codeforces Submission #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; int n, m, k, s, whw[100000 + 5][100 + 5], a[100000 + 5]; queue&lt;int&gt; q; vector&lt;int&gt; G[100000 + 5]; vector&lt;int&gt; gd[100 + 5]; void ins(int x, int y) {G[x].push_back(y), G[y].push_back(x);} void clean() { ms(whw, -1); } int solve() { clean(); scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;k, &amp;s); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]), gd[a[i]].push_back(i); for (int x, y, i = 1; i &lt;= m; i++) scanf(&quot;%d%d&quot;, &amp;x, &amp;y), ins(x, y); for (int i = 1; i &lt;= k; i++) { if ((int)gd[i].size() == 0) continue; for (int j = 0; j &lt; (int)gd[i].size(); j++) q.push(gd[i][j]), whw[gd[i][j]][i] = 0; while (!q.empty()) { int u = q.front(); q.pop(); for (int k = 0; k &lt; (int)G[u].size(); k++) { int v = G[u][k]; if (whw[v][i] &lt; 0) whw[v][i] = whw[u][i] + 1, q.push(v); } } } for (int i = 1; i &lt;= n; i++) { sort(whw[i] + 1, whw[i] + 1 + k); int ans = 0; for (int j = 1; j &lt;= s; j++) ans += whw[i][j]; printf(&quot;%d &quot;, ans); } return 0; } int main() { solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1003E(树的直径)]]></title>
    <url>%2FCodeforces1003E%2F</url>
    <content type="text"><![CDATA[Codeforces 1003E题意：要构造一棵$n$个点的直径为$d$，并且每个点度数必须小于等于$k$的树 先将直径连起来，然后从中间开始在直径上拓展树，子树上每个点到直径两端都不可以超过$d$，并且要满足每个点度数必须小于等于$k$。用 DFS 完成拓展子树。算是一个细节题，注意处处当前节点如果达到$n$就马上退出 Codeforces Submission #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; int n, d, k, sz, tot; pair&lt;int, int&gt; ans[500000 + 5]; void dfs(int curlen, int kidlen, int curu) { if (curlen == d) return ; for (int i = 1; i &lt;= kidlen; i++) { sz++; ans[++tot].first = curu, ans[tot].second = sz; if (sz &gt;= n) { cout &lt;&lt; &quot;YES\n&quot;; for (int i = 1; i &lt;= tot; i++) printf(&quot;%d %d\n&quot;, ans[i].first, ans[i].second); exit(0); } dfs(curlen + 1, k - 1, sz); } } void clean() {} int solve() { clean(); cin &gt;&gt; n &gt;&gt; d &gt;&gt; k; if (n &lt; d + 1) return cout &lt;&lt; &quot;NO&quot;, 0; if (k == 1 &amp;&amp; n != 2 &amp;&amp; d != 1) return cout &lt;&lt; &quot;NO&quot;, 0; tot = 0, sz = 1; for (int i = 1; i &lt; d + 1; i++) ans[++tot].first = sz, sz++, ans[tot].second = sz; if (sz &gt;= n) { cout &lt;&lt; &quot;YES\n&quot;; for (int i = 1; i &lt;= tot; i++) printf(&quot;%d %d\n&quot;, ans[i].first, ans[i].second); exit(0); } int l = (d + 1 + 1) / 2, r = (d + 1) / 2 + 1; while (1) { if (l == 1 || r == d + 1) break; dfs(max(l - 1, d + 1 - l), k - 2, l); if (l != r) dfs(max(l - 1, d + 1 - l), k - 2, r); l--, r++; } if (sz &lt; n) return cout &lt;&lt; &quot;NO&quot;, 0; else { cout &lt;&lt; &quot;YES\n&quot;; for (int i = 1; i &lt;= tot; i++) printf(&quot;%d %d\n&quot;, ans[i].first, ans[i].second); } return 0; } int main() { solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>树的直径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斜率优化 学习笔记]]></title>
    <url>%2Fsz%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[模板及讲解斜率优化解决什么问题DP方程形如$dp(i)=\min(dp(j)+(a_i-a_j)^2)$，有像$(a_i-a_j)^2$这样与$i, j$都相关的信息，就不能用单调队列等来优化，要利用斜率优化来做。 斜率优化例题：Bzoj 1010 有$n$个数${C_n}$，分成连续的若干段，每段（假设从第$j$个到第$i$个组成一段）的分数为$(X-L)^2$，$X$为$j-i+ \sum C_k , i \leq k \leq j$，其中$L$是一个常量。目标：各段分数的总和最小。 设$dp(i)$表示分组完前$i$件物品的最小花费, $sum_i$表示是前$i$件物品的长度和。$dp(i)=\min(dp(j)+(sum_i-sum_j+i-j-L-1)^2|1 \leq j &lt; i)$设$S_i=sum_i+i$，则$dp(i)=\min(dp(j)+(S_i-S_j-L-1)^2)$设$P=L+1​$, 代入，$dp(i)=dp(j)+(S_i-S_j-P)^2$ 证明决策单调性使用数学归纳法证明。假设$i$前有两个决策$j, k(j &lt; k)$, 且决策$k$比$j$优，则$$dp(j)+(S_i-S_j-P)^2 &gt; dp(k)+(S_i-S_k-P)^2 –(1)$$假设$i$后面的某状态$t$有$S(t)=S(i)+v$，则$$dp(j)+(S_t-S_j-P)^2 &gt; dp(k)+(S_t-S_k-P)^2$$$$dp(j)+(S_i-S_j-P)^2 +2v(S_i-S_j-P) + v^2 &gt; dp(k)+(S_i-S_k-P)^2 +2v(S_i-S_k-P) + v^2$$因为$S_i-S_j &gt; S_i-S_k$并且$P \in \mathbb N+$，所以$S_i-S_j-P &gt; S_i-S_k-P$，综合(1)，假设(1)成立 用点来求斜率即可。 斜率斜截式将常数、仅和$i$相关的项、仅与$j$相关的项、$i、j$乘积项分开 分解，$dp(i)=dp(j)+S_i^2-2S_i \cdot (S_j + P) + (S_j+P)^2$移项，$2S_i \cdot (S_j+P)+dp(i)=dp(j)+S_i^2+(S_j+P)^2$$dp(j)+(S_j+P)^2+S_i^2=dp(i)+2S_i(S_j+P)$把左边($dp(j)+(S_j+P)^2+S_i^2$)看成平面直角坐标系的$y$坐标，右边的$2(S_j+P)$看成$x$坐标。那么这就是一条$k=S_i, b=dp(i)$的直线方程。决策$j$可以表示为坐标$(2(S_j+P), dp(j)+S_i^2+(S_j+P)^2)$这里每一条直线的$x$都单调递增，$k$也单调递增。且对于同一个$i$，$k$为定值，所以我们对于每个$i$转移时只需要在知道斜率的情况下将截距$b=dp(i)$最小化。 决策的舍弃 (l)那么现在问题转化为斜率为$S_i$的直线过一个决策$j$($j$点)，求出截距最小的那一条直线。那么如果过了$j$点就代表从$j$状态转移到$i$。现在有以下情况： $k_{AB}$的斜率比直线斜率$S_i$小，那么就要舍弃$A$点。后面点更优，因为 直线过$A$点时直线过$B$点时比较显然在$B$点截距$dp(i)$更小，比$A$点更优，并且直线斜率单增，以后所有的斜率都不会从$j$转移。因为符合决策单调性，$k$递增，所以用单调队列维护点，实际上是维护了一个凸壳。如果在单调队列中，$k_{q_{l}q_{l+1}} &lt; S_i$，那么就要舍弃$l$. 对于一条斜率为$k$的直线，将他放到凸壳中的应该排的位置即为最优决策点。由于$S_i$单增，所以凸壳左端点必为最优决策。 决策的舍弃 (r)当前的$i$转移完后，要将其加入单调队列以便$i+1$选择决策。要维护下凸包，就必须让单调队列里的$k$单调递增。如图，新增点与$C$连线可以满足下凸包性质(选这个点比$D,E$截距更小，答案更优)，所以$D,E$两点要舍弃如果在单调队列中，$k_{q_rq_{r-1}} &gt; k_{q_rq_{i}}$，那么就要舍弃$r$. 因为$x$坐标单增，所以新决策一定在凸壳右边。 代码例题：Bzoj 1010 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; LL n, P, dp[50005], s[50005]; LL l, r, que[150005]; inline db getK(int k, int j) {return (db)(dp[k] - dp[j] + (s[k] + P) * (s[k] + P) - (s[j] + P) * (s[j] + P)) / (2.0 * (db)(s[k] - s[j]));} //计算两个点之间斜率 void clean() {} int solve() { clean(); scanf(&quot;%lld%lld&quot;, &amp;n, &amp;P), s[0] = 0, P++; for (int i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;s[i]), s[i] += s[i - 1]; for (int i = 1; i &lt;= n; i++) s[i] += i; dp[1] = 0, l = 1, r = 1; //原点是决策点 r必须为1 for (int i = 1; i &lt;= n; i++) { while (l &lt; r &amp;&amp; getK(que[l], que[l + 1]) &lt;= (db)s[i]) l++; //l必须严格小于r，因为单调队列中要有两个元素 dp[i] = dp[que[l]] + (s[i] - s[que[l]] - P) * (s[i] - s[que[l]] - P); while (l &lt; r &amp;&amp; getK(que[r - 1], que[r]) &gt;= getK(que[r], i)) r--; que[++r] = i; } printf(&quot;%lld\n&quot;, dp[n]); return 0; } int main() { solve(); return 0; } 易错点：1、que[l]和l区别2、原点是决策点 初始化r必须为13、单调队列中要有两个元素才能算斜率，所以l &lt; r4、斜率优化实数会被卡精度，用叉积来判，用叉积斜率必须大减小！5、用叉积斜率必须大减小！否则不等式变号！6、可以适当用数组简化一些东西 数的方法求斜率我们设$i$前有两个决策$j, k(j &lt; k)$, 且决策$k$比$j$优，则$$dp(j)-2S_i(S_j+P)+(S_j+P)^2 &gt; dp(k)-2S_i(S_k+P)+(S_k+P)^2$$将包含$i$的移到左边，其他移到右边$$-2S_i(S_j+P)+2S_i(S_k+P) &gt; dp(k)-dp(j)-(S_j+P)^2+(S_k+P)^2$$把左边$S_i$提取出来，再把提取出来的式子除到右边($S_i-S_j &gt; 0$)$$S_i &gt; \frac{dp(k)+(S_k+P)^2-dp(j)+(S_j+P)^2}{2(S_k-S_j)}​$$令$k_{jk}=\frac{dp(k)+(S_k+P)^2-dp(j)+(S_j+P)^2}{2(S_k-S_j)}$，则满足$S_i &gt; k_{jk}$时在$i$处时$k$比$j$优。 总结斜率优化就是用来解决DP方程中有像$(a_i-a_j)^2$这样与$i, j$都相关的信息的优化，并且满足决策单调性，能够化作斜率式，并且斜率和$x$是单调的。如果斜率不是单调的，就要用二分查找队列中的最优解。如果$x$不是单调的，我们需要使用CDQ分治或者splay来解决这个问题。 斜率横坐标不单增例题：Bzoj 2726 这里斜率横坐标不单增，所以凸壳左端点不一定为最优决策。因为对于一条斜率为$k$的直线，将他放到凸壳中的应该排的位置即为最优决策点，所以我们可以不在队首淘汰元素，而是维护整个凸壳，然后在队列里二分找到将他放到凸壳中的应该排的位置即可转移。 常见题型参考资料 【一路走下去的斜率优化动态规划】 - 大米饼 - 博客园 斜率优化学习笔记 - MashiroSky - 博客园 斜率优化 - CSDN博客]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>斜率优化</tag>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1010」「HNOI2008」玩具装箱toy (斜率优化DP)]]></title>
    <url>%2Fbzoj1010%2F</url>
    <content type="text"><![CDATA[BZOJ 1010见此讲解 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; LL n, P, dp[50005], s[50005]; LL l, r, que[150005]; inline db getK(int k, int j) {return (db)(dp[k] - dp[j] + (s[k] + P) * (s[k] + P) - (s[j] + P) * (s[j] + P)) / (2.0 * (db)(s[k] - s[j]));} //计算两个点之间斜率 void clean() {} int solve() { clean(); scanf(&quot;%lld%lld&quot;, &amp;n, &amp;P), s[0] = 0, P++; for (int i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;s[i]), s[i] += s[i - 1]; for (int i = 1; i &lt;= n; i++) s[i] += i; dp[1] = 0, l = 1, r = 1; //原点是决策点 r必须为1 for (int i = 1; i &lt;= n; i++) { while (l &lt; r &amp;&amp; getK(que[l], que[l + 1]) &lt;= (db)s[i]) l++; //l必须严格小于r，因为单调队列中要有两个元素 dp[i] = dp[que[l]] + (s[i] - s[que[l]] - P) * (s[i] - s[que[l]] - P); while (l &lt; r &amp;&amp; getK(que[r - 1], que[r]) &gt;= getK(que[r], i)) r--; que[++r] = i; } printf(&quot;%lld\n&quot;, dp[n]); return 0; } int main() { solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 980E(倍增)]]></title>
    <url>%2FCodeforces980E%2F</url>
    <content type="text"><![CDATA[Codeforces 980E题意：有一颗无根树编号$1$到$n$，每个点权值为$2^i$, 要删除$k$个点，并且删后原树还是联通的。请问整棵树权值最大的删点方案？ 因为每个点权值为$2^i​$，而$2^i = \sum_{j=1}^{i-1}2^j+1​$，所以最大的那个点权值比其他所有点的权值都大。那么我们必须用一切代价保留大编号的点。我们可以把删除转化为选择问题，看从大开始能选几个点进去。预处理将$n​$转为根，$n​$加入选择集合。这个选择集合的所有节点必须在树上是连通块。所以我们枚举$n-1​$到$1​$的点看它到联通块的最短距离来判断能不能加，能加就把路径上所有点加入集合。对于看它到联通块集合的最短距离，我们用树上倍增的方法找到距离该点最近的已经在联通块集合的点在哪里。易错点：1、$10^5~10^6$以上要输入输出优化知识点：1、$2^i = \sum_{j=1}^{i-1}2^j+1$2、删除转化为选择问题3、将$n$转为根：不一定要用$1$当根 Codeforces Submission #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 1e6 + 5, logs = 20; int n, k, vis[MAXN], pre[MAXN][logs + 5]; vector&lt;int&gt; G[MAXN]; inline void ins(int x, int y) { G[x].push_back(y), G[y].push_back(x); } void dfs(int u, int pa) { pre[u][0] = pa; for (int i = 1; i &lt;= logs; i++) pre[u][i] = pre[pre[u][i - 1]][i - 1]; for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i]; if (v != pa) dfs(v, u); } } void clean() { ms(vis, 0), ms(pre, 0); } int solve() { clean(); cin &gt;&gt; n &gt;&gt; k; if (n == k) {for (int i = 1; i &lt;= n; i++) printf(&quot;%d\n&quot;, i); return 0;} k = n - k - 1; for (int x, y, i = 1; i &lt; n; i++) scanf(&quot;%d%d&quot;, &amp;x, &amp;y), ins(x, y); dfs(n, 0), vis[n] = 1; for (int x = n - 1; x; x--) { int t = k, v = x, flag = 0; for (int i = logs; i &gt;= 0; i--) { if (vis[v]) {flag = 1; break;} if (pre[v][i] == 0) continue; if (t &lt; (1 &lt;&lt; i)) continue; v = pre[v][i], t -= (1 &lt;&lt; i); } if (vis[v]) flag = 1; v = x; if (flag) { while (!vis[v]) { vis[v] = 1, k--; v = pre[v][0]; } } if (k == 0) break; } for (int i = 1; i &lt;= n; i++) if (!vis[i]) printf(&quot;%d\n&quot;, i); return 0; } int main() { solve(); return 0; } //23:11-23:19-23:23-23:29 //¿ªÊ¼Ð´´úÂë-´úÂëÍê³É-¾²Ì¬µ÷ÊÔÍê³É-¹ýÑùÀý]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 909E(拓扑排序)]]></title>
    <url>%2FCodeforces909E%2F</url>
    <content type="text"><![CDATA[Codeforces 909E题意：给你一堆任务，有些要用主处理器处理，有些要用副处理器处理，副处理器可以一次处理很多个任务，一个任务能被执行的条件为前继任务已经被执行过了或者前继任务和自己同时被放进副处理器处理，现在给你这些前继任务的关系和每个任务处理要用的处理器，求副处理器最少运行了几次，保证关系是一张有向无环图 (主处理器与副处理器之间没有任何关系，随意顺序处理) DAG图就能想到DP和拓扑排序，这题明显可以拓扑排序。先把最外面能被拓扑的一堆0点处理(不一定就一层)，然后再处理里面的能被拓扑的一堆1点，并且使答案加一。以此类推 Codeforces Submission #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; LL n, m, ino[100000 + 5], ei[100000 + 5]; vector&lt;int&gt; G[100000 + 5]; queue&lt;int&gt; q[2]; inline void ins(int x, int y) { G[x].push_back(y), ino[y]++; } void clean() { ms(ino, 0); } int solve() { clean(); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; ei[i]; for (int x, y, i = 1; i &lt;= m; i++) cin &gt;&gt; x &gt;&gt; y, ins(y + 1, x + 1); for (int i = 1; i &lt;= n; i++) if (!ino[i]) { if (ei[i] == 0) q[0].push(i); else q[1].push(i); } int cur = 0, tot = 0, ans = 0; while (tot &lt; n) { while (!q[cur].empty()) { int u = q[cur].front(); q[cur].pop(); tot++; for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i]; ino[v]--; if (!ino[v]) { if (ei[v] == cur) q[cur].push(v); else q[cur ^ 1].push(v); } } } if (cur == 1) ans++; cur ^= 1; } cout &lt;&lt; ans; return 0; } int main() { solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 922E(DP)]]></title>
    <url>%2FCodeforces922E%2F</url>
    <content type="text"><![CDATA[Codeforces 922E题意：一条直线上有$n$棵树, 每棵树上有$c_i$只鸟, 在一棵树底下召唤一只鸟的魔法代价是$cost_i$ ，每召唤一只鸟，魔法上限会增加$B$ ，从一棵树走到另一棵树，会增加魔法$X $，一开始的魔法和魔法上限都是$W$， 问最多能够召唤的鸟的个数(题意来自Luogu) 只能向前走，所以一定是DP。但是费用都是$10^9$明显不能加到状态里。那么设$dp(i,j)$为到$i$棵树下已经召唤了$j$只鸟剩下的魔法，那么就是一个比较容易的DP$$dp(i,j)=max(dp(i-1, j-k)-cost_i \cdot k|1 \leq k \leq min(j, c_i))$$由于$c_i$的总数不大，直接循环即可。注意无用的状态和初始化都$dp(i,j)=-1$, 只有$dp(0,0)=W$，要注意不要有负数出现，要及时剪枝。也不能从无用状态转移。最后由于相邻状态转移会恢复$X$魔法，所以要根据当前容量大小来修改dp的值。 一定要注意初值、无用状态转移的处理。 Codeforces Submission #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const LL INF = 1000000000; LL n, W, B, X, ci[1000 + 5], csti[1000 + 5], totci; LL dp[1000 + 5][10000 + 5]; void clean() { totci = 0; } int solve() { clean(); for (LL i = 1; i &lt;= n; i++) scanf(&quot;%I64d&quot;, &amp;ci[i]); for (LL i = 1; i &lt;= n; i++) scanf(&quot;%I64d&quot;, &amp;csti[i]); ms(dp, -1); dp[0][0] = W; for (LL i = 1; i &lt;= n; i++) { totci += ci[i]; for (LL j = 0; j &lt;= totci; j++) { for (LL k = 0; k &lt;= min(j, ci[i]); k++) { if (dp[i - 1][j - k] &lt; 0) continue; if (dp[i - 1][j - k] - k * csti[i] &lt; 0) continue; dp[i][j] = max(dp[i][j], dp[i - 1][j - k] - k * csti[i]); } if (dp[i][j] &gt;= 0) dp[i][j] = min(dp[i][j] + X, W + j * B); } } LL ans = 0; for (int i = 0; i &lt;= totci; i++) if (dp[n][i] &gt;= 0) ans = i; printf(&quot;%I64d\n&quot;, ans); return 0; } int main() { scanf(&quot;%I64d%I64d%I64d%I64d&quot;, &amp;n, &amp;W, &amp;B, &amp;X), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1013E(DP)]]></title>
    <url>%2FCodeforces1013E%2F</url>
    <content type="text"><![CDATA[Codeforces 1013E题意：给你$n$个数，你一次操作可以把某一个数$-1$（可以减为负数），你的目标是使任意的$k$个数严格小于它旁边的两个数（第一个数只用严格小于第二个数，第$n$个数只用严格小于第$n-1$个数），问最少需要几次操作。$k$是不确定的，请输出$k \in[1,\left\lceil\dfrac{n}{2}\right\rceil]$时的答案。(题意来自Luogu) 求最优值，想到DP，并且要求$,\left\lceil\dfrac{n}{2}\right\rceil$个值，所以可以设$dp(i,j)$为前$i$个数有$j$个数满足题意的最优值。但是这样转移非常困难，因为不知道上一个接上的是不是满足题意的值。那么我们设： dp(i,j,0) 为前$i$个数有$j$个数满足题意，并且$i, i-1$都不满足题意的最优值dp(i,j,1) 为前$i$个数有$j$个数满足题意，并且$i$满足题意的最优值dp(i,j,2) 为前$i$个数有$j$个数满足题意，并且$i-1$满足题意的最优值 是否很像树状DP的样子？然后分别转移：$$dp(i,j,0)=min(dp(i - 1, j ,0), dp(i - 1, j ,2))$$这个意思是直接继承之前的，画个图就能搞明白$$dp(i,j,2)=dp(i - 1, j ,1)+max(0, a_{i} - a_{i - 1} + 1)$$因为之前$dp(i - 1, j ,1)​$的最后一个满足题意没有考虑现在的$i​$，于是要进行操作。 然后考虑$dp(i,j,1)$$$s =dp(i - 1,j - 1,0) + max(0, a_{i - 1} - a_{i} + 1)$$前面两个都不是满足题意的，所以直接操作$$t=dp(i - 1,j - 1,2) + max(0, min(a_{i - 1}, a_{i - 2} - 1) - a_{i} + 1)$$前面两个点中$i-2$满足题意，并且$i-1$必然在之前操作中已经小于$i-2$，所以操作要取$min$$$dp(i,j,1)=min(s, t)$$综合前面的答案取最小。 初始值：$dp(i,0,0)=0, dp(1,1,1)=1$，其他赋值$∞$第一个不用解释，第二个因为只有一个数所以必然有一个满足题意的数。写初值的时候要注意全面考虑，不要忘 然后就可以直接做了 方法二，设$dp(i,j,0/1)$为前$i$个数有$j$个数修房子，并且$i$修(0)/不修(1)房子的最优值注意转移$dp(i,j,1)​$的时候不要从$i-1​$转移，而是从$i-2​$转移，这样转移非常方便转移方程：$dp[i][j][0] = min(dp[i - 1][j][0], dp[i - 1][j][1] + max(0, a[i] - a[i - 1] + 1))$$dp[i][j][1] = min(dp[i - 2][j - 1][1] + max(0, a[i - 1] - min(a[i - 2], a[i]) + 1), dp[i - 2][j - 1][0] + max(0, a[i - 1] - a[i] + 1))$ 方法一 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; int n, ai[5000 + 5], dp[5005][3005][3]; void clean() { } int solve() { clean(); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;ai[i]); for (int i = 0; i &lt;= n; i++) for (int j = 0; j &lt;= (n + 1) / 2; j++) dp[i][j][0] = dp[i][j][1] = dp[i][j][2] = 1000000000; for (int i = 1; i &lt;= n; i++) dp[i][0][0] = 0; dp[1][1][1] = 0; for (int i = 2; i &lt;= n; i++) for (int j = 1; j &lt;= (i + 1) / 2; j++) { dp[i][j][0] = min(dp[i - 1][j][0], dp[i - 1][j][2]); dp[i][j][1] = min(dp[i - 1][j - 1][0] + max(0, ai[i - 1] - ai[i] + 1), dp[i - 1][j - 1][2] + max(0, min(ai[i - 1], ai[i - 2] - 1) - ai[i] + 1)); dp[i][j][2] = dp[i - 1][j][1] + max(0, ai[i] - ai[i - 1] + 1); //printf(&quot;i=%d j=%d\n&quot;, i, j); //printf(&quot;%d %d %d\n\n&quot;, dp[i][j][0], dp[i][j][1], dp[i][j][2]); } for (int j = 1; j &lt;= (n + 1) / 2; j++) printf(&quot;%d &quot;, min(dp[n][j][0], min(dp[n][j][1], dp[n][j][2]))); return 0; } int main() { scanf(&quot;%d&quot;, &amp;n), solve(); return 0; } 方法二 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;stack&gt; #include&lt;set&gt; #include&lt;queue&gt; #include&lt;climits&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; namespace flyinthesky { const LL MAXN = 5000 + 5; LL n, a[MAXN], dp[MAXN][MAXN][2]; void clean() { for (LL i = 0ll; i &lt;= n; i++) for (LL j = 0ll; j &lt;= n; j++) dp[i][j][0] = dp[i][j][1] = LONG_LONG_MAX / 2; } int solve() { scanf(&quot;%lld&quot;, &amp;n); clean(); for (LL i = 1ll; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;a[i]); dp[0][0][0] = 0ll, dp[1][0][0] = 0ll, dp[1][1][1] = 0ll; for (LL i = 2ll; i &lt;= n; i++) for (LL j = 0ll; j &lt;= min(i, (n + 1ll) / 2ll); j++) { dp[i][j][0] = min(dp[i - 1][j][0], dp[i - 1][j][1] + max(0ll, a[i] - a[i - 1] + 1ll)); if (j &gt;= 1) dp[i][j][1] = min(dp[i - 2][j - 1][1] + max(0ll, a[i - 1] - min(a[i - 2], a[i]) + 1ll), dp[i - 2][j - 1][0] + max(0ll, a[i - 1] - a[i] + 1ll)); } for (LL i = 1ll; i &lt;= (n + 1ll) / 2ll; i++) printf(&quot;%lld &quot;, min(dp[n][i][0], dp[n][i][1])); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj 1386(有向图判欧拉路+并查集)]]></title>
    <url>%2Fpoj1386%2F</url>
    <content type="text"><![CDATA[poj 1386题意：给出几个字符串问能否首位相接成一个环或者一条链。 就是判有向图是否存在欧拉路即可。 欧拉路存在条件(图连通)：有向图：有一个点入度等于出度加一，有一个点出度等于入度加一，其余所有点入度等于出度欧拉回路存在条件(图连通)：有向图：所有点入度等于出度 用并查集维护一下就好。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; int en, n, ino[35], outo[35], f[35]; char s[1005]; struct edge { int v, vis; }ed[200000 + 5]; vector&lt;int&gt; G[35]; int find(int x) {return x == f[x] ? x : f[x] = find(f[x]);} void ins(char x, char y) { ed[++en] = (edge){y - &#39;a&#39;, 0}; G[x - &#39;a&#39;].push_back(en); ino[y - &#39;a&#39;]++, outo[x - &#39;a&#39;]++; int u = find(x - &#39;a&#39;), v = find(y - &#39;a&#39;); if (u != v) f[u] = v; } void clean() { en = 0; for (int i = 0; i &lt;= 30; i++) G[i].clear(), f[i] = i, ino[i] = outo[i] = 0; } int solve() { scanf(&quot;%d&quot;, &amp;n); clean(); for (int i = 0; i &lt; 26; i++) f[i] = i; for (int i = 1; i &lt;= n; i++) scanf(&quot;%s&quot;, s), ins(s[0], s[strlen(s) - 1]); for (int i = 0; i &lt; 26; i++) find(i); int ans = 0; for (int i = 0; i &lt; 26; i++) ans += (f[i] == i &amp;&amp; (ino[i] || outo[i])); if (ans != 1) return cout &lt;&lt; &quot;The door cannot be opened.&quot; &lt;&lt; endl, 0; int st = -1, ed = -1, fl = 0; for (int i = 0; i &lt; 26; i++) { if (ino[i] != outo[i]) { fl = 1; if (ino[i] == outo[i] + 1) { if (ed &gt;= 0) return cout &lt;&lt; &quot;The door cannot be opened.&quot; &lt;&lt; endl, 0; ed = i; } else if (ino[i] == outo[i] - 1) { if (st &gt;= 0) return cout &lt;&lt; &quot;The door cannot be opened.&quot; &lt;&lt; endl, 0; st = i; } else return cout &lt;&lt; &quot;The door cannot be opened.&quot; &lt;&lt; endl, 0; } } if ((st == -1 || ed == -1) &amp;&amp; fl) return cout &lt;&lt; &quot;The door cannot be opened.&quot; &lt;&lt; endl, 0; return cout &lt;&lt; &quot;Ordering is possible.&quot; &lt;&lt; endl, 0; return 0; } int main() { int T; scanf(&quot;%d&quot;, &amp;T); while (T--) solve(); return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>poj</tag>
        <tag>欧拉图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欧拉图 学习笔记]]></title>
    <url>%2Fsz%E6%AC%A7%E6%8B%89%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[模板及讲解定义欧拉路：能从无向图的一个点出发走一条路径，每条边恰好经过一次，这样的路叫欧拉路。欧拉回路：能从无向图任意一个点出发走一条路径，每条边恰好经过一次，并且回到该点，这样的路叫欧拉路。欧拉图：具有欧拉回路的图称为欧拉图，具有欧拉路而无欧拉回路的图称为半欧拉图 性质至多有两个奇点(度数为奇数)的无向图一定存在欧拉路 当有两个奇点时欧拉路必然从一个奇点到另一个奇点当有没有奇点时欧拉路必然是一个欧拉回路 欧拉图中所有点都是偶点并且所有点连通。 一笔画：连通分量是一个孤立的点, 只需要0笔可以完成连通分量是一个欧拉图或半欧拉图, 只需要1笔可以完成否则需要奇点数目/2笔可以完成简单证明为一个联通分量中两个奇点(非欧拉图/半欧拉图)就要有一条笔画划过，如果没有奇点(就是一个欧拉图)也要用一条笔画划过，结论得证HDU 3018 题目判断是否有欧拉回路/欧拉路Hdu 1878题意：欧拉回路是指不令笔离开纸面，可画过图中每条边仅一次，且可以回到起点的一条回路。现给定一个图，问是否存在欧拉回路？解：欧拉图中所有点都是偶点并且所有点连通。用并查集判连通，记录度数即可。代码： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; int n, m, de[1005], f[1005]; int find(int x) {return x == f[x] ? x : f[x] = find(f[x]);} void clean() {} int solve() { clean(); for (int i = 1; i &lt;= n; i++) de[i] = 0, f[i] = i; for (int x, y, i = 1; i &lt;= m; i++) { scanf(&quot;%d%d&quot;, &amp;x, &amp;y); de[x]++, de[y]++; int u = find(x), v = find(y); if (u != v) f[u] = v; } int ans1 = 0, ans2 = 0; for (int i = 1; i &lt;= n; i++) find(i); for (int i = 1; i &lt;= n; i++) ans1 += (f[i] == i), ans2 += ((de[i] % 2) ? 0 : 1); if (ans1 != 1) return printf(&quot;0\n&quot;), 0; if (ans2 != n) return printf(&quot;0\n&quot;), 0; return printf(&quot;1\n&quot;), 0; } int main() { while (scanf(&quot;%d%d&quot;, &amp;n, &amp;m) == 2 &amp;&amp; n &amp;&amp; m) solve(); return 0; } 欧拉路存在条件(图连通)：有向图：有一个点入度等于出度加一，有一个点出度等于入度加一，其余所有点入度等于出度无向图：至多有两个奇点(无向图中奇点个数为奇数)欧拉回路存在条件(图连通)：有向图：所有点入度等于出度无向图：没有奇点 找欧拉回路/欧拉路poj 2230题意：在有向图中从1点找出一条欧拉回路并输出经过点。解：直接搜索标记边是否访问即可。无向图类似，只是标记边一次标两次就行了代码： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; struct edge { int v, vis; }ed[100000 + 5]; int n, m, en; vector&lt;int&gt; G[100000 + 5]; void ins(int x, int y) { ed[++en] = (edge){y, 0}, G[x].push_back(en); ed[++en] = (edge){x, 0}, G[y].push_back(en); } void clean() { en = 0; for (int i = 0; i &lt;= 100000; i++) G[i].clear(); } void dfs(int u) { for (int i = 0; i &lt; (int)G[u].size(); i++) { edge &amp;a = ed[G[u][i]]; if (!a.vis) a.vis = 1, dfs(a.v); } printf(&quot;%d\n&quot;, u); } int solve() { clean(); for (int x, y, i = 1; i &lt;= m; i++) scanf(&quot;%d%d&quot;, &amp;x, &amp;y), ins(x, y); dfs(1); return 0; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m), solve(); return 0; } 混合图欧拉回路常见题型1、判断是否有欧拉回路2、找欧拉回路/欧拉路]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>欧拉图</tag>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hdu 1045(二分图最大匹配)]]></title>
    <url>%2Fhdu1045%2F</url>
    <content type="text"><![CDATA[Hdu 1045题意：题目告诉你一张网格图，图上有的格子有障碍物挡着，问一个在图上最多放几个炮台能覆盖整张图，且不会火力部重叠。 考虑二分图，并且如果没有障碍物，那二分图一条边相当于一个格子，求最大匹配即可。如果有障碍物，我们不妨拆行拆列，即如果一行中有障碍物，那么障碍物前后的行是互不影响的，所以我们可以拆出一个行，之后也是同理，列的情况也是同理。 (样例一为例) .X.. .... XX.. .... 拆行直接在后面加行即可，行列坐标就可以是((X, X)是X) (1, 1), (X, X), (5, 3), (5, 4) (2, 1), (2, 5), (2, 3), (2, 4) (X, X), (X, X), (6, 3), (6, 4) (4, 6), (4, 7), (4, 3), (4, 4) 然后用这个坐标来加边，对新图进行最大匹配即可。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; int n, hang, lie, vis[1005], cnt, lk[1005]; char map[10][10]; vector&lt;int&gt; G[1005]; inline void ins(int x, int y) {G[x].push_back(y);} int hungary(int u) { for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i]; if (vis[v] != cnt) { vis[v] = cnt; if (!lk[v] || hungary(lk[v])) { lk[v] = u; return true; } } } return false; } void clean() { hang = lie = 0; for (int i = 0; i &lt;= 1000; i++) G[i].clear(), lk[i] = vis[i] = 0; } int solve() { clean(); for (int i = 1; i &lt;= n; i++) scanf(&quot;%s&quot;, map[i] + 1); for (int i = 1; i &lt;= n; i++) { int fh = 0, fl = 0; for (int j = 1; j &lt;= n; j++) { if (map[i][j] == &#39;X&#39;) continue; if (map[i][j - 1] == &#39;X&#39;) fh = 1, ++hang; if (map[i - 1][j] == &#39;X&#39;) fl = 1, ++lie; if (fh) { if (map[i - 1][j] == &#39;X&#39; &amp;&amp; fl) { ins(hang + n, lie + n); } else ins(hang + n, j); } else { if (map[i - 1][j] == &#39;X&#39; &amp;&amp; fl) { ins(i, lie + n); } else ins(i, j); } } } int ans = 0; for (int i = 1; i &lt;= hang + n; i++) ans += hungary(cnt = i); printf(&quot;%d\n&quot;, ans); return 0; } int main() { while (scanf(&quot;%d&quot;, &amp;n) == 1 &amp;&amp; n) solve(); return 0; }]]></content>
      <categories>
        <category>Hdu</category>
      </categories>
      <tags>
        <tag>二分图</tag>
        <tag>Hdu</tag>
        <tag>可并堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj 2226(二分图最小顶点覆盖)]]></title>
    <url>%2Fpoj2226%2F</url>
    <content type="text"><![CDATA[poj 2226题意：用宽度为1长度不限的木板将 * 盖住而不盖住 .。 我们考虑二分图中一条边为一个点。我们对横竖进行遍历，看只横和只竖所需要的木板并且标号，例如样例 4 4 *.*. .*** ***. ..*. 横着：（图中数字表示用的是第几块木板） 1.2. .333 444. ..5. 竖着： 1.4. .345 234. ..4. 我们发现每一个点都可以被两块方向不同的木板覆盖，所以就以这个为依据建边，边相当于一个点，那么只要求出最小顶点覆盖即可。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; int r, c; char map[100][100]; int hang[100][100], lie[100][100], sz_hang = 0, sz_lie = 0; vector&lt;int&gt; G[3000]; int lk[3000], vis[3000], cnt; bool hungary(int u) { for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i]; if (vis[v] != cnt) { vis[v] = cnt; if (!lk[v] || hungary(lk[v])) { lk[v] = u; return true; } } } return false; } void clean() { ms(lk, 0), ms(vis, 0), ms(hang, 0), ms(lie, 0); } int solve() { clean(); for (int i = 1; i &lt;= c; i++) map[0][i] = &#39;\0&#39;; for (int i = 1; i &lt;= r; i++) scanf(&quot;%s&quot;, map[i] + 1), map[i][0] = &#39;\0&#39;; for (int i = 1; i &lt;= r; i++) { for (int j = 1; j &lt;= c; j++) { if (map[i][j] == &#39;*&#39; &amp;&amp; map[i][j - 1] != &#39;*&#39;) hang[i][j] = ++sz_hang; if (map[i][j] == &#39;*&#39; &amp;&amp; map[i][j - 1] == &#39;*&#39;) hang[i][j] = hang[i][j - 1]; } } for (int i = 1; i &lt;= c; i++) { for (int j = 1; j &lt;= r; j++) { if (map[j][i] == &#39;*&#39; &amp;&amp; map[j - 1][i] != &#39;*&#39;) lie[j][i] = ++sz_lie; if (map[j][i] == &#39;*&#39; &amp;&amp; map[j - 1][i] == &#39;*&#39;) lie[j][i] = lie[j - 1][i]; } } for (int i = 1; i &lt;= r; i++) for (int j = 1; j &lt;= c; j++) G[hang[i][j]].push_back(lie[i][j]); int ans = 0; for (int i = 1; i &lt;= sz_hang; i++) ans += hungary(cnt = i); printf(&quot;%d&quot;, ans); return 0; } int main() { scanf(&quot;%d%d&quot;, &amp;r, &amp;c), solve(); return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>二分图</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj 2446(二分图黑白染色)]]></title>
    <url>%2Fpoj2446%2F</url>
    <content type="text"><![CDATA[poj 2446题意：给出一个网格图，有$k$个格子是空洞，然后用$1 \times 2$的矩形，对所有非空洞的格子进行覆盖，问是否可以全部覆盖。考虑将图黑白染色，即相邻的格子颜色不同(黑白相间)。本题就是相当于将白格和黑格进行匹配，连边二分图，然后求出最大匹配即可。但是最大匹配后可能还会有$1 \times 1$的小方块不在匹配中，要验证答案。对于一个点$(x,y)$，如果$x,y$是奇数，则他是一种颜色；反之是另一种颜色。我们用这种方法来区分颜色。注意障碍物不要连边。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define pb push_back using namespace std; int m, n, k, map[40][40], vis[2000], cnt, lk[2000]; vector&lt;int&gt; G[2000]; inline int getID(int x, int y) {return (x - 1) * n + y;} int hungary(int u) { for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i]; if (vis[v] != cnt) { vis[v] = cnt; if (!lk[v] || hungary(lk[v])) { lk[v] = u; return true; } } } return false; } void clean() { ms(lk, 0), ms(map, 0), ms(vis, 0); } int solve() { clean(); for (int x, y, i = 1; i &lt;= k; i++) scanf(&quot;%d%d&quot;, &amp;x, &amp;y), map[y][x] = 1; for (int i = 1; i &lt;= m; i++) { for (int j = 1; j &lt;= n; j++) { if (!map[i][j]) { if (i - 1 &gt; 0 &amp;&amp; !map[i - 1][j]) { if ((i + j) % 2) { G[getID(i - 1, j)].pb(getID(i, j)); } else { G[getID(i, j)].pb(getID(i - 1, j)); } } if (j - 1 &gt; 0 &amp;&amp; !map[i][j - 1]) { if ((i + j) % 2) { G[getID(i, j - 1)].pb(getID(i, j)); } else { G[getID(i, j)].pb(getID(i, j - 1)); } } } } } int ans = 0; for (int i = 1; i &lt;= getID(m, n); i++) ans += hungary(cnt = i); if (ans * 2 + k == m * n) printf(&quot;YES\n&quot;); else printf(&quot;NO\n&quot;); return 0; } int main() { scanf(&quot;%d%d%d&quot;, &amp;m, &amp;n, &amp;k), solve(); return 0; } /* 4 4 2 1 4 4 2 */]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>二分图</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1013D(并查集维护行列)]]></title>
    <url>%2FCodeforces1013D%2F</url>
    <content type="text"><![CDATA[Codeforces 1013D题意：一个矩形的其中三个顶点有东西的话第四个顶点也会有东西, 然后问你铺满网格最少需要买多少东西。 维护行列方法：并查集、图论、2-SAT、二分图这里用并查集。我们根据三个点坐标，发现如果连上$(r1, c1), (r1, c2), (r2, c1)$无向边，则$(r2, c2)$连通，相当于这个点存在了。所以我们用并查集连边，判断连通块个数$siz$，买$siz-1$个点使得整个图连通即可。 Codeforces Submission #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; int n, m, q, f[400000 + 5]; int find(int x) {return x == f[x] ? x : f[x] = find(f[x]);} void clean() {} int solve() { clean(); for (int i = 1; i &lt;= n + m; i++) f[i] = i; while (q--) { int r, c; cin &gt;&gt; r &gt;&gt; c; int x = find(r), y = find(c + n); if (x != y) f[x] = y; } int ans = 0; for (int i = 1; i &lt;= n + m; i++) if (f[i] == i) ans++; cout &lt;&lt; ans - 1; return 0; } int main() { cin &gt;&gt; n &gt;&gt; m &gt;&gt; q, solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 940E(DP+单调队列)]]></title>
    <url>%2FCodeforces940E%2F</url>
    <content type="text"><![CDATA[Codeforces 940E题意：给你一个长为$n$的序列和一个数字$c$，你要将这个序列切成若干段，对于每一段，这段中最小的$\frac nc$个数字（向下取整）都会被自动删除，问怎么切割使最后剩下的数字和最小 可以证明一段长度不会超过$c$。假设有一段长度超过$c$，因为超过$c$的部分不能给这个段提供更大的删除值，而如果长度为$xc$($x$为任意正整数)，那么这个段可以分成$x$段$c$长度的段，并且答案可能更优。那么每一段长度等于$c$的段就只用删除一个数。所以我们设$dp(i)$为前$i$个数删除数值的最大值，那么$dp(i)=dp(i-c)+min(a_j|i - c + 1 \leq j \leq i)$，删区间$[i-c+1, i]$最小的数。也有可能$i$点不取最优(在此处后面断开)，则$dp(i)=dp(i-1)$。 知识点：本题 DP 状态使用了补集转化思想，并且利用$dp(i)=dp(i-1)$来处理段长不为$c$的情况。Codeforces Submission #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; LL n, c, ai[100000 + 5], dp[100000 + 5], que[100000 + 5], l, r, sum = 0; void clean() {} int solve() { clean(); for (int i = 1; i &lt;= n; i++) cin &gt;&gt; ai[i], sum += ai[i]; dp[0] = 0; l = 1, r = 0; for (int i = 1; i &lt;= n; i++) { while (l &lt;= r &amp;&amp; que[l] &lt; i - c + 1) l++; while (l &lt;= r &amp;&amp; ai[que[r]] &gt;= ai[i]) r--; que[++r] = i; dp[i] = dp[i - 1]; if (i - c &gt;= 0) dp[i] = max(dp[i], dp[i - c] + ai[que[l]]); } cout &lt;&lt; sum - dp[n]; return 0; } int main() { cin &gt;&gt; n &gt;&gt; c, solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>单调队列</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三分法 学习笔记]]></title>
    <url>%2Fsz%E4%B8%89%E5%88%86%E6%B3%95%2F</url>
    <content type="text"><![CDATA[模板及讲解三分和二分区别二分法用于单调函数上逼近某值，而三分法用于单峰函数 (凸函数/凹函数)上逼近极值点。 基本思路对于区间$[l,r]$，我们求出$[l,r]$中点$mid$，再求出$[mid,r]$的中点$mmid$. 如果$f(mid) &gt; f(mmid)$，那么$mmid$在极值点右边。如果$f(mid) &lt; f(mmid)$，那么$mmid$在极值点左边。 以上直接用反证法可以证明，根据单调性的定义。 然后就可以用这个方法来更新了，最后$l,r$大的那个点是极值点。 代码例题：P3382 三分法 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define pb push_back #define sec second #define fir first using namespace std; int n; db l, r, a[20]; const db eps = 1e-7; db f(db x) { db ret = a[1]; for (int i = 2; i &lt;= n + 1; i++) ret = ret * x + a[i];//秦九韶算法 (提取各项的x) return ret; } void clean() {} int solve() { clean(); for (int i = 1; i &lt;= n + 1; i++) scanf(&quot;%lf&quot;, &amp;a[i]); f(2); db mid, mmid; while (fabs(r - l) &gt; eps) { mid = (l + r) / 2, mmid = (mid + r) / 2; if (f(mid) &gt; f(mmid)) r = mmid; else l = mid; } printf(&quot;%.5f\n&quot;, mid); return 0; } int main() { scanf(&quot;%d%lf%lf&quot;, &amp;n, &amp;l, &amp;r), solve(); return 0; } 常见题型1、三分法Q：见讲解解：见讲解例题：P3382 三分法2、三分套三分Q：有两个点需要三分解：有两个点需要三分，就三分后再三分一次例题：Bzoj 1857]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>三分</tag>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分治 学习笔记]]></title>
    <url>%2Fsz%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[模板及讲解分治分治关键为1、分 (分区间)2、解 (解小范围的答案)3、并 (合并分的两个区间，处理跨区间的答案) 归并排序、逆序对棋盘覆盖最大连续子序列和例题：Hdu 1003 求最大连续子序列和。 我们可以将区间一分为二，然后对两个区间求出最大连续子序列和，然后合并时考虑在两边的答案，在中间的答案。对于在中间的答案，我们需要求出左边区间右边开始最大连续子序列和大小，右边区间左边开始的最大连续子序列和大小。然后合并即可。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;vector&gt; #include&lt;utility&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; int T, kse = 0; namespace flyinthesky { const int MAXN = 100000 + 5; int n, a[MAXN]; int dc(int l, int r, int &amp;x, int &amp;y) { if (l == r) { x = y = l; return a[l]; } int mid = (l + r) &gt;&gt; 1; int ans1, l1, r1; ans1 = dc(l, mid, l1, r1); int ans2, l2, r2; ans2 = dc(mid + 1, r, l2, r2); int maxrs = -1000000000, rs = 0, r3 = mid + 1; for (int i = mid + 1; i &lt;= r; ++i) { rs += a[i]; if (rs &gt; maxrs) maxrs = rs, r3 = i; } int maxls = -1000000000, ls = 0, l3 = mid; for (int i = mid; i &gt;= l; --i) { ls += a[i]; if (ls &gt; maxls) maxls = ls, l3 = i; else if (ls == maxls) l3 = i; } if (ans1 &lt; ans2) { ans1 = ans2; l1 = l2, r1 = r2; } else if (ans1 == ans2) { if (l1 &gt; l2) l1 = l2, r1 = r2; } if (ans1 &lt; maxls + maxrs) { ans1 = maxls + maxrs; l1 = l3, r1 = r3; } else if (ans1 == maxls + maxrs) { if (l1 &gt; l3) l1 = l3, r1 = r3; } x = l1, y = r1; return ans1; } void clean() { } int solve() { clean(); scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i]); int g1, g2; int ans = dc(1, n, g1, g2); printf(&quot;Case %d:\n%d %d %d\n&quot;, ++kse, ans, g1, g2); if (T) printf(&quot;\n&quot;); return 0; } } int main() { scanf(&quot;%d&quot;, &amp;T); while (T--) flyinthesky::solve(); return 0; } 最近点对问题例题：Luogu 1429 给定平面上$n$个点，找出其中的一对点的距离，使得在这$n$个点的所有点对中，该距离为所有点对中最小的 (以下内容来自http://jvruo.com/archives/84/) 一维$n$个点退化为$x$轴上的$n$个实数$x_1，x_2，…，x_n$。最近点对即为这$n$个实数中相差最小的两个实数。显然可以先将点排好序，然后用$O(n)$线性扫描。但为了便于推广到二维的情形，尝试用分治法解决这个问题。 首先肯定要先对点进行排序，接着假设我们用$m$点将$S$分为$S_1$和$S_2$两个集合，这样对于所有的$p(S_1$中的点)和$q(S_2$中的点)，有$p &lt; q$。 然后把$S_1$和$S_2$分别当作完整的序列$S$，分治地在$S_1$和$S_2$上找出其最近点对，并设$ d $为两个集合的最近点对长度 由此，$S$中最近点对可能是在$S_1$中的，可能是在$S_2$中的，也可能是跨越两个集合的。 如果此时最近点对是跨越两个集合的，则集合两点与$m$的距离都不超过$d$，且一定分别出现在区间$(m-d,d]$和$(d,m+d]$。并且只有一对这样的点对。时间复杂度为$O(nlogn)$。 二维我们可以对刚刚的做法进行推广，首先先对$x$坐标进行排序，取出中点，然后对于左右两边的区域$S_1，S_2$，重复上述过程，递归地求出左右两边分别的最近点对的距离$d_1，d_2$，并且$d=min(d_1,d_2)$。 接着我们来考虑跨越集合的情况，由左图可见(注: $l:x=m$)，由于可能的点只会落在$(m-d，m+d)$的宽为$2d$的带状区间内，但最多可能有$n$个点，合并时间最坏情况下为$O(n^2)$。然而，$P_1$和$P_2$中的点具有一种稀疏的性质——对于$P_1$中的任意一点，$P_2$中的点必定落在一个$d \times 2d$(如右图，不然$P_1，P_2$之间的距离$d_3$一定大于$d$，可反证 ，相当于将$y$坐标投影到直线$l$上)的矩形中，且最多只需检查六个点（鸽巢原理，后面会证明）。那么我们可以先将带状区间的点按$y$坐标排序，然后扫描，这样合并的时间复杂度$O(nlogn)$。总的时间复杂度为$O(nlognlogn)$。 最多六个节点的证明： 因为$d=min(d_1,d_2)$，所以这个$d \times 2d$的矩形中，任意两点的之间的距离都要大于等于$d$。那么我们想在这个$d \times 2d$的矩形中放尽量多的点，并且彼此之间距离都要大于等于$d$。 按照上图的红点位置放，是最优的策略。此时最多只能放下六个点。所以原结论是正确的。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;vector&gt; #include&lt;utility&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 200000 + 5; struct node { db x, y; }p[MAXN], f[MAXN]; int n; bool cmp1(node a, node b) {return a.x &lt; b.x;} bool cmp2(node a, node b) {return a.y &lt; b.y;} db dist(node a, node b) { return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y)); } db dc(int l, int r) { if (l == r) return 2e9; if (l == r - 1) return dist(p[l], p[r]); int mid = (l + r) &gt;&gt; 1, tot = 0; db d1 = dc(l, mid); db d2 = dc(mid + 1, r); db d = min(d1, d2); for (int i = l; i &lt;= r; ++i) if (fabs(p[i].x - p[mid].x) &lt;= d) f[++tot] = p[i]; sort(f + 1, f + 1 + tot, cmp2); for (int i = 1; i &lt;= tot; ++i) { for (int j = i + 1; j &lt;= tot; ++j) { if (f[j].y - f[i].y &lt;= d) { db tmp = dist(f[i], f[j]); if (tmp &lt; d) d = tmp; } else break; } } return d; } void clean() { } int solve() { clean(); scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%lf%lf&quot;, &amp;p[i].x, &amp;p[i].y); sort(p + 1, p + 1 + n, cmp1); printf(&quot;%.4f\n&quot;, dc(1, n)); return 0; } } int main() { flyinthesky::solve(); return 0; } 常见题型]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>算法笔记</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 982D(模拟)]]></title>
    <url>%2FCodeforces982D%2F</url>
    <content type="text"><![CDATA[Codeforces 982D题意：有一只鲨鱼每天游$a_i$公里，如果它一天游的距离大于等于$k$，我们就认为它游到了一个新的地方；否则认为它这一天停留在原来的地方。这只鲨鱼到过的地方不会重复。现在给出它$n$天游的距离（每天都不相等），我们要求出一个$k$，满足：1.鲨鱼停留在每个地方的天数相等。（一天游的距离大于等于$k$时不算停留）。2.停留过的地方尽可能多。3.有多个解时$k$取最小值。 很容易想到答案就是某个$a_i+1$，并且没有单调性，不能二分。另一个角度想，因为每天都不相等，所以我们按照从小到大按顺序将每个点加入，形成几个区间。就变成了区间合并问题。如果加的数左右都没有区间，就新建一个区间。左边或者右边有，扩展区间。都有的话就直接合并区间。然后为了每个区间大小相等，就用当前最长的区间大小乘以当前区间个数如果等于已经插入的点，那么一定每个区间大小相等，更新答案即可。 Codeforces Submission #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define pb push_back #define sec second #define fir first using namespace std; int n, ai[100000 + 5], lazy[100000 + 5]; pair&lt;int, int &gt; bi[100000 + 5]; void clean() { ms(lazy, -1); } int solve() { clean(); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; ai[i], bi[i].fir = ai[i], bi[i].sec = i; sort(bi + 1, bi + 1 + n); int maxlen = 0, cnt = 0, ans = 0, maxcnt = 0; for (int i = 1; i &lt;= n; i++) { if (lazy[bi[i].sec - 1] &gt;= 0 &amp;&amp; lazy[bi[i].sec + 1] &gt;= 0) { int l = lazy[bi[i].sec - 1], r = lazy[bi[i].sec + 1]; lazy[bi[i].sec - lazy[bi[i].sec - 1]] += r + 1; lazy[bi[i].sec + lazy[bi[i].sec + 1]] += l + 1; maxlen = max(maxlen, l + r + 1); cnt--; lazy[bi[i].sec - 1] = lazy[bi[i].sec + 1] = 0; } else if (lazy[bi[i].sec + 1] &gt;= 0) { lazy[bi[i].sec] = lazy[bi[i].sec + 1] + 1; lazy[bi[i].sec + lazy[bi[i].sec + 1]] = lazy[bi[i].sec]; maxlen = max(maxlen, lazy[bi[i].sec]); lazy[bi[i].sec + 1] = 0; } else if (lazy[bi[i].sec - 1] &gt;= 0) { lazy[bi[i].sec] = lazy[bi[i].sec - 1] + 1; lazy[bi[i].sec - lazy[bi[i].sec - 1]] = lazy[bi[i].sec]; maxlen = max(maxlen, lazy[bi[i].sec]); lazy[bi[i].sec - 1] = 0; } else { lazy[bi[i].sec] = 1; maxlen = max(maxlen, lazy[bi[i].sec]), cnt++; } if (maxlen * cnt == i) { if (cnt &gt; maxcnt) ans = bi[i].fir + 1, maxcnt = cnt; else if (cnt == maxcnt) { if (ans &gt; bi[i].fir + 1) ans = bi[i].fir + 1; } } } cout &lt;&lt; ans; return 0; } int main() { solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1497」「NOI2006」最大获利 (最大权闭合子图, 最小割)]]></title>
    <url>%2Fbzoj1497%2F</url>
    <content type="text"><![CDATA[BZOJ 1497题意：有$n$个结点，$m$条无向边可供建设。建立一个结点$u$有一定的花费$p_u$。建立一条无向边有一定的非负收益$w_e$。建立一条无向边$(u, v)$的必要条件是要先建立点$u$，点$v$。求最大获利。 将点、边作为事件，边$(u, v)$依赖点$u,v$，即转化为一个最大权闭合子图问题。将边拆成点，按最大权闭合子图问题做即可。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;bits/stdc++.h&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 60000 + 5, MAXM = 200000 + 5, INF = 2147483647; struct data { int v, cap;//ÖÕµã£¬²ÐÁ¿ }ed[MAXM * 2]; int n, m, s, t, maxd; vector&lt;int&gt; G[MAXN]; int en, cur[MAXN], d[MAXN];//±ßÊý£¬µ±Ç°»¡(ÓÃÓÚÓÅ»¯)£¬¾àÀëSµÄ¾àÀë void ins(int u, int v, int c) {//¼ÓË«Ïò±ß ed[en] = (data){v, c}, G[u].push_back(en++); ed[en] = (data){u, 0}, G[v].push_back(en++);//·´Ïò»¡ÈÝÁ¿Îª0£¡²»ÊÇ-c£¬Á÷Á¿²ÅÊÇÊØºãµÄ } bool bfs() {//Çó·Ö²ãÍ¼ queue&lt;int&gt; q; for (int i = 0; i &lt;= maxd; i++) d[i] = INF; d[s] = 0, q.push(s); while (!q.empty()) { int u = q.front(); q.pop(); for (int i = 0; i &lt; G[u].size(); i++) { int v = ed[G[u][i]].v, cap = ed[G[u][i]].cap; if (d[v] == INF &amp;&amp; cap) {//Ã»±»·Ö²ã²¢ÇÒ¿ÉÒÔ¸Ä½ø d[v] = d[u] + 1;//·Ö²ã q.push(v); } } } return d[t] != INF;//Èç¹û´æÔÚÔö¹ãÂ·Ôòt»á±»·ÃÎÊ } int dfs(int u, int a) {//¶àÂ·Ôö¹ã if (u == t) return a;//Ôö¹ãµ½ÖÕµã if (a == 0) return 0;//Ã»ÓÐ¿É¸Ä½øÁ¿ int retflow = 0; for (int &amp;i = cur[u]; i &lt; G[u].size(); i++) { int v = ed[G[u][i]].v, cap = ed[G[u][i]].cap; if (d[u] + 1 == d[v]) {//°´²ã´ÎÔö¹ã int f = dfs(v, min(a, cap)); //¼ÌÐøÔö¹ã if (f &gt; 0) {//ÄÜ¹»¸Ä½ø retflow += f, a -= f, ed[G[u][i]].cap -= f, ed[G[u][i] ^ 1].cap += f;//¸Ä½ø if (a == 0) break;//ÓÅ»¯£ºÃ»ÓÐ¿É¸Ä½øÁ¿Ê±´ËµãÓ¦¸Ã²»ÔÙ·ÃÎÊ } } } return retflow; } int dinic() {//Çó×î´óÁ÷ int flow = 0; while (bfs()) { for (int i = 0; i &lt;= maxd; i++) cur[i] = 0; //DFSÍêÒÔºóÒªÇå¿Õµ±Ç°»¡ flow += dfs(s, INF); } return flow; } void clean() { en = 0; for (int i = 0; i &lt;= n; i++) G[i].clear(); } void solve() { clean(); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); s = n + m + 1, t = n + m + 2, maxd = n + m + 2; for (int p, i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;p), ins(i, t, p); int ans = 0; for (int x, y, c, i = 1; i &lt;= m; ++i) { scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;c); ins(s, n + i, c); ins(n + i, x, INF); ins(n + i, y, INF); ans += c; } printf(&quot;%d\n&quot;, ans - dinic()); } int main() { solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>最小割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spoj Count on a tree II(树上莫队)]]></title>
    <url>%2Fspoj-COT2%2F</url>
    <content type="text"><![CDATA[SPOJ-COT2题意：给一棵树，每个点有一个权值。多次询问路径$(u, v)$上有多少个权值不同的点。树上莫队的资料考虑树上莫队。难点在于怎么将树搬到序列中。将树的括号序求出来，树的括号序就是维护一个序列，这个序列是dfs这棵树时，每个节点在dfs到的时候将本身加入序列，然后离开该节点(返回父节点)也将本身加入序列的一个序列(具体可以看资料，有图解)。我们设$st,ed$分别为某个点最开始在序列出现位置和最后出现在序列的位置。对于一条路径$(u,v)$(这里$st_u \leq st_v$)：如果$LCA=u$，那么路径就是$st_u$到$st_v$之间一段中出现次数为奇数次的点。否则，路径就是$ed_u$到$st_v$之间一段中出现次数为奇数次的点。注意这一段并不包含LCA，要手动加上。然后就是注意莫队转移的时候的方法，用奇偶性判断这个节点出现几次，只考虑奇偶性。奇数就可以让记录权值出现次数的数组加一，反之减一。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 40000 + 5, logs = 18; int n, m, whw, blolen, bl[MAXN * 2], ai[MAXN], st[MAXN], ed[MAXN], T[MAXN * 2], tax[MAXN], sz; int dep[MAXN], vis[MAXN], nl, nr, nans, pre[MAXN][22], ans[100000 + 5]; vector&lt;int&gt; G[MAXN]; struct data { int l, r, u, v, id, lca; bool operator &lt; (const data &amp;b) const { if (bl[l] == bl[b.l]) return r &lt; b.r; return bl[l] &lt; bl[b.l]; } }xw[100000 + 5]; void dfs(int u, int pa) { dep[u] = dep[pa] + 1, T[++sz] = u, st[u] = sz, pre[u][0] = pa; for (int i = 1; i &lt;= logs; i++) pre[u][i] = pre[pre[u][i - 1]][i - 1]; for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i]; if (v != pa) dfs(v, u); } T[++sz] = u, ed[u] = sz; } void ins(int a, int b) {G[a].push_back(b), G[b].push_back(a);} int LCA(int a, int b) { if (dep[a] &lt; dep[b]) swap(a, b); for (int i = logs; i &gt;= 0; i--) if (dep[pre[a][i]] &gt;= dep[b]) a = pre[a][i]; if (a == b) return a; for (int i = logs; i &gt;= 0; i--) if (pre[a][i] != pre[b][i]) a = pre[a][i], b = pre[b][i]; return pre[a][0]; } void adjust(int x) { tax[T[x]] = 1 - tax[T[x]]; if (tax[T[x]] % 2) { vis[ai[T[x]]]++; if (vis[ai[T[x]]] == 1) nans++; } else { vis[ai[T[x]]]--; if (vis[ai[T[x]]] == 0) nans--; } } void clean() { ms(dep, 0), sz = 0; } int solve() { clean(); blolen = (int)sqrt(2 * n); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;ai[i]), tax[i] = ai[i]; for (int i = 1; i &lt;= 2 * n; i++) bl[i] = (i - 1) / blolen + 1; sort(tax + 1, tax + 1 + n), whw = unique(tax + 1, tax + 1 + n) - tax - 1; for (int i = 1; i &lt;= n; i++) ai[i] = lower_bound(tax + 1, tax + 1 + whw, ai[i]) - tax; for (int u, v, i = 1; i &lt; n; i++) scanf(&quot;%d%d&quot;, &amp;u, &amp;v), ins(u, v); dfs(1, 0); for (int i = 1; i &lt;= m; i++) scanf(&quot;%d%d&quot;, &amp;xw[i].u, &amp;xw[i].v), xw[i].id = i, xw[i].lca = LCA(xw[i].u, xw[i].v); for (int i = 1; i &lt;= m; i++) { if (st[xw[i].u] &gt; st[xw[i].v]) swap(xw[i].u, xw[i].v); if (xw[i].lca != xw[i].u) xw[i].l = ed[xw[i].u], xw[i].r = st[xw[i].v]; else xw[i].l = st[xw[i].u], xw[i].r = st[xw[i].v]; } sort(xw + 1, xw + 1 + m); ms(tax, 0), ms(vis, 0), nl = 1, nr = 0, nans = 0; for (int i = 1; i &lt;= m; i++) { while (nl &lt; xw[i].l) adjust(nl), nl++; while (nl &gt; xw[i].l) adjust(nl - 1), nl--; while (nr &lt; xw[i].r) adjust(nr + 1), nr++; while (nr &gt; xw[i].r) adjust(nr), nr--; ans[xw[i].id] = nans; if (xw[i].lca != xw[i].u) { if (vis[ai[xw[i].lca]] == 0) ans[xw[i].id]++; } } for (int i = 1; i &lt;= m; i++) printf(&quot;%d\n&quot;, ans[i]); return 0; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m), solve(); return 0; } /* 8 3 105 2 9 3 8 5 7 7 1 2 1 3 1 4 3 5 3 6 3 7 4 8 1 8 6 8 5 4 */]]></content>
      <categories>
        <category>spoj</category>
      </categories>
      <tags>
        <tag>莫队</tag>
        <tag>spoj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 4241」历史研究 (分块/回滚莫队)]]></title>
    <url>%2Fbzoj4241%2F</url>
    <content type="text"><![CDATA[BZOJ 4241题意：有一个长度为$n$的序列，有$m$个询问，每次询问「$[l, r]$内每个数值乘以该数值出现次数」的最大值。 分块做法(在线)：预处理$s(i,j)$为$i$块到$j$块的答案最优的那个数值是什么，然后像区间众数一样做，询问的时候直接不完整块查询出现次数更新答案，整块就用之前预处理的数值来查询 莫队做法(离线)：由于删除更新答案不方便，那么这里可以用回滚莫队。按照原莫队方法排序，那么左端点在一块的询问就到了一起，并且右端点单调递增，右端点只有增加，考虑左端点。要使得左端点只能增加，我们把所有在一个块的左端点的询问一起处理，都将莫队中的左端点移到块最右边，每次查询的时候就从最右边开始向左延伸，记录答案，然后再回退到块最右边，这样就避免了删除。一个块处理完后，因为右端点会有删除的情况，所以直接抛弃之前的所有答案，重新从新询问开始记录答案。对于左右端点在同块的询问，直接暴力即可。时间复杂度分析：1、对于左右端点在同块的询问，其时间复杂度最坏为$O(m\sqrt n)$2、在同块中处理时，右端点单调递增，最多增加$n$次，复杂度$O(n\sqrt n)$。左端点回滚，由于在块中，最多滚动$\sqrt n$次，复杂度$O(m\sqrt n)$。3、对于左端点不同块之间的转换，清除记录数组时间复杂度$O(n\sqrt n)$由于$m,n$同级，所有算法复杂度为$O(n\sqrt n)$比分块快多了 分块做法 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 100000 + 5; int n, q, blolen, ai[MAXN], bl[MAXN], tax1[MAXN], tax[MAXN], whw, s[2000][2000]; vector&lt;int&gt; hh[MAXN]; int cha(int v, int l, int r) { return upper_bound(hh[v].begin(), hh[v].end(), r) - upper_bound(hh[v].begin(), hh[v].end(), l - 1); } LL query(int l, int r) { LL ans = 0; if (bl[l] == bl[r]) { for (int i = l; i &lt;= r; i++) { tax[ai[i]]++; if ((LL)tax1[ai[i]] * (LL)tax[ai[i]] &gt; ans) ans = (LL)tax1[ai[i]] * (LL)tax[ai[i]]; } for (int i = l; i &lt;= r; i++) tax[ai[i]] = 0; } else { ans = (LL)cha(s[bl[l] + 1][bl[r] - 1], l, r) * (LL)tax1[s[bl[l] + 1][bl[r] - 1]]; for (int i = l; i &lt;= bl[l] * blolen; i++) { LL tmp = (LL)cha(ai[i], l, r) * (LL)tax1[ai[i]]; if (tmp &gt; ans) ans = tmp; } for (int i = (bl[r] - 1) * blolen + 1; i &lt;= r; i++) { LL tmp = (LL)cha(ai[i], l, r) * (LL)tax1[ai[i]]; if (tmp &gt; ans) ans = tmp; } } return ans; } void clean() { ms(s, 0); } int solve() { clean(); blolen = (int)sqrt((db)n / log2(n)); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;ai[i]), tax1[i] = ai[i], bl[i] = (i - 1) / blolen + 1; sort(tax1 + 1, tax1 + 1 + n), whw = unique(tax1 + 1, tax1 + 1 + n) - tax1 - 1; for (int i = 1; i &lt;= n; i++) ai[i] = lower_bound(tax1 + 1, tax1 + 1 + whw, ai[i]) - tax1, hh[ai[i]].push_back(i); bool f = n % blolen; for (int i = 1; i &lt;= n / blolen + f; i++) { ms(tax, 0); int tms = 1; for (int j = i; j &lt;= n / blolen + f; j++) { s[i][j] = s[i][j - 1]; for (int k = (j - 1) * blolen + 1; k &lt;= j * blolen; k++) { tax[ai[k]]++; if ((LL)tax1[s[i][j]] * (LL)tms &lt; (LL)tax[ai[k]] * (LL)tax1[ai[k]]) tms = tax[ai[k]], s[i][j] = ai[k]; } } } ms(tax, 0); while (q--) { int l, r; scanf(&quot;%d%d&quot;, &amp;l, &amp;r); printf(&quot;%lld\n&quot;, query(l, r)); } return 0; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;q), solve(); return 0; } 莫队做法 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 100000 + 5; int blolen, whw, n, q, ai[MAXN], bl[MAXN], tax1[MAXN], tax[MAXN], nl, nr; LL ans[MAXN], nans; struct data { int l, r, id; bool operator &lt; (const data &amp;b) const { if (bl[l] == bl[b.l]) return r &lt; b.r; return bl[l] &lt; bl[b.l]; } }xw[MAXN]; void clean() { nl = 1, nr = 0, nans = 0; } int solve() { clean(); blolen = (int)sqrt(n); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;ai[i]), tax1[i] = ai[i], bl[i] = (i - 1) / blolen + 1; sort(tax1 + 1, tax1 + 1 + n), whw = unique(tax1 + 1, tax1 + 1 + n) - tax1 - 1; for (int i = 1; i &lt;= n; i++) ai[i] = lower_bound(tax1 + 1, tax1 + 1 + whw, ai[i]) - tax1; for (int i = 1; i &lt;= q; i++) scanf(&quot;%d%d&quot;, &amp;xw[i].l, &amp;xw[i].r), xw[i].id = i; sort(xw + 1, xw + 1 + q); ms(tax, 0); for (int i = 1; i &lt;= q; i++) { if (bl[xw[i].l] != bl[xw[i - 1].l]) nl = bl[xw[i].l] * blolen, nr = nl - 1, nans = 0, ms(tax, 0); if (bl[xw[i].l] == bl[xw[i].r]) { ans[xw[i].id] = 0; for (int j = xw[i].l; j &lt;= xw[i].r; j++) { tax[ai[j]]++; if ((LL)tax1[ai[j]] * (LL)tax[ai[j]] &gt; ans[xw[i].id]) ans[xw[i].id] = (LL)tax1[ai[j]] * (LL)tax[ai[j]]; } for (int j = xw[i].l; j &lt;= xw[i].r; j++) tax[ai[j]] = 0; } else { while (nr &lt; xw[i].r) { tax[ai[nr + 1]]++; if ((LL)tax1[ai[nr + 1]] * (LL)tax[ai[nr + 1]] &gt; nans) nans = (LL)tax1[ai[nr + 1]] * (LL)tax[ai[nr + 1]]; nr++; } LL tmpans = nans; while (nl &gt; xw[i].l) { tax[ai[nl - 1]]++; if ((LL)tax1[ai[nl - 1]] * (LL)tax[ai[nl - 1]] &gt; tmpans) tmpans = (LL)tax1[ai[nl - 1]] * (LL)tax[ai[nl - 1]]; nl--; } while (nl &lt; bl[xw[i].l] * blolen) tax[ai[nl]]--, nl++; ans[xw[i].id] = tmpans; } } for (int i = 1; i &lt;= q; i++) printf(&quot;%lld\n&quot;, ans[i]); return 0; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;q), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>分块</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 2821」作诗(Poetize)(分块)]]></title>
    <url>%2Fbzoj2821%2F</url>
    <content type="text"><![CDATA[BZOJ 2821题意：求区间内出现次数为正偶数的数字的个数。 老套路，这种能方便将点加入答案的题目，维护$s(i,j)$为$i$块到$j$块出现次数为正偶数的数的个数(块到块节约空间)，然后整块就处理完了，不完整块就每个数查询一下这个数出现在整块的次数和$[l,r]$的次数，用奇偶性判断是否要增加/减少答案。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 100000 + 5; int key, n, c, m, ai[MAXN], bl[MAXN], blolen, tax[MAXN], s[1500][1500]; vector&lt;int&gt; hh[MAXN]; int cha(int v, int l, int r) { return upper_bound(hh[v].begin(), hh[v].end(), r) - upper_bound(hh[v].begin(), hh[v].end(), l - 1); } int query(int l, int r) { int ans = 0; if (bl[l] == bl[r]) { for (int i = l; i &lt;= r; i++) { tax[ai[i]]++; if (tax[ai[i]] % 2 == 0) ans++; else if (tax[ai[i]] % 2 == 1 &amp;&amp; tax[ai[i]] != 1) ans--; } for (int i = l; i &lt;= r; i++) tax[ai[i]] = 0; } else { ans = s[bl[l] + 1][bl[r] - 1]; for (int i = l; i &lt;= bl[l] * blolen; i++) { if (tax[ai[i]]) continue; tax[ai[i]] = 1; int lr = cha(ai[i], l, r), li = cha(ai[i], l, bl[l] * blolen) + cha(ai[i], (bl[r] - 1) * blolen + 1, r); if (lr == li) { if (lr != 0 &amp;&amp; lr % 2 == 0) ans++; continue; } if ((lr - li) % 2 == 0) { if (lr % 2 == 1) ans--; } else { if (lr % 2 == 0) ans++; } } for (int i = (bl[r] - 1) * blolen + 1; i &lt;= r; i++) { if (tax[ai[i]]) continue; tax[ai[i]] = 1; int lr = cha(ai[i], l, r), ir = cha(ai[i], l, bl[l] * blolen) + cha(ai[i], (bl[r] - 1) * blolen + 1, r); if (lr == ir) { if (lr != 0 &amp;&amp; lr % 2 == 0) ans++; continue; } if ((lr - ir) % 2 == 0) { if (lr % 2 == 1) ans--; } else { if (lr % 2 == 0) ans++; } } for (int i = l; i &lt;= bl[l] * blolen; i++) tax[ai[i]] = 0; for (int i = (bl[r] - 1) * blolen + 1; i &lt;= r; i++) tax[ai[i]] = 0; } return ans; } void clean() { } int solve() { clean(); blolen = sqrt((db)n / log2(n)); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;ai[i]), bl[i] = (i - 1) / blolen + 1, hh[ai[i]].push_back(i); bool f = n % blolen; for (int i = 1; i &lt;= n / blolen + f; i++) { ms(tax, 0); for (int j = i; j &lt;= n / blolen + f; j++) { int x = (j - 1) * blolen + 1; s[i][j] = s[i][j - 1]; for (int k = x; k &lt;= j * blolen; k++) { tax[ai[k]]++; if (tax[ai[k]] % 2 == 0) s[i][j]++; else if (tax[ai[k]] % 2 == 1 &amp;&amp; tax[ai[k]] != 1) s[i][j]--; } } } ms(tax, 0); while (m--) { int l, r; scanf(&quot;%d%d&quot;, &amp;l, &amp;r); l = (l + key) % n + 1, r = (r + key) % n + 1; if (l &gt; r) swap(l, r); printf(&quot;%d\n&quot;, key = query(l, r)); } return 0; } int main() { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;c, &amp;m), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bzoj 3744(主席树+树状数组+分块)]]></title>
    <url>%2Fbzoj3744%2F</url>
    <content type="text"><![CDATA[BZOJ 3744题意：强制在线不修改求区间逆序对。 比较容易想到一个做法：用树状数组维护$[1, i]$逆序对数目，然后每个询问$[l,r]$就用$[1,r]$的答案再去除$[1,l-1]$的答案，去除方法是枚举每个$[1,l-1]$的数，在之后$[l, r]$区间找比他小的数的个数，答案减去这个个数即可，可以用树状数组/主席树维护(前缀和)，时间复杂度很高，高达$O(mnlog_n)$ 我们可以优化，可以用分块优化暴力枚举。预处理出$s(i,j)$表示第$i$个块最开始的位置到点$j$之间逆序对的个数，用树状数组维护即可，时间复杂度$O(n\sqrt n)$对于询问，如果$l,r$在同一块，直接树状数组暴力统计，因为在块中。不在一块的话，找$l$在的块的后面一块，运用$s(i,j)$直接将后面所有的逆序对都处理完了，然后考虑前面不整块，与前面说的容易想到的方法一样，直接做就行，因为在块中所有枚举量被大大减小。 这里代码用了主席树。为了练习主席树求区间小于等于$k$。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 50000 + 5; int key = 0, n, q, whw, blolen, ai[MAXN], tax[MAXN], bl[MAXN], s[300][50000 + 5], c[MAXN]; int lowbit(int x) {return x &amp; (-x);} int query(int x) { int ret = 0; for (int i = x; i &gt; 0; i -= lowbit(i)) ret += c[i]; return ret; } void add(int x, int v) { for (int i = x; i &lt;= whw; i += lowbit(i)) c[i] += v; } #define M ((l + r) &gt;&gt; 1) int sz, sumv[MAXN * 40], lc[MAXN * 40], rc[MAXN * 40], rt[MAXN]; int mge(int &amp;x, int y) { if (x == 0) return x = y, 0; if (y == 0) return 0; sumv[x] += sumv[y]; mge(lc[x], lc[y]), mge(rc[x], rc[y]); return 0; } void build(int l, int r, int &amp;x, int pos, int v) { if (x == 0) x = ++sz, sumv[x] = lc[x] = rc[x] = 0; sumv[x] += v; if (l == r) return ; if (pos &lt;= M) build(l, M, lc[x], pos, v); else build(M + 1, r, rc[x], pos, v); } int query_zxs(int l, int r, int x, int v) { if (l == r) return 0; if (v &lt;= M) return query_zxs(l, M, lc[x], v); else return sumv[lc[x]] + query_zxs(M + 1, r, rc[x], v); } int calc(int l, int r) { int ret = 0; if (bl[l] == bl[r]) { ms(c, 0); for (int i = l; i &lt;= r; i++) add(ai[i], 1), ret += query(whw) - query(ai[i]); return ret; } else { ret = s[bl[l] + 1][r]; for (int i = blolen * bl[l]; i &gt;= l; i--) { ret += query_zxs(1, whw, rt[r], ai[i]) - query_zxs(1, whw, rt[i], ai[i]); } return ret; } } void clean() { sz = 0; } int solve() { clean(); blolen = sqrt(n); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;ai[i]), tax[i] = ai[i], bl[i] = (i - 1) / blolen + 1; sort(tax + 1, tax + 1 + n), whw = unique(tax + 1, tax + 1 + n) - tax - 1; for (int i = 1; i &lt;= n; i++) ai[i] = lower_bound(tax + 1, tax + 1 + whw, ai[i]) - tax; bool f = n % blolen; for (int i = 1; i &lt;= n / blolen + f; i++) { int x = (i - 1) * blolen + 1; ms(c, 0); for (int j = x; j &lt;= n; j++) s[i][j] = s[i][j - 1], add(ai[j], 1), s[i][j] += query(whw) - query(ai[j]); } for (int i = 1; i &lt;= n; i++) build(1, whw, rt[i], ai[i], 1), mge(rt[i], rt[i - 1]); scanf(&quot;%d&quot;, &amp;q); while (q--) { int l, r; scanf(&quot;%d%d&quot;, &amp;l, &amp;r); l ^= key, r ^= key; printf(&quot;%d\n&quot;, key = calc(l, r)); } return 0; } int main() { scanf(&quot;%d&quot;, &amp;n), solve(); return 0; } /* 9 5 1 2 3 6 7 8 4 9 100 1 9 */]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>树状数组</tag>
        <tag>分块</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bzoj 3289(莫队+树状数组)]]></title>
    <url>%2Fbzoj3289%2F</url>
    <content type="text"><![CDATA[BZOJ 3289题意：不强制在线求区间逆序对。离线莫队，右端点对逆序对答案的贡献等于当前区间所有大于右端点值的数的个数，可以用树状数组维护这个数。左端点类似，是所有小于左端点值的数的个数。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 50000 + 5; int n, q, whw, ai[MAXN], ans[MAXN], blolen, bl[MAXN], tax[MAXN], c[MAXN]; int nl = 1, nr = 0, nans = 0; struct data { int l, r, id; bool operator &lt; (const data &amp;b) const { if (bl[l] == bl[b.l]) return r &lt; b.r; return bl[l] &lt; bl[b.l]; } }xw[MAXN]; int lowbit(int x) {return x &amp; (-x);} int query(int x) { int ret = 0; for (int i = x; i &gt; 0; i -= lowbit(i)) ret += c[i]; return ret; } void add(int x, int v) { for (int i = x; i &lt;= whw + 1; i += lowbit(i)) c[i] += v; } void clean() { } int solve() { clean(); blolen = sqrt(n); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;ai[i]), tax[i] = ai[i], bl[i] = (i - 1) / blolen + 1; sort(tax + 1, tax + 1 + n), whw = unique(tax + 1, tax + 1 + n) - tax - 1; for (int i = 1; i &lt;= n; i++) ai[i] = lower_bound(tax + 1, tax + 1 + whw, ai[i]) - tax + 1; scanf(&quot;%d&quot;, &amp;q); for (int i = 1; i &lt;= q; i++) scanf(&quot;%d%d&quot;, &amp;xw[i].l, &amp;xw[i].r), xw[i].id = i; sort(xw + 1, xw + 1 + q); for (int i = 1; i &lt;= q; i++) { while (nl &lt; xw[i].l) nans -= query(ai[nl] - 1), add(ai[nl], -1), nl++; while (nl &gt; xw[i].l) nans += query(ai[nl - 1] - 1), add(ai[nl - 1], 1), nl--; while (nr &lt; xw[i].r) nans += query(whw + 1) - query(ai[nr + 1]), add(ai[nr + 1], 1), nr++; while (nr &gt; xw[i].r) nans -= query(whw + 1) - query(ai[nr]), add(ai[nr], -1), nr--; ans[xw[i].id] = nans; } for (int i = 1; i &lt;= q; i++) printf(&quot;%d\n&quot;, ans[i]); return 0; } int main() { scanf(&quot;%d&quot;, &amp;n), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>树状数组</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[caioj 1442(带修主席树)]]></title>
    <url>%2Fcaioj1442%2F</url>
    <content type="text"><![CDATA[caioj 1447题意：给$n(1 \leq n \leq 50000)$个数字，进行$m(1 \leq m \leq 10000)$次操作，有两种操作： $Q,l,r,k$：询问$l$到$r$第$k$小的数。$C,x,k$：改变第$x$个数的值为$k$。 因为普通的主席树是前缀和套线段树，所以不能修改。那么我们想到修改，就发现可以用树状数组/线段树套线段树，由于此题单点修改，所以用树状数组。对于前缀和套线段树先建主席树，然后再建树状数组套线段树的，修改在树状数组上操作，原数组在前缀和中，综合可以得到修改后的信息，要注意树状数组上的点在线段树上跳动(jump函数调节，存在$ust$数组)，查询就用$ust$数组即可 实际上可以不必要建$2n$棵线段树，原数组直接加到树状数组中即可，不过会慢一点，代码在下面 建$2n$棵线段树的代码： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 50000 + 5, MV = 1000000000; int n, q, sz, rt[MAXN * 2], ai[MAXN]; #define M ((l + r) &gt;&gt; 1) int sumv[MAXN * 100], lc[MAXN * 100], rc[MAXN * 100], ust[MAXN * 100]; int lowbit(int x) {return x &amp; (-x);} int mge(int &amp;x, int y) {//线段树 合并 -&gt;将线段树y合并至线段树x if (x == 0) return x = y, 0; if (y == 0) return 0; sumv[x] += sumv[y]; mge(lc[x], lc[y]), mge(rc[x], rc[y]); return 0; } void build(int l, int r, int &amp;x, int pos, int v) {//线段树 建链 -&gt; 维护[l,r]区间，当前线段树上点x，修改位置为pos=v if (x == 0) x = ++sz, lc[x] = rc[x] = sumv[x] = 0; sumv[x] += v; if (l == r) return ; if (pos &lt;= M) build(l, M, lc[x], pos, v); else build(M + 1, r, rc[x], pos, v); } void add(int u, int x, int c) {//Bit 加 -&gt; bit上u点，x位置加c for (int i = u; i &lt;= 2 * n; i += lowbit(i)) build(1, MV, rt[i], x, c); } void jump(int u, int tp) {//Bit 更新 -&gt; bit上u跳 for (int i = u; i &gt; n; i -= lowbit(i)) { if (tp == -1) ust[i] = rt[i]; if (tp == 0) ust[i] = lc[ust[i]]; if (tp == 1) ust[i] = rc[ust[i]]; } } int getBitSum(int u) {//Bit 查询 -&gt; bit上u查询 int ret = 0; for (int i = u; i &gt; n; i -= lowbit(i)) { ret += sumv[lc[ust[i]]]; } return ret; } int query(int l, int r, int x, int y, int x_2, int y_2, int kth) {//线段树 查询 -&gt; 维护[l,r]区间，当前线段树上点x，y, 位置x_2, y_2, 查询第kth大 if (l == r) return l; int sum = sumv[lc[y]] - sumv[lc[x]] + getBitSum(y_2 + n) - getBitSum(x_2 + n); if (sum &gt;= kth) { jump(x_2 + n, 0), jump(y_2 + n, 0); return query(l, M, lc[x], lc[y], x_2, y_2, kth); } else { jump(x_2 + n, 1), jump(y_2 + n, 1); return query(M + 1, r, rc[x], rc[y], x_2, y_2, kth - sum); } } void clean() { sz = 0; for (int i = 0; i &lt;= 100000 + 5; i++) rt[i] = 0; for (int i = 0; i &lt;= 5000000 + 5; i++) sumv[i] = lc[i] = rc[i] = ust[i] = 0; } int solve() { clean(); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;ai[i]); for (int i = 1; i &lt;= n; i++) build(1, MV, rt[i], ai[i], 1), mge(rt[i], rt[i - 1]); char s[5]; while (q--) { scanf(&quot;%s&quot;, s); if (s[0] == &#39;C&#39;) { int x, k; scanf(&quot;%d%d&quot;, &amp;x, &amp;k); add(x + n, ai[x], -1), ai[x] = k, add(x + n, ai[x], 1); } else { int l, r, k; scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;k); jump(r + n, -1), jump(l - 1 + n, -1); printf(&quot;%d\n&quot;, query(1, MV, rt[l - 1], rt[r], l - 1, r, k)); } } return 0; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;q), solve(); return 0; } 建$n$棵线段树直接维护树状数组： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 50000 + 5, MV = 1000000000; int n, q, sz, rt[MAXN], ai[MAXN]; #define M ((l + r) &gt;&gt; 1) int sumv[MAXN * 100], lc[MAXN * 100], rc[MAXN * 100], ust[MAXN * 100]; int lowbit(int x) {return x &amp; (-x);} int mge(int &amp;x, int y) { if (x == 0) return x = y, 0; if (y == 0) return 0; sumv[x] += sumv[y]; mge(lc[x], lc[y]), mge(rc[x], rc[y]); return 0; } void build(int l, int r, int &amp;x, int pos, int v) { if (x == 0) x = ++sz, lc[x] = rc[x] = sumv[x] = 0; sumv[x] += v; if (l == r) return ; if (pos &lt;= M) build(l, M, lc[x], pos, v); else build(M + 1, r, rc[x], pos, v); } void add(int u, int x, int c) { for (int i = u; i &lt;= n; i += lowbit(i)) build(1, MV, rt[i], x, c); } void jump(int u, int tp) { for (int i = u; i &gt; 0; i -= lowbit(i)) { if (tp == -1) ust[i] = rt[i]; if (tp == 0) ust[i] = lc[ust[i]]; if (tp == 1) ust[i] = rc[ust[i]]; } } int getBitSum(int u) { int ret = 0; for (int i = u; i &gt; 0; i -= lowbit(i)) { ret += sumv[lc[ust[i]]]; } return ret; } int query(int l, int r, int x, int y, int x_2, int y_2, int kth) { if (l == r) return l; int sum = getBitSum(y_2) - getBitSum(x_2); if (sum &gt;= kth) { jump(x_2, 0), jump(y_2, 0); return query(l, M, lc[x], lc[y], x_2, y_2, kth); } else { jump(x_2, 1), jump(y_2, 1); return query(M + 1, r, rc[x], rc[y], x_2, y_2, kth - sum); } } void clean() { sz = 0; for (int i = 0; i &lt;= 50000 + 5; i++) rt[i] = 0; for (int i = 0; i &lt;= 5000000 + 5; i++) sumv[i] = lc[i] = rc[i] = ust[i] = 0; } int solve() { clean(); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;ai[i]); for (int i = 1; i &lt;= n; i++) add(i, ai[i], 1); char s[5]; while (q--) { scanf(&quot;%s&quot;, s); if (s[0] == &#39;C&#39;) { int x, k; scanf(&quot;%d%d&quot;, &amp;x, &amp;k); add(x, ai[x], -1), ai[x] = k, add(x, ai[x], 1); } else { int l, r, k; scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;k); jump(r, -1), jump(l - 1, -1); printf(&quot;%d\n&quot;, query(1, MV, rt[l - 1], rt[r], l - 1, r, k)); } } return 0; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;q), solve(); return 0; }]]></content>
      <categories>
        <category>caioj</category>
      </categories>
      <tags>
        <tag>主席树</tag>
        <tag>caioj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[caioj 1447(主席树)]]></title>
    <url>%2Fcaioj1447%2F</url>
    <content type="text"><![CDATA[caioj 1447题意：维护区间和，有区间增加，要求可持久化 (回退、查询某个版本) 每个询问开一棵线段树，回退直接删掉中间的线段树即可。由于是主席树不能pushdown，pushup，所以增加的时候直接更新sumv的值，查询时lazy值直接累加乘以查询区间长度即可，具体操作可以看代码 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const LL MAXN = 100000 + 5; LL n, m, ai[MAXN], qzh[MAXN], rt[MAXN], now, sz; #define M ((l + r) &gt;&gt; 1) LL sumv[MAXN * 40], lc[MAXN * 40], rc[MAXN * 40], lazy[MAXN * 40]; int mge(LL &amp;x, LL y) { if (y == 0) return 0; if (x == 0) return x = y, 0; sumv[x] += sumv[y], lazy[x] += lazy[y]; mge(lc[x], lc[y]), mge(rc[x], rc[y]); return 0; } void build(LL l, LL r, LL &amp;x, LL cl, LL cr, LL v) { if (x == 0) x = ++sz; sumv[x] += (cr - cl + 1) * v;//直接加，免去pushup if (l == cl &amp;&amp; r == cr) { lazy[x] += v; return ; } if (cr &lt;= M) build(l, M, lc[x], cl, cr, v); else if (cl &gt; M) build(M + 1, r, rc[x], cl, cr, v); else build(l, M, lc[x], cl, M, v), build(M + 1, r, rc[x], M + 1, cr, v); //整个区间在左边、右边、分开两边 } LL query(LL l, LL r, LL x, LL cl, LL cr, LL tmp) { if (l == cl &amp;&amp; r == cr) return (r - l + 1) * tmp + sumv[x]; if (cr &lt;= M) return query(l, M, lc[x], cl, cr, tmp + lazy[x]); else if (cl &gt; M) return query(M + 1, r, rc[x], cl, cr, tmp + lazy[x]); else return query(l, M, lc[x], cl, M, tmp + lazy[x]) + query(M + 1, r, rc[x], M + 1, cr, tmp + lazy[x]); //整个查询区间在左边、右边、分开两边，和普通线段树不同，相当于用 M 分离查询区间 //直接累加lazy最后乘查询区间长度 } void clean() { now = sz = 0; for (LL i = 0; i &lt;= 100000 + 3; i++) rt[i] = qzh[i] = 0; for (LL i = 0; i &lt;= 4000000 + 3; i++) sumv[i] = lc[i] = rc[i] = lazy[i] = 0; } int solve() { clean(); for (LL i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;ai[i]), qzh[i] = qzh[i - 1] + ai[i]; for (LL i = 1; i &lt;= m; i++) { LL tp; scanf(&quot;%lld&quot;, &amp;tp); if (tp == 1) { LL l, r, k; scanf(&quot;%lld%lld%lld&quot;, &amp;l, &amp;r, &amp;k); build(1, n, rt[++now], l, r, k), mge(rt[now], rt[now - 1]); } if (tp == 2) { LL l, r; scanf(&quot;%lld%lld&quot;, &amp;l, &amp;r); printf(&quot;%lld\n&quot;, qzh[r] - qzh[l - 1] + query(1, n, rt[now], l, r, 0)); } if (tp == 3) { LL l, r, h; scanf(&quot;%lld%lld%lld&quot;, &amp;l, &amp;r, &amp;h); printf(&quot;%lld\n&quot;, qzh[r] - qzh[l - 1] + query(1, n, rt[h], l, r, 0)); } if (tp == 4) { LL h; scanf(&quot;%lld&quot;, &amp;h); for (LL i = h + 1; i &lt;= now; i++) rt[i] = 0; now = h; } } return 0; } int main() { scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m), solve(); return 0; } 【题目描述】给出一个长度为n（1&lt;=n&lt;=100000）的序列a[1],a[2],a[3]……,a[n]（1&lt;=a[i]&lt;=1000000000），有m个操作（1&lt;=n&lt;=100000）。操作类型分为4种。1 l r k：给l到r之间的数都加上k（1&lt;=k&lt;=1000）。2 l r：询问当前l到r的和。3 l r h：询问第h次修改（修改只指1操作）时l到r的和。4 h：回到第h次修改的时候不再返回。 【输入数据】第一行两个数n和m(n,m&lt;=10^5)。接下来一行n个数。接下来m行m个操作。 【输出数据】每行对应一个询问。 【输入样例】10 51 2 3 4 5 6 7 8 9 102 4 42 1 102 2 41 3 6 32 2 4 【输出样例】455915 原样例太弱，补充一个样例【输入样例】5 101 2 3 4 52 2 41 1 2 32 2 41 2 4 1002 2 43 2 4 13 2 4 24 11 2 4 102 2 4【输出样例】9123121232142]]></content>
      <categories>
        <category>caioj</category>
      </categories>
      <tags>
        <tag>主席树</tag>
        <tag>caioj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spoj DQUERY(树状数组+离线/主席树)]]></title>
    <url>%2Fspoj-DQUERY%2F</url>
    <content type="text"><![CDATA[spoj DQUERYcaioj 1445题意：给出一个$n$个数的序列，求区间$[l,r]$里有多少种不同数字。 树状数组离线作法：我们将所有询问离线，按$r$排序。树状数组维护区间。然后不断根据询问向右加点加到$r$(排序避免删点)，如果当前数之前没有出现过，直接在树状数组该位置加$1$。否则就把之前出现这个值的位置减$1$，为的是把数尽可能放到右边，因为记录值中位置不影响答案。这样就方便求解$[l,r]$的信息，直接减即可，正确性显然，因为数都尽可能在右边。 主席树做法：与树状数组类似，主席树维护区间，相当于可持久化维护每次加点后的情况。每个点按顺序建树，如果这个点的数之前没有出现过，直接在本棵主席树该位置加$1$。否则就把之前出现这个值的位置减$1$，再重复做没有出现的情况。为的是把数尽可能放到右边，因为记录值中位置不影响答案。这样就方便求解$[l,r]$的信息。询问直接用右端点的主席树，由于上述操作后答案可减，所以直接把右端点的主席树左端点以右的值求和即可 树状数组离线做法： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 50000 + 5; struct data { int l, r, id; bool operator &lt; (const data &amp;b) const { return r &lt; b.r; } }qj[200000 + 5]; int n, q, ai[MAXN], c[MAXN], lst[1000000 + 5], ans[200000 + 5]; int lowbit(int x) {return x &amp; (-x);} void add(int x, int v) { for (int i = x; i &lt;= n; i += lowbit(i)) c[i] += v; } int query(int x) { int ret = 0; for (int i = x; i &gt; 0; i -= lowbit(i)) ret += c[i]; return ret; } void clean() { ms(lst, -1); } int solve() { clean(); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;ai[i]); scanf(&quot;%d&quot;, &amp;q); for (int i = 1; i &lt;= q; i++) scanf(&quot;%d%d&quot;, &amp;qj[i].l, &amp;qj[i].r), qj[i].id = i; sort(qj + 1, qj + 1 + q); int now = 1; for (int i = 1; i &lt;= q; i++) { while (now &lt;= qj[i].r) { if (lst[ai[now]] &lt; 0) add(now, 1); else add(lst[ai[now]], -1), add(now, 1); lst[ai[now]] = now, now++; } ans[qj[i].id] = query(qj[i].r) - query(qj[i].l - 1); } for (int i = 1; i &lt;= q; i++) printf(&quot;%d\n&quot;, ans[i]); return 0; } int main() { scanf(&quot;%d&quot;, &amp;n), solve(); return 0; } 主席树做法： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 30000 + 5; int n, q, sz, ai[MAXN], rt[MAXN], lst[1000000 + 5]; #define M ((l + r) &gt;&gt; 1) int sumv[MAXN * 20], lc[MAXN * 20], rc[MAXN * 20]; int mge(int &amp;x, int y) {//主席树x合并主席树y if (y == 0) return 0; if (x == 0) return x = y, 0; sumv[x] += sumv[y]; mge(lc[x], lc[y]), mge(rc[x], rc[y]); return 0; } void build(int l, int r, int &amp;x, int pos, int v) {//建链维护[l,r], 主席树上x点，修改位置和值 if (x == 0) x = ++sz, lc[x] = rc[x] = sumv[x] = 0; sumv[x] += v; if (l == r) return ; if (pos &lt;= M) build(l, M, lc[x], pos, v); else build(M + 1, r, rc[x], pos, v); } int query(int l, int r, int x, int u) {//查询[l,r]答案，主席树上x点，左边临界点u if (l == r) return 0; if (u &lt;= M) return sumv[rc[x]] + query(l, M, lc[x], u); //加上右边，查询左边 else return query(M + 1, r, rc[x], u); //不要加左，左边有临界点 } void clean() { sz = 0, ms(lst, -1); } int solve() { clean(); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;ai[i]); for (int i = 1; i &lt;= n; i++) {//维护 [0, n] 区间，因为l - 1可能为 0 if (lst[ai[i]] &lt; 0) build(0, n, rt[i], i, 1), mge(rt[i], rt[i - 1]);//之前没有 else { build(0, n, rt[i], lst[ai[i]], -1), build(0, n, rt[i], i, 1); mge(rt[i], rt[i - 1]); }//之前有 lst[ai[i]] = i; } scanf(&quot;%d&quot;, &amp;q); while (q--) { int l, r; scanf(&quot;%d%d&quot;,&amp;l, &amp;r); printf(&quot;%d\n&quot;, query(0, n, rt[r], l - 1)); } return 0; } int main() { scanf(&quot;%d&quot;, &amp;n), solve(); return 0; }]]></content>
      <categories>
        <category>spoj</category>
      </categories>
      <tags>
        <tag>离线</tag>
        <tag>树状数组</tag>
        <tag>主席树</tag>
        <tag>spoj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 2724」[Violet 6] 蒲公英(分块)]]></title>
    <url>%2Fbzoj2724%2F</url>
    <content type="text"><![CDATA[BZOJ 2724题意：强制在线不修改求区间众数。如果不强制在线，可以离线莫队直接处理。这里强制在线，我们将原数列分块，预处理$i$块到$j$块区间的众数，直接开桶统计，用于求解整块的区间。用vector把相同的数的位置按顺序存储下来，求众数可以用询问区间的每个数字去求他出现次数，比较即可。对于整块，我们预处理了$i$块到$j$块区间的众数，直接询问这个数字在询问区间出现次数即可；对于不完整的块，我们暴力每个数字在询问区间出现次数即可最后输出即可，时间复杂度$O(m \cdot logn+\frac nm)$, 其中$n$为数列长，$m$为每个块长，根据均值不等式，在$m \cdot logn=\frac nm$时和有最小值，$m=\sqrt{\frac{n}{logn}}$，即得到最优分块大小 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 40000 + 5; int n, q, whw, ai[MAXN], key = 0, tax[MAXN], tax1[MAXN], blolen, bl[MAXN], s[1005][1005]; vector&lt;int&gt; hh[MAXN]; int cx(int v, int x, int y) { return upper_bound(hh[v].begin(), hh[v].end(), y) - upper_bound(hh[v].begin(), hh[v].end(), x - 1); } int query(int x, int y) { int mks = cx(s[bl[x] + 1][bl[y] - 1], x, y), ret = s[bl[x] + 1][bl[y] - 1]; for (int i = x; i &lt;= min(y, bl[x] * blolen); i++) { int tmp = cx(ai[i], x, y); if (tmp &gt; mks) ret = ai[i], mks = tmp; else if (tmp == mks &amp;&amp; ai[i] &lt; ret) ret = ai[i]; } if (bl[x] != bl[y]) for (int i = (bl[y] - 1) * blolen + 1; i &lt;= y; i++) { int tmp = cx(ai[i], x, y); if (tmp &gt; mks) ret = ai[i], mks = tmp; else if (tmp == mks &amp;&amp; ai[i] &lt; ret) ret = ai[i]; } return ret; } void clean() {} int solve() { clean(); blolen = (int)sqrt((db)n / log2(n)); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;ai[i]), tax1[i] = ai[i], bl[i] = (i - 1) / blolen + 1; sort(tax1 + 1, tax1 + 1 + n), whw = unique(tax1 + 1, tax1 + 1 + n) - tax1 - 1; for (int i = 1; i &lt;= n; i++) ai[i] = lower_bound(tax1 + 1, tax1 + 1 + whw, ai[i]) - tax1, hh[ai[i]].push_back(i); bool f = n % blolen; for (int i = 1; i &lt;= n / blolen + f; i++) { ms(tax, 0); int mks = 0; for (int j = i; j &lt;= n / blolen + f; j++) { s[i][j] = s[i][j - 1]; for (int k = (j - 1) * blolen + 1; k &lt;= min(n, j * blolen); k++) { tax[ai[k]]++; if (tax[ai[k]] &gt; mks) mks = tax[ai[k]], s[i][j] = ai[k]; else if (tax[ai[k]] == mks &amp;&amp; ai[k] &lt; s[i][j]) s[i][j] = ai[k]; } } } while (q--) { int l, r; scanf(&quot;%d%d&quot;, &amp;l, &amp;r); l = (l + key - 1) % n + 1, r = (r + key - 1) % n + 1; if (l &gt; r) swap(l, r); printf(&quot;%d\n&quot;, key = tax1[query(l, r)]); } return 0; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;q), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[主席树 学习笔记]]></title>
    <url>%2Fsz%E4%B8%BB%E5%B8%AD%E6%A0%91%2F</url>
    <content type="text"><![CDATA[模板及讲解什么是主席树主席树也称为函数式线段树、可持久化线段树，主要是利用动态开点每个点建线段树(维护$[1,i]$的区间)、线段树可加可减性($[x,y]=[1,y]-[1,x-1]$)来解决如区间内的某些问题。主席树实际上是树套树，最普通的主席树问题就是前缀和套线段树。 主席树的实现例题caioj 1441 给$n$（$1 \leq n \leq 100000$）个数字,$a[1],a[2],……,a[n]（0 \leq a[i]&lt;=1000000000）,m（1 \leq m \leq 100000）$次询问$l$到$r$之间的第$k$小的值。 由题不需要修改操作，就是最普通的主席树问题。 从全局入手对于整个区间的$k$小，我们可以开权值线段树记录每个值的大小，然后查询时仿造平衡树的方法可以找到第$k$大值。 线段树可加可减性那么对于区间$[x,y]$，我们怎么办？想到每个点$i$开$[1,i]$的线段树(整个线段树维护区间不变，只是每个数值的范围，不然不能满足加减性), 则$[x,y]=[1,y]-[1,x-1]$ 这样可以看出我们要研究线段树是否可加可减，看下面的例子(借用了 caioj 的图片) 两棵线段树显然可加，并且对应位置上的和相加(维护区间和)。 主席树实现首先要对每个点开$[1,i]$的线段树，先开一条只包含$i$点信息的链，再与前面一棵线段树合并(相加)。合并线段树也很方便，只要加上$i$点的信息，合并$[1,i-1]$( $merge$ 操作，代码中的$mge$) 查询的时候类似平衡树的查询，例如求$k$小，因为权值线段树，所以左边点都小于这个点，右边点都大于这个点，判断一下第$k$小在左边还是右边，就可以找到了。 代码注意要离散化。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 100000 + 5; int n, m, whw, tax[MAXN], ai[MAXN], rt[MAXN]; #define M ((l + r) &gt;&gt; 1) int sumv[MAXN * 20], lc[MAXN * 20], rc[MAXN * 20], sz; int getPos(int x) {return lower_bound(tax + 1, tax + 1 + whw, x) - tax;} int mge(int &amp;x, int y) {//合并 if (y == 0) return 0; if (x == 0) return x = y, 0;//x及其子树与y一致，直接使用 sumv[x] += sumv[y];//合并信息 mge(lc[x], lc[y]), mge(rc[x], rc[y]); return 0; } void build(int l, int r, int &amp;x, int pos) {//建一条链 if (x == 0) x = ++sz, sumv[x] = 0, lc[x] = rc[x] = 0;//动态开点 sumv[x]++; if (l == r) return ; if (pos &lt;= M) build(l, M, lc[x], pos); else build(M + 1, r, rc[x], pos); } int query(int l, int r, int x, int y, int kth) {//查询 if (l == r) return l; int dlt = sumv[lc[y]] - sumv[lc[x]]; if (kth &lt;= dlt) return query(l, M, lc[x], lc[y], kth); else return query(M + 1, r, rc[x], rc[y], kth - dlt);//类似平衡树查询 } void clean() { sz = 0; for (int i = 1; i &lt;= 2000001; i++) sumv[i] = lc[i] = rc[i] = 0; for (int i = 1; i &lt;= 100001; i++) tax[i] = ai[i] = rt[i] = 0; } int solve() { clean(); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;ai[i]), tax[i] = ai[i]; sort(tax + 1, tax + 1 + n), whw = unique(tax + 1, tax + 1 + n) - tax - 1;//离散化 for (int i = 1; i &lt;= n; i++) build(1, whw, rt[i], getPos(ai[i])), mge(rt[i], rt[i - 1]);//建链、合并 for (int x, y, k, i = 1; i &lt;= m; i++) { scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;k); printf(&quot;%d\n&quot;, tax[query(1, whw, rt[x - 1], rt[y], k)]); } return 0; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m), solve(); return 0; } 树上主席树caioj 1443 给定一棵$N（1 \leq N \leq 100000）$个节点的树，每个点有一个权值，对于$M（1 \leq M \leq 100000）$个询问$(x,y,k)$，你需要回答$x$和$y$这两个节点间第$k$小的点权。 我们对于每个点建主席树维护$(u,rt)​$路径链，$rt​$为根，合并时与他的父亲节点合并，计算$(u,v)​$信息线段树时使用$(u,v)=(u, rt)+(v,rt)-(lca,rt)-(fa[lca], rt)$, $lca=LCA(u,v), fa[lca]$为$lca$的父亲节点$rt$为根，画图理解然后按照普通的主席树做就行了 代码#include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 100000 + 5, logs = 18; int n, q, whw, ai[MAXN], tax[MAXN], rt[MAXN], sz, dep[MAXN], pre[MAXN][25]; vector&lt;int&gt; G[MAXN]; int getPos(int x) {return lower_bound(tax + 1, tax + 1 + whw, x) - tax;} void ins(int a, int b) {G[a].push_back(b), G[b].push_back(a);} #define M ((l + r) &gt;&gt; 1) int sumv[MAXN * 20], lc[MAXN * 20], rc[MAXN * 20]; int mge(int &amp;x, int y) { if (y == 0) return 0; if (x == 0) return x = y, 0; sumv[x] += sumv[y]; mge(lc[x], lc[y]), mge(rc[x], rc[y]); return 0; } void build(int l, int r, int &amp;x, int pos) { if (x == 0) x = ++sz, sumv[x] = lc[x] = rc[x] = 0; sumv[x]++; if (l == r) return ; if (pos &lt;= M) build(l, M, lc[x], pos); else build(M + 1, r, rc[x], pos); } int query(int l, int r, int x, int y, int lca, int flca, int kth) { if (l == r) return tax[l]; int sum = sumv[lc[x]] + sumv[lc[y]] - sumv[lc[lca]] - sumv[lc[flca]]; if (sum &gt;= kth) return query(l, M, lc[x], lc[y], lc[lca], lc[flca], kth); else return query(M + 1, r, rc[x], rc[y], rc[lca], rc[flca], kth - sum); } void dfs(int u, int pa) { dep[u] = dep[pa] + 1, pre[u][0] = pa, mge(rt[u], rt[pa]); for (int i = 1; i &lt;= logs; i++) pre[u][i] = pre[pre[u][i - 1]][i - 1]; for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i]; if (v != pa) dfs(v, u); } } int LCA(int a, int b) { if (dep[a] &lt; dep[b]) swap(a, b); for (int i = logs; i &gt;= 0; i--) if (dep[pre[a][i]] &gt;= dep[b]) a = pre[a][i]; if (a == b) return a; for (int i = logs; i &gt;= 0; i--) if (pre[a][i] != pre[b][i]) a = pre[a][i], b = pre[b][i]; return pre[a][0]; } void clean() { sz = 0; for (int i = 0; i &lt;= 100001; i++) { G[i].clear(), dep[i] = tax[i] = ai[i] = rt[i] = 0; for (int j = 0; j &lt;= 19; j++) pre[i][j] = 0; } for (int i = 0; i &lt;= 2000001; i++) sumv[i] = lc[i] = rc[i] = 0; } int solve() { clean(); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;ai[i]), tax[i] = ai[i]; sort(tax + 1, tax + 1 + n), whw = unique(tax + 1, tax + 1 + n) - tax - 1; for (int x, y, i = 1; i &lt; n; i++) scanf(&quot;%d%d&quot;, &amp;x, &amp;y), ins(x, y); for (int i = 1; i &lt;= n; i++) build(1, whw, rt[i], getPos(ai[i])); dfs(1, 0); while (q--) { int x, y, k, lca; scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;k); lca = LCA(x, y); printf(&quot;%d\n&quot;, query(1, whw, rt[x], rt[y], rt[lca], rt[pre[lca][0]], k)); } return 0; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;q), solve(); return 0; } /* 13 100 3 4 1 2 3 2 4 5 3 2 1 1 3 1 2 2 3 3 4 4 5 5 6 5 7 2 8 8 9 9 10 10 11 10 12 11 13 7 13 8 */ 带修主席树caioj 1442 给$n(1 \leq n \leq 50000)$个数字，进行$m(1 \leq m \leq 10000)$次操作，有两种操作：$Q,l,r,k$：询问$l$到$r$第$k$小的数。$C,x,k$：改变第$x$个数的值为$k$。 因为普通的主席树是前缀和套线段树，所以不能修改。那么我们想到修改，就发现可以用树状数组/线段树套线段树，由于此题单点修改，所以用树状数组。对于前缀和套线段树先建主席树，然后再建树状数组套线段树的，修改在树状数组上操作，原数组在前缀和中，综合可以得到修改后的信息，要注意树状数组上的点在线段树上跳动(jump函数调节，存在$ust$数组)，查询就用$ust$数组即可 实际上可以不必要建$2n$棵线段树，原数组直接加到树状数组中即可，不过会慢一点，参见此处 代码建$2n$棵线段树的代码： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 50000 + 5, MV = 1000000000; int n, q, sz, rt[MAXN * 2], ai[MAXN]; #define M ((l + r) &gt;&gt; 1) int sumv[MAXN * 100], lc[MAXN * 100], rc[MAXN * 100], ust[MAXN * 100]; int lowbit(int x) {return x &amp; (-x);} int mge(int &amp;x, int y) {//线段树 合并 -&gt;将线段树y合并至线段树x if (x == 0) return x = y, 0; if (y == 0) return 0; sumv[x] += sumv[y]; mge(lc[x], lc[y]), mge(rc[x], rc[y]); return 0; } void build(int l, int r, int &amp;x, int pos, int v) {//线段树 建链 -&gt; 维护[l,r]区间，当前线段树上点x，修改位置为pos=v if (x == 0) x = ++sz, lc[x] = rc[x] = sumv[x] = 0; sumv[x] += v; if (l == r) return ; if (pos &lt;= M) build(l, M, lc[x], pos, v); else build(M + 1, r, rc[x], pos, v); } void add(int u, int x, int c) {//Bit 加 -&gt; bit上u点，x位置加c for (int i = u; i &lt;= 2 * n; i += lowbit(i)) build(1, MV, rt[i], x, c); } void jump(int u, int tp) {//Bit 更新 -&gt; bit上u跳 for (int i = u; i &gt; n; i -= lowbit(i)) { if (tp == -1) ust[i] = rt[i]; if (tp == 0) ust[i] = lc[ust[i]]; if (tp == 1) ust[i] = rc[ust[i]]; } } int getBitSum(int u) {//Bit 查询 -&gt; bit上u查询 int ret = 0; for (int i = u; i &gt; n; i -= lowbit(i)) { ret += sumv[lc[ust[i]]]; } return ret; } int query(int l, int r, int x, int y, int x_2, int y_2, int kth) {//线段树 查询 -&gt; 维护[l,r]区间，当前线段树上点x，y, 位置x_2, y_2, 查询第kth大 if (l == r) return l; int sum = sumv[lc[y]] - sumv[lc[x]] + getBitSum(y_2 + n) - getBitSum(x_2 + n); if (sum &gt;= kth) { jump(x_2 + n, 0), jump(y_2 + n, 0); return query(l, M, lc[x], lc[y], x_2, y_2, kth); } else { jump(x_2 + n, 1), jump(y_2 + n, 1); return query(M + 1, r, rc[x], rc[y], x_2, y_2, kth - sum); } } void clean() { sz = 0; for (int i = 0; i &lt;= 100000 + 5; i++) rt[i] = 0; for (int i = 0; i &lt;= 5000000 + 5; i++) sumv[i] = lc[i] = rc[i] = ust[i] = 0; } int solve() { clean(); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;ai[i]); for (int i = 1; i &lt;= n; i++) build(1, MV, rt[i], ai[i], 1), mge(rt[i], rt[i - 1]); char s[5]; while (q--) { scanf(&quot;%s&quot;, s); if (s[0] == &#39;C&#39;) { int x, k; scanf(&quot;%d%d&quot;, &amp;x, &amp;k); add(x + n, ai[x], -1), ai[x] = k, add(x + n, ai[x], 1); } else { int l, r, k; scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;k); jump(r + n, -1), jump(l - 1 + n, -1); printf(&quot;%d\n&quot;, query(1, MV, rt[l - 1], rt[r], l - 1, r, k)); } } return 0; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;q), solve(); return 0; } 主席树维护区间问题spoj DQUERY 给出一个$n$个数的序列，求区间$[l,r]$里有多少种不同数字。 与树状数组类似，主席树维护区间，相当于可持久化维护每次加点后的情况。每个点按顺序建树，如果这个点的数之前没有出现过，直接在本棵主席树该位置加$1$。否则就把之前出现这个值的位置减$1$，再重复做没有出现的情况。为的是把数尽可能放到右边，因为记录值中位置不影响答案。这样就方便求解$[l,r]$的信息。询问直接用右端点的主席树，由于上述操作后答案可减，所以直接把右端点的主席树左端点以右的值求和即可 代码#include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 30000 + 5; int n, q, sz, ai[MAXN], rt[MAXN], lst[1000000 + 5]; #define M ((l + r) &gt;&gt; 1) int sumv[MAXN * 20], lc[MAXN * 20], rc[MAXN * 20]; int mge(int &amp;x, int y) {//主席树x合并主席树y if (y == 0) return 0; if (x == 0) return x = y, 0; sumv[x] += sumv[y]; mge(lc[x], lc[y]), mge(rc[x], rc[y]); return 0; } void build(int l, int r, int &amp;x, int pos, int v) {//建链维护[l,r], 主席树上x点，修改位置和值 if (x == 0) x = ++sz, lc[x] = rc[x] = sumv[x] = 0; sumv[x] += v; if (l == r) return ; if (pos &lt;= M) build(l, M, lc[x], pos, v); else build(M + 1, r, rc[x], pos, v); } int query(int l, int r, int x, int u) {//查询[l,r]答案，主席树上x点，左边临界点u if (l == r) return 0; if (u &lt;= M) return sumv[rc[x]] + query(l, M, lc[x], u); //加上右边，查询左边 else return query(M + 1, r, rc[x], u); //不要加左，左边有临界点 } void clean() { sz = 0, ms(lst, -1); } int solve() { clean(); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;ai[i]); for (int i = 1; i &lt;= n; i++) {//维护 [0, n] 区间，因为l - 1可能为 0 if (lst[ai[i]] &lt; 0) build(0, n, rt[i], i, 1), mge(rt[i], rt[i - 1]);//之前没有 else { build(0, n, rt[i], lst[ai[i]], -1), build(0, n, rt[i], i, 1); mge(rt[i], rt[i - 1]); }//之前有 lst[ai[i]] = i; } scanf(&quot;%d&quot;, &amp;q); while (q--) { int l, r; scanf(&quot;%d%d&quot;,&amp;l, &amp;r); printf(&quot;%d\n&quot;, query(0, n, rt[r], l - 1)); } return 0; } int main() { scanf(&quot;%d&quot;, &amp;n), solve(); return 0; } 可持久化caioj 1447 维护区间和，有区间增加，要求可持久化 (回退、查询某个版本) 每个询问开一棵线段树，回退直接删掉中间的线段树即可。由于是主席树不能pushdown，pushup，所以增加的时候直接更新sumv的值，查询时lazy值直接累加乘以查询区间长度即可，具体操作可以看代码 代码#include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const LL MAXN = 100000 + 5; LL n, m, ai[MAXN], qzh[MAXN], rt[MAXN], now, sz; #define M ((l + r) &gt;&gt; 1) LL sumv[MAXN * 40], lc[MAXN * 40], rc[MAXN * 40], lazy[MAXN * 40]; int mge(LL &amp;x, LL y) { if (y == 0) return 0; if (x == 0) return x = y, 0; sumv[x] += sumv[y], lazy[x] += lazy[y]; mge(lc[x], lc[y]), mge(rc[x], rc[y]); return 0; } void build(LL l, LL r, LL &amp;x, LL cl, LL cr, LL v) { if (x == 0) x = ++sz; sumv[x] += (cr - cl + 1) * v;//直接加，免去pushup if (l == cl &amp;&amp; r == cr) { lazy[x] += v; return ; } if (cr &lt;= M) build(l, M, lc[x], cl, cr, v); else if (cl &gt; M) build(M + 1, r, rc[x], cl, cr, v); else build(l, M, lc[x], cl, M, v), build(M + 1, r, rc[x], M + 1, cr, v); //整个区间在左边、右边、分开两边 } LL query(LL l, LL r, LL x, LL cl, LL cr, LL tmp) { if (l == cl &amp;&amp; r == cr) return (r - l + 1) * tmp + sumv[x]; if (cr &lt;= M) return query(l, M, lc[x], cl, cr, tmp + lazy[x]); else if (cl &gt; M) return query(M + 1, r, rc[x], cl, cr, tmp + lazy[x]); else return query(l, M, lc[x], cl, M, tmp + lazy[x]) + query(M + 1, r, rc[x], M + 1, cr, tmp + lazy[x]); //整个查询区间在左边、右边、分开两边，和普通线段树不同，相当于用 M 分离查询区间 //直接累加lazy最后乘查询区间长度 } void clean() { now = sz = 0; for (LL i = 0; i &lt;= 100000 + 3; i++) rt[i] = qzh[i] = 0; for (LL i = 0; i &lt;= 4000000 + 3; i++) sumv[i] = lc[i] = rc[i] = lazy[i] = 0; } int solve() { clean(); for (LL i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;ai[i]), qzh[i] = qzh[i - 1] + ai[i]; for (LL i = 1; i &lt;= m; i++) { LL tp; scanf(&quot;%lld&quot;, &amp;tp); if (tp == 1) { LL l, r, k; scanf(&quot;%lld%lld%lld&quot;, &amp;l, &amp;r, &amp;k); build(1, n, rt[++now], l, r, k), mge(rt[now], rt[now - 1]); } if (tp == 2) { LL l, r; scanf(&quot;%lld%lld&quot;, &amp;l, &amp;r); printf(&quot;%lld\n&quot;, qzh[r] - qzh[l - 1] + query(1, n, rt[now], l, r, 0)); } if (tp == 3) { LL l, r, h; scanf(&quot;%lld%lld%lld&quot;, &amp;l, &amp;r, &amp;h); printf(&quot;%lld\n&quot;, qzh[r] - qzh[l - 1] + query(1, n, rt[h], l, r, 0)); } if (tp == 4) { LL h; scanf(&quot;%lld&quot;, &amp;h); for (LL i = h + 1; i &lt;= now; i++) rt[i] = 0; now = h; } } return 0; } int main() { scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m), solve(); return 0; } 注意事项1、主席树节点数和操作次数有关，与值域无关2、主席树边更新边合并和更新完合并两种写法不要写混 常见题型1、逆序对问题 1、静态区间逆序对 (离线莫队)：Bzoj 32892、动态逆序对 (每次删除一个数，求序列逆序对个数)：Bzoj 32953、区间逆序对 (强制在线求区间 $ [l,r] $ 的逆序对)：Bzoj 3744 2、众数问题1、强制在线区间众数：Bzoj 27242、摩尔投票法 (序列大于一半数的众数)：Luogu 3765 3、区间k大 / 区间小于某数的个数1、区间$k$大：Bzoj 39322、区间小于某数的个数：Bzoj 1926, Bzoj 3295]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>主席树</tag>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj 2417(BSGS)]]></title>
    <url>%2Fpoj2417%2F</url>
    <content type="text"><![CDATA[poj 2417 BSGS模板题，见此处 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;map&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; LL p, x, z; map&lt;LL, LL&gt; a; LL ksm(LL a, LL b, LL m) { LL base = a, ret = 1; while (b) { if (b &amp; 1) ret = (ret * base) % m; b &gt;&gt;= 1, base = (base * base) % m; } return ret; } void clean() { a.clear(); } int solve() { clean(); LL m = (LL)ceil(sqrt(p - 1)), whw = x;//必须ceil取大，否则会小 a[1] = m + 1; for (LL i = 1; i &lt; m; i++) {//求左边的x^b if (!a.count(whw)) a[whw] = i; whw = (whw * x) % p; } LL ni = ksm(x, m, p); ni = ksm(ni, p - 2, p);//x^{-m} for (LL i = 0; i &lt; m; i++) {//枚举a LL j = a[z]; if (j) { if (j == m + 1) return printf(&quot;%lld\n&quot;, i * m), 0; else return printf(&quot;%lld\n&quot;, i * m + j), 0; } z = (z * ni) % p; } printf(&quot;no solution\n&quot;); return 0; } int main() { while (scanf(&quot;%lld%lld%lld&quot;, &amp;p, &amp;x, &amp;z) == 3) x %= p, z %= p, solve(); return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>poj</tag>
        <tag>BSGS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DP题训练]]></title>
    <url>%2F%E5%8A%A8%E5%BD%92%E9%A2%98%E4%B8%93%E7%BB%83%2F</url>
    <content type="text"><![CDATA[第1题 Luogu P2734 游戏 A GameLuogu P2734 游戏 A Game题意：有一个序列，有两个玩家，每个玩家用最优策略在两端拿数，求先手拿到数字和的最大值。解：由于两个玩家都采取最优策略，我们设$dp(i,j)$为区间$[i,j]$先手能得到的最优解。然后方程为$dp(i,j)=max(sum(i,j) - dp(i + 1, j), sum(i,j)-dp(i,j-1))$。$sum$是这一段的和。原理是区间DP的原理，整个区间$[i,j]$的先手，在$(i,j],[i,j)$是后手，$dp(i + 1, j), dp(i,j-1)$是$(i,j],[i,j)$的先手最优值 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; int n, a[105], dp[105][105], sum[105][105]; void clean() { ms(dp, 0); } int solve() { clean(); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]), dp[i][i] = a[i]; for (int i = 1; i &lt;= n; i++) { sum[i][i] = a[i]; for (int j = i + 1; j &lt;= n; j++) sum[i][j] = sum[i][j - 1] + a[j]; } for (int i = n; i; i--) { for (int j = i + 1; j &lt;= n; j++) { dp[i][j] = max(sum[i][j] - dp[i + 1][j], sum[i][j] - dp[i][j - 1]); } } printf(&quot;%d %d\n&quot;, dp[1][n], sum[1][n] - dp[1][n]); return 0; } int main() { scanf(&quot;%d&quot;, &amp;n), solve(); return 0; } 第2题 Luogu P3800 Power收集Luogu P3800 Power收集题意：$N$行$M$列的格子，某些点有一些权值，每秒钟可以左右移动至多$T$个单位长度(瞬间完成)，每秒必须向下走一行(不能折返)，求一条路径使得权值和最大解：朴素的DP是$O(n^3)$的，无法通过测试，我们将有权值的点按横坐标排序，然后设$dp(i)$为第$i$个权值点的最优解，那么就有 $dp(i)=dp(j)+v(i)$当且仅当$j$能移动到$i$位置，$v(i)$为$i$权值点的权值然后初始化第一层的值就行 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; struct data { int x, y, v, dp; bool operator &lt; (const data &amp;b) const { return x &lt; b.x; } }v[4000 + 5]; int n, m, k, t; int abss(int x) {return x &gt; 0 ? x : -x;} void clean() {} int solve() { clean(); for (int i = 1; i &lt;= k; i++) scanf(&quot;%d%d%d&quot;, &amp;v[i].x, &amp;v[i].y, &amp;v[i].v), v[i].dp = 0; sort(v + 1, v + 1 + k); for (int i = 1; ; i++) if (v[i].x != v[i - 1].x &amp;&amp; i != 1) break; else v[i].dp = v[i].v; for (int i = 1; i &lt;= k; i++) for (int j = 0; j &lt; i; j++) if (abss(v[i].y - v[j].y) &lt;= t * (v[i].x - v[j].x)) v[i].dp = max(v[i].dp, v[j].dp + v[i].v); int ans = 0; for (int i = 1; i &lt;= k; i++) ans = max(ans, v[i].dp); printf(&quot;%d\n&quot;, ans); return 0; } int main() { scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;k, &amp;t), solve(); return 0; } 第3题 Luogu P2889 挤奶的时间Milking TimeLuogu P2889 挤奶的时间Milking Time题意：有$m$个区间，区间有一个权值，现在要选择一些区间使得权值和最大，选取的每两个区间之间不能覆盖且距离为$r$解：区间按右端点排序，消除后效性，设$dp(i)$为$i$前$i$个区间的最优值，转移方程$$dp(i)=max(dp(j)+e(i)|x_i-r \geq y_j)$$ #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;map&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; struct data { int x, y, v; bool operator &lt; (const data &amp;b) const { return y &lt; b.y; } }inv[1005]; int n, m, r, dp[1005]; void clean() { ms(dp, 0); } int solve() { clean(); for (int i = 1; i &lt;= m; i++) scanf(&quot;%d%d%d&quot;, &amp;inv[i].x, &amp;inv[i].y, &amp;inv[i].v); sort(inv + 1, inv + 1 + m); for (int i = 1; i &lt;= m; i++) dp[i] = inv[i].v; for (int i = 1; i &lt;= m; i++) for (int j = 1; j &lt; i; j++) if (inv[i].x - r &gt;= inv[j].y) dp[i] = max(dp[i], dp[j] + inv[i].v); else dp[i] = max(dp[i], dp[j]); printf(&quot;%d\n&quot;, dp[m]); return 0; } int main() { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;r), solve(); return 0; } 第4题 Luogu P2233 [HNOI2002]公交车路线Luogu P2233 [HNOI2002]公交车路线 题意：有一个ABCDEFGH组成的环，求A到E路程为$n$的方案数，要求到达E之前不能到达E解：遇到环就拆成链，在E点切开，那么成了一条链FGHABCD，到达E点路径总数等于F点和D点的路径总数，把链节点抽象为数字点，设$dp(i,j)$为$j$路程后到$i$点的方案数，则$dp(i,j)=dp(i+1, j-1), dp(i - 1,j-1)$，初始化$dp(4, 0)$为1(从1开始标号)。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;map&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MO = 1000; int n, dp[8][2]; void clean() {} int solve() { clean(); dp[4][0] = 1; int pos = 0; for (int i = 1; i &lt; n; i++) { pos ^= 1; for (int j = 1; j &lt;= 7; j++) dp[j][pos] = (dp[j - 1][pos ^ 1] + dp[j + 1][pos ^ 1]) % MO; } printf(&quot;%d\n&quot;, (dp[1][pos] + dp[7][pos]) % MO); return 0; } int main() { scanf(&quot;%d&quot;, &amp;n), solve(); return 0; } 第5题 Luogu P1373 小a和uim之大逃离Luogu P1373 小a和uim之大逃离题意：见上。解：设$dp(x,y,i,0/1)$为在$(x,y)$小a比uim多$i$毒液的方案数，转移看代码。知识点：差值状态 DP ，读题要勾画重点 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;bitset&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double const int MAXN = 800 + 5, MO = 1000000007; int n, m, k, a[MAXN][MAXN], dp[MAXN][MAXN][17][2]; void clean() { ms(dp, 0); } int solve() { clean(); k++; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) scanf(&quot;%d&quot;, &amp;a[i][j]), dp[i][j][a[i][j] % k][0] = 1; int ans = 0; for (int x = 1; x &lt;= n; x++) { for (int y = 1; y &lt;= m; y++) { for (int i = 0; i &lt; k; i++) { dp[x][y][i][0] = (dp[x][y][i][0] + dp[x - 1][y][((i - a[x][y]) % k + k) % k][1]) % MO; dp[x][y][i][0] = (dp[x][y][i][0] + dp[x][y - 1][((i - a[x][y]) % k + k) % k][1]) % MO; dp[x][y][i][1] = (dp[x][y][i][1] + dp[x - 1][y][((i + a[x][y]) % k + k) % k][0]) % MO; dp[x][y][i][1] = (dp[x][y][i][1] + dp[x][y - 1][((i + a[x][y]) % k + k) % k][0]) % MO; if (i == 0) ans = (ans + dp[x][y][0][1]) % MO; //printf(&quot;x=%d y=%d i=%d k=0 dp=%d&quot;, x, y, i, dp[x][y][i][0]); if (i == 0) printf(&quot;&amp;&amp;&amp;\n&quot;); else printf(&quot;\n&quot;); //printf(&quot;x=%d y=%d i=%d k=1 dp=%d&quot;, x, y, i, dp[x][y][i][1]); if (i == 0) printf(&quot;&amp;&amp;&amp;\n&quot;); else printf(&quot;\n&quot;); } } } printf(&quot;%d\n&quot;, ans); return 0; } int main() { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k), solve(); return 0; } 第6题 Luogu P1435 回文字串Luogu P1435 回文字串题意：有一个串需要添加最少的字符使得它变为回文串。解：1、区间DP。设$dp(i,j)$为区间$[i,j]$变回文的最小值。转移$dp(i,j)=min(dp(i+1,j-1)|s_i=s_j, dp(i+1,j)+1,dp(i,j - 1)+1)$，直接记忆化搜索即可。(不要忘了直接返回记忆化搜索已经算完的值)2、因为回文串正读倒读一样，所以正反做公共子序列可以找出回文串部分，然后其余部分就是需要增加来对称的。代码用方法1。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double const int MAXN = 1000 + 5, INF = 1000000000; int n, dp[MAXN][MAXN]; char s[MAXN]; int DP(int i, int j) { if (dp[i][j] != INF) return dp[i][j];//别忘了这一步 if (i == j) return dp[i][j] = 0; if (i &gt; j) return 0; int ret = INF; if (s[i] == s[j]) ret = std::min(ret, DP(i + 1, j - 1)); ret = std::min(ret, std::min(DP(i + 1, j) + 1, DP(i, j - 1) + 1)); return dp[i][j] = ret; } void clean() { for (int i = 0; i &lt;= 1001; i++) for (int j = 0; j &lt;= 1001; j++) dp[i][j] = INF; } int solve() { clean(); n = strlen(s + 1); DP(1, n); printf(&quot;%d\n&quot;, dp[1][n]); return 0; } int main() { scanf(&quot;%s&quot;, s + 1), solve(); return 0; } 第7题 Luogu P1220 关路灯P1220 关路灯题意：有$n$盏路灯，老张在$m$处，求老上关完所有电灯的最小所需的功率数。解：这题看似不满足后效性，但是可以当做区间DP来做。知识点：如果前…的状态不好用就用区间状态。代码： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double const int INF = 1000000000; int n, c, dp[55][55][2], xi[55], pi[55]; int abss(int x) {return x &gt; 0 ? x : -x;} int cal(int i, int j, int x, int y) { return abss(xi[i] - xi[j]) * (pi[x] + pi[n] - pi[y - 1]); } int DP(int i, int j, int k) { if (dp[i][j][k] != INF) return dp[i][j][k]; if (i == j &amp;&amp; i == c) return 0; if (i &gt;= j) return INF; if (k == 0) dp[i][j][k] = std::min(DP(i + 1, j, 0) + cal(i, i + 1, i, j + 1), DP(i + 1, j, 1) + cal(i, j, i, j + 1)); else dp[i][j][k] = std::min(DP(i, j - 1, 0) + cal(i, j, i - 1, j), DP(i, j - 1, 1) + cal(j - 1, j, i - 1, j)); return dp[i][j][k]; } void clean() { for (int i = 0; i &lt;= 51; i++) for (int j = 0; j &lt;= 51; j++) dp[i][j][0] = dp[i][j][1] = INF; } int solve() { clean(); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d%d&quot;, &amp;xi[i], &amp;pi[i]), pi[i] += pi[i - 1]; DP(1, n, 0), DP(1, n, 1); /*for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) for (int k = 0; k &lt; 2; k++) printf(&quot;i=%d, j=%d, k=%d, dp=%d\n&quot;, i, j, k, dp[i][j][k]);*/ printf(&quot;%d\n&quot;, std::min(dp[1][n][0], dp[1][n][1])); return 0; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;c), solve(); return 0; } 第8题 NOIP 2003 加分二叉树NOIP 2003 加分二叉树题意：见上。解：中序遍历可以将树分开，如果其中一个点是根，那么区间左边就是他的左子树，右边就是他的右子树。所以这题就是一个 区间DP。DP时记录最终是哪个中间值使他最优，递归地分解区间输出前序遍历即可。知识点：中序遍历可以将树分开，如果其中一个点是根，那么区间左边就是他的左子树，右边就是他的右子树。代码： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;bitset&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double LL n, dp[35][35], a[35], pre[35][35]; LL DP(LL i, LL j) { if (dp[i][j] &gt;= 0ll) return dp[i][j]; if (i &gt; j) return 1ll; if (i == j) return pre[i][j] = i, dp[i][j] = a[i]; for (LL k = i; k &lt;= j; k++) if (dp[i][j] &lt; DP(i, k - 1ll) * DP(k + 1ll, j) + a[k]) dp[i][j] = DP(i, k - 1ll) * DP(k + 1ll, j) + a[k], pre[i][j] = k; return dp[i][j]; } void print(LL x, LL y) { if (pre[x][y]) printf(&quot;%lld &quot;, pre[x][y]); if (x &gt;= y) return ; print(x, pre[x][y] - 1); print(pre[x][y] + 1, y); } void clean() { ms(dp, -1); } int solve() { clean(); for (LL i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;a[i]); DP(1ll, n); printf(&quot;%lld\n&quot;, dp[1][n]); print(1, n); return 0; } int main() { scanf(&quot;%lld&quot;, &amp;n), solve(); return 0; } 第9题 Luogu P1736 创意吃鱼法&amp;P1387 最大正方形Luogu P1736 创意吃鱼法P1387 最大正方形题意：见上。解(最大正方形)：这题求一个最大的1正方形(对角线或全部)，设$dp(i,j)$为以$(i,j)$为右下顶点的最大1正方形边长，转移$dp(i,j)=min(dp(i-1,j-1), dp(i-1,j), dp(i,j-1))+1$, 并且$a(i,j)=1$。创意吃鱼法这题与上面一题非常相似，只有预处理即可替换DP方程就能做出来了。 第10题 Bzoj 1057Bzoj 1057 第11题 Hdu 1024Hdu 1024题意：$m$子段和的最大值。解：设$dp(j,i)$为分了$j$段，前$i$个数的最大值。(状态方便滚动数组)那么转移$dp(j,i)=max(dp(j-1,k)|0 \leq k \leq i - 1)$初始化$dp(0,0)=0, othewise=-INF$求最大值时可以由上一层用数组存上一层的最大值，然后在这一层直接用。知识点：用数组存上一层的最大值/最小值很好用，求 LCIS 也利用了类似的方法。 #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;limits.h&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define ULL unsigned long long #define db double const int MAXN = 1000000 + 5, INF = 2000000000; int n, m, a[MAXN], dp[MAXN], whw[MAXN]; void clean() { } int solve() { clean(); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]), dp[i] = -INF; dp[0] = 0; for (int i = 0; i &lt;= n; i++) { whw[i] = std::max(dp[i], -INF); if (i - 1 &gt;= 0) whw[i] = std::max(whw[i], whw[i - 1]); } int ans = -INF; for (int j = 1; j &lt;= m; j++) { // printf(&quot;j=%d\n&quot;, j); for (int i = 1; i &lt;= n; i++) { dp[i] = std::max(whw[i - 1] + a[i], dp[i - 1] + a[i]); //printf(&quot;i=%d, dp[i]=%d, whw[i - 1]=%d, dp[i - 1]=%d\n&quot;, i, dp[i], whw[i - 1], dp[i - 1]); if (j == m) ans = std::max(ans, dp[i]); } dp[0] = -INF; for (int i = 0; i &lt;= n; i++) { whw[i] = std::max(dp[i], -INF); if (i - 1 &gt;= 0) whw[i] = std::max(whw[i], whw[i - 1]); } } printf(&quot;%d\n&quot;, ans); return 0; } int main() { while (scanf(&quot;%d%d&quot;, &amp;m, &amp;n) == 2) solve(); return 0; } 第12题 Hdu 1069Hdu 1069题意：给出一些长方体，然后让你把他堆成塔，要求下面的塔的要比上面的塔大（长和宽），而且每一种长方体的数量都是无限的。解：发现本题就是一个二维上升序列。我们对于每个长方形设 DP 状态。设$dp(i)$为以$i$长方形为顶的最高值。但是长方体的数量都是无限怎么办？我们发现长方形其实是有限的，最多选取 $ 6 $ 种。其中因为长宽可互换，只用存 $ 3 $ 种即可，在转移时讨论一下即可。转移就： if (blk[i].mj &lt; blk[j].mj &amp;&amp; ((blk[i].x &lt; blk[j].x &amp;&amp; blk[i].y &lt; blk[j].y) || (blk[i].x &lt; blk[j].y &amp;&amp; blk[i].y &lt; blk[j].x))) dp[i] = max(dp[i], dp[j] + blk[i].z); 初始化所有dp[i] = blk[i].z知识点：对于无穷，我们尝试化成有限。(复杂化简单)序列上升问题与 DP 有关。排序后 DP。 #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;limits.h&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define ULL unsigned long long #define db double const int MAXN = 35; struct data { int x, y, z, mj; bool operator &lt; (const data &amp;b) const {return mj &gt; b.mj;} }blk[MAXN * 3]; int kase = 0, n, cnt, dp[MAXN * 3]; inline void ins(int a, int b, int c) {blk[++cnt] = (data){a, b, c, a * b};} void clean() { ms(dp, 0), cnt = 0; } int solve() { clean(); for (int a, b, c, i = 1; i &lt;= n; i++) scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c), ins(b, c, a), ins(a, c, b), ins(a, b, c); std::sort(blk + 1, blk + 1 + 3 * n); for (int i = 1; i &lt;= 3 * n; i++) dp[i] = blk[i].z; for (int i = 2; i &lt;= 3 * n; i++) for (int j = 1; j &lt; i; j++) if (blk[i].mj &lt; blk[j].mj &amp;&amp; ((blk[i].x &lt; blk[j].x &amp;&amp; blk[i].y &lt; blk[j].y) || (blk[i].x &lt; blk[j].y &amp;&amp; blk[i].y &lt; blk[j].x))) dp[i] = std::max(dp[i], dp[j] + blk[i].z); int ans = 0; for (int i = 1; i &lt;= 3 * n; i++) ans = std::max(dp[i], ans); printf(&quot;Case %d: maximum height = %d\n&quot;, kase, ans); return 0; } int main() { while (scanf(&quot;%d&quot;, &amp;n) == 1 &amp;&amp; n) kase++, solve(); return 0; } 第13题 Hdu 1074Hdu 1074题意：主人公有$n$门功课要做，每门功课做完需要一定的时间，而且每门功课有一个最后期限，如果该门功课延后一天交就得扣一分，而且每做一门功课主人公就一定把它做完为止，不会中途停下来再去做其他的。问怎样安排可使扣的分最少，如果有多组解，输出字典序最小的。解：贪心是错的。本题数据范围小，并且是最优化问题，可以考虑状压。状压维护当前已经完成的功课。然后根据状态转移来更新答案。具体可以看代码注释。知识点：状压条件1、数据范围小2、原题是最优化/计数问题3、顺序相对给出序列一般不单调/或者是维护集合代码： #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;limits.h&gt; #include&lt;stack&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define ULL unsigned long long #define db double int n, dl[20], len[20]; char s[20][105]; std::stack&lt;int &gt; stk; int dp[(1 &lt;&lt; 20) + 5], dp_tm[(1 &lt;&lt; 20) + 5], dp_lst[(1 &lt;&lt; 20) + 5], dp_sub[(1 &lt;&lt; 20) + 5]; //dp 是最优的扣分值， dp_tm 是在最优的扣分值下的用掉的时间，dp_lst 表示当前状态由哪个状态转移过来，dp_sub 表示当前状态是做了某门科目后得到的状态 void clean() { } int solve() { clean(); for (int i = 1; i &lt;= n; i++) scanf(&quot;%s%d%d&quot;, s[i] + 1, &amp;dl[i], &amp;len[i]); ms(dp, 67), dp[0] = 0, dp_tm[0] = dp_lst[0] = dp_sub[0] = 0; for (int st = 1; st &lt; (1 &lt;&lt; n); st++) { for (int i = n; i; i--) { if ((1 &lt;&lt; (i - 1)) &amp; st) { int nst = st - (1 &lt;&lt; (i - 1)); int val = std::max(0, dp_tm[nst] + len[i] - dl[i]);//会扣的分 if (dp[nst] + val &lt; dp[st]) { dp[st] = dp[nst] + val; dp_lst[st] = nst, dp_sub[st] = i, dp_tm[st] = dp_tm[nst] + len[i]; } //if (st == 5 &amp;&amp; i == 3) printf(&quot;nst=%d, dp[nst]=%d, val=%d, dp[st]=%d\n&quot;, nst, dp[nst], val, dp[st]); } } } //倒序输出 for (int st = (1 &lt;&lt; n) - 1; st != 0; st = dp_lst[st]) stk.push(dp_sub[st]); printf(&quot;%d\n&quot;, dp[(1 &lt;&lt; n) - 1]); while (!stk.empty()) printf(&quot;%s\n&quot;, s[stk.top()] + 1), stk.pop(); return 0; } int main() { int T; scanf(&quot;%d&quot;, &amp;T); while (T--) scanf(&quot;%d&quot;, &amp;n), solve(); return 0; } 第14题 Luogu P2893 [USACO08FEB]修路Making the GradeLuogu P2893 修路Making the Grade题意：农夫约翰想改造一条路，原来的路的每一段海拔是$A_i$，修理后是$B_i$，花费$|A_i – B_i|$。我们要求修好的路是单调不升或者单调不降的。求最小花费。解：设$dp(i,j)$为前$i$条路符合上升并且第$i$条路海拔为$j$的最优花费然后$dp(i,j)=min(dp(i-1,k)+|j-A_i| | 1 \leq k \leq j)$这样是$O(n^3)$的，然后发现$dp(i-1,k)$与$j$无关所以可以在上一层预处理一下变成$O(n^2)$知识点：1、一道题一时调试不出来可以放一下，然后之后来调估计就马上调出来了2、用数组可以求出上一层的最值优化DP3、花费有时候也可以表示在状态上代码： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;climits&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double const LL MAXN = 2000 + 5; std::vector&lt;LL &gt; vec; LL n, whw, a[MAXN], b[MAXN], dp[MAXN][MAXN], gg[MAXN]; inline LL abss(LL x) {return x &gt; 0 ? x : -x;} void clean() { for (LL i = 0; i &lt;= n; i++) for (LL j = 0; j &lt;= n; j++) dp[i][j] = LONG_LONG_MAX / 2; for (LL i = 0; i &lt;= n; i++) gg[i] = LONG_LONG_MAX / 2; } int solve() { clean(); for (LL i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;a[i]), vec.push_back(a[i]); std::sort(vec.begin(), vec.end()), whw = std::unique(vec.begin(), vec.end()) - vec.begin(); for (LL i = 1; i &lt;= n; i++) b[i] = lower_bound(vec.begin(), vec.end(), a[i]) - vec.begin() + 1; LL ans = LONG_LONG_MAX / 2; dp[0][0] = 0; for (LL j = 1; j &lt;= whw; j++) gg[j] = 0; for (LL i = 1; i &lt;= n; i++) { for (LL j = 1; j &lt;= whw; j++) { dp[i][j] = gg[j] + abss(vec[j - 1] - a[i]); gg[j] = std::min(gg[j - 1], dp[i][j]); if (i == n) ans = std::min(ans, dp[i][j]); } } std::cout &lt;&lt; ans; return 0; } int main() { scanf(&quot;%lld&quot;, &amp;n), solve(); return 0; } 第15题 Luogu P2340 奶牛会展Luogu P2340 奶牛会展题意：见上。我先没想背包，想到一个状态是$dp(PrefixCows, IQ, EQ)=max(IQ+EQ)$，显然GG，而且很奇怪发现这个状态记录$EQ$是无用的，所以可以$dp(PrefixCows, IQ)=max(EQ)$，然后转移发现就是在做背包，滚动数组优化空间，时间很紧张所以看命过不过吧。 第16题 Loj 10153 二叉苹果树Loj 10153 二叉苹果树题意：见上。解：设$dp(u,i)$为$u$点子树中选了$i$条边的最大值，做个简单背包即可。代码： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;stack&gt; #include&lt;set&gt; #include&lt;queue&gt; #include&lt;climits&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; namespace flyinthesky { const int MAXN = 100 + 5; struct edge {int u, v, w, nxt;} ed[MAXN * 2]; int n, q, en, hd[MAXN], dp[MAXN][MAXN]; void ins(int x, int y, int w) {ed[++en] = (edge){x, y, w, hd[x]}, hd[x] = en;} int dfs(int u, int i, int fa) { if (dp[u][i] &gt;= 0) return dp[u][i]; int lc = -1, rc = -1; int lv = 0, rv = 0; for (int o = hd[u]; o &gt; 0; o = ed[o].nxt) if (ed[o].v != fa) { if (lc == -1) lc = ed[o].v, lv = ed[o].w; else if (rc == -1) rc = ed[o].v, rv = ed[o].w; } dp[u][i] = 0; if (lc == -1 &amp;&amp; rc == -1) return dp[u][i]; if (i - 1 &gt;= 0) dp[u][i] = max(dp[u][i], dfs(lc, i - 1, u) + lv); if (i - 1 &gt;= 0) dp[u][i] = max(dp[u][i], dfs(rc, i - 1, u) + rv); for (int j = 0; j &lt;= i - 2; ++j) dp[u][i] = max(dp[u][i], dfs(lc, j, u) + dfs(rc, i - 2 - j, u) + lv + rv); return dp[u][i]; } void clean() { en = 0, ms(hd, -1), ms(dp, -1); } int solve() { scanf(&quot;%d%d&quot;, &amp;n, &amp;q); clean(); for (int x, y, w, i = 1; i &lt; n; ++i) scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;w), ins(x, y, w), ins(y, x, w); dfs(1, q, 0); printf(&quot;%d\n&quot;, dp[1][q]); return 0; } } int main() { flyinthesky::solve(); return 0; } 第17题 51nod 1007 正整数分组51nod 1007 正整数分组题意：见上。刚开始想贪心来着。好像行不通。最优化问题，DP。两种DP：1、由于一组数肯定要逼近$\frac 12 sum$，所以用$\frac 12 sum$当容量跑背包即可2、设$dp(i, x)$为前$i$个数差值为$x$是否存在。转移显然。 第18题 Hdu 5256 序列变换Hdu 5256 序列变换题意：求将一个序列改成严格单调的最小次数。解：答案为序列$a_i-i$的不严格单调的最小次数，有一个对应的思想。不严格单调的最小次数为$n-LIS$。注意二分的 upper_bound #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; int kse = 0; namespace flyinthesky { int n, A[100000 + 5], b[100000 + 5], cnt; void clean() { cnt = 1; for (int i = 0; i &lt;= 100001; ++i) b[i] = -1000000000; } int solve() { clean(); scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;A[i]), A[i] -= i; b[1] = A[1]; for (int i = 2; i &lt;= n; ++i) { if (A[i] &gt;= b[cnt]) b[++cnt] = A[i]; else { int pos = upper_bound(b + 1, b + 1 + cnt, A[i]) - b; b[pos] = A[i]; } } printf(&quot;Case #%d:\n%d\n&quot;, ++kse, n - cnt); return 0; } } int main() { int T; scanf(&quot;%d&quot;, &amp;T); while (T--) flyinthesky::solve(); return 0; } 第19题 CodeForces E. Palindrome-less ArraysE. Palindrome-less Arrays 发现等价于不存在三长度的回文串，奇偶分离后就是一个求相邻数不同的方案数。对于整段$-1$求解即可。容易写出一个$O(nk)$的DP，但是这里可以更简单。设$dp(i,0/1)$表示当前有$i$个$-1$, 两边不等 / 等。转移以后算就行。注意两边$-1$的特判 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;queue&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL MO = 998244353, MAXN = 200000 + 5; LL ksm(LL a, LL b) { LL ret = 1, bs = a; while (b) { if (b &amp; 1) ret = (ret * bs) % MO; bs = (bs * bs) % MO; b &gt;&gt;= 1; } return ret; } LL n, k, a[MAXN], b[MAXN], tota, totb, dp[MAXN][2]; LL gg(LL *arr, LL n) { LL l, r; for (l = 1; l &lt;= n &amp;&amp; arr[l] == -1; ++l) ; if (l == n + 1) return ksm(k - 1, n - 1) * k % MO; for (r = n; r &gt;= 1 &amp;&amp; arr[r] == -1; --r) ; LL ret = 1; ret = ret * ksm(k - 1, l - 1) % MO; ret = ret * ksm(k - 1, n - r) % MO; LL lst = l; for (LL i = l + 1; i &lt;= r; ++i) { if (arr[i] != -1) { ret = (ret * dp[i - lst - 1][arr[i] == arr[lst]]) % MO; lst = i; } } return ret; } void clean() { } int solve() { clean(); cin &gt;&gt; n &gt;&gt; k; for (LL x, i = 1; i &lt;= n; ++i) { scanf(&quot;%lld&quot;, &amp;x); if (i % 2) a[++tota] = x; else b[++totb] = x; } dp[0][0] = 1, dp[0][1] = 0; for (LL i = 1; i &lt;= n; ++i) { dp[i][0] = (dp[i - 1][0] * (k - 2) % MO + dp[i - 1][1]) % MO; dp[i][1] = dp[i - 1][0] * (k - 1) % MO; // (k - 1) 下面 } printf(&quot;%lld\n&quot;, (gg(a, tota) * gg(b, totb)) % MO); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>状压DP</tag>
        <tag>区间DP</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP 搜索题训练]]></title>
    <url>%2F%E6%90%9C%E7%B4%A2%E9%A2%98%E4%B8%93%E7%BB%83%2F</url>
    <content type="text"><![CDATA[第1题 NOIP2010 引水入城 (DFS+贪心)NOIP2010 引水入城题意：见上。解：对第一行每个点 DFS 求出这个点可以覆盖最后一行的区间，然后对这些区间做最小完全区间覆盖$O(n^2)$即可。剪枝：如果第一行左右有比他高的，这个点不用继续搜索。Hack 点：如果n=1直接特判。知识点：本题提供了一个思路，不需要枚举第一行设置的状态(1位置放、2位置不放……)，而是单独枚举每一种情况然后再进行操作。对于这种$n=500$规模的题目好用。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double const int MAXN = 500 + 10, INF = 1000000000; const int dx[4] = {1, 0, -1, 0}; const int dy[4] = {0, 1, 0, -1}; int n, m, ans, ll[MAXN], rr[MAXN], h[MAXN][MAXN], vis[MAXN][MAXN]; void dfs(int x, int y, int k) { if (x == n) ll[k] = std::min(ll[k], y), rr[k] = std::max(rr[k], y); for (int i = 0; i &lt; 4; i++) { int tx = x + dx[i], ty = y + dy[i]; if (tx &gt; 0 &amp;&amp; ty &gt; 0 &amp;&amp; tx &lt;= n &amp;&amp; ty &lt;= m &amp;&amp; vis[tx][ty] != k &amp;&amp; h[tx][ty] &lt; h[x][y]) vis[tx][ty] = k, dfs(tx, ty, k); } } void clean() { ms(vis, 0); } int solve() { clean(); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) scanf(&quot;%d&quot;, &amp;h[i][j]); int gg = 0; for (int i = 1; i &lt;= m; i++) if (!(h[1][i - 1] &gt; h[1][i] || h[1][i + 1] &gt; h[1][i])) ll[i] = INF, rr[i] = -INF, dfs(1, i, i), gg++; if (n == 1) return printf(&quot;1\n%d\n&quot;, gg), 0; //for (int i = 1; i &lt;= m; i++) printf(&quot;i=%d l=%d r=%d\n&quot;, i, ll[i], rr[i]); int ans = 0; for (int i = 1; i &lt;= m; i++) if (vis[n][i]) ans++; if (ans != m) return printf(&quot;0\n%d\n&quot;, m - ans), 0; ans = 0; int e = 0; while (e &lt; m) { int mks = 0; for (int i = 1; i &lt;= m; i++) if (ll[i] &lt;= e + 1 &amp;&amp; rr[i] &gt; mks &amp;&amp; rr[i] &gt; e) mks = rr[i]; ans++, e = mks; } printf(&quot;1\n%d\n&quot;, ans); return 0; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m), solve(); return 0; } 第2题 Luogu P1441 砝码称重 (DFS+DP)Luogu P1441 砝码称重题意：见上。解：DFS 枚举$C^m_n$种去砝码方案，再用普通的 01背包 判存在性即可。这复杂度在爆炸边缘QAQ……我们尝试用bitset优化 std::bitset&lt;2048 &gt; dp; dp[0] = 1; for (int i = 1; i &lt;= n; i++) { if (vis[i]) continue; dp |= dp &lt;&lt; a[i]; } dp |= dp &lt;&lt; a[i]等同于 01 背包第二重循环。dp &lt;&lt; a[i]相当于将方案$dp(j-a_i)$的全部加上了$a_i$后的新方案集合。知识点：这种储存二进制/状态的题目就可以用 bitset 水过去。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;bitset&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double int n, m, a[25], vis[25], ans, sum; void dfs(int u, int b) { if (b &gt;= m) { std::bitset&lt;2048 &gt; dp; dp[0] = 1; for (int i = 1; i &lt;= n; i++) { if (vis[i]) continue; dp |= dp &lt;&lt; a[i]; } ans = std::max(ans, (int)dp.count() - 1); return ; } if (u == n + 1) return ; dfs(u + 1, b); vis[u] = 1, dfs(u + 1, b + 1), vis[u] = 0; } void clean() { sum = 0, ms(vis, 0); } int solve() { clean(); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]), sum += a[i]; dfs(1, 0); printf(&quot;%d\n&quot;, ans); return 0; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m), solve(); return 0; } 第3题 Luogu P1242 新汉诺塔Luogu P1242 新汉诺塔题意：见上。解：移动一个大盘必须将所有比他小的盘移到不是这个大盘的目标柱中，因为这样大盘才能移到目标柱去。这样 DFS 即可。注意在移动过程中同一根柱子里就不需要再移动了知识点：写 DFS 要注意合法性。代码： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;bitset&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double int n, cnt, s[3][50], pos[50], gl[50]; void mve(int i, int fr, int t) { printf(&quot;move %d from %c to %c\n&quot;, i, fr + &#39;A&#39;, t + &#39;A&#39;), cnt++; s[fr][0]--, pos[i] = t, s[t][++s[t][0]] = i; } void dfs(int i, int fr, int t, int hp) { if (fr == t) return ;//不要漏，在同一根柱子里就不用移动 for (int j = i - 1; j; j--) dfs(j, pos[j], hp, 3 - pos[j] - hp); mve(i, fr, t); } void clean() { cnt = 0; } int solve() { clean(); if(n == 3) { printf(&quot;move 3 from A to B\nmove 1 from C to B\nmove 2 from C to A\nmove 1 from B to A\nmove 3 from B to C\n5\n&quot;); exit(0); } for (int i = 0; i &lt; 3; i++) { scanf(&quot;%d&quot;, &amp;s[i][0]); for (int j = 1; j &lt;= s[i][0]; j++) scanf(&quot;%d&quot;, &amp;s[i][j]), pos[s[i][j]] = i; } for (int len, i = 0; i &lt; 3; i++) { scanf(&quot;%d&quot;, &amp;len); for (int x, j = 1; j &lt;= len; j++) scanf(&quot;%d&quot;, &amp;x), gl[x] = i; } for (int i = n; i; i--) if (pos[i] != gl[i]) dfs(i, pos[i], gl[i], 3 - pos[i] - gl[i]); printf(&quot;%d\n&quot;, cnt); return 0; } int main() { scanf(&quot;%d&quot;, &amp;n), solve(); return 0; } 第4题 NOIP2009 靶形数独 (DFS按位，枚举顺序优化)NOIP2009 靶形数独题意：见上。解：暴力 dfs 即可。优化方法：1、倒搜 2、从9到1枚举 3、先填空格少的(代码没用这种方法，所以TLE了一个点) #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double const int sco[11][11] = { {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 6, 6, 6, 6, 6, 6, 6, 6, 6}, {0, 6, 7, 7, 7, 7, 7, 7, 7, 6}, {0, 6, 7, 8, 8, 8, 8, 8, 7, 6}, {0, 6, 7, 8, 9, 9, 9, 8, 7, 6}, {0, 6, 7, 8, 9,10, 9, 8, 7, 6}, {0, 6, 7, 8, 9, 9, 9, 8, 7, 6}, {0, 6, 7, 8, 8, 8, 8, 8, 7, 6}, {0, 6, 7, 7, 7, 7, 7, 7, 7, 6}, {0, 6, 6, 6, 6, 6, 6, 6, 6, 6} }; int flag = 0, ans = 0, a[11][11], blg[11][11], hang[11][11], lie[11][11], gong[11][11]; inline int max(int x, int y) {return x &gt; y ? x : y;} void dfs(int x, int y, int tot) { if (x == 0) { ans = max(ans, tot), flag = 1; return ; } int tx = x, ty = y + 1; if (ty &gt; 9) --tx, ty = 1; if (a[x][y]) dfs(tx, ty, tot + a[x][y] * sco[x][y]); for (int i = 9; i &gt;= 1; --i) { if (!hang[x][i] &amp;&amp; !lie[y][i] &amp;&amp; !gong[blg[x][y]][i]) { hang[x][i] = lie[y][i] = gong[blg[x][y]][i] = 1; dfs(tx, ty, tot + i * sco[x][y]); hang[x][i] = lie[y][i] = gong[blg[x][y]][i] = 0; } } } void clean() { ms(hang, 0), ms(lie, 0), ms(gong, 0); for (int i = 1; i &lt;= 9; ++i) for (int j = 1; j &lt;= 9; ++j) blg[i][j] = ((i - 1) / 3) * 3 + ((j - 1) / 3 + 1); } int solve() { clean(); for (int i = 1; i &lt;= 9; ++i) for (int j = 1; j &lt;= 9; ++j) scanf(&quot;%d&quot;, &amp;a[i][j]), hang[i][a[i][j]] = 1, lie[j][a[i][j]] = 1, gong[blg[i][j]][a[i][j]] = 1; dfs(9, 1, 0); if (flag) printf(&quot;%d\n&quot;, ans); else printf(&quot;-1\n&quot;); return 0; } int main() { solve(); return 0; } 第5题 P1120 小木棍 (DFS )P1120 小木棍题意：见上。解：暴力dfs+剪枝。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { int vis[100], a[100], n, sum, len; bool dfs(int lst, int cnt, int rm) { if (cnt &gt;= n &amp;&amp; rm == len) return true; int f = 0; // 冗余排除 for (int i = lst; i &lt;= n; ++i) { // 冗余排除 if (vis[i]) continue; if (a[i] &lt;= rm &amp;&amp; a[i] != f) { int fl = 0; vis[i] = 1; if (a[i] == rm) fl = dfs(1, cnt + 1, len); else fl = dfs(i + 1, cnt + 1, rm - a[i]); vis[i] = 0; if (fl) return true; if (rm == len) return false; // 冗余排除 if (rm == a[i]) return false; // 冗余排除 f = a[i]; } } return false; } bool cmp(int x, int y) {return x &gt; y;} void clean() { } int solve() { clean(); int gg; scanf(&quot;%d&quot;, &amp;gg); for (int x, i = 1; i &lt;= gg; ++i) { scanf(&quot;%d&quot;, &amp;x); if (x &lt;= 50) a[++n] = x, sum += x; } sort(a + 1, a + 1 + n, cmp); // 搜索顺序 for (int i = 1; i &lt;= sum; ++i) if (sum % i == 0) { if (len = i, dfs(1, 0, i)) return printf(&quot;%d\n&quot;, i); } return 0; } } int main() { flyinthesky::solve(); return 0; } 第6题 Luogu 1379 八数码难题 (BFS + 状压)Luogu 1379 八数码难题题意：见上。解：用 0 在搜索中转移，相当于整个棋盘只有 0 在动。然后 BFS 每个状态，用 set 判重。知识点：9 维 bool 数组也可以判断，可以不用 set 。不要被主观意识干扰。代码： #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;queue&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define ULL unsigned long long #define db double const LL gl = 123804765ll; const int dx[4] = {1, 0, -1, 0}; const int dy[4] = {0, 1, 0, -1}; struct data { int stp; LL st; }; LL now; int ma[5][5]; std::queue&lt;data &gt; q; std::set&lt;LL &gt; s; void split(LL st) { for (int i = 1; i &lt;= 3; i++) ma[1][i] = st % 10, st /= 10; for (int i = 1; i &lt;= 3; i++) ma[2][i] = st % 10, st /= 10; for (int i = 1; i &lt;= 3; i++) ma[3][i] = st % 10, st /= 10; } LL gethash() { LL ret = 0; for (int i = 3; i; i--) ret = ret * 10 + ma[3][i]; for (int i = 3; i; i--) ret = ret * 10 + ma[2][i]; for (int i = 3; i; i--) ret = ret * 10 + ma[1][i]; return ret; } void clean() { } int solve() { clean(); s.insert(now), q.push((data){0, now}); while (!q.empty()) { data p = q.front(); q.pop(); if (p.st == gl) return printf(&quot;%d\n&quot;, p.stp); split(p.st); int x, y; for (int i = 1; i &lt;= 3; i++) for (int j = 1; j &lt;= 3; j++) if (ma[i][j] == 0) {x = i, y = j; break;} for (int i = 0; i &lt; 4; i++) { int tx = x + dx[i], ty = y + dy[i]; if (tx &gt; 0 &amp;&amp; ty &gt; 0 &amp;&amp; tx &lt;= 3 &amp;&amp; ty &lt;= 3) { std::swap(ma[tx][ty], ma[x][y]); LL tmp = gethash(); if (!s.count(tmp)) s.insert(tmp), q.push((data){p.stp + 1, tmp}); std::swap(ma[tx][ty], ma[x][y]); } } } return 0; } int main() { scanf(&quot;%lld&quot;, &amp;now), solve(); return 0; } 第6题 Luogu 1731 生日蛋糕 (DFS + 优化)Luogu 1731 生日蛋糕题意：见上。解：直接搜索即可。注意剪枝，代码中有知识点：剪枝方法：1、可行性剪枝 (初值，最好情况下无法到达xxx)2、最优化剪枝 (最好情况下不能达到当前全局最优解，当前已经不能是全局最优解)3、倒搜 (倒搜出奇迹)4、玄学 #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;climits&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define ULL unsigned long long #define db double int n, C, S = INT_MAX; void dfs(int a, int rm, int nowy, int nowc, int lstr, int lsth) { if (nowy + nowc &gt;= S) return ; //最优性剪枝 (当前已经不能是全局最优解) if (a == n + 1) { if (rm == 0) { S = std::min(S, nowy + nowc); } return ; } int z = n - a + 1;// 剩下的层数 if(rm - lstr * lstr * lsth * z &gt; 0) return ;//可行性剪枝 (最好情况下无法到达xxx) 已经无法将体积消耗完 for (int H = lsth - 1; H &gt;= z; H--) { //当前半径或高一定要大于等于 z，否则因为单调递减最上层不够 for (int R = lstr - 1; R &gt;= z; R--) {//可行性剪枝 (初值) if (rm - R * R * H &lt; 0) continue; dfs(a + 1, rm - R * R * H, std::max(R * R, nowy), nowc + 2 * R * H, R, H); } } } void clean() { } int solve() { clean(); dfs(1, C, 0, 0, (int)sqrt(C), (int)sqrt(C));//半径从 sqrt 开始 (初值) if (S == INT_MAX) return printf(&quot;0\n&quot;), 0; else return printf(&quot;%d\n&quot;, S), 0; return 0; } int main() { scanf(&quot;%d%d&quot;, &amp;C, &amp;n), solve(); return 0; } 第7题 NOIP2011 Mayan游戏 (DFS + 枚举重复性，必要性)NOIP2011 Mayan游戏题意：见上。解：实现4个操作： update 更新游戏棋盘 (将悬空方块下降) remove 删除能消除的方块 (先打标记后删除的方法可以解决多个合法消除共享方块的情况) move 左右移动一个方块 (move 完后要 update，并且要循环) check 是否消除完毕 具体实现看代码相关部分 剪枝：1、移动的两个方块颜色一样不用移动2、方块左移如果有方块也不用移动，因为字典序枚举，枚举左边右移时已经包含了该情况。 知识点：先打标记后删除可以避免一些问题暴力搜索考虑重复性，枚举必要性 #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;climits&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define ULL unsigned long long #define db double int ma[10][10][10], seq[10][5], bj[10][10]; int T; void update(int stg) { for (int j = 1; j &lt;= 5; j++) { int flag = false, wz = 0; for (int i = 1; i &lt;= 7; i++) { if (!flag &amp;&amp; ma[stg][i][j] == 0) flag = true, wz = i; if (flag &amp;&amp; ma[stg][i][j] &gt; 0) ma[stg][wz][j] = ma[stg][i][j], ma[stg][i][j] = 0, wz++; } } } bool remove(int stg) { int flag = false; ms(bj, 0); for (int i = 1; i &lt;= 7; i++) for (int j = 1; j &lt;= 5; j++) { if (i - 1 &gt; 0 &amp;&amp; i + 1 &lt;= 7) if (ma[stg][i - 1][j] != 0 &amp;&amp; ma[stg][i - 1][j] == ma[stg][i][j] &amp;&amp; ma[stg][i][j] == ma[stg][i + 1][j]) bj[i - 1][j] = bj[i][j] = bj[i + 1][j] = 1; if (j - 1 &gt; 0 &amp;&amp; j + 1 &lt;= 5) if (ma[stg][i][j - 1] != 0 &amp;&amp; ma[stg][i][j - 1] == ma[stg][i][j] &amp;&amp; ma[stg][i][j] == ma[stg][i][j + 1]) bj[i][j - 1] = bj[i][j] = bj[i][j + 1] = 1; } for (int i = 1; i &lt;= 7; i++) for (int j = 1; j &lt;= 5; j++) if (bj[i][j]) ma[stg][i][j] = 0, flag = 1; return flag; } void move(int stg, int x, int y, int opt) { if (y + opt &lt; 0 || y + opt &gt; 5) return ; std::swap(ma[stg][x][y], ma[stg][x][y + opt]); update(stg); while (remove(stg)) update(stg); } bool check(int stg) { int flag = true; for (int i = 1; i &lt;= 7; i++) for (int j = 1; j &lt;= 5; j++) if (ma[stg][i][j] &gt; 0) {flag = false; break;} return flag; } void dfs(int a) { if (a &gt; T + 1) return ; if (a == T + 1) { if (check(a - 1)) { for (int i = 1; i &lt;= T; i++) printf(&quot;%d %d %d\n&quot;, seq[i][0] - 1, seq[i][1] - 1, seq[i][2]); exit(0); } return ; } for (int i = 1; i &lt;= 7; i++) for (int j = 1; j &lt;= 5; j++) ma[a][i][j] = ma[a - 1][i][j]; for (int j = 1; j &lt;= 5; j++) { for (int i = 1; i &lt;= 7; i++) { if (j + 1 &lt;= 5) { if (ma[a][i][j] != ma[a][i][j + 1] &amp;&amp; ma[a][i][j] != 0) { move(a, i, j, 1), seq[a][0] = j, seq[a][1] = i, seq[a][2] = 1, dfs(a + 1); for (int i = 1; i &lt;= 7; i++) for (int j = 1; j &lt;= 5; j++) ma[a][i][j] = ma[a - 1][i][j]; } } if (j - 1 &gt; 0) { if (ma[a][i][j] != ma[a][i][j - 1] &amp;&amp; ma[a][i][j] != 0 &amp;&amp; ma[a][i][j - 1] == 0) { move(a, i, j, -1), seq[a][0] = j, seq[a][1] = i, seq[a][2] = -1, dfs(a + 1); for (int i = 1; i &lt;= 7; i++) for (int j = 1; j &lt;= 5; j++) ma[a][i][j] = ma[a - 1][i][j]; } } } } } void clean() { } int solve() { clean(); for (int i = 1; i &lt;= 5; i++) { int x, j = 1; scanf(&quot;%d&quot;, &amp;x); while (x != 0) ma[0][j][i] = x, scanf(&quot;%d&quot;, &amp;x), j++; } dfs(1); printf(&quot;-1\n&quot;); return 0; } int main() { scanf(&quot;%d&quot;, &amp;T), solve(); return 0; } 第8题 NOIP2015 斗地主 (DFS + 枚举必要性)NOIP2015 斗地主题意：见上。解：最朴素的方法是枚举每个题目所给的牌型，然后判断有没有空。只有30分，30分也可以乱搞。其实我们发现炸弹、三张牌、对子、单牌都可以一次性走完，那么我们就直接将这4种情况都合并起来一下处理，然后就不会超时了。知识点：暴力搜索考虑重复性和后程枚举必要性。要把题目看全面才行 //代码后面提供了一些检验数据 #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;climits&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define ULL unsigned long long #define db double int n, tax[20], ans; int check() { for (int i = 1; i &lt;= 15; i++) if (tax[i]) return false; return true; } void dfs(int a) { if (a - 1 &gt;= ans) return ; if (check()) { ans = std::min(ans, a - 1); return ; } //三顺子 2 for (int i = 3; i &lt;= 12; i++) if (tax[i] &gt;= 3) { int j = i + 1; if (j &gt; 13) j = 1; while (1) { if (j == 2) break; if (tax[j] &lt; 3) break; j++; if (j &gt; 13) j = 1; } j--; if (j == 1) { int tmp = 13 - i + 1 + 1; if (tmp &lt; 3) continue; for (int k = i; k &lt;= 13; k++) tax[k] -= 3; tax[1] -= 3; dfs(a + 1); for (int k = i; k &lt;= 13; k++) tax[k] += 3; tax[1] += 3; } else if (j == 0) { int tmp = 13 - i + 1; if (tmp &lt; 3) continue; for (int k = i; k &lt;= 13; k++) tax[k] -= 3; dfs(a + 1); for (int k = i; k &lt;= 13; k++) tax[k] += 3; } else { int tmp = j - i + 1; if (tmp &lt; 3) continue; for (int k = i; k &lt;= j; k++) tax[k] -= 3; dfs(a + 1); for (int k = i; k &lt;= j; k++) tax[k] += 3; } } //双顺子 3 for (int i = 3; i &lt;= 12; i++) if (tax[i] &gt;= 2) { int j = i + 1; if (j &gt; 13) j = 1; while (1) { if (j == 2) break; if (tax[j] &lt; 2) break; j++; if (j &gt; 13) j = 1; } j--; if (j == 1) { int tmp = 13 - i + 1 + 1; if (tmp &lt; 3) continue; for (int k = i; k &lt;= 13; k++) tax[k] -= 2; tax[1] -= 2; dfs(a + 1); for (int k = i; k &lt;= 13; k++) tax[k] += 2; tax[1] += 2; } else if (j == 0) { int tmp = 13 - i + 1; if (tmp &lt; 3) continue; for (int k = i; k &lt;= 13; k++) tax[k] -= 2; dfs(a + 1); for (int k = i; k &lt;= 13; k++) tax[k] += 2; } else { int tmp = j - i + 1; if (tmp &lt; 3) continue; for (int k = i; k &lt;= j; k++) tax[k] -= 2; dfs(a + 1); for (int k = i; k &lt;= j; k++) tax[k] += 2; } } //单顺子 4 for (int i = 3; i &lt;= 12; i++) if (tax[i] &gt;= 1) { int j = i + 1; if (j &gt; 13) j = 1; while (1) { if (j == 2) break; if (tax[j] &lt; 1) break; j++; if (j &gt; 13) j = 1; } j--; if (j == 1) { int tmp = 13 - i + 1 + 1; if (tmp &lt; 5) continue; for (int k = i; k &lt;= 13; k++) tax[k] -= 1; tax[1] -= 1; dfs(a + 1); for (int k = i; k &lt;= 13; k++) tax[k] += 1; tax[1] += 1; } else if (j == 0) { int tmp = 13 - i + 1; if (tmp &lt; 5) continue; for (int k = i; k &lt;= 13; k++) tax[k] -= 1; dfs(a + 1); for (int k = i; k &lt;= 13; k++) tax[k] += 1; } else { int tmp = j - i + 1; if (tmp &lt; 5) continue; for (int k = i; k &lt;= j; k++) tax[k] -= 1; dfs(a + 1); for (int k = i; k &lt;= j; k++) tax[k] += 1; } } //四带二 1 //对子 for (int i = 1; i &lt;= 13; i++) if (tax[i] &gt;= 4) { tax[i] -= 4; for (int j = 1; j &lt;= 13; j++) if (tax[j] &gt;= 2) { tax[j] -= 2; for (int k = 1; k &lt;= 13; k++) if (tax[k] &gt;= 2) { tax[k] -= 2; dfs(a + 1); tax[k] += 2; } tax[j] += 2; } tax[i] += 4; } //单牌 for (int i = 1; i &lt;= 13; i++) if (tax[i] &gt;= 4) { tax[i] -= 4; for (int j = 1; j &lt;= 15; j++) if (tax[j] &gt;= 1) { tax[j] -= 1; for (int k = 1; k &lt;= 15; k++) if (tax[k] &gt;= 1) { tax[k] -= 1; dfs(a + 1); tax[k] += 1; } tax[j] += 1; } tax[i] += 4; } //三带二 5 for (int i = 1; i &lt;= 13; i++) if (tax[i] &gt;= 3) { tax[i] -= 3; for (int j = 1; j &lt;= 13; j++) if (tax[j] &gt;= 2) { tax[j] -= 2; dfs(a + 1); tax[j] += 2; } tax[i] += 3; } //三带一 6 for (int i = 1; i &lt;= 13; i++) if (tax[i] &gt;= 3) { tax[i] -= 3; for (int j = 1; j &lt;= 15; j++) if (tax[j] &gt;= 1) { tax[j] -= 1; dfs(a + 1); tax[j] += 1; } tax[i] += 3; } //火箭 9 if (tax[14] &amp;&amp; tax[15]) tax[14]--, tax[15]--, dfs(a + 1), tax[14]++, tax[15]++; int hh = a - 1; for (int i = 1; i &lt;= 15; i++) if (tax[i]) hh++; ans = std::min(ans, hh); } void clean() { ms(tax, 0); } int solve() { clean(); for (int a, b, i = 1; i &lt;= n; i++) { scanf(&quot;%d%d&quot;, &amp;a, &amp;b); if (a == 0) tax[13 + b]++; else tax[a]++; } ans = n; dfs(1); printf(&quot;%d\n&quot;, ans); return 0; } int main() { int T; scanf(&quot;%d%d&quot;, &amp;T, &amp;n); while (T--) solve(); return 0; } /* //单，三顺子 1 10 4 1 4 2 4 3 5 1 5 2 5 3 6 1 6 2 6 3 13 1 //单，双顺子 1 7 4 1 4 2 5 1 5 2 6 1 6 2 5 3 //单，顺子 1 9 1 1 7 1 8 1 9 1 10 1 11 1 12 1 13 1 2 2 //单，双，火箭 1 6 0 1 0 2 1 3 1 2 2 1 13 5 //炸 1 4 3 1 3 2 3 3 3 4 //三张 1 3 3 1 3 2 3 3 //三带一 1 4 3 1 3 2 3 3 13 1 //三带二 1 5 3 1 3 2 3 3 13 1 13 2 //四带二 1 6 3 1 3 2 3 3 3 4 13 1 13 2 */ 第9题 NOIP2003 传染病控制 (DFS + 枚举必要性)NOIP2003 传染病控制题意：见上。解：本题相当于每一层删掉一个子树，那么我们预处理每一层的点，用 DFS 按层删除子树即可。1、如果一个子树被删除了就要打上标记，然后如果一个子树已经在一个打了标记的子树中，就不要删除这个子树。这里判断就暴力枚举祖先节点就行。2、如果一层一个节点都没删除，那么就是已经处理完毕了，直接更新答案即可，类似斗地主思想，不要 DFS 一个个下去，很慢很慢很慢，直接处理即可知识点：这种数据1000以内的都可能是搜索题，但是必要剪枝。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; #include&lt;queue&gt; #include&lt;climits&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double const int MAXN = 300 + 5; int n, p, fa[MAXN], dep[MAXN], siz[MAXN], ans = 0, maxd = 0, vis[MAXN]; std::vector&lt;int &gt; G[MAXN], whw[MAXN]; void dfs1(int u, int pa) { dep[u] = dep[pa] + 1, siz[u] = 1, fa[u] = pa; for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i]; if (v != pa) dfs1(v, u), siz[u] += siz[v]; } } void dfs2(int a, int tmp) { if (a == maxd + 1) { ans = std::max(ans, tmp); return ; } int gg = 0; for (int i = 0; i &lt; (int)whw[a].size(); i++) { int u = whw[a][i], nmd = u, fl = 0; while (nmd != 1) { if (vis[nmd]) {fl = 1; break;} nmd = fa[nmd]; } if (fl) continue; gg = 1, vis[u] = 1, dfs2(a + 1, tmp + siz[u]), vis[u] = 0; } if (!gg) ans = std::max(ans, tmp); } void clean() { ms(vis, 0), ms(dep, 0), ms(siz, 0); } int solve() { clean(); for (int x, y, i = 1; i &lt;= p; i++) scanf(&quot;%d%d&quot;, &amp;x, &amp;y), G[x].push_back(y), G[y].push_back(x); dfs1(1, 0); for (int i = 1; i &lt;= n; i++) whw[dep[i]].push_back(i), maxd = std::max(maxd, dep[i]); dfs2(2, 0); printf(&quot;%d\n&quot;, n - ans); return 0; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;p), solve(); return 0; } 第10题 NOIP2017 时间复杂度 (栈模拟)NOIP2017 时间复杂度题意：虽然这是个栈模拟题……解：用栈维护模拟即可。注意如果语法错误不能立刻退出，否则就会对后面的数据造成影响。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; #include&lt;queue&gt; #include&lt;climits&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double struct data { char ch; int bj, gg; }; int L, fzd, top, vis[30]; char s[500]; data st[105]; void clean() { ms(vis, 0), fzd = top = 0; } int solve() { clean(); scanf(&quot;%d%s&quot;, &amp;L, s); //复杂度 if (s[2] == &#39;1&#39;) fzd = 0; else { int tmp = 0, i = 4; while (&#39;0&#39; &lt;= s[i] &amp;&amp; s[i] &lt;= &#39;9&#39;) tmp = tmp * 10 + s[i] - &#39;0&#39;, ++i; fzd = tmp; //printf(&quot;%d\n&quot;, fzd); } int ans = 0, now = 0, cs = 0, fl = 0; for (int i = 1; i &lt;= L; ++i) { scanf(&quot;%s&quot;, s); if (s[0] == &#39;F&#39;) { ++cs; scanf(&quot;%s&quot;, s); char c = s[0]; if (vis[c - &#39;a&#39;]) fl = 1; int hh = false, jj = false; scanf(&quot;%s&quot;, s); if (s[0] == &#39;n&#39;) { scanf(&quot;%s&quot;, s); if (s[0] != &#39;n&#39;) hh = true;//x 是 n，y 不是 n，显然不能进入循环 else jj = true, --cs;//x y 都是 n } else { int tmp1 = 0, tmp2 = 0, j = 0; while (&#39;0&#39; &lt;= s[j] &amp;&amp; s[j] &lt;= &#39;9&#39;) tmp1 = tmp1 * 10 + s[j] - &#39;0&#39;, ++j; scanf(&quot;%s&quot;, s); if (s[0] != &#39;n&#39;) {//x y 都是数字 int k = 0; while (&#39;0&#39; &lt;= s[k] &amp;&amp; s[k] &lt;= &#39;9&#39;) tmp2 = tmp2 * 10 + s[k] - &#39;0&#39;, ++k; if (tmp1 &gt; tmp2) hh = true;//x y 都是数字，x 比 y 大，显然不能进入循环 else jj = true, --cs; //x y 都是数字，x 比 y 小 } //x 是数字, y 是 n } vis[c - &#39;a&#39;] = 1, st[++top] = (data){c, now, jj}; now |= hh; if (!now) ans = std::max(ans, cs); } else if (s[0] == &#39;E&#39;) { if (top == 0) {fl = 1;continue;} data b = st[top]; --top; vis[b.ch - &#39;a&#39;] = 0, now = b.bj, cs -= !b.gg; } } if (fl || top != 0) return printf(&quot;ERR\n&quot;), 0; if (ans == fzd) printf(&quot;Yes\n&quot;); else printf(&quot;No\n&quot;); return 0; } int main() { int T; scanf(&quot;%d&quot;, &amp;T); while (T--) solve(); return 0; } 第11题 NOIP2017 棋盘 (记忆化 DFS)NOIP2017 棋盘题意：见上。解：BFS解法：根据 BFS 转移费用为1第一次找到为最短路来优化复杂度。我们让同色之间转移费用设为1，然后异色之间转移费用拆成两步进行，相当于这个转移拆成两个费用为1的转移。对于魔法，我们拆成4步或者6步进行，具体类似上面的操作。这样 vis 数组就要加维。然而拆转移后状态不多，可以轻松AC。记忆化搜索：直接搜索，然后最优化剪枝，每个坐标点记忆化一个最优解，最优化剪枝即可。注意这题如果目标点没颜色如果能魔法就可以到达的！知识点：1、记忆化搜索-搜索-DP之间密切联系2、不要忘记特殊情况的考虑 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;stack&gt; #include&lt;set&gt; #include&lt;map&gt; #include&lt;queue&gt; #include&lt;climits&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; namespace flyinthesky { struct data {int x, y, rm, dis, tms;}; const int dx[4] = {1, 0, -1, 0}; const int dy[4] = {0, 1, 0, -1}; int m, n, ma[105][105], vis[105][105][10]; queue&lt;data &gt; q; void clean() { ms(ma, -1), ms(vis, 0); } int solve() { scanf(&quot;%d%d&quot;, &amp;m, &amp;n); clean(); for (int x, y, c, i = 1; i &lt;= n; ++i) scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;c), ma[x][y] = c; vis[1][1][0] = 1, q.push((data){1, 1, 0, 0, 0}); while (!q.empty()) { data p = q.front(); q.pop(); //printf(&quot;x=%d, y=%d, rm=%d, dis=%d, tms=%d\n&quot;, p.x, p.y, p.rm, p.dis, p.tms); if (p.rm != 0) { if (!vis[p.x][p.y][p.rm - 1]) q.push((data){p.x, p.y, p.rm - 1, p.dis + 1, p.tms}), vis[p.x][p.y][p.rm - 1] = 1; continue; } if (p.x == m &amp;&amp; p.y == m &amp;&amp; p.rm == 0) return printf(&quot;%d\n&quot;, p.dis - p.tms), 0; for (int i = 0; i &lt; 4; i++) { int tx = p.x + dx[i], ty = p.y + dy[i]; if (tx &gt; 0 &amp;&amp; ty &gt; 0 &amp;&amp; tx &lt;= m &amp;&amp; ty &lt;= m) { if (ma[p.x][p.y] == 0) { if (ma[tx][ty] == 0 &amp;&amp; !vis[tx][ty][0]) q.push((data){tx, ty, 0, p.dis + 1, p.tms + 1}), vis[tx][ty][0] = 1; else if (ma[tx][ty] == 1 &amp;&amp; !vis[tx][ty][1]) q.push((data){tx, ty, 1, p.dis + 1, p.tms + 1}), vis[tx][ty][1] = 1; } else if (ma[p.x][p.y] == 1) { if (ma[tx][ty] == 0 &amp;&amp; !vis[tx][ty][1]) q.push((data){tx, ty, 1, p.dis + 1, p.tms + 1}), vis[tx][ty][1] = 1; else if (ma[tx][ty] == 1 &amp;&amp; !vis[tx][ty][0]) q.push((data){tx, ty, 0, p.dis + 1, p.tms + 1}), vis[tx][ty][0] = 1; } if (ma[tx][ty] &lt; 0) { if (tx == m &amp;&amp; ty == m) return printf(&quot;%d\n&quot;, p.dis - p.tms + 2), 0; for (int j = 0; j &lt; 4; j++) { int gx = tx + dx[j], gy = ty + dy[j]; if (gx == p.x &amp;&amp; gy == p.y) continue; if (gx &gt; 0 &amp;&amp; gy &gt; 0 &amp;&amp; gx &lt;= m &amp;&amp; gy &lt;= m &amp;&amp; (ma[gx][gy] == 0 || ma[gx][gy] == 1)) { if (ma[p.x][p.y] == 0) { if (ma[gx][gy] == 0 &amp;&amp; !vis[gx][gy][3]) q.push((data){gx, gy, 3, p.dis + 1, p.tms + 2}), vis[gx][gy][3] = 1; else if (ma[gx][gy] == 1 &amp;&amp; !vis[gx][gy][4]) q.push((data){gx, gy, 4, p.dis + 1, p.tms + 2}), vis[gx][gy][4] = 1; } else if (ma[p.x][p.y] == 1) { if (ma[gx][gy] == 0 &amp;&amp; !vis[gx][gy][4]) q.push((data){gx, gy, 4, p.dis + 1, p.tms + 2}), vis[gx][gy][4] = 1; else if (ma[gx][gy] == 1 &amp;&amp; !vis[gx][gy][3]) q.push((data){gx, gy, 3, p.dis + 1, p.tms + 2}), vis[gx][gy][3] = 1; } } } } } } } printf(&quot;-1\n&quot;); return 0; } } int main() { flyinthesky::solve(); return 0; } 第12题 Poj 1691 Painting A Board (DFS + 最优化剪枝)Poj 1691题意：有这样一个面板（如下图），分成大大小小的矩形块。现在要对其上色，每个矩形块上一种颜色，颜色已经预先指定好。每次对一个矩形区域上色，要求必须在该矩形区域上方的所有矩形区域已经被上色后，才能对该矩形区域上色。如下图：如果要对F区域上色，则在它上面的区域A、B、C、D必须已经被上色。又每次上色，选择一种特定眼色的笔刷，例如选择蓝色，对A上色，此时可继续对C上色，无需更改颜色。之后，则只能对B区域上色了，则要选择红色笔刷，所以笔刷的使用次数加1。如果后续过程中，又要重新选择蓝色笔刷，则笔刷仍加1。问：所需的最少笔刷个数？解：判断是否有矩形在上面用线段交。然后每个矩形预处理一个上面的矩形状态，每次DFS找到能刷的刷完再看换颜色刷的情况。知识点：1、要记得加最优化剪枝 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;climits&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #include&lt;stack&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 20; struct rc { int xl, yl, xr, yr; int st, col; } jx[MAXN]; int n, vis[MAXN], ans; bool check(int i, int j) { if (jx[i].xr &gt;= jx[j].xl &amp;&amp; jx[i].xr &lt;= jx[j].xr) return 1; return 0; } void dfs(int step, int st, int col) { while (1) { int fl = 0; for (int i = 1; i &lt;= n; ++i) if (!vis[i]) { if (jx[i].col != col) continue ; if ((jx[i].st &amp; st) == jx[i].st) { st += (1 &lt;&lt; (i - 1)), vis[i] = step, fl = 1; } } if (!fl) break; } int fl = 0; for (int i = 1; i &lt;= n; ++i) if (!vis[i]) fl = 1; if (!fl) { ans = min(ans, step); for (int i = 1; i &lt;= n; ++i) if (vis[i] == step) vis[i] = 0; return ; } for (int i = 1; i &lt;= n; ++i) if (!vis[i]) { if ((jx[i].st &amp; st) == jx[i].st) { vis[i] = step + 1; dfs(step + 1, st + (1 &lt;&lt; (i - 1)), jx[i].col); vis[i] = 0; } } for (int i = 1; i &lt;= n; ++i) if (vis[i] == step) vis[i] = 0; } void clean() { ans = 1000000000, ms(vis, 0); } int solve() { cin &gt;&gt; n; clean(); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d%d%d%d%d&quot;, &amp;jx[i].yl, &amp;jx[i].xl, &amp;jx[i].yr, &amp;jx[i].xr, &amp;jx[i].col); for (int i = 1; i &lt;= n; ++i) { jx[i].st = 0; for (int j = 1; j &lt;= n; ++j) if (i != j) { if (jx[j].yr == jx[i].yl &amp;&amp; (check(i, j) || check(j, i))) jx[i].st += (1 &lt;&lt; (j - 1)); } } for (int i = 1; i &lt;= n; ++i) if (jx[i].st == 0) vis[i] = 1, dfs(1, (1 &lt;&lt; (i - 1)), jx[i].col), vis[i] = 0; printf(&quot;%d\n&quot;, ans); return 0; } } int main() { int T; scanf(&quot;%d&quot;, &amp;T); while (T--) flyinthesky::solve(); return 0; } 第13题 Poj 2308 (DFS + 可行性剪枝)Poj 2308题意：连连看判是否有解。解：DFS中途BFS。DFS看哪个点没消除用BFS找这个点能和哪个其他点消除，然后DFS递归消除即可。注意剪枝，如果出现ABBA并且AB就各只有2个，则无解，直接退出本层DFS。 知识点：1、无解早判省时间2、DFS不要局限于下一步，下一个坐标，而是整体上的，适当情况下可以用BFS辅助。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;set&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int dx[4] = {1, 0, -1, 0}; const int dy[4] = {0, 1, 0, -1}; int n, m, a[15][15]; // 原矩阵 int sz, whw[200][2]; // 可行消除方案 int vis[15][15]; int cnt, num[10], flag = 0; // 记录，答案 struct data {int x, y, fx, gj;}; bool check() { for (int i = 1; i &lt; n; ++i) { for (int j = 1; j &lt; m; ++j) { if(!a[i][j] || !a[i][j + 1]) continue ; if (a[i][j] == a[i + 1][j + 1] &amp;&amp; a[i + 1][j] == a[i][j + 1] &amp;&amp; num[a[i][j]] == 2 &amp;&amp; num[a[i + 1][j]] == 2) return true; } } return false; } void bfs(int x, int y, int col) { queue&lt;data &gt; q; ms(vis, 67), vis[x][y] = 0, q.push((data){x, y, -1, 0}); while (!q.empty()) { data p = q.front(); q.pop(); //if (col == 1) cerr &lt;&lt; p.x &lt;&lt; &quot; &quot; &lt;&lt; p.y &lt;&lt; &quot; &quot; &lt;&lt; p.gj &lt;&lt; endl; for (int i = 0; i &lt; 4; ++i) { int tx = p.x + dx[i], ty = p.y + dy[i], tgj = p.gj; if (tx &lt;= 0 || ty &lt;= 0 || tx &gt; n || ty &gt; m) continue ; if (i != p.fx &amp;&amp; p.fx != -1) ++tgj; // 拐角判断 if (tgj &gt; 2) continue ; if (vis[tx][ty] &lt; tgj) continue ; vis[tx][ty] = tgj; // 不如那么优 if (a[tx][ty] == col) { // 找到同一颜色 whw[++sz][0] = tx, whw[sz][1] = ty; // 记录位置 continue ; } if (a[tx][ty]) continue ; // 有方块挡着 q.push((data){tx, ty, i, tgj}); } } } void dfs(int rm) { if (rm == 0) { flag = 1; return ; } if (check()) return ; for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= m; ++j) { if (a[i][j] == 0) continue ; sz = 0; bfs(i, j, a[i][j]); //for (int k = 1; k &lt;= sz; ++k) cerr &lt;&lt; &quot;i=&quot; &lt;&lt; i &lt;&lt; &quot; j=&quot; &lt;&lt; j &lt;&lt; &quot;pos=&quot; &lt;&lt; whw[k][0] &lt;&lt; &quot; &quot; &lt;&lt; whw[k][1] &lt;&lt; endl; int col = a[i][j]; num[col] -= 2; a[i][j] = 0; for (int k = 1; k &lt;= sz; ++k) { a[whw[k][0]][whw[k][1]] = 0; dfs(rm - 2); a[whw[k][0]][whw[k][1]] = col; } num[col] += 2; a[i][j] = col; } } } void clean() { ms(num, 0), cnt = 0, ms(a, 0), ms(whw, 0), flag = 0; } int solve() { clean(); char s[15]; for (int i = 1; i &lt;= n; ++i) { scanf(&quot;%s&quot;, s + 1); int len = strlen(s + 1); for (int j = 1; j &lt;= len; ++j) { if (s[j] != &#39;*&#39;) ++cnt, ++num[s[j] - &#39;A&#39; + 1], a[i][j] = s[j] - &#39;A&#39; + 1; } } dfs(cnt); if (flag) printf(&quot;yes\n&quot;); else printf(&quot;no\n&quot;); return 0; } } int main() { while (scanf(&quot;%d%d&quot;, &amp;flyinthesky::n, &amp;flyinthesky::m) == 2 &amp;&amp; (flyinthesky::n &amp;&amp; flyinthesky::m)) flyinthesky::solve(); return 0; } 第14题 Poj 3322 (BFS)Poj 3322题意：题目中游戏最小步数。解：如果方块是一个，那就是裸BFS。将移动转移写到增量数组中，然后每个方块状态以他两个坐标值最小的方格为主要格子。然后 BFS 即可。知识点：1、BFS / DFS 选用2、多方格搜索要定义一个主格 (状压放$1 \times 2$方块也有类似方法) #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;set&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int dx[3][4] = {{-2, 1, 0, 0}, {2, -1, 0, 0}, {0, 0, 1, -1}}; const int dy[3][4] = {{ 0, 0, -2, 1}, {0, 0, -1, 1}, {2, -1, 0, 0}}; const int dz[3][4] = {{ 1, 1, 2, 2}, {0, 0, 1, 1}, {0, 0, 2, 2}}; struct data {int x, y, z, stp;}; int n, m, endx, endy, stx, sty, stz, vis[505][505][5]; char s[505][505]; bool check(int x, int y, int z) { if (x &lt;= 0 || y &lt;= 0 || x &gt; n || y &gt; m) return 0; if (z == 0) { if (s[x][y] != &#39;#&#39; &amp;&amp; s[x][y] != &#39;E&#39;) return 1; } else if (z == 1) { if (s[x][y] != &#39;#&#39; &amp;&amp; s[x + 1][y] != &#39;#&#39;) return 1; } else if (z == 2) { if (s[x][y] != &#39;#&#39; &amp;&amp; s[x][y + 1] != &#39;#&#39;) return 1; } return 0; } void clean() { stx = sty = stz = endx = endy = 0, ms(vis, 0); } int solve() { for (int i = 1; i &lt;= n; ++i) scanf(&quot;%s&quot;, s[i] + 1); clean(); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) { if (s[i][j] == &#39;O&#39;) endx = i, endy = j; if (!stx &amp;&amp; s[i][j] == &#39;X&#39; &amp;&amp; s[i + 1][j] == &#39;X&#39;) stx = i, sty = j, stz = 1; else if (!stx &amp;&amp; s[i][j] == &#39;X&#39; &amp;&amp; s[i][j + 1] == &#39;X&#39;) stx = i, sty = j, stz = 2; else if (!stx &amp;&amp; s[i][j] == &#39;X&#39;) stx = i, sty = j, stz = 0; } // cerr &lt;&lt; stx &lt;&lt; &quot; &quot; &lt;&lt; sty &lt;&lt; &quot; &quot; &lt;&lt; stz &lt;&lt; &quot; &quot; &lt;&lt; endl; // cerr &lt;&lt; endx &lt;&lt; &quot; &quot; &lt;&lt; endy &lt;&lt; endl; queue&lt;data &gt; q; vis[stx][sty][stz] = 1, q.push((data){stx, sty, stz, 0}); while (!q.empty()) { data p = q.front(); q.pop(); // cerr &lt;&lt; p.x &lt;&lt; &quot; &quot; &lt;&lt; p.y &lt;&lt; &quot; &quot; &lt;&lt; p.z &lt;&lt; endl; if (p.x == endx &amp;&amp; p.y == endy &amp;&amp; !p.z) return printf(&quot;%d\n&quot;, p.stp), 0; for (int i = 0; i &lt; 4; ++i) { int tx = p.x + dx[p.z][i], ty = p.y + dy[p.z][i], tz = dz[p.z][i]; if (vis[tx][ty][tz]) continue ; vis[tx][ty][tz] = 1; if (!check(tx, ty, tz)) continue ; q.push((data){tx, ty, tz, p.stp + 1}); } } printf(&quot;Impossible\n&quot;); return 0; } } int main() { while (scanf(&quot;%d%d&quot;, &amp;flyinthesky::n, &amp;flyinthesky::m) == 2 &amp;&amp; flyinthesky::n &amp;&amp; flyinthesky::m) flyinthesky::solve(); return 0; } /* 3 3 X.. ... ..O */ 第15题 Poj 1475 (BFS套BFS+状态简化)Poj 1475题意：推箱子游戏。解：先 BFS 箱子的位移，然后再进行 BFS 人能不能到另一侧。状态记录人的位置，箱子的位置。由于箱子的位置和箱子上一次从哪里推来知道就能得出人的位置，所以 $vis$ 只用记录三维。 知识点：1、搜索状态简化，类似差值DP2、BFS 套 BFS #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #include&lt;string&gt; #define LL long long #define db double #define ms(i, j) memset(i, j, sizeof i) using namespace std; int kse = 0; namespace flyinthesky { const int dx[4] = {-1, 1, 0, 0}; const int dy[4] = { 0, 0, 1, -1}; const char upfx[4] = {&#39;N&#39;, &#39;S&#39;, &#39;E&#39;, &#39;W&#39;}; const char lwfx[4] = {&#39;n&#39;, &#39;s&#39;, &#39;e&#39;, &#39;w&#39;}; struct data {int x, y, px, py; string s;}; struct data2 {int x, y; string s; }; int n, m, Tx, Ty, Sx, Sy, Bx, By, vis[25][25][4], v2[25][25]; char ma[25][25]; string ans, bs; bool insd(int x, int y) { if (x &gt; 0 &amp;&amp; y &gt; 0 &amp;&amp; x &lt;= n &amp;&amp; y &lt;= m) return true; return false; } bool bfsyou(int px, int py, int gx, int gy, int bx, int by) { // you position, goal position queue&lt;data2 &gt; q; ms(v2, 0), v2[px][py] = v2[bx][by] = 1, bs = &quot;&quot;; q.push((data2){px, py, &quot;&quot;}); while (!q.empty()) { data2 p = q.front(); q.pop(); if (p.x == gx &amp;&amp; p.y == gy) return bs = p.s, true; for (int i = 0; i &lt; 4; ++i) { int tx = p.x + dx[i], ty = p.y + dy[i]; if (!insd(tx, ty)) continue ; if (v2[tx][ty]) continue ; if (ma[tx][ty] == &#39;#&#39;) continue ; if (tx == bx &amp;&amp; ty == by) continue ; v2[tx][ty] = 1; q.push((data2){tx, ty, p.s + lwfx[i]}); } } return false; } bool bfsbox() { queue&lt;data &gt; q; ans = &quot;&quot;, ++kse; q.push((data){Bx, By, Sx, Sy, &quot;&quot;}); while (!q.empty()) { data p = q.front(); q.pop(); // p.x, p.y 当前箱子所在 // px, py 目标玩家位置 // tx，ty 目标箱子位置 if (p.x == Tx &amp;&amp; p.y == Ty) return ans = p.s, true; for (int i = 0; i &lt; 4; ++i) { int tx = p.x + dx[i], ty = p.y + dy[i]; int px = p.x - dx[i], py = p.y - dy[i]; if (!insd(tx, ty)) continue ; if (!insd(px, py)) continue ; if (ma[tx][ty] == &#39;#&#39;) continue ; if (ma[px][py] == &#39;#&#39;) continue ; if (vis[tx][ty][i] == kse) continue ; //cerr &lt;&lt; &quot;!!!&quot; &lt;&lt; p.px &lt;&lt; &quot; &quot; &lt;&lt; p.py &lt;&lt; &quot; &quot; &lt;&lt; px &lt;&lt; &quot; &quot; &lt;&lt; py &lt;&lt; &quot; &quot; &lt;&lt; tx &lt;&lt; &quot; &quot; &lt;&lt; ty &lt;&lt; endl; if (bfsyou(p.px, p.py, px, py, p.x, p.y)) { // cerr &lt;&lt; &quot;???&quot; &lt;&lt; tx &lt;&lt; &quot; &quot; &lt;&lt; ty &lt;&lt; &quot; &quot; &lt;&lt; p.x &lt;&lt; &quot; &quot; &lt;&lt; p.y &lt;&lt; endl; q.push((data){tx, ty, p.x, p.y, p.s + bs + upfx[i]}), vis[tx][ty][i] = kse; } } } return false; } void clean() { ms(vis, 0); } int solve() { for (int i = 1; i &lt;= n; ++i) scanf(&quot;%s&quot;, ma[i] + 1); clean(); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) { if (ma[i][j] == &#39;S&#39;) Sx = i, Sy = j; if (ma[i][j] == &#39;T&#39;) Tx = i, Ty = j; if (ma[i][j] == &#39;B&#39;) Bx = i, By = j; } if (bfsbox()) { printf(&quot;Maze #%d\n&quot;, kse); cout &lt;&lt; ans &lt;&lt; endl &lt;&lt; endl; } else printf(&quot;Maze #%d\nImpossible.\n\n&quot;, kse); return 0; } }; int main() { while (scanf(&quot;%d%d&quot;, &amp;flyinthesky::n, &amp;flyinthesky::m) == 2 &amp;&amp; flyinthesky::n &amp;&amp; flyinthesky::m) flyinthesky::solve(); return 0; } 第16题 Poj 1324 (状压BFS+状态简化)Poj 1324题意：贪吃蛇。要求蛇头到$(1,1)$的最短路程。解：BFS。然后状态状压判重。发现这里蛇身体都相邻，所以只用记录某个方块和哪个相邻即可。知识点：BFS 开函数写不要写在 solve 里！！！ #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; int kse = 0; namespace flyinthesky { const int dx[4] = {1, 0, -1, 0}; const int dy[4] = {0, 1, 0, -1}; struct data { int x, y, fx[10], bs; }; int n, m, L, Hx, Hy, Bx[10], By[10], ma[22][22]; int vis[22][22][4][4][4][4][4][4][4]; void clean() { ms(vis, 0), ms(Bx, 0), ms(By, 0), ms(ma, 0); } int solve() { scanf(&quot;%d%d&quot;, &amp;Hx, &amp;Hy); clean(); for (int i = 1; i &lt; L; ++i) scanf(&quot;%d%d&quot;, &amp;Bx[i], &amp;By[i]); int k; scanf(&quot;%d&quot;, &amp;k); for (int x, y, i = 1; i &lt;= k; ++i) scanf(&quot;%d%d&quot;, &amp;x, &amp;y), ma[x][y] = 1; // printf(&quot;%.3f\n&quot;, (sizeof vis) / 1048576.0); int fx[10]; ms(fx, 0); for (int i = 0; i &lt; 4; ++i) if ((Bx[1] == Hx + dx[i]) &amp;&amp; (By[1] == Hy + dy[i])) {fx[1] = i; break ;} for (int o = 1; o &lt; L - 1; ++o) { if (Bx[o] == 0 &amp;&amp; By[o] == 0) break ; for (int i = 0; i &lt; 4; ++i) if ((Bx[o + 1] == Bx[o] + dx[i]) &amp;&amp; (By[o + 1] == By[o] + dy[i])) {fx[o + 1] = i; break ;} } // for (int i = 1; i &lt;= 7; ++i) cerr &lt;&lt; fx[i] &lt;&lt; endl; vis[Hx][Hy][fx[1]][fx[2]][fx[3]][fx[4]][fx[5]][fx[6]][fx[7]] = 1; data gg; gg.x = Hx, gg.y = Hy, gg.bs = 0; for (int i = 1; i &lt;= 7; ++i) gg.fx[i] = fx[i]; queue&lt;data &gt; q; q.push(gg); while (!q.empty()) { data p = q.front(); q.pop(); // cerr &lt;&lt; &quot;***&quot; &lt;&lt; p.x &lt;&lt; &quot; &quot; &lt;&lt; p.y &lt;&lt; endl; // for (int i = 1; i &lt;= 7; ++i) cerr &lt;&lt; p.fx[i] &lt;&lt; &quot; &quot;; // cerr &lt;&lt; endl; if (p.x == 1 &amp;&amp; p.y == 1) return printf(&quot;Case %d: %d\n&quot;, ++kse, p.bs), 0; for (int i = 0; i &lt; 4; ++i) { int tx = p.x + dx[i], ty = p.y + dy[i]; if (tx &lt;= 0 || ty &lt;= 0 || tx &gt; n || ty &gt; m) continue ; if (ma[tx][ty] == 1) continue ; // check 1 int nx = p.x, ny = p.y, fl = 0; // cerr &lt;&lt; &quot;!!!&quot; &lt;&lt; tx &lt;&lt; &quot; &quot; &lt;&lt; ty &lt;&lt; endl; for (int j = 1; j &lt; L; ++j) { nx += dx[p.fx[j]], ny += dy[p.fx[j]]; // cerr &lt;&lt; &quot;???&quot; &lt;&lt; nx &lt;&lt; &quot; &quot; &lt;&lt; ny &lt;&lt; endl; if (tx == nx &amp;&amp; ty == ny) {fl = 1; break ;} } if (fl) continue ; // check 2 data gg; gg.x = tx, gg.y = ty, gg.bs = p.bs + 1, ms(gg.fx, 0); for (int j = 2; j &lt; L; ++j) gg.fx[j] = p.fx[j - 1]; for (int j = 0; j &lt; 4; ++j) if (tx + dx[j] == p.x &amp;&amp; ty + dy[j] == p.y) {gg.fx[1] = j; break ;} /* if(tx == 5 &amp;&amp; ty == 1) { cerr &lt;&lt; &quot;Fuck&quot;; for (int i = 1; i &lt;= 7; ++i) cerr &lt;&lt; gg.fx[i] &lt;&lt; &quot; &quot;; cerr &lt;&lt; endl; }*/ if (vis[tx][ty][gg.fx[1]][gg.fx[2]][gg.fx[3]][gg.fx[4]][gg.fx[5]][gg.fx[6]][gg.fx[7]] == 1) continue ; // in queue vis[tx][ty][gg.fx[1]][gg.fx[2]][gg.fx[3]][gg.fx[4]][gg.fx[5]][gg.fx[6]][gg.fx[7]] = 1; // cerr &lt;&lt; vis[5][1][2][1][1][2][2][0][0] &lt;&lt; endl; q.push(gg); } } printf(&quot;Case %d: %d\n&quot;, ++kse, -1); return 0; } } int main() { while (scanf(&quot;%d%d%d&quot;, &amp;flyinthesky::n, &amp;flyinthesky::m, &amp;flyinthesky::L) == 3 &amp;&amp; flyinthesky::n &amp;&amp; flyinthesky::m &amp;&amp; flyinthesky::L) flyinthesky::solve(); return 0; } 第17题 Poj 2248 Addition Chains (迭代加深 DFS)Poj 2248 考虑对于每个位置 $k$ 枚举 $i,j$ 成为 $k$ 位置的值。观察样例，层数不会太大，即 $m$ 不会太大，所以迭代加深搜索即可。剪枝：1、可行性剪枝A：a[i] + a[j] &gt; n 则剪枝2、搜索顺序A：从大到小枚举$i,j$以尽快逼近$n$3、冗余排除A：a[i] + a[j] 相等的不要二次进行分支 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 200; int fl, len, n, a[MAXN]; void dfs(int ith) { bool vis[101]; if (fl) return ; if (ith &gt; len) { if (a[ith - 1] == n) fl = 1; return ; } ms(vis, 0); for (int i = ith - 1; i &gt;= 0; --i) for (int j = ith - 1; j &gt;= 0; --j) { if (fl) return ; if (a[i] + a[j] &gt; n) continue ; if (a[i] + a[j] &lt;= a[ith - 1]) continue ; if (vis[a[i] + a[j]]) continue ; vis[a[i] + a[j]] = 1; a[ith] = a[i] + a[j]; dfs(ith + 1); } } void clean() { fl = 0; len = 1; a[0] = 1; } int solve() { clean(); if(n == 1) {printf(&quot;1\n&quot;); return 0;} while (1) { for (int i = 1; i &lt;= len; ++i) a[i] = 0; a[len] = n; dfs(1); if (fl) { for (int i = 0; i &lt;= len; ++i) printf(&quot;%d &quot;, a[i]); printf(&quot;\n&quot;); break ; } ++len; } return 0; } } int main() { while (scanf(&quot;%d&quot;, &amp;flyinthesky::n) == 1 &amp;&amp; flyinthesky::n) flyinthesky::solve(); return 0; } 第18题 CH 2401 (折半搜索+DFS)CH 2401题意：值域为$2^{31}-1$的01背包。解：暴力即可。折半搜索减半复杂度。将物品分成两半，前一半的答案存进桶/set/map/平衡树里，后一半答案边 DFS 边查询更新合并。剪枝：A: 降序排序B: 适当增加前面一半的物品数量 (只在后半段用二分的话)这里代码用set被卡两个点。知识点：这种搜索爆炸又是搜索的题目就要像到折半搜索。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 45 + 5; LL w, n, g[MAXN], m, ans = 0; set&lt;LL &gt; s; void dfs1(LL a, LL v) { if (v &gt; w) return ; s.insert(-v); if (a &gt; m) return ; dfs1(a + 1, v), dfs1(a + 1, v + g[a]); } void dfs2(LL a, LL v) { if (v &gt; w) return ; set&lt;LL &gt;::iterator it = s.lower_bound(-(w - v)); ans = max(ans, v); if (it != s.end()) if (v + -*it &lt;= w) ans = max(ans, v + -*it); if (a &gt; n) return ; dfs2(a + 1, v), dfs2(a + 1, v + g[a]); } bool cmp(int a, int b) {return a &gt; b;} void clean() { } int solve() { clean(); scanf(&quot;%lld%lld&quot;, &amp;w, &amp;n); for (LL i = 1; i &lt;= n; ++i) scanf(&quot;%lld&quot;, &amp;g[i]); sort(g + 1, g + 1 + n, cmp); m = n / 2 + 2; dfs1(1, 0); dfs2(m + 1, 0); printf(&quot;%lld\n&quot;, ans); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP 贪心训练]]></title>
    <url>%2F%E8%B4%AA%E5%BF%83%E9%A2%98%E4%B8%93%E7%BB%83%2F</url>
    <content type="text"><![CDATA[第1题 CF 867ECF 867E题意：考虑股票市场，一共有$n$天。对于第$i$天，B君知道股票的价格是每单位$a_i$元在每一天，可以选择买入一个单位的股票，卖出一个单位的股票，或者什么都不做。刚开始有无穷多的钱，但是没有任何股票。问$n$天之后最多可以赚多少钱。 解：用大根堆维护。从左往右扫，每次扫到一个数如果不大于当前堆的根，那么直接插。否则就先买(根和当前值)，然后再插两个当前值到堆里。相当于这次卖是一个中转点，不一定最终在这里卖。所以在后面如果有更优解那么将会继承中转点的值，也就是返回思想。 知识点：贪心思想可以用返回、中转点思想。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { int n, t; LL ans = 0; priority_queue&lt;int, vector&lt;int &gt;, greater&lt;int &gt; &gt; q; void clean() { } int solve() { scanf(&quot;%d&quot;, &amp;n); for (int x, i = 1; i &lt;= n; ++i) { scanf(&quot;%d&quot;, &amp;x); if (!q.empty() &amp;&amp; x &gt; q.top()) { ans += (LL)x - (LL)q.top(); q.pop(); q.push(x); } q.push(x); } cout &lt;&lt; ans; return 0; } } int main() { flyinthesky::solve(); return 0; } 第2题 Bzoj 4198Bzoj 4198题意：多叉哈夫曼树。解：按照二叉树方法贪心是错的，最后在根节点会出现节点不够用的情况。所以我们可以修改一下，将下面的节点移到上面。具体是加一堆0点以至于$(n-1) \mod (k-1)=0$(画图分析)。对于第二问，贪心最小合并次数的合并即可， #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;set&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { struct data { LL val, tms; bool operator &lt; (const data &amp;rhs) const { if (val == rhs.val) return tms &gt; rhs.tms; return val &gt; rhs.val; } }; LL n, k, ans, maxd; priority_queue&lt;data &gt; q; void clean() { maxd = ans = 0; } int solve() { clean(); scanf(&quot;%lld%lld&quot;, &amp;n, &amp;k); for (LL x, i = 1; i &lt;= n; ++i) scanf(&quot;%lld&quot;, &amp;x), q.push((data){x, 0}); while ((n - 1) % (k - 1) != 0) q.push((data){0, 0}), ++n; for (LL i = 1; i &lt;= (n - 1) / (k - 1); ++i) { LL tmp1 = 0, tmp2 = 0; for (LL j = 1; j &lt;= k; ++j) { data p = q.top(); q.pop(); tmp1 += p.val, tmp2 = max(tmp2, p.tms); } maxd = max(maxd, tmp2 + 1); ans += tmp1; q.push((data){tmp1, tmp2 + 1}); } printf(&quot;%lld\n%lld\n&quot;, ans, maxd); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP 数学训练]]></title>
    <url>%2F%E6%95%B0%E5%AD%A6%E9%A2%98%E4%B8%93%E7%BB%83%2F</url>
    <content type="text"><![CDATA[第1题 LightOJ - 1027 A Dangerous Maze (期望)LightOJ - 1027 A Dangerous Maze题意：小Q在迷宫中，他站在$n$个门前面，每个门只有两个可能，要么在$A_i$时间后，回到原地，要么在$A_i$时间后离开迷宫。每次他都会随机选择一个门，计算他离开的期望时间。解：设当前期望为$E$如果选择了正数时间，那么期望值为$\frac{A_i}{n}$如果选择了负数时间，那么期望值为$\frac{E-A_i}{n}$，因为浪费了$-A_i$的时间然后让所有负数和为$T_0$，负数个数为$n_0$，正数和为$T_1$，正数个数为$n_1$$E=\frac{T_1}{n}+\frac{n_0E-T_0}{n}$，整理可得$E=\frac{T_1-T_0}{n_1}$，用 GCD 约分一下 知识点：期望的递归定义在处理无法直接用普通式子表达的时候非常好用，最后化简式子即可。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;climits&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { int gcd(int a, int b) { return (b == 0) ? a : gcd(b, a % b); } void clean() {} int solve() { int n, K, T0, T1, N1, kase = 0; cin &gt;&gt; K; clean(); while (K--) { T0 = 0, T1 = 0, N1 = 0; ++kase, cin &gt;&gt; n; for (int x, i = 1; i &lt;= n; i++) { cin &gt;&gt; x; if (x &lt; 0) T0 += x; else T1 += x, ++N1; } int x = -T0 + T1, y = N1; if (y == 0) printf(&quot;Case %d: inf\n&quot;, kase); else { int g = gcd(x, y); printf(&quot;Case %d: %d/%d\n&quot;, kase, x / g, y / g); } } return 0; } } int main() { flyinthesky::solve(); return 0; } 第2题 LightOJ - 1030 Discovering Gold (期望DP)LightOJ - 1030 Discovering Gold题意：有一个直线的金矿，每个点有一定数量的金子；你从$0$开始，每次扔个骰子，扔出几点就走几步，然后把那个点的金子拿走；如果扔出的骰子超出了金矿，就重新扔，知道你站在最后一个点；问拿走金子的期望值是多少解：设$dp(i)$为从$i$到$n$的期望值，则$dp(i)=\frac{1}{x}\sum dp(i + j) + a_i$，其中$x$是不超出金矿的掷骰子次数。初始化$dp(i)=a_i$答案是$dp(1)$。注意本题正推有问题，无法保证$dp(n)$由$1$推来。我们类比飞行棋那题，发现那题因为出现了航线所以不能倒推，否则能倒推。并且本题因为不能掷骰子的数大于$n$，所以不能像飞行棋那题一样全部概率为定值，在边缘的概率不一样。知识点：1、要看期望DP的状态是否从无效状态推向有效来确定枚举顺序2、每一步概率和为1，否则有错 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;climits&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; int kase = 0; namespace flyinthesky { int n, a[105]; db dp[105]; void clean() { ms(dp, 0); } int solve() { cin &gt;&gt; n; clean(); for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i], dp[i] = a[i]; for (int i = n - 1; i &gt;= 1; i--) { db tmp = 0.0; int tms = 0; for (int j = 1; j &lt;= 6; j++) { if (i + j &lt;= n) tmp += dp[i + j], ++tms; } dp[i] = tmp / (db)tms + a[i]; } printf(&quot;Case %d: %.7f\n&quot;, ++kase, dp[1]); return 0; } } int main() { int T; cin &gt;&gt; T; while (T--) flyinthesky::solve(); return 0; } 第3题 Loj 10230/Bzoj 3398 牡牛和牝牛 (组合数学)Loj 10230题意：见上。解：方法1：DP设$dp(i)$表示$i$位置以牡牛结尾的方案数。那么$dp(i)=\sum^{i-k-1}_{j=1} dp(j)$，使$pre(i)=\sum^{i}_{j=1} dp(j)$，那么原转移方程变为$O(n)$，最后输出$pre(n)$即可。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;climits&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL MO = 5000011; LL n, k, dp[100000 + 5], pre[100000 + 5]; void clean() { } int solve() { cin &gt;&gt; n &gt;&gt; k; clean(); pre[0] = dp[0] = 1; for (LL i = 1; i &lt;= n; i++) { dp[i] = pre[max(i - k - 1, 0ll)]; pre[i] = (pre[i - 1] + dp[i]) % MO; //cout &lt;&lt; dp[i] &lt;&lt; &quot; &quot; &lt;&lt; pre[i] &lt;&lt; endl; } cout &lt;&lt; pre[n]; return 0; } } int main() { flyinthesky::solve(); return 0; } 方法2：排列组合考虑枚举当前方案的牡牛只数$i$，可以知道每个犊牛间一定有$k$个牝牛，所以每次将这固定的$(i-1) \cdot k$个牝牛删除，然后再剩下的牛中选$i$个犊牛，将删除的牝牛加回来显然满足条件。所以答案是$C^{i}_{(i-1) \cdot k}$，因为这个组合数范围大不方便二维求出，我们预处理阶乘和阶乘逆元用定义法求解组合数。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;climits&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL MO = 5000011; LL n, k, jc[100000 + 5], jc_inv[100000 + 5]; LL ksm(LL a, LL b) { LL bs = a % MO, ans = 1ll; while (b) { if (b &amp; 1) ans = (ans * bs) % MO; bs = (bs * bs) % MO; b &gt;&gt;= 1ll; } return ans; } LL c(LL n, LL m) { if (m &gt; n) return 0; LL tmp = jc[n]; tmp = (tmp * jc_inv[m]) % MO; tmp = (tmp * jc_inv[n - m]) % MO; return tmp; } void clean() { } int solve() { cin &gt;&gt; n &gt;&gt; k; clean(); jc[0] = jc[1] = 1ll; jc_inv[0] = jc_inv[1] = 1ll; for (int i = 2; i &lt;= n; i++) { jc[i] = (jc[i - 1] * i) % MO; jc_inv[i] = (jc_inv[i - 1] * ksm(i, MO - 2)) % MO; } int ans = 0ll; for (int i = 1; i &lt;= n; i++) { int tmp = n - (i - 1ll) * k; if (tmp &lt; 0) break ; ans = (ans + c(tmp, i)) % MO; } cout &lt;&lt; ans + 1ll; return 0; } } int main() { flyinthesky::solve(); return 0; } 知识点：1、计数问题可以 1 DP 2 组合数学2、DP 方程如果出现了求前缀DP和，可以用前缀和优化3、排列组合中将定下来的东西删除或者添加不影响答案的东西(插板法求有空的部分)可以帮助解题4、预处理能带入$n$就用$n$，防止 TLE 第4题 Loj 10231 方程的解 (组合数学)Loj 10231题意：见上。解：显然插板法求。用快速幂算出$g(x)$，然后答案为$C^{k}_{g(x)}$，注意要高精度。代码没写高精 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;climits&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { LL k, x, c[1005][1005]; LL ksm(LL a, LL b, LL c) { LL bs = a % c, ans = 1ll; while (b) { if (b &amp; 1) ans = (ans * bs) % c; bs = (bs * bs) % c; b &gt;&gt;= 1; } return ans; } void clean() { ms(c, 0); } int solve() { clean(); cin &gt;&gt; k &gt;&gt; x; for (LL i = 0; i &lt;= 1001; ++i) c[i][i] = c[i][0] = 1; for (LL i = 2; i &lt;= 1001; ++i) { for (LL j = 1; j &lt; i; ++j) c[i][j] = c[i - 1][j] + c[i - 1][j - 1]; } /*for (LL i = 0; i &lt;= 10; ++i) { for (LL j = 0; j &lt;= i; ++j) printf(&quot;%I64d%c&quot;, c[i][j], (j == i) ? &#39;\n&#39; : &#39; &#39;); }*/ LL gg = ksm(x, x, 1000ll); //cout &lt;&lt; gg &lt;&lt; endl; cout &lt;&lt; c[gg - 1][k - 1]; return 0; } } int main() { flyinthesky::solve(); return 0; } 第5题 Loj 10232 车的放置 (组合数学)Loj 10232题意：见上。解：方法1：排列组合我们先考虑不被切掉一块的方法，很显然是$C^{n}_{k} \cdot A^{k}_{m}$，其中长为$n$, 宽$m$。 然后我们考虑切一块的方法，我们将它分成两个矩形来处理，然后枚举一个矩形放几个车，设当前枚举到$i$, 则最终答案加上$C^{a}_{i} \cdot A^{i}_{b} \cdot C^{a+c-i}_{k-i} \cdot A^{k - i}_{d}$ 方法2：DP #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;climits&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { LL MO = 100000 + 3; LL a, b, c, d, k, C[2005][2005]; void clean() { ms(C, 0); } int solve() { cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; k; clean(); LL sz = a + c; for (LL i = 0; i &lt;= sz; ++i) C[i][i] = C[i][0] = 1; for (LL i = 2; i &lt;= sz; ++i) for (LL j = 1; j &lt; i; ++j) C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % MO; /*for (LL i = 0; i &lt;= sz; ++i) for (LL j = 0; j &lt;= i; ++j) printf(&quot;%I64d%c&quot;, C[i][j], j == i ? &#39;\n&#39; : &#39; &#39;);*/ LL ans = 0ll; for (LL i = 0; i &lt;= k; ++i) { LL tmp = C[a][i]; for (LL j = b; j &gt;= b - i + 1; --j) tmp = (tmp * j) % MO; tmp = (tmp * C[a + c - i][k - i]) % MO; for (LL j = d; j &gt;= d - (k - i) + 1; --j) tmp = (tmp * j) % MO; ans = (ans + tmp) % MO; } cout &lt;&lt; ans; return 0; } } int main() { flyinthesky::solve(); return 0; } 第6题 LightOJ - 1038 Race to 1 Again (期望DP)LightOJ - 1038 Race to 1 Again题意：给定一个整数$n$, 每次操作可以对当前数进行除以它的某个因子。除以哪个因子是随机的，求把$n$变成$1$的期望步数。解：设$dp(i)$为$i$除到$1$的期望步数。则$dp(i)=\frac{dp(a_1)+dp(a_2)+…+dp(a_n)}{m}+1$，其中$a_n | i$，我们将右边的$dp(i)$拿过来以后式子变为$dp(i)=\frac{dp(a_1)+dp(a_2)+…+dp(a_{n-1})+m}{m-1}$然后DP即可，先进行DP后$O(1)$询问。 知识点：1、这题使用了记忆化打表的思想2、期望DP式子右边有$dp(i)$就移到左边3、期望DP不要忘了转移花费 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;climits&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { int n, p[100005], sz; //p[index] = val, sz is index db dp[100005]; //dp[val] = expected number void clean() { } int solve() { clean(); dp[1] = 0.0; for (int x = 2; x &lt;= 100000; ++x) {// x is val sz = 0; for (int i = 1; i * i &lt;= x; ++i) { // i is val, x / i is val if (x % i == 0) p[++sz] = i; if (i != (x / i) &amp;&amp; x % (x / i) == 0) p[++sz] = x / i; } for (int i = 1; i &lt;= sz; ++i) dp[x] += dp[p[i]]; // i is index dp[x] += sz, dp[x] /= (db)(sz - 1); } int T, kase = 0; scanf(&quot;%d&quot;, &amp;T); while (T--) { cin &gt;&gt; n; printf(&quot;Case %d: %.8f\n&quot;, ++kase, dp[n]); } return 0; } } int main() { flyinthesky::solve(); return 0; } 第7题 Bzoj 3505 输三角形 (组合数学)Bzoj 3505 第8题 LightOJ - 1079 Just another Robbery (概率背包DP)题意：XX想抢银行，当危险率低于$P$的时候才能行动，现在给出每家银行的金钱$m_i$和危险率$p_i$，求最多能获得多少金钱。解：设$dp(i,j)$为前$i$个银行抢$j$元钱的不被抓概率。$dp(i,j)=min(dp(i-1,j-w_i) \cdot (1-p_i))$转移即可知识点：1、设概率求期望2、正难则反思想 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;climits&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; int kase = 0; namespace flyinthesky { const db INF = 1000000000.0, eps = 1e-9; const int MAXV = 10005; db maxP, p[105], dp[10010]; int n, w[105]; void clean() { for (int i = 0; i &lt;= MAXV; ++i) dp[i] = -INF; } int solve() { scanf(&quot;%lf%d&quot;, &amp;maxP, &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d%lf&quot;, &amp;w[i], &amp;p[i]); clean(); dp[0] = 1.0; for (int i = 1; i &lt;= n; ++i) { for (int j = MAXV; j &gt;= w[i]; --j) { dp[j] = max(dp[j], dp[j - w[i]] * (1 - p[i])); } } int ans = 0; for (int j = MAXV; j &gt;= 0; --j) { db tmp = 1.0 - dp[j]; if (maxP - tmp &gt; -eps) { ans = j; break; } } printf(&quot;Case %d: %d\n&quot;, ++kase, ans); return 0; } } int main() { int T; scanf(&quot;%d&quot;, &amp;T); while (T--) flyinthesky::solve(); return 0; } 第9题 LightOJ - 1265 Island of Survival (期望)LightOJ - 1265 Island of Survival题意：有$ t $只老虎，$ d $只鹿，还有一个人，每天都要有两个生物碰面，现在有以下规则：老虎不管碰到谁都吃掉，同类的话就同归于尽。问人存活下来的概率。解：如果老虎有奇数只，那么老虎绝对可以把人吃掉，概率为0如果老虎有偶数只，那么老虎可以两两吃掉，并且人遇到鹿不会死，所以人存活的概率和鹿没关系。所以我们从$t+1$个生物中选1个出来当做幸存者，那么人存活概率为$\frac{1}{t+1}$ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #define LL long long #define db double #define ms(i, j) memset(i, j, sizeof i) using namespace std; namespace flyinthesky { void clean() { } int solve() { clean(); int kase = 0, T; scanf(&quot;%d&quot;, &amp;T); while (T--) { int t, d; scanf(&quot;%d%d&quot;, &amp;t, &amp;d); if (t % 2 == 0) printf(&quot;Case %d: %.8f\n&quot;, ++kase, 1.0 / (t + 1.0)); else printf(&quot;Case %d: 0\n&quot;, ++kase); } return 0; } }; int main() { flyinthesky::solve(); return 0; } 第10题 LightOJ - 10228 Discovering Gold (Lucas 定理)#10228. 「一本通 6.6 例 3」组合题意：见上。解：发现 $ m $ 很小，我们用组合数阶乘定义式两边求，即先乘$(n-m+1)$到$n$，再除$m!$。然后因为 $ p $ 不一定和所要求逆元的数互质，所以我们要用 Lucas 定理来求，因为 Lucas 保证了每次的组合数$n, m$小于 $p$，并且$p$为质数，所以不会有不互质的情况。知识点： Lucas 定理可以用来求模数和被求逆元数不互质下的组合数公式。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;map&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { LL n1, m1, p; LL ksm(LL a, LL b) { LL bs = a % p, ans = 1ll; while (b) { if (b &amp; 1) ans = (ans * bs) % p; bs = (bs * bs) % p; b &gt;&gt;= 1; } return ans; } LL C(LL n, LL m) { LL ans = 1ll, ni = 1ll; for (LL i = n - m + 1; i &lt;= n; ++i) ans = (ans * i) % p; for (LL i = 2; i &lt;= m; ++i) ni = (ni * ksm(i, p - 2)) % p; return (ans * ni) % p; } LL lucas(LL n, LL m) { if (m == 0) return 1; return (C(n % p, m % p) * lucas(n / p, m / p)) % p; } void clean() { } int solve() { clean(); cin &gt;&gt; n1 &gt;&gt; m1 &gt;&gt; p; cout &lt;&lt; lucas(n1, m1) &lt;&lt; endl; return 0; } } int main() { int T; scanf(&quot;%d&quot;, &amp;T); while (T--) flyinthesky::solve(); return 0; } 第11题 Poj 1845 (分治+分解质因数+约数和公式 / 逆元讨论)Poj 1845题意：求$A^B$因子和。解：这里主要讲讲等比数列求和方法。可以用逆元，但是模的质数太小可能有倍数关系不存在逆元，但是可以通过同余来化简特判没逆元的情况。也可以在$log(c)$的时间内分治求解, 具体看算法竞赛进阶指南上的解析，注意分治边界特判 注意$B=0$ #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL MO = 9901; LL A, B, pri[50000000 + 5], cnt[50000000 + 5], tot; LL ksm(LL a, LL b) { LL bs = a % MO, ans = 1ll; while (b) { if (b &amp; 1) ans = (bs * ans) % MO; bs = (bs * bs) % MO; b &gt;&gt;= 1; } return ans; } LL sum(LL n, LL q) { if (n == 0) return 0; if (n == 1) return q + 1; if (n == 2) return q + 1 + q * q; if (n % 2 == 1) { return (1ll + ksm(q, (n + 1) &gt;&gt; 1)) * sum((n - 1) &gt;&gt; 1, q) % MO; } else { LL qtmp = ksm(q, n &gt;&gt; 1); LL qtmp2 = ksm(q, (n &gt;&gt; 1) + 1); return (qtmp + ((qtmp2 + 1ll) * sum((n &gt;&gt; 1) - 1, q) % MO)) % MO; } } void clean() { tot = 0; } int solve() { cin &gt;&gt; A &gt;&gt; B; if (B == 0) return cout &lt;&lt; 1 &lt;&lt; endl, 0; clean(); for (LL i = 2; i * i &lt;= A; ++i) { if (A % i == 0) { pri[++tot] = i; while (A % i == 0) A /= i, ++cnt[tot]; } } if (A != 1) ++cnt[++tot], pri[tot] = A; LL ans = 1ll; for (LL i = 1; i &lt;= tot; ++i) { ans = (ans * sum(cnt[i] * B, pri[i])) % MO; } cout &lt;&lt; ans; return 0; } } int main() { flyinthesky::solve(); return 0; } 第12题 P1365 WJMZBMR打osu! / EasyWJMZBMR打osu! / Easy 利用两个数组DP，期望值计算 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;queue&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { int n; db f[300000 + 5], g[300000 + 5]; char s[300000 + 5]; void clean() { } int solve() { clean(); cin &gt;&gt; n; scanf(&quot;%s&quot;, s + 1); for (int i = 1; i &lt;= n; ++i) { if (s[i] == &#39;o&#39;) f[i] = f[i - 1] + 2.0 * g[i - 1] + 1.0, g[i] = g[i - 1] + 1.0; else if (s[i] == &#39;x&#39;) f[i] = f[i - 1], g[i] = 0.0; else f[i] = f[i - 1] + g[i - 1] + 0.5, g[i] = (g[i - 1] + 1) / 2.0; } printf(&quot;%.4f\n&quot;, f[n]); return 0; } } int main() { flyinthesky::solve(); return 0; } 第13题 CF 1154 G. Minimum Possible LCMCF 1154 G. Minimum Possible LCM 可以枚举因数$d$，然后$O(n\ln n)$去找，然后算第一个和第二个的$\text{lcm}$即可，具体可以容易证明。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;queue&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 1000000 + 5; LL n, a[MAXN], vis[10000000 + 5], ans = 1e18; LL g1, g2; LL gcd(LL a, LL b) {return b != 0 ? gcd(b, a % b) : a;} LL lcm(LL a, LL b) {return a * b / gcd(a, b);} void clean() { } int solve() { clean(); cin &gt;&gt; n; for (LL i = 1; i &lt;= n; ++i) { scanf(&quot;%lld&quot;, &amp;a[i]); if (vis[a[i]]) { if (ans &gt; a[i]) ans = a[i], g1 = vis[a[i]], g2 = i; } vis[a[i]] = i; } for (LL d = 1; d &lt;= 10000000; ++d) { if (d &gt;= ans) break ; LL h1 = 0, h2 = 0; for (LL j = d; j &lt;= 10000000; j += d) { if (vis[j]) { if (!h1) h1 = j; else if (!h2) h2 = j; else break; } } if (h1 &amp;&amp; h2) { if (lcm(h1, h2) &lt; ans) ans = lcm(h1, h2), g1 = vis[h1], g2 = vis[h2]; } } if (g1 &gt; g2) swap(g1, g2); cout &lt;&lt; g1 &lt;&lt; &quot; &quot; &lt;&lt; g2 &lt;&lt; endl; return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>概率DP</tag>
        <tag>组合数学</tag>
        <tag>期望</tag>
        <tag>Lucas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hdu 1573(扩展中国剩余定理)]]></title>
    <url>%2Fhdu1573%2F</url>
    <content type="text"><![CDATA[Hdu 1573题意：求同余方程组小于某数的解的个数。 利用中国剩余定理求出最小一个整数解，因为模数不互质，要一一合并。由于解有周期性，用最大限度值减去最小解除以周期即为答案，但是要记住正整数解不包括0，所以如果最小解为0要舍弃。即如果最小解不在$(0, n]$范围内则整个同余方程组无解。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #defin#include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; LL n, m, mi[20], ai[20]; LL gcd(LL a, LL b) { if (b == 0) return a; return gcd(b, a % b); } LL lcm(LL a, LL b) {return a * b / gcd(a, b);} void exgcd(LL a, LL b, LL &amp;x, LL &amp;y) { if (b == 0) { x = 1, y = 0; return ; } exgcd(b, a % b, x, y); LL tmp = x; x = y, y = tmp - a / b * y; } void clean() {} int solve() { scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m); clean(); for (LL i = 1; i &lt;= m; i++) scanf(&quot;%lld&quot;, &amp;mi[i]); for (LL i = 1; i &lt;= m; i++) scanf(&quot;%lld&quot;, &amp;ai[i]); for (LL i = 2; i &lt;= m; i++) { LL x1, x2, a = mi[i - 1], b = mi[i], c = ai[i] - ai[i - 1]; LL g = gcd(a, b); if (c % g != 0) { return printf(&quot;0\n&quot;), 0; } a /= g, b /= g, c /= g; exgcd(a, b, x1, x2); b = (b &gt; 0) ? b : -b; x1 = (x1 * c % b + b) % b; ai[i] = ai[i - 1] + mi[i - 1] * x1; mi[i] = lcm(mi[i], mi[i - 1]); } LL x1, x2, a = 1, b = -mi[m], c = ai[m]; LL g = gcd(a, b); if (c % g != 0) { return printf(&quot;0\n&quot;), 0; } a /= g, b /= g, c /= g; exgcd(a, b, x1, x2); b = (b &gt; 0) ? b : -b; x1 = (x1 * c % b + b) % b; LL ans = (n - x1) / b; if (x1 != 0 &amp;&amp; x1 &lt;= n) ans++; printf(&quot;%lld\n&quot;, ans); return 0; } int main() { int T; scanf(&quot;%d&quot;, &amp;T); while (T--) solve(); return 0; }]]></content>
      <categories>
        <category>Hdu</category>
      </categories>
      <tags>
        <tag>中国剩余定理</tag>
        <tag>Hdu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hdu 3579(扩展中国剩余定理)]]></title>
    <url>%2Fhdu3579%2F</url>
    <content type="text"><![CDATA[poj 3579 模数不互质的中国剩余定理模板，证明见此 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; LL kase, n, mi[10], ai[10]; LL gcd(LL a, LL b) { if (b == 0) return a; return gcd(b, a % b); } LL lcm(LL a, LL b) { return a * b / gcd(a, b); } void exgcd(LL a, LL b, LL &amp;x, LL &amp;y) { if (b == 0) { x = 1, y = 0; return ; } exgcd(b, a % b, x, y); LL tmp = x; x = y, y = tmp - (a / b) * y; } void clean() {} int solve() { scanf(&quot;%lld&quot;, &amp;n); clean(); LL fl = false; for (LL i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;mi[i]); for (LL i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;ai[i]); LL ll = mi[1];//所有的lcm for (LL i = 2; i &lt;= n; i++) {//合并n-1次 ll = lcm(ll, mi[i]); LL x1, x2, a = mi[i - 1], b = mi[i], c = ai[i] - ai[i - 1]; LL g = gcd(a, b); if (c % g != 0) {fl = true; break;} a /= g, b /= g, c /= g; exgcd(a, b, x1, x2); b = (b &gt; 0) ? b : -b; x1 = (x1 * c % b + b) % b; mi[i] = lcm(mi[i], mi[i - 1]); ai[i] = ai[i - 1] + mi[i - 1] * x1; } if (fl) printf(&quot;Case %lld: -1\n&quot;, kase); else {//计算最后一个 LL x1, x2, a = 1, b = -mi[n], c = ai[n]; LL g = gcd(a, b); a /= g, b /= g, c /= g; exgcd(a, b, x1, x2); b = (b &gt; 0) ? b : -b; x1 = (x1 * c % b + b) % b; if (x1 == 0) { printf(&quot;Case %lld: %lld\n&quot;, kase, ll); } else printf(&quot;Case %lld: %lld\n&quot;, kase, x1); } return 0; } int main() { kase = 0; LL T; scanf(&quot;%lld&quot;, &amp;T); while (T--) kase++, solve(); return 0; }]]></content>
      <categories>
        <category>Hdu</category>
      </categories>
      <tags>
        <tag>中国剩余定理</tag>
        <tag>Hdu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Manacher 学习笔记]]></title>
    <url>%2FszManacher%2F</url>
    <content type="text"><![CDATA[模板及讲解Manacher是什么Manacher 算法是用于算一个字符串最长回文子串长度的一个算法，其时间复杂度为$O(n)$ Manacher的实现例题：Luogu: (模板)manacher算法 给出一个只由小写英文字符组成的字符串S， 字符串长度为n，求S中最长回文串的长度 暴力1、直接枚举区间判回文串，$O(n^3)$ 2、由于回文串关于中间点/中间点的线，枚举对称轴向两边扩展分奇偶讨论即可，$O(n^2)$ Manacher因为字符串有奇有偶，所以我们要进行操作免除奇偶性讨论，我们在0处加一个’\$’, 最后面加’\0’，中间每个字符之间加’#’，即可将除了头尾两个字符以外的字符串长度都变成奇数个。例如abca可以变为\$#a#b#c#a#\0’，则变为奇数个，对称中心为中间那个字符。我们设$p_i$为以$i$为对称中心，最长的回文半径长度。#a#b#b#b#a#中间的字符的$p_i$值为6，则$p_i-1$的值是以$i$为对称中心的最长回文子串长度。设$mr$为回文串最右能触及到的地方，$pos$为这个回文串的对称中心位置。 步骤：1、给$p_i$赋初值 2、向两边扩展 3、更新$mr$和$pos$ 给$p_i$赋初值, 下面分两种情况讨论；1、$i$在$mr$左边 $j=2 \cdot pos - i $为$i$关于$pos$的对称点。 当$j$的回文子串很小不超过左半区间时，我们令$p_i=p_j$，如下图(根据对称性，$i$的回文子串一定包含$j$的回文子串) 当$j$的回文子串很大超过左半区间时，我们只能确定$p_i=mr-i$ 2、$i$在$mr$右边此时$i$没有对称的$j$给它赋值，只能$p_i=1$ 然后扩展字符串，之后不要忘记更新$mr, pos$的值，因为我们要使得$mr$更大，才能更多调用$p_i=p_j$ 代码例题：Luogu: (模板)manacher算法 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 11000000 + 5; char s_old[MAXN], s[MAXN * 2];//旧数组，新数组 int n, cnt, pos, mr, p[MAXN * 2];//n，新数组长度cnt，pos，mr，以i为对称轴最长回文半径长度p int manacher() { int ret = 0; for (int i = 1; i &lt;= cnt; i++) { if (i &lt; mr) p[i] = min(p[2 * pos - i], mr - i); else p[i] = 1;//对称性继承 while (s[i + p[i]] == s[i - p[i]]) p[i]++;//向两边扩展 ，不用判边界因为 前有$后有\0 if (i + p[i] - 1 &gt; mr) mr = i + p[i] - 1, pos = i;//更新mr，注意用 i + p[i] - 1更新 ret = max(ret, p[i] - 1);//更新答案 } return ret; } void clean() { mr = -1, cnt = 1; } int solve() { clean(); n = strlen(s_old), s[0] = &#39;$&#39;, s[1] = &#39;#&#39;; for (int i = 0; i &lt; n; i++) s[++cnt] = s_old[i], s[++cnt] = &#39;#&#39;; s[cnt + 1] = &#39;\0&#39;;//处理字符串，前加$后加\0 printf(&quot;%d\n&quot;, manacher()); return 0; } int main() { scanf(&quot;%s&quot;, s_old), solve(); return 0; } 常见题型1、求最长回文子串Q：给出一个只由小写英文字符组成的字符串S， 字符串长度为n，求S中最长回文串的长度解：见解析例题：Luogu: (模板)manacher算法]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>算法笔记</tag>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单调队列/单调栈 学习笔记]]></title>
    <url>%2Fsz%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E5%8D%95%E8%B0%83%E6%A0%88%2F</url>
    <content type="text"><![CDATA[模板及讲解单调队列单调队列是什么单调队列是一个双端队列两边都可以支持删除，并且队列里的数据都是单调的队列。单调队列可以方便查询距离当前位置左边一段连续区间最大最小值，常用于DP优化等单调性问题。类似滑动窗口。 单调队列的实现以单调递增(维护最小值)的单调队列为例。 1、建立一个队列，都指向数组第一个位置。2、加入数据$9,11,20$3、之后加入$10$，序列为$(9,11,20,10)$ ，显然单调性被破坏4、我们把比$10$大或者等于$10$的数都删除，最后得到的序列是$(9, 10)$，恢复了单调性，最左边元素即为最小值 这就是单调队列的一般步骤了，如果有长度限制，还要在处理前判断左边元素是否超出范围，超出则要删除。 代码Bzoj 2442, 单调队列优化DP注意队列数组开两倍，que[l]和l的区别 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 100000 + 5; int n, k; LL tot, ei[MAXN], dp[MAXN], que[MAXN * 2]; void clean() { tot = 0; ms(dp, 0), ms(que, 0); } void solve() { clean(); for (int i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;ei[i]), tot += ei[i]; int l = 1, r = 1; dp[0] = 0; for (int i = 1; i &lt;= n; i++) { while (l &lt;= r &amp;&amp; que[l] &lt; i - k - 1) l++; dp[i] = dp[que[l]] + ei[i]; while (l &lt;= r &amp;&amp; dp[que[r]] &gt;= dp[i]) r--; que[++r] = i; } LL mn = 1000000000000000000; for (int i = n - k; i &lt;= n; i++) mn = min(mn, dp[i]); printf(&quot;%lld\n&quot;, tot - mn); } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;k), solve(); return 0; } 单调栈单调栈是什么单调栈是一个栈内元素单调的栈。与单调队列相似，但是只有一边删除。 单调栈的实现以从底到顶单调递增(维护最大值)的单调栈为例。 1、建立一个栈，都指向数组第一个位置。2、加入数据$9,11,20$3、之后加入$10$，序列为$(9,11,20,10)$ ，显然单调性被破坏4、我们把比$10$大或者等于$10$的数都删除，最后得到的序列是$(9, 10)$，恢复了单调性，最上边元素即为最大值 代码bzoj 1660 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long using namespace std; const int MAXN = 80000 + 5; int n, hi[MAXN], top, stk[MAXN]; void clear() { top = 0; } void init() { clear(); for (int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;, &amp;hi[i]); } void solve() { LL ans = 0; for (int i=1;i&lt;=n;i++) { if (hi[i]&lt;stk[top]) { ans += top; } else { while (top&amp;&amp;hi[i]&gt;=stk[top]) top--; ans += top; } stk[++top] = hi[i]; } printf(&quot;%lld\n&quot;, ans); } int main() { while (scanf(&quot;%d&quot;, &amp;n)==1&amp;&amp;n) init(), solve(); return 0; } 常见题型1、单调队列优化DPQ：bzoj2442解：bzoj2442例题：bzoj 24422、单调栈维护i周围比i小的数Q：bzoj1660解：bzoj1660例题：bzoj 1660]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>单调队列</tag>
        <tag>单调栈</tag>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 950D(模拟)]]></title>
    <url>%2FCodeforces950D%2F</url>
    <content type="text"><![CDATA[Codeforces 950D题意：最开始$n$个数字中的数字$i$在位置$2 \cdot i-1$，之后从右向左依次用数字将该列填充。最后$q$个$query$问你$pos$为$x_i$该填上什么数字。 可以发现奇数位的数字不会改变，然后只需要考虑偶数位是哪里移过来的。考虑还原，当偶数位$x$的数被移动时，它的右边一定有$x / 2$个未移动的数，所以是从$x+x/2$移动过来的如果当前还原操作位置已经是奇数，输出$(x+1)/2$Codeforces Submission #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #include&lt;set&gt; #include&lt;iostream&gt; using namespace std; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define pr pair&lt;int, int&gt; #define fir first #define sec second #define mp make_pair LL n, q; void clean() { } int solve() { clean(); while (q--) { LL x; cin &gt;&gt; x; while (1) { if (x &amp; 1) { cout &lt;&lt; (x + 1) / 2 &lt;&lt; endl; break; } x += n - x / 2; } } return 0; } int main() { cin &gt;&gt; n &gt;&gt; q, solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 基础知识]]></title>
    <url>%2Fsz_c%2B%2B_%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[(项目向)，作为 OI 一些不常用的东西的补充。 流操作(iomanip.h)具体操作见书 函数函数参数初始化int example(int x, int y = 7, int z = 10) { return x + y + z; } example(2);//调用 以下写法是错误的，只能将初始化的参数放在右边 int error(int x, int y = 10, int z) { return x + y + z; } static变量方式： static int a; 定义的a不会因为退出函数而消失，而是在整个程序完成后才消失 指针定义int *a, *b;//定义了两个int类型指针 指针赋值(地址)int i = 10; a = &amp;i;//&amp;i取地址 指针对应值int value = *a; 常量指针不能改变内存指向： int *const p = &amp;a; 不能改变值： int const *p = &amp;a; 不能改变内存指向、也不能改变值： int const *const p = &amp;a; 指针函数int max(int a, int b) {return a &gt; b ? a : b;} int min(int a, int b) {return a &gt; b ? b : a;} int (*func)(int, int); func = &amp;max; cout &lt;&lt; func(3, 6) &lt;&lt; endl; func = &amp;min; cout &lt;&lt; func(3, 6) &lt;&lt; endl; 引用右值引用 (C++11)int get() {int a = 9; return a;} int &amp;&amp;k = get() + 4; //int &amp;k = get() + 4;是错误的 Struct和枚举类型枚举类型enum dog{Taidi, Jinmao, Hashiqi}; 并且默认 enum dog{Taidi=0, Jinmao=1, Hashiqi=2}; 可以人为修改，只修改部分则后面按顺序单调增长 类型推导 (C++11)Type k = sv; decltype(k) p = sv; union共用体union { int i; char ch; double db; }u; union mn{ int i; char ch; double db; }u; 相当于只有一个值可用，就是最后赋值的值，不是三个值的struct 面向对象类和对象构造函数class a { int x, y; a(){//构造函数 x = 1, y = 0; } a(int x, int y){//重载构造函数 this-&gt;x = x, this-&gt;y = y; } }; 析构函数析构函数：没有返回值没有参数 销毁时调用 class a { int x, y; a(){//构造函数 x = 1, y = 0; } a(int x, int y){//重载构造函数 this-&gt;x = x, this-&gt;y = y; } ~a() {//析构函数 没有返回值没有参数 销毁时调用 x = 888, y = 888; } }; 访问public：公开private：私有，仅本类可用protected：私有，派生类可用 友元class b { int u, v; }; int whw(a hh) {return hh.x + hh.y;} class a { private: int x, y; friend class b;//友元类 friend int whw(a hh);//友元函数 }; 继承定义class a { protected: int x, y; }; class b : public a {};//b是a的派生类 //public：基类是什么就是什么 //private：不能访问基类private //protected：所有基类的public，protected都继承为protected 构造/析构函数访问顺序构造函数：由父类到子类析构函数：由子类到父类 父类构造函数有参数情况class a { private: int x, y; protected: a(int u, int v) {x = u, y = v;} }; class b : public a { b(int u, int v) : a(u, v) {}//显示调用父类构造函数 };]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 912D(期望+BFS)]]></title>
    <url>%2FCodeforces912D%2F</url>
    <content type="text"><![CDATA[Codeforces 912D题意：有一个$n \times m$的鱼塘，有一张$r \times r$的渔网，现在往池塘里面放$k$条鱼(每个格子只能放一条鱼)， 现在撒网的地方是随机的(必须在池塘内)，问能捕的鱼的期望值最大是多少？ 原题的期望值为$$\frac{\sum max_k(f(i,j))}{(n - r + 1)(m - r + 1)}$$其中$f(i,j)$为$r \times r$的网在鱼塘$(i,j)$点上总共会撒的次数，$max_k$表示最大的$k$个数 然后可以证明从中间开始是最优的，我们可以BFS来模拟这个过程，但是要用一个优先队列保证每次取的都是最大值 代码中的$cal$就是上述公式的$f$函数Codeforces Submission #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #include&lt;set&gt; #include&lt;iostream&gt; using namespace std; #define ms(i, j) memset(i, j, sizeof i) #define ll long long #define db double #define pr pair&lt;int, int&gt; #define fir first #define sec second #define mp make_pair const ll dx[4] = {1, 0, -1, 0}; const ll dy[4] = {0, 1, 0, -1}; ll n, m, r, k; set&lt;pr&gt; s; struct data { ll x, y, v; bool operator &lt; (const data &amp;b) const { return v &lt; b.v; } }; priority_queue&lt;data&gt; q; ll cal(ll i, ll j) { return 1ll * (min(i, n - r + 1ll) - max(1ll, i - r + 1ll) + 1ll) * (min(j, m - r + 1ll) - max(1ll, j - r + 1ll) + 1ll); } void clean() { } int solve() { clean(); if (n == 1 || m == 1) { printf(&quot;%.10f\n&quot;, (db)k / (db)((db)n * (db)m)); return 0; } ll fz = 0, fm = (n - r + 1) * (m - r + 1); q.push((data){(n + 1) / 2, (m + 1) / 2, cal((n + 1) / 2, (m + 1) / 2)}); s.insert(mp((n + 1) / 2, (m + 1) / 2)); while (!q.empty()) { data p = q.top(); q.pop(); fz += p.v; k--; if (!k) break; for (ll i = 0; i &lt; 4; i++) { ll tx = p.x + dx[i], ty = p.y + dy[i]; if (tx &gt; 0 &amp;&amp; ty &gt; 0 &amp;&amp; tx &lt;= n &amp;&amp; ty &lt;= m &amp;&amp; !s.count(mp(tx, ty))) { q.push((data){tx, ty, cal(tx, ty)}); s.insert(mp(tx, ty)); } } } printf(&quot;%.10f\n&quot;, (db)fz / (db)fm); return 0; } int main() { cin &gt;&gt; n &gt;&gt; m &gt;&gt; r &gt;&gt; k, solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>Codeforces</tag>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 922D(贪心)]]></title>
    <url>%2FCodeforces922D%2F</url>
    <content type="text"><![CDATA[Codeforces 922D题意：已知n个字符串只含s和h 对着n个字符串进行排序组成新的一串字符 使得新字符串中子序列是sh的数目最多 贪心，s自然要放在前面，所以s比重大的字符串要放在前面，差值是不行的 Codeforces Submission #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #include&lt;set&gt; #include&lt;iostream&gt; using namespace std; #define ms(i, j) memset(i, j, sizeof i) #define ll long long #define db double int n; struct data { string s; int ns, nh; double cha; bool operator &lt; (const data &amp;b) const { return cha &gt; b.cha; } }t[100000 + 5]; string ss; void clean() { } int solve() { clean(); for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; t[i].s; int len = t[i].s.length(); t[i].ns = 0, t[i].nh = 0; for (int j = 0; j &lt; len; j++) { if (t[i].s[j] == &#39;s&#39;) t[i].ns++; else if (t[i].s[j] == &#39;h&#39;) t[i].nh++; } if (t[i].nh == 0) t[i].cha = 1e11; else t[i].cha = (db)t[i].ns / (db)t[i].nh; } sort(t + 1, t + 1 + n); for (int i = 1; i &lt;= n; i++) ss += t[i].s; int len = ss.length(); ll ans = 0, ns = 0, nh = 0; for (int i = 0; i &lt; len; i++) { if (ss[i] == &#39;s&#39;) ns++; if (ss[i] == &#39;h&#39;) nh++, ans += ns; else nh = 0; } printf(&quot;%I64d\n&quot;, ans); return 0; } int main() { cin &gt;&gt; n, solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 934D(数学)]]></title>
    <url>%2FCodeforces934D%2F</url>
    <content type="text"><![CDATA[Codeforces 934D题意：给出$k,p$, 求多项式$f(x)$使得$f(x) = q(x) \cdot (x + k) + p$成立，输出$f(x)$多项式系数(系数必须为非负数以及小于$k$) 方法1：设$f(x)$和$q(x)$的系数，代换后发现$p$是进制形式的多项式，所以直接转化$p$为$-k$进制数即可方法2：余式定理。$f(x)$除以$(x-k)$的多项式余数为$f(k)$，则$f(x)$除以$(x+k)$的多项式余数为$p$，所以$f(-k)=p$，可以将$p$转化为$-k$进制的数即可 注意：负进制的除法要严格向下取整。(默认靠0)。并且系数都要大于0，模时注意 Codeforces Submission #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; using namespace std; #define ms(i, j) memset(i, j, sizeof i) #define ll long long #define db double ll p, k; vector&lt;int&gt; vec; void clean() { } int solve() { clean(); while (p != 0) { vec.push_back((p % k + k) % k); p = (vec.back() - p) / k; } printf(&quot;%d\n&quot;, vec.size()); for (int i = 0; i &lt; (int)vec.size(); i++) printf(&quot;%d &quot;, vec[i]); return 0; } int main() { scanf(&quot;%I64d%I64d&quot;, &amp;p, &amp;k), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 938D(Dij解带环DP)]]></title>
    <url>%2FCodeforces938D%2F</url>
    <content type="text"><![CDATA[Codeforces 938D题意：给出一张无向带点权带边权图，你需要对于每个点$i$求出$min(2dis_{i,j}+1|j \in E(i, j))$ 此做法不是最短路的思路，只是利用dij的松弛来解带环DP显然这题的转移方程如题所示。 Codeforces Submission #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; using namespace std; #define ms(i, j) memset(i, j, sizeof i) #define ll long long const int MAXN = 2e5 + 5; ll n, m, en, dis[MAXN], vis[MAXN]; struct edge { ll v, w; }ed[MAXN * 2]; struct node { ll no, w; bool operator &lt; (const node &amp;b) const { return w &gt; b.w; } }; vector&lt;int&gt; G[MAXN]; void ins(ll u, ll v, ll w) { en++, ed[en] = (edge){v, w}, G[u].push_back(en); en++, ed[en] = (edge){u, w}, G[v].push_back(en); } void clean() { ms(vis, 0), en = 0; } ll solve() { clean(); for (ll i = 1; i &lt;= m; i++) { ll u, v, w; scanf(&quot;%I64d%I64d%I64d&quot;, &amp;u, &amp;v, &amp;w); ins(u, v, w &lt;&lt; 1); } priority_queue&lt;node &gt; q; for (ll i = 1; i &lt;= n; i++) scanf(&quot;%I64d&quot;, &amp;dis[i]), q.push((node){i, dis[i]}); while (!q.empty()) { node p = q.top(); q.pop(); if (vis[p.no]) continue; vis[p.no] = true; for (ll i = 0; i &lt; (ll)G[p.no].size(); i++) { ll v = ed[G[p.no][i]].v, w = ed[G[p.no][i]].w; if (dis[p.no] + w &lt; dis[v]) { dis[v] = dis[p.no] + w; q.push((node){v, dis[v]}); } } } for (ll i = 1; i &lt;= n; i++) printf(&quot;%I64d &quot;, dis[i]); return 0; } int main() { scanf(&quot;%I64d%I64d&quot;, &amp;n, &amp;m), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>Codeforces</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bzoj 2120(带修莫队)]]></title>
    <url>%2Fbzoj2120%2F</url>
    <content type="text"><![CDATA[Bzoj 2120带修莫队基础题，见此处讲解 #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; using namespace std; #define ms(i, j) memset(i, j, sizeof i) #define ll long long const int MAXN = 10000 + 5; int n, m, bl[MAXN], totblo, n_q, n_u, ai[MAXN], oai[MAXN], ans[MAXN], lst[MAXN], tax[1000000 + 5]; //n_q, n_u分别为q，u数组大小(询问，修改个数) //oai为原数组，lst为该位置现在的值是哪个修改修改的(没有修改为0) //tax为桶 struct query {//询问 int l, r, t, id; //t为时间戳 bool operator &lt; (const query &amp;b) const {//带修莫队排序 if (bl[l] == bl[b.l]) return (bl[r] == bl[b.r] ? t &lt; b.t : r &lt; b.r); return bl[l] &lt; bl[b.l]; } }q[MAXN]; struct update {//修改 int p, col, lst;//位置、颜色、上一个该位置(p)的修改 (没有修改为0) }u[MAXN]; int nt, nl, nr, nans; void clean() { n_q = n_u = 0; ms(tax, 0); } void adjust(int x, int add) { tax[ai[x]] += add; if (add == 1 &amp;&amp; tax[ai[x]] == 1) nans++; if (add == -1 &amp;&amp; tax[ai[x]] == 0) nans--; } void update_update(int type, int id, int x) { //1撤销，2更新 if (type == 1) { if (nl &lt;= x &amp;&amp; x &lt;= nr) adjust(x, -1);//nl &lt;= x &amp;&amp; x &lt;= nr才adjust!!!!! if (u[id].lst == 0) ai[x] = oai[x]; else ai[x] = u[u[id].lst].col; if (nl &lt;= x &amp;&amp; x &lt;= nr) adjust(x, +1);//nl &lt;= x &amp;&amp; x &lt;= nr才adjust!!!!! lst[x] = u[id].lst; } else { u[id].lst = lst[x]; lst[x] = id; if (nl &lt;= x &amp;&amp; x &lt;= nr) adjust(x, -1);//nl &lt;= x &amp;&amp; x &lt;= nr才adjust!!!!! ai[x] = u[id].col; if (nl &lt;= x &amp;&amp; x &lt;= nr) adjust(x, +1);//nl &lt;= x &amp;&amp; x &lt;= nr才adjust!!!!! } } int solve() { clean(); totblo = pow(n, 0.66666666); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;ai[i]), oai[i] = ai[i]; for (int i = 1; i &lt;= m; i++) { char opt[10]; scanf(&quot;%s&quot;, opt); if (opt[0] == &#39;Q&#39;) { n_q++; q[n_q].id = n_q, q[n_q].t = n_u; scanf(&quot;%d%d&quot;, &amp;q[n_q].l, &amp;q[n_q].r); } else { n_u++, lst[n_u] = 0, u[n_u].lst = 0; scanf(&quot;%d%d&quot;, &amp;u[n_u].p, &amp;u[n_u].col); } } sort(q + 1, q + 1 + n_q); nt = 0, nl = 1, nr = 0, nans = 0; for (int i = 1; i &lt;= n_q; i++) { while (nt &gt; q[i].t) update_update(1, nt, u[nt].p), nt--;//撤销 while (nt &lt; q[i].t) update_update(2, nt + 1, u[nt + 1].p), nt++;//更新 while (nl &lt; q[i].l) adjust(nl , -1), nl++; while (nl &gt; q[i].l) adjust(nl - 1, +1), nl--; while (nr &lt; q[i].r) adjust(nr + 1, +1), nr++; while (nr &gt; q[i].r) adjust(nr , -1), nr--; ans[q[i].id] = nans; } for (int i = 1; i &lt;= n_q; i++) printf(&quot;%d\n&quot;, ans[i]); return 0; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m), solve(); return 0; } /* 不判 nl &lt;= x &amp;&amp; x &lt;= nr WA的数据 6 8 1 2 3 4 5 5 R 4 4 R 2 3 Q 1 4 R 1 2 Q 1 4 R 3 5 R 5 8 Q 1 4 */]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[莫队算法 学习笔记]]></title>
    <url>%2Fsz%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[模板及讲解莫队是什么莫(膜)队是离线处理区间问题的一大武器，由莫队发明，其核心为最优化分块思想排序，用已知区间推区间的算法。 莫队解决什么问题1、无修改或者修改不苛刻2、离线3、能用很小的复杂度从$[l,r]$转移到$[l-1, r], [l, r-1], [l+1, r], [l, r+1]$，例如$O(1), O(logn)$ 莫队的实现例题：Bzoj 1878 HH 有一串由各种漂亮的贝壳组成的项链。HH 相信不同的贝壳会带来好运，所以每次散步完后，他都会随意取出一段贝壳，思考它们所表达的含义。HH 不断地收集新的贝壳，因此，他的项链变得越来越长。有一天，他突然提出了一个问题：某一段贝壳中，包含了多少种不同的贝壳？这个问题很难回答……因为项链实在是太长了。于是，他只好求助睿智的你，来解决这个问题。 暴力暴力是显然$O(n^2)$的，我们想想暴力是否会有很多重复的计算，比如说$[1, 6]$和$[2,7]$，暴力会算$11$次，而实际需要那么多次吗？当然不需要，我们直接在询问$[1, 6]$基础上删掉$1$处的贡献，增加$7$处的贡献就可以得到，只用算$8$次。这就是莫队的思想。 暴力优化我们尝试把询问区间离线按$l$排序，则会有一定的优化，但是看下面的例子：$[1, 100], [2, 4], [3, 101]$这会使得当前右边界时大时小，影响效率。怎么办？我们可以取一下平均，$l$不最优，$r$不最优，但总体最优的情况。 莫队我们把询问数组分块，分成$n / \sqrt n$块，然后进行以下的排序： bool cmp1(const query &amp;a, const query &amp;b) {//莫队排序 if (bl[a.l] == bl[b.l]) return a.r &lt; b.r; return bl[a.l] &lt; bl[b.l]; } 其中$bl[i]$表示$i$所在的块。化作文字即为：把一个个块看作整体则$l$有序，块中$r$有序。这样就能达到比较”好”的复杂度，但是这个复杂度是什么呢？ 复杂度证明对于$l$: 如果下一个询问区间$l$不在这个块里，则需要最多$2 \times \sqrt n$次对于$r$: $r$在一个块里单调递增，所以$r$在每个块中最多$n$次，有$n / \sqrt n$个块，所以最多需要$n \times n / \sqrt n$次 综上所述，莫队算法的复杂度为$O(n\sqrt n)​$ 代码Bzoj 1878的代码： #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; using namespace std; #define ms(i, j) memset(i, j, sizeof i) #define ll long long const int MAXN = 1000000 + 5; int m, n, totblo, ai[MAXN], bl[MAXN]; struct query { int l, r, id, ans;//询问左边界，右边界，第几个询问，答案 }q[MAXN]; bool cmp1(const query &amp;a, const query &amp;b) {//莫队排序 if (bl[a.l] == bl[b.l]) return a.r &lt; b.r; return bl[a.l] &lt; bl[b.l]; } bool cmp2(const query &amp;a, const query &amp;b) { return a.id &lt; b.id; } int nl, nr, nans, tax[MAXN];//当前l位置，当前r位置，当前答案，桶 void clean() {nl = nr = nans = 0, ms(tax, 0);} void adjust(int x, int add) { if (tax[ai[x]] == 0 &amp;&amp; add == 1) nans++; tax[ai[x]] += add; if (tax[ai[x]] == 0 &amp;&amp; add == -1) nans--; /*一定要指明add 否则 对于询问区间1 3后询问5 8 会炸 */ } int solve() { clean(); totblo = sqrt(n); for (int i = 1; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;ai[i]); bl[i] = (i - 1) / totblo + 1; } scanf(&quot;%d&quot;, &amp;m); for (int i = 1; i &lt;= m; i++) { scanf(&quot;%d%d&quot;, &amp;q[i].l, &amp;q[i].r); q[i].id = i; } sort(q + 1, q + 1 + m, cmp1); nl = 1, nr = 0; for (int i = 1; i &lt;= m; i++) { while (nl &lt; q[i].l) adjust(nl , -1), nl++; while (nl &gt; q[i].l) adjust(nl - 1, +1), nl--; while (nr &lt; q[i].r) adjust(nr + 1, +1), nr++; while (nr &gt; q[i].r) adjust(nr , -1), nr--; q[i].ans = nans;//进行调整 } sort(q + 1, q + 1 + m, cmp2); for (int i = 1; i &lt;= m; i++) printf(&quot;%d\n&quot;, q[i].ans); return 0; } int main() { scanf(&quot;%d&quot;, &amp;n), solve(); return 0; } 注意：莫队的扩充区间放在缩小区间前可以避免出现某些问题，比如 while (nl &lt; q[i].l) adjust(nl , -1), nl++; while (nl &gt; q[i].l) adjust(nl - 1, +1), nl--; while (nr &lt; q[i].r) adjust(nr + 1, +1), nr++; while (nr &gt; q[i].r) adjust(nr , -1), nr--; 改为 while (nl &lt; q[i].l) adjust(nl , -1), nl++; while (nr &lt; q[i].r) adjust(nr + 1, +1), nr++; while (nl &gt; q[i].l) adjust(nl - 1, +1), nl--; while (nr &gt; q[i].r) adjust(nr , -1), nr--; 带修莫队例题：Bzoj 2120 墨墨购买了一套N支彩色画笔（其中有些颜色可能相同），摆成一排，你需要回答墨墨的提问。墨墨会像你发布如下指令： 1、 Q L R代表询问你从第L支画笔到第R支画笔中共有几种不同颜色的画笔。 2、 R P Col 把第P支画笔替换为颜色Col。为了满足墨墨的要求，你知道你需要干什么了吗？ 大意：多个区间询问，询问$[l,r]$中颜色的种类数。可以单点修改颜色 莫队怎么支持修改？我们可以引入一个时间$t$, 来记录某个询问是顺序修改了几次后的。然后就可以按照莫队的思路，根据$t$不断地更新/回退修改，以达到目的。但是直接改复杂度不能保证，所以我们要用以下排序方法： bool cmp1(const query &amp;a, const query &amp;b) {//莫队带修排序 if (bl[a.l] == bl[b.l]) return (bl[a.r] == bl[b.r] ? a.t &lt; b.t : a.r &lt; b.r); return bl[a.l] &lt; bl[b.l]; } 这样就能保证复杂度了。 复杂度证明($totblo$为块长，不等于$\sqrt n$)对于$l$和$r$，与不带修得莫队相同。对于$t$: 考虑有几个单调段，假设最坏情况每个块中的$t$都不单调，则会有$(n / totblo)^2$个单调段，每个单调段互相转移的时间是$O(n)$，所以最后的复杂度为$O(n(n / totblo)^2)$ 综上所述，在$totblo=n^{\frac23}$时带修莫队算法的复杂度为$O(n^{\frac53})$，一般能过$10000$及以下的数据(只比暴力好一点点)。 代码Bzoj 2120的代码： #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; using namespace std; #define ms(i, j) memset(i, j, sizeof i) #define ll long long const int MAXN = 10000 + 5; int n, m, bl[MAXN], totblo, n_q, n_u, ai[MAXN], oai[MAXN], ans[MAXN], lst[MAXN], tax[1000000 + 5]; //n_q, n_u分别为q，u数组大小(询问，修改个数) //oai为原数组，lst为该位置现在的值是哪个修改修改的(没有修改为0) //tax为桶 struct query {//询问 int l, r, t, id; //t为时间戳 bool operator &lt; (const query &amp;b) const {//带修莫队排序 if (bl[l] == bl[b.l]) return (bl[r] == bl[b.r] ? t &lt; b.t : r &lt; b.r); return bl[l] &lt; bl[b.l]; } }q[MAXN]; struct update {//修改 int p, col, lst;//位置、颜色、上一个该位置(p)的修改 (没有修改为0) }u[MAXN]; int nt, nl, nr, nans; void clean() { n_q = n_u = 0; ms(tax, 0); } void adjust(int x, int add) { tax[ai[x]] += add; if (add == 1 &amp;&amp; tax[ai[x]] == 1) nans++; if (add == -1 &amp;&amp; tax[ai[x]] == 0) nans--; } void update_update(int type, int id, int x) { //1撤销，2更新 if (type == 1) { if (nl &lt;= x &amp;&amp; x &lt;= nr) adjust(x, -1);//nl &lt;= x &amp;&amp; x &lt;= nr才adjust!!!!! if (u[id].lst == 0) ai[x] = oai[x]; else ai[x] = u[u[id].lst].col; if (nl &lt;= x &amp;&amp; x &lt;= nr) adjust(x, +1);//nl &lt;= x &amp;&amp; x &lt;= nr才adjust!!!!! lst[x] = u[id].lst; } else { u[id].lst = lst[x]; lst[x] = id; if (nl &lt;= x &amp;&amp; x &lt;= nr) adjust(x, -1);//nl &lt;= x &amp;&amp; x &lt;= nr才adjust!!!!! ai[x] = u[id].col; if (nl &lt;= x &amp;&amp; x &lt;= nr) adjust(x, +1);//nl &lt;= x &amp;&amp; x &lt;= nr才adjust!!!!! } } int solve() { clean(); totblo = pow(n, 0.66666666); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;ai[i]), oai[i] = ai[i]; for (int i = 1; i &lt;= m; i++) { char opt[10]; scanf(&quot;%s&quot;, opt); if (opt[0] == &#39;Q&#39;) { n_q++; q[n_q].id = n_q, q[n_q].t = n_u; scanf(&quot;%d%d&quot;, &amp;q[n_q].l, &amp;q[n_q].r); } else { n_u++, lst[n_u] = 0, u[n_u].lst = 0; scanf(&quot;%d%d&quot;, &amp;u[n_u].p, &amp;u[n_u].col); } } sort(q + 1, q + 1 + n_q); nt = 0, nl = 1, nr = 0, nans = 0; for (int i = 1; i &lt;= n_q; i++) { while (nt &gt; q[i].t) update_update(1, nt, u[nt].p), nt--;//撤销 while (nt &lt; q[i].t) update_update(2, nt + 1, u[nt + 1].p), nt++;//更新 while (nl &lt; q[i].l) adjust(nl , -1), nl++; while (nl &gt; q[i].l) adjust(nl - 1, +1), nl--; while (nr &lt; q[i].r) adjust(nr + 1, +1), nr++; while (nr &gt; q[i].r) adjust(nr , -1), nr--; ans[q[i].id] = nans; } for (int i = 1; i &lt;= n_q; i++) printf(&quot;%d\n&quot;, ans[i]); return 0; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m), solve(); return 0; } /* 不判 nl &lt;= x &amp;&amp; x &lt;= nr WA的数据 6 8 1 2 3 4 5 5 R 4 4 R 2 3 Q 1 4 R 1 2 Q 1 4 R 3 5 R 5 8 Q 1 4 */ 树上莫队例题：SPOJ COT2 给一棵树，每个点有一个权值。多次询问路径$(u, v)$上有多少个权值不同的点。 树上莫队的资料考虑树上莫队。难点在于怎么将树搬到序列中。将树的括号序求出来，树的括号序就是维护一个序列，这个序列是dfs这棵树时，每个节点在dfs到的时候将本身加入序列，然后离开该节点(返回父节点)也将本身加入序列的一个序列(具体可以看资料，有图解)。我们设$st,ed$分别为某个点最开始在序列出现位置和最后出现在序列的位置。对于一条路径$(u,v)$(这里$st_u \leq st_v$)：如果$LCA=u$，那么路径信息就是$st_u$到$st_v$之间一段中出现次数为奇数次的点的信息。否则，路径就是$ed_u$到$st_v$之间一段中出现次数为奇数次的点。注意这一段并不包含LCA，要手动加上。然后就是注意莫队转移的时候的方法，用奇偶性判断这个节点出现几次，只考虑奇偶性。奇数就可以让记录权值出现次数的数组加一，反之减一。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 40000 + 5, logs = 18; int n, m, whw, blolen, bl[MAXN * 2], ai[MAXN], st[MAXN], ed[MAXN], T[MAXN * 2], tax[MAXN], sz; int dep[MAXN], vis[MAXN], nl, nr, nans, pre[MAXN][22], ans[100000 + 5]; vector&lt;int&gt; G[MAXN]; struct data { int l, r, u, v, id, lca; bool operator &lt; (const data &amp;b) const { if (bl[l] == bl[b.l]) return r &lt; b.r; return bl[l] &lt; bl[b.l]; } }xw[100000 + 5]; void dfs(int u, int pa) { dep[u] = dep[pa] + 1, T[++sz] = u, st[u] = sz, pre[u][0] = pa; for (int i = 1; i &lt;= logs; i++) pre[u][i] = pre[pre[u][i - 1]][i - 1]; for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i]; if (v != pa) dfs(v, u); } T[++sz] = u, ed[u] = sz; } void ins(int a, int b) {G[a].push_back(b), G[b].push_back(a);} int LCA(int a, int b) { if (dep[a] &lt; dep[b]) swap(a, b); for (int i = logs; i &gt;= 0; i--) if (dep[pre[a][i]] &gt;= dep[b]) a = pre[a][i]; if (a == b) return a; for (int i = logs; i &gt;= 0; i--) if (pre[a][i] != pre[b][i]) a = pre[a][i], b = pre[b][i]; return pre[a][0]; } void adjust(int x) { tax[T[x]] = 1 - tax[T[x]]; if (tax[T[x]] % 2) { vis[ai[T[x]]]++; if (vis[ai[T[x]]] == 1) nans++; } else { vis[ai[T[x]]]--; if (vis[ai[T[x]]] == 0) nans--; } } void clean() { ms(dep, 0), sz = 0; } int solve() { clean(); blolen = (int)sqrt(2 * n); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;ai[i]), tax[i] = ai[i]; for (int i = 1; i &lt;= 2 * n; i++) bl[i] = (i - 1) / blolen + 1; sort(tax + 1, tax + 1 + n), whw = unique(tax + 1, tax + 1 + n) - tax - 1; for (int i = 1; i &lt;= n; i++) ai[i] = lower_bound(tax + 1, tax + 1 + whw, ai[i]) - tax; for (int u, v, i = 1; i &lt; n; i++) scanf(&quot;%d%d&quot;, &amp;u, &amp;v), ins(u, v); dfs(1, 0); for (int i = 1; i &lt;= m; i++) scanf(&quot;%d%d&quot;, &amp;xw[i].u, &amp;xw[i].v), xw[i].id = i, xw[i].lca = LCA(xw[i].u, xw[i].v); for (int i = 1; i &lt;= m; i++) { if (st[xw[i].u] &gt; st[xw[i].v]) swap(xw[i].u, xw[i].v); if (xw[i].lca != xw[i].u) xw[i].l = ed[xw[i].u], xw[i].r = st[xw[i].v]; else xw[i].l = st[xw[i].u], xw[i].r = st[xw[i].v]; }//转到括号序上 sort(xw + 1, xw + 1 + m); ms(tax, 0), ms(vis, 0), nl = 1, nr = 0, nans = 0; for (int i = 1; i &lt;= m; i++) { while (nl &lt; xw[i].l) adjust(nl), nl++; while (nl &gt; xw[i].l) adjust(nl - 1), nl--; while (nr &lt; xw[i].r) adjust(nr + 1), nr++; while (nr &gt; xw[i].r) adjust(nr), nr--; ans[xw[i].id] = nans; if (xw[i].lca != xw[i].u) { if (vis[ai[xw[i].lca]] == 0) ans[xw[i].id]++;//加上LCA } } for (int i = 1; i &lt;= m; i++) printf(&quot;%d\n&quot;, ans[i]); return 0; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m), solve(); return 0; } 回滚莫队用于一些不方便删除或者添加更新答案的离线区间题目。比如Bzoj 4241 有一个长度为$n$的序列，有$m$个询问，每次询问$[l, r]$内每个数值乘以该数值出现次数的最大值。 由于删除更新答案不方便，那么这里可以用回滚莫队。按照原莫队方法排序，那么左端点在一块的询问就到了一起，并且右端点单调递增，右端点只有增加，考虑左端点。要使得左端点只能增加，我们把所有在一个块的左端点的询问一起处理，都将莫队中的左端点移到块最右边，每次查询的时候就从最右边开始向左延伸，记录答案，然后再回退到块最右边，这样就避免了删除。一个块处理完后，因为右端点会有删除的情况，所以直接抛弃之前的所有答案，重新从新询问开始记录答案。对于左右端点在同块的询问，直接暴力即可。时间复杂度分析：1、对于左右端点在同块的询问，其时间复杂度最坏为$O(m\sqrt n)$2、在同块中处理时，右端点单调递增，最多增加$n$次，复杂度$O(n\sqrt n)$。左端点回滚，由于在块中，最多滚动$\sqrt n$次，复杂度$O(m\sqrt n)$。3、对于左端点不同块之间的转换，清除记录数组时间复杂度$O(n\sqrt n)$由于$m,n$同级，所有算法复杂度为$O(n\sqrt n)$ 常见题型1、维护区间离线，无修改Q：维护区间离线无修改解：见讲解的莫队实现例题：Bzoj 18782、维护区间离线，有简单修改(带修莫队)Q：维护区间离线有简单修改解：见讲解的带修莫队实现例题：Bzoj 21203、维护树离线(树上莫队)Q：见讲解解：见讲解例题：SPOJ COT24、维护区间离线，删除/添加更新答案不方便(回滚莫队)Q：见讲解解：见讲解例题：Bzoj 4241]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>莫队</tag>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高中数学集合与函数做题笔记]]></title>
    <url>%2Fwhk%E9%9B%86%E5%90%88%E4%B8%8E%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[一些Trick1、偶数表示为$2n$, 奇数表示为$2n + 1$2、正难则反(教材全解必修1 p11 例2)3、十字相乘解形如$px^2+ax+q=0$的方程4、集合元素有互异性，可以判断不相等的情况(教材全解必修1 p17 t12)5、$\in N$或者$\in Z$有分数要讨论奇偶性(教材全解必修1 p20 例5)6、集合一般能化简就要化简做7、方程条件转化为范围条件：$px^2+rx+q=0 →(x_1 - a)(x_2 - b) &lt; 0$8、对勾函数解析式：$f(x)=x+\frac ax$，极值点在$\sqrt a$ 集合分类讨论思想对应性：教材全解必修1 p13 例8, 教材全解必修1 p17 t12多情况：教材全解必修1 p15 考例1，教材全解必修1 p16 考例2，教材全解必修1 p16 考例3正负性：教材全解必修1 p17 t4方程根：教材全解必修1 p13 例9分段：教材全解必修1 p21 变式3 集合的含义及表示元素与集合的关系构造题 此类题目一般要求某些元素是否是属于某个集合，一般要构造成与条件形式相同的形式。 第一问构造平方差，第二问构造与条件形式相同的形式：教材全解必修1 p11 例1，教材全解必修1 p17 t6 循环带入题 此类题目一般是将代数式循环带入后形成周期。 若$X \in M$, 则$\frac{1+a}{1-a} \in M$，求集合$M$的元素个数/证明集合中各数不同教材全解必修1 p11 变式1 集合相等问题有且只有一个正确 此类题目一般分情况对应以及运用相异性来解题 教材全解必修1 p16 考例2教材全解必修1 p16 考例3 推断题 此类题目一般分情况对应以及运用相异性, 正负性等来解题 根据相异性，正负性等解题：教材全解必修1 p17 t12 方程根的问题 抓住以下导图做题 $a=0$——–$b≠0$——–$b=0$—————-$c=0$—————-$c≠0$$a≠0$——–$\Delta &lt; 0$——–$\Delta=0$——–$\Delta &gt; 0$ 教材全解必修1 p13 例9 集合间的基本关系判断集合是否包含元素对比 仅仅根据元素对比或者条件对比 条件范围对比 运用集合条件范围来对比 教材全解必修1 p20 示例2 判断集合是否相等元素, 条件范围对比 仅仅根据元素对比或者条件对比 双重包含 运用$A \subseteq B，B \subseteq A$来得出$A=B$ 教材全解必修1 p20 例5 判断集合是否真子集B属于A且A不属于B 运用$B \subseteq A，A \nsubseteq B$来得出$B \subsetneqq A$ 教材全解必修1 p20 示例2 判断集合之间的关系构造拼凑 将某个集合的条件凑成另一个集合的条件形式 教材全解必修1 p21 例2 求集合中含参问题条件为范围 将已知范围集合画在数轴上，根据实际情况列不等式方程组(注意空集的情况) $A \subseteq B$或$A \subsetneqq B$且$B≠\emptyset$的情况要分$A=\emptyset，A≠\emptyset$的情况讨论 教材全解必修1 p22 例4 统一为所求参数：教材全解必修1 p21 变式3 条件为数 分类讨论根的情况，一个/两个/没有的情况 两个根的情况要检验是否是原来的两个根 高中必刷题必修1 p5 t10 集合的基本运算转化为集合间的基本关系 转化为集合间的基本关系运用之前的知识解题 $A \cap B = A$等价于$B \subseteq A$$A \cup B = A$等价于$A \subseteq B$ 补集转化 正难则反 教材全解必修1 p31 例12 数形结合 运用数轴和Venn图灵活解题 Venn图：教材全解必修1 p31 例13 容斥原理求并集元素个数 奇加偶减 设未知数：教材全解必修1 p31 例13套容斥公式：教材全解必修1 p32 变式7 函数函数的概念同一函数的判定 定义域、对应关系相等的是同一函数 求函数定义域 根据定义/实际问题求解 复合函数注意内函数必须要保证外函数 抽象函数给出$f[g(x)]$的定义域，求$f[\varphi(x)]$的定义域思路：先求$f(x)$的定义域，再求$f[\varphi(x)]$的定义域教材全解必修1 p40 例10 求函数值域图象法能画出图象的函数可以画图求解。例题：$y=2x+1$的值域, $y=x^2+2x-3$的值域 解析式法1、给出二次函数，配方为顶点式求最大/最小值 分离常数法形如$y= \frac{ax+b}{cx+d}$的函数值域一般要分离常数，即将$a,c$提取出来，然后再通过反比例函数性质求解。 形如$y= \frac{a_1x^2+b_1x+c_1}{a_2x^2+b_2x+c_2}$的函数值域解法：1、能十字相乘就相乘，然后约去相同因子(注意如果消掉要考虑0的情况)，然后转化为$y= \frac{ax+b}{cx+d}$的形式2、不能做就转为一元二次方程求解，分类讨论是否存在根(方程思想)：教材全解必修1 p40 例8 观察法观察某个部分的性质求解。例题：$y=\sqrt{x}+1$的值域 换元法不好表示的部分要设元替换。如$\sqrt{2x-1}$例题：$y=x+\sqrt{2x-1}$的值域 方程思想将函数化为方程，方程要有解列不等式/方程教材全解必修1 p40 例8 求函数参数 一般是逆向思维解题。 给出定义域分母不为0，且方程$分母=0$无整数解 教材全解必修1 p40 例7 给出值域教材全解必修1 p40 例8 函数的表示法求函数解析式替换法例题：已知$f(x+1)=x^2$，求$f(x)$的解析式：将$x$换为$x-1$，则$f(x)=(x-1)^2$ 配凑法例题：已知$f(t)=g(x)$，求$f(x)$的解析式：将$g(x)$变形为只含$t$的式子，再将$t$换成$x$ 换元法将整体代换。 待定系数法已知函数类型，直接设函数然后解出系数即可。例题：已知$f(x)$为二次函数，求解析式：设$f(x)=ax^2+bx+c$ 解方程组法例题：已知$f(x)+2f(\frac1x)=x(x≠0)$，求$f(x)$：$x$与$\frac1x$互换 数形结合画出已知函数图象解题如果已知函数/不知函数都可以画出图象来解问题。 图象变化问题平移：1、左右：$f(x+a)$(左加右减)2、上下：$f(x)+a$(上加下减)对称：1、$y$轴：$f(-x)$2、$x$轴：$-f(x)$3、原点：$-f(-x)$翻折：1、$|f(x)|$：整个图象都是在$N$集合的，对应负数区域对称翻折2、$f(|x|)$：右边图象保留，左边删除，左边对称翻折右边的图象 给出图象分析问题1、求参：带入特殊值进行推理即可2、转化为 画出已知函数图象解题 分段函数|x|分段讨论正负性求得分段函数$|x-2|+|5-x|$分$x \leq 2, 2 \leq x \leq 5, x \geq 5$三种情况讨论 函数的单调性与极值(重难点)定义法证明单调性例题1：证明$f(x)=\sqrt{x}$在其定义域上是增函数。(定义法)解法：1、取$x_1&lt;x_2$2、$f(x_1)-f(x_2)$代数出来，化成带有$x_1-x_2$或$x_2-x_1$的式子3、比较$f(x_1)-f(x_2)$的符号4、定论(增函数、减函数)(不仅可以作差，还可以作商)技巧：因式分解、通分、配方、分子有理化 例题2：$f(x)=x+\frac ax$的单调性。(分类讨论参数法)解法：(总体和上面的做法一致)，但是参数$a$的值不知道，就要分类讨论从极端情况入手，可取$x_1=x_2$找到边界进行讨论 分段求单调性根据单调函数运算性质求单调性例题：$\frac{x^3-4x+3}{x}，x \notin N$ 求单调区间(重难点)图象法画出图象即可判断单调区间：高中必刷题必修1 p22 t11教材全解必修1 p59 例3教材全解必修1 p59 变式2 获取信息法教材全解必修1 p59 例4 定义法与 定义法证明单调性 差不多，但要先求出函数的定义域，在每个定义域上找单调区间：高中必刷题必修1 p24 t5 常数分离法形如$y= \frac{ax+b}{cx+d}$的函数，提取之后根据反比例函数等的性质判断教材全解必修1 p60 例5 分类讨论绝对值、$max、min$一般要分类进行讨论高中必刷题必修1 p22 t11 复合函数教材全解必修1 p65 例22 求一般函数极值单调性法证明函数在区间的单调性，根据区间端点求极值。教材全解必修1 p60 例6 图象法画出图象即可求函数极值。 配方法把二次函数配方为顶点式。 换元法把带根号的式子用一个字母表示，然后转化为配方法求极值。 求二次函数的极值轴定，区间定初中题。 轴动，区间定分类讨论轴的位置教材全解必修1 p61 例11 轴动，区间动(难点)将区间看作不动，对称轴变化教材全解必修1 p62 例12 单调性求参数取值范围(重难点)定义法未知函数的单调性，求参数取值范围：教材全解必修1 p62 例15高中必刷题必修1 p24 t9高中必刷题必修1 p25 t4(定义域定义) 获取信息法分段函数已知单调性，列不等式求参数取值范围(可能的约束都要写)：教材全解必修1 p68 t10教材全解必修1 p64 t21高中必刷题必修1 p23 t12高中必刷题必修1 p24 t6高中必刷题必修1 p24 t8 二次函数二次函数求对称轴位置列不等式求参数取值范围：高中必刷题必修1 p22 t11高中必刷题必修1 p22 t14高中必刷题必修1 p25 t1 单调性解不等式将不等式化为$f(x_1)&lt;f(x_2)$的形式。变形：教材全解必修1 p63 例16构造：教材全解必修1 p63 例18 单调函数运算性质基本：$a$大于$0$时，$af(x)$与$f(x)$有相同性质，否则相反$f(x)$与$\frac{1}{f(x)}$有相反性质$f(x)$与$\sqrt{f(x)}$有相同性质有公共单调区间：增+增=增，减+减=减增-减=增，减-增=减 复合函数的单调性复合函数的单调性同增异减，步骤：1、确定函数定义域2、分解函数3、分别确定函数单调性4、确定复合函数单调性 求复合函数的单调区间1、确定函数定义域2、分解函数3、分别确定函数单调性4、再求单调区间5、确定复合函数的单调区间 抽象函数的单调性常用方法：1、赋值法：即特殊值法2、配凑法：有$f(x+y)$，则$f(x_2)-f(x_1)$配为$f((x_2-x_1)+x_1)-f(x_1)$有$f(xy)$，则$f(x_2)-​f(x_1)$配为$f(x_1 \cdot \frac{x_2}{x_1})-f(x_1)$ 函数的奇偶性(重难点)判断函数奇偶性举反例就能证明函数不具有奇偶性。 不含参数定义法1、求定义域2、定义域是否关于原点对称3、验证$f(x)$与$f(-x)$的关系 图象法从图中观察即可。 运算性质法由多个奇偶函数组成的函数，一般用运算的性质来解题。 含参数定义法1、分$a=0,a≠0$两种情况讨论。用定义法，代入式子求值，验证$f(x)$与$f(-x)$的关系 函数奇偶性的定义应用求函数值通过$f(x)=-f(-x), f(x)=f(-x)$来求函数值教材全解必修1 p72 例3 求函数解析式通过$f(x)=-f(-x), f(x)=f(-x)$来求函数解析式教材全解必修1 p72 例4 求参数通过$f(x)=-f(-x), f(x)=f(-x)$来求参数教材全解必修1 p72 例6 函数奇偶性的单调区间比较大小求出单调区间然后结合单调性(图象最方便) 解不等式用单调性来解不等式教材全解必修1 p73 例8教材全解必修1 p73 例9 分段函数的奇偶性证明奇偶性分段证明或者图象法(分段要没一段进行证明) 抽象函数的奇偶性赋值法、定义法进行证明。教材全解必修1 p74 例11 函数图象对称点/直线偶函数：$f(a+x)=f(a-x)$关于直线$x=a$对称$f(a+x)=f(b-x)$关于直线$x=\frac{a+b}{2}$对称奇函数：$f(a+x)+f(a-x)=0$关于点$(a,0)$对称$f(a+x)+f(b-x)=0$关于点$(\frac{a+b}{2},0)$对称 恒存在问题题目的$key word$：$xx$图象总在$xx$图象上、对一切$xx$都成立、$xx$恒成立 $m$为所求参数，一定要单独放在一边！如果m的正负性不定就整体复合函数换元$m \geq f(x)$恒成立等价于$m \geq f(x)_{max}$$m \leq f(x)$恒成立等价于$m \leq f(x)_{min}$例题：教材全解必修1 p84 t16，教材全解必修1 p84 t21，教材全解必修1 p84 t22 存在问题题目的$key word$：存在一个$x$使得$xx$ $m$为所求参数，一定要单独放在一边！如果m的正负性不定就整体复合函数换元$m \geq f(x)$存在一个$x$使得$xx$等价于$m \geq f(x)_{min}$$m \leq f(x)$存在一个$x$使得$xx$等价于$m \leq f(x)_{max}$ 指数函数指数幂的运算化简求值公式完全平方公式: $(a^{\frac12}±b^{\frac12})^2=a±2a^{\frac12}b^{\frac12}+b$平方差公式: $a-b=(a^{\frac12}+b^{\frac12})(a^{\frac12}-b^{\frac12})$立方差公式: $a±b=(a^{\frac13}\pm b^{\frac13})(a^{\frac23}\mp a^{\frac13}b^{\frac13}+b^{\frac23})$ 技巧1、化负为正将指数含有减法算式的分开，比如$4^{1-x}=4 * 4^{-x}$将指数含有负数的算式转为正数：$1-a^{-\frac13}=\frac{a^{\frac13}-1}{a^{\frac13}}$2、加入$x^y \cdot x^{-y}=1$ 比较大小1、通分2、化为同底数3、化为同指数 指数函数求定义域、值域定义域$y=a^{f(x)}$的定义域是$f(x)$的定义域 值域$y=a^{f(x)}$的值域：1、求$f(x)$的值域2、由$y=a^u$的单调性求$y=a^{f(x)}$的值域 $y=f(a^x)$的值域：1、求$u=a^x$的值域2、由$y=f(b)$的单调性求$y=f(a^x)$的值域 (注意$a$的分类讨论) 指数幂大小比较比差/商法比差法，差小于$0$则$a$小于$b$比商法，商小于$1$则$a$小于$b$ 函数单调性法根据单调性比较两个底数相同的指数幂 图象法画出图象解决问题 中间值法$x^0=1$来作为中间值，常用中间值：$0,1,2$ 指数函数复合函数单调性先求出复合函数的单调性，再求指数函数的单调性，最后进行综合。同增异减。 解指数不等式方程方程方法一：将等式两边带换为同一底数方法二：换元方法三：分离参数法 不等式1、将等式两边带换为同一底数2、利用单调性求解，必要时要分类讨论$a$ 对数函数对数计算技巧$lgN=log_{10}N, log_eN=lnN$$log_a1=0,log_aa=1,a^{log_aN}=N$$lg5+lg2=1$$lg20=1+lg2$ 常用公式基本：1$log_cab=log_ca+log_cb$2$log_ca/b=log_ca-log_cb$3$log_ca^b=blog_ca$换底：4$log_ab=\frac{log_cb}{log_ca}$5$log_{a^m}b^n=\frac nmlog_ab$6$log_ab=\frac{1}{log_ba}$7$log_ab \cdot log_bc=log_ac$扩展：指数式可以和对数式互换：1、(式子)性质法2、(方程)方程两边同时取对数 对数方程1、基本：$log_af(x)=b$，转化为$f(x)=a^b$2、同底数：$log_af(x)=log_a g(x)$，转化为$f(x)=g(x)$(要检验)3、代换：$F(log_ax)=0$，用$t=log_ax$换元 对数函数求定义域、值域定义域根据对数函数性质概念即可。 值域与最值值域：根据定义域以及单调性即可。最值：单调性，可以配合换元等 解对数不等式比较对数值大小1、同底：单调性2、同真数：图象3、otherwise：中介值 复合函数求单调区间1、$y=log_af(x)$的单调性：在$a \in (0, 1)$时与函数$f(x)=u$相反，反之相同2、$y=f(log_ax)$的单调性：换元，使$t=log_ax$，然后讨论$t=log_ax$和$y=f(t)$的单调性 求值域、最值换元、单调性等方法 幂函数幂函数性质 比较大小根据单调性等比较大小 单调性根据单调性解最值问题 函数零点求函数零点求解析式的根给出$f(x)$具体的函数解析式，求$f(x)=0$的值即可。 利用函数图象观察函数图象即可。 求函数零点个数利用函数零点存在性定理略去，按照单调性和定理即可。 数形结合给出$F(x)=f(x)-g(x)$，可以转化为$f(x)-g(x)=0$, 即$f(x)=g(x)$，然后讨论两个函数的交点个数 利用奇偶性区间$[-a, a]$上的零点可以先研究$(0, a]$上的零点情况 利用单调性某个函数在某个区间单调，即可利用判断零点的位置 已知函数有零点问题将一个个值求出来用函数零点存在性定理找即可 一元二次方程根的分布 最后的总结 End]]></content>
      <categories>
        <category>文化课</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 919D(拓扑排序+DP)]]></title>
    <url>%2FCodeforces919D%2F</url>
    <content type="text"><![CDATA[Codeforces 919D题意：给出一个有向图，每个点有一个小写英文字母，求一条路径使得路径上有一种字母数出现频率最多这题如果不是图可以想到DP，设$dp(i,j)$为在$i$处，$j$字母时的最大值放在图中，如果想DP，又不保证是DAG，那么就要用拓扑序来无后效性转移 ps: 图中要判环的一般是SPFA，拓扑排序，DFSCodeforces Submission #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;vector&gt; #include&lt;queue&gt; using namespace std; #define ms(i, j) memset(i, j, sizeof i) #define ll long long int n, m, ino[300000 + 5], seq[300000 + 5], idx, dp[300000 + 5][30]; char s[300000 + 5]; vector&lt;int&gt; G[300000 + 5]; int topsort() { queue&lt;int&gt; q; for (int i = 1; i &lt;= n; i++) if (ino[i] == 0) seq[++idx] = i, q.push(i); while (!q.empty()) { int u = q.front(); q.pop(); for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i]; ino[v]--; if (ino[v] == 0) seq[++idx] = v, q.push(v); } } if (idx != n) return 0; return 1; } void clean() { idx = 0, ms(ino, 0), ms(dp, 0); } int solve() { clean(); for (int i = 1; i &lt;= m; i++) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); G[x].push_back(y), ino[y]++; } if (!topsort()) return printf(&quot;-1\n&quot;), 0; for (int i = 1; i &lt;= n; i++) { int u = seq[i]; dp[u][s[u] - &#39;a&#39;]++; for (int j = 0; j &lt; (int)G[u].size(); j++) { int v = G[u][j]; for (int c = 0; c &lt; 26; c++) { dp[v][c] = max(dp[v][c], dp[u][c]); } } } int ans = 0; for (int i = 1; i &lt;= n; i++) { for (int c = 0; c &lt; 26; c++) { ans = max(ans, dp[i][c]); } } printf(&quot;%d\n&quot;, ans); return 0; } int main() { scanf(&quot;%d%d%s&quot;, &amp;n, &amp;m, s + 1), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>Codeforces</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 915D(拓扑排序)]]></title>
    <url>%2FCodeforces915D%2F</url>
    <content type="text"><![CDATA[Codeforces 915D题意：给出一个有向图，这个图有可能有一条边删去后整幅图变为DAG，求该图是否能变成DAG。环可以想到拓扑排序，但$m$大，不能枚举边去删。删边的本质在拓扑排序中就是入点的入度减一，所以枚举每一个点入度减一，然后拓扑排序看是否有环，就可以判断了 Codeforces Submission #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;vector&gt; #include&lt;queue&gt; using namespace std; #define ms(i, j) memset(i, j, sizeof i) #define ll long long vector&lt;int&gt; G[505]; int n, m, ino[505], ino2[505], tot; bool topsort() { queue&lt;int&gt; q; for (int i = 1; i &lt;= n; i++) if (ino2[i] == 0) tot++, q.push(i); while (!q.empty()) { int u = q.front(); q.pop(); for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i]; ino2[v]--; if (ino2[v] == 0) tot++, q.push(v); if (ino2[v] &lt; 0) ino2[v] = 0; } } if (tot == n) return 1; else return 0; } void clean() { tot = 0, ms(ino, 0); } int solve() { clean(); for (int u, v, i = 1; i &lt;= m; i++) { scanf(&quot;%d%d&quot;, &amp;u, &amp;v); G[u].push_back(v), ino[v]++; } for (int i = 1; i &lt;= n; i++) { memcpy(ino2, ino, sizeof ino); if (!ino2[i]) continue; ino2[i]--, tot = 0; if (topsort()) return printf(&quot;YES\n&quot;), 0; } printf(&quot;NO\n&quot;); return 0; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分块 学习笔记]]></title>
    <url>%2Fsz%E5%88%86%E5%9D%97%2F</url>
    <content type="text"><![CDATA[模板及讲解分块是什么主体思想是把序列分块每块长为$\sqrt n$，然后进行处理(一般是考虑1.处理不完整块2.处理完整块3.预处理的三种情况)。分块的调试检测技巧：可以生成一些大数据，然后用两份分块大小不同的代码来对拍，还可以根据运行时间尝试调整分块大小，减小常数。(以下文字部分转与hzwer的博客) 分块常见题型区间加法，单点查询(知识点：lazy标记)给出一个长为$n$的数列，以及$m$个操作，操作涉及区间加法，单点查值。Luogu 3368解法：把原序列分块，我们把每$\sqrt n$个元素分为一块，然后就能得到$n / \sqrt n = \sqrt n$个块。我们给每个块设置一个加法标记(就是记录这个块中元素一起加了多少)，每次操作对每个整块直接$O(1)$标记，而不完整的块由于元素比较少，暴力修改元素的值。每次询问时返回元素的值加上其所在块的加法标记。每次区间加的操作复杂度为$O(\sqrt n + \sqrt n)$(中间块的整体修改+两边不完整的块的逐一修改)。 //由于luogu题目数据范围大，无法承受sprt(n)*m的复杂度，所以本程序只有70分 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 500000 + 5; int n, m, ai[MAXN];//输入数组 int totblo, lazy[MAXN], bl[MAXN];//每块大小(sqrt(n))，lazy标记，每个数属于哪个块 void add(int x, int y, int k) { for (int i = x; i &lt;= min(y, bl[x] * totblo); i++) ai[i] += k;//左边的块 if (bl[x] != bl[y]) for (int i = (bl[y] - 1) * totblo + 1; i &lt;= y; i++) ai[i] += k;//右边的块，记得有可能[x,y]只在一个块中的情况 for (int i = bl[x] + 1; i &lt;= bl[y] - 1; i++) lazy[i] += k;//中间整块只更新lazy } void clean() {} void solve() { clean(); totblo = sqrt(n); for (int i = 1; i &lt;= n; i++) bl[i] = (i - 1) / totblo + 1;//随便推堆公式就能出来 for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;ai[i]); while (m--) { int opt; scanf(&quot;%d&quot;, &amp;opt); if (opt == 1) { int x, y, k; scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;k); add(x, y, k); } else if (opt == 2) { int x; scanf(&quot;%d&quot;, &amp;x); printf(&quot;%d\n&quot;, ai[x] + lazy[bl[x]]);//原数加上lazy标记值 } } } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m), solve(); return 0; } 扩展1： 区间加法，区间查询给出一个长为$n$的数列，以及$m$个操作，操作涉及区间加法，区间查询。解法：还是按照上面的方法，但是要记录一个块的总元素和。很好维护，处理不完整块的时候就直接加就行；完整块直接按照块大小乘以增加量即可。代码略去。扩展2： 区间乘法，单点查询/区间查询给出一个长为$n$的数列，以及$m$个操作，操作涉及区间乘法，单点查询/区间查询。解法：和以上两种方法类似，不再做解释。 区间加法，查询区间小于/大于某数的总个数(知识点：块中套数据结构/STL等)给出一个长为$n$的数列，以及$m$个操作，操作涉及区间加法，区间查询区间小于/大于某数的总个数Luogu 2801解法：思路是将序列分成$\sqrt n$个块，然后每个块排序，每次查询非整块暴力处理，整块二分。预处理：把序列分成$\sqrt n$个块，然后分别排序修改：非整块直接暴力修改；整块修改lazy值即可。但是非整块修改会影响这个块的顺序，而整块不会，所以非整块要重新排序。查询：非整块直接暴力统计；整块二分即可，记得带上lazy值即可注意：totblo只是块长，bl[n]才是总块数 这里用vector来存块的排序 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long using namespace std; const int MAXN = 1000000 + 5, MAXK = 1000 + 5; LL n, Q, ai[MAXN], totblo, bl[MAXN], lazy[MAXK]; //输入的n，Q，序列ai, 总块数totblo, 每个数属于哪个块，lazy标记 vector&lt;LL&gt; vec_sortedBlo[MAXK];//每个块的排序后的有序区间 void add(LL x, LL y, LL c) { for (LL i = x; i &lt;= min(y, totblo * bl[x]); i++) ai[i] += c; vec_sortedBlo[bl[x]].clear(); for (LL i = totblo * (bl[x] - 1) + 1; i &lt;= totblo * bl[x]; i++) vec_sortedBlo[bl[x]].push_back(ai[i] += lazy[bl[x]]); lazy[bl[x]] = 0; sort(vec_sortedBlo[bl[x]].begin(), vec_sortedBlo[bl[x]].end()); //处理非整块(前) if (bl[x] != bl[y]) { for (LL i = (bl[y] - 1) * totblo + 1; i &lt;= y; i++) ai[i] += c; vec_sortedBlo[bl[y]].clear(); for (LL i = (bl[y] - 1) * totblo + 1; i &lt;= bl[y] * totblo; i++) vec_sortedBlo[bl[y]].push_back(ai[i] += lazy[bl[y]]); lazy[bl[y]] = 0; sort(vec_sortedBlo[bl[y]].begin(), vec_sortedBlo[bl[y]].end()); }//处理非整块(后) for (LL i = bl[x] + 1; i &lt;= bl[y] - 1; i++) lazy[i] += c;//处理整块 } LL query(LL x, LL y, LL c) { LL ret = 0; for (LL i = x; i &lt;= min(y, totblo * bl[x]); i++) if (ai[i] + lazy[bl[x]] &gt;= c) ret++; if (bl[x] != bl[y]) for (LL i = (bl[y] - 1) * totblo + 1; i &lt;= y; i++) if (ai[i] + lazy[bl[y]] &gt;= c) ret++; //处理非整块 for (LL i = bl[x] + 1; i &lt;= bl[y] - 1; i++) { //LL les = lower_bound(vec_sortedBlo[i].begin(), vec_sortedBlo[i].end(), c - lazy[i]) - vec_sortedBlo[i].begin(); LL ans = -1, l = 0, r = vec_sortedBlo[i].size(); while (l &lt; r) { LL mid = (l + r) &gt;&gt; 1; if (lazy[i] + vec_sortedBlo[i][mid] &lt; c) ans = mid, l = mid + 1; else r = mid; } ret += (LL)vec_sortedBlo[i].size() - ans - 1; }//处理整块 return ret; } void clean() { ms(bl, 0); } void solve() { clean(); totblo = sqrt(n); for (LL i = 1; i &lt;= n; i++) bl[i] = (i - 1) / totblo + 1; for (LL i = 1; i &lt;= n; i++) { scanf(&quot;%lld&quot;, &amp;ai[i]); vec_sortedBlo[bl[i]].push_back(ai[i]); } for (LL i = 1; i &lt;= bl[n]; i++) sort(vec_sortedBlo[i].begin(), vec_sortedBlo[i].end());//预处理，排序。totblo只是块长，bl[n]才是总块数 char ch[10]; while (Q--) { scanf(&quot;%s&quot;, ch); if (ch[0] == &#39;M&#39;) { LL l, r, w; scanf(&quot;%lld%lld%lld&quot;, &amp;l, &amp;r, &amp;w); add(l, r, w); } else { LL l, r, c; scanf(&quot;%lld%lld%lld&quot;, &amp;l, &amp;r, &amp;c); printf(&quot;%lld\n&quot;, query(l, r, c)); } } } int main() { scanf(&quot;%lld%lld&quot;, &amp;n, &amp;Q), solve(); return 0; } 扩展1： 区间加法，区间添加/删除元素/求前驱/后继给出一个长为$n$的数列，以及$m$个操作，操作涉及区间加法，区间添加/删除元素/求前驱/后继解：可以和上面的做法一样，不用vector而是使用set即可 区间开方，区间求值(知识点：块中标记优化)给出一个长为$n$的数列，以及$m$个操作，操作涉及区间开方，区间求值SPOJ GSS4解：非整块还是暴力更新。由于一个数sqrt很少次数变为0或1，因为一个块的开方和不能直接得到，那么只能是如果一个块全是1或0，标记这个块不再处理，否则无论是整块还是非整块都暴力更新。每个数更新的次数非常小。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long using namespace std; const int MAXN = 100000 + 5, MAXK = 400 + 5; LL n, Q, totblo, bl[MAXN], ai[MAXN]; //输入n,Q,块的大小，每个元素属于的块，序列ai LL sum[MAXK], mark[MAXK]; //块元素和，标记(是否都为1或0) void solveSqrt(LL x) {//处理 if (mark[x]) return ; int flag = true; for (LL i = (x - 1) * totblo + 1; i &lt;= x * totblo; i++) { if (ai[i] != 0 || ai[i] != 1) { sum[x] -= ai[i], ai[i] = sqrt(ai[i]), sum[x] += ai[i]; if (ai[i] != 0 &amp;&amp; ai[i] != 1) flag = false; } } if (flag) mark[x] = 1;//标记 } void update(LL x, LL y) { for (LL i = x; i &lt;= min(y, totblo * bl[x]); i++) sum[bl[x]] -= ai[i], ai[i] = sqrt(ai[i]), sum[bl[x]] += ai[i]; if (bl[x] != bl[y]) for (LL i = totblo * (bl[y] - 1) + 1; i &lt;= y; i++) sum[bl[y]] -= ai[i], ai[i] = sqrt(ai[i]), sum[bl[y]] += ai[i]; for (LL i = bl[x] + 1; i &lt;= bl[y] - 1; i++) solveSqrt(i); } LL query(LL x, LL y) { LL ret = 0; for (LL i = x; i &lt;= min(y, totblo * bl[x]); i++) ret += ai[i]; if (bl[x] != bl[y]) for (LL i = totblo * (bl[y] - 1) + 1; i &lt;= y; i++) ret += ai[i]; for (LL i = bl[x] + 1; i &lt;= bl[y] - 1; i++) ret += sum[i]; return ret; } void clean() { ms(sum, 0), ms(mark, 0); } void solve() { clean(); totblo = sqrt(n); for (LL i = 1; i &lt;= n; i++) { scanf(&quot;%lld&quot;, &amp;ai[i]); bl[i] = (i - 1) / totblo + 1, sum[bl[i]] += ai[i]; } scanf(&quot;%lld&quot;, &amp;Q); while (Q--) { LL x, l, r; scanf(&quot;%lld%lld%lld&quot;, &amp;x, &amp;l, &amp;r); if (l &gt; r) swap(l, r); if (x == 1) { printf(&quot;%lld\n&quot;, query(l, r)); } else { update(l, r); } } } int main() { LL kase = 0; while (scanf(&quot;%lld&quot;, &amp;n) == 1) printf(&quot;Case #%lld:\n&quot;, ++kase), solve(), printf(&quot;\n&quot;); return 0; } 区间众数(知识点：预处理i块/i点到j块/j点区间)题意：强制在线不修改求区间众数。Bzoj 2724我们将原数列分块，预处理$i$块到$j$块区间的众数，直接开桶统计，用于求解整块的区间。用vector把相同的数的位置按顺序存储下来，求众数可以用询问区间的每个数字去求他出现次数，比较即可。对于整块，我们预处理了$i$块到$j$块区间的众数，直接询问这个数字在询问区间出现次数即可；对于不完整的块，我们暴力每个数字在询问区间出现次数即可最后输出即可，时间复杂度$O(m \cdot logn+\frac nm)$, 其中$n$为数列长，$m$为每个块长，根据均值不等式，在$m \cdot logn=\frac nm$时和有最小值，$m=\sqrt{\frac{n}{logn}}$，即得到最优分块大小 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 40000 + 5; int n, q, whw, ai[MAXN], key = 0, tax[MAXN], tax1[MAXN], blolen, bl[MAXN], s[1005][1005]; vector&lt;int&gt; hh[MAXN]; int cx(int v, int x, int y) { return upper_bound(hh[v].begin(), hh[v].end(), y) - upper_bound(hh[v].begin(), hh[v].end(), x - 1); } int query(int x, int y) { int mks = cx(s[bl[x] + 1][bl[y] - 1], x, y), ret = s[bl[x] + 1][bl[y] - 1]; for (int i = x; i &lt;= min(y, bl[x] * blolen); i++) { int tmp = cx(ai[i], x, y); if (tmp &gt; mks) ret = ai[i], mks = tmp; else if (tmp == mks &amp;&amp; ai[i] &lt; ret) ret = ai[i]; } if (bl[x] != bl[y]) for (int i = (bl[y] - 1) * blolen + 1; i &lt;= y; i++) { int tmp = cx(ai[i], x, y); if (tmp &gt; mks) ret = ai[i], mks = tmp; else if (tmp == mks &amp;&amp; ai[i] &lt; ret) ret = ai[i]; } return ret; } void clean() {} int solve() { clean(); blolen = (int)sqrt((db)n / log2(n)); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;ai[i]), tax1[i] = ai[i], bl[i] = (i - 1) / blolen + 1; sort(tax1 + 1, tax1 + 1 + n), whw = unique(tax1 + 1, tax1 + 1 + n) - tax1 - 1; for (int i = 1; i &lt;= n; i++) ai[i] = lower_bound(tax1 + 1, tax1 + 1 + whw, ai[i]) - tax1, hh[ai[i]].push_back(i); bool f = n % blolen; for (int i = 1; i &lt;= n / blolen + f; i++) { ms(tax, 0); int mks = 0; for (int j = i; j &lt;= n / blolen + f; j++) { s[i][j] = s[i][j - 1]; for (int k = (j - 1) * blolen + 1; k &lt;= min(n, j * blolen); k++) { tax[ai[k]]++; if (tax[ai[k]] &gt; mks) mks = tax[ai[k]], s[i][j] = ai[k]; else if (tax[ai[k]] == mks &amp;&amp; ai[k] &lt; s[i][j]) s[i][j] = ai[k]; } } } while (q--) { int l, r; scanf(&quot;%d%d&quot;, &amp;l, &amp;r); l = (l + key - 1) % n + 1, r = (r + key - 1) % n + 1; if (l &gt; r) swap(l, r); printf(&quot;%d\n&quot;, key = tax1[query(l, r)]); } return 0; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;q), solve(); return 0; }]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 894E(Tarjan缩点+离线+DAG上最长路DP)]]></title>
    <url>%2FCodeforces894E%2F</url>
    <content type="text"><![CDATA[Codeforces 894E题意：给出$n$个点和$m$条有向边和出发点$fr$，求从$fr$出发可重复走的最大边权和，其中一条边如果走了一次边权就会减去当前走的次数，比如$w=56$，走过一次以后$w=56-1=55$，走过两次以后$w=56-1-2=55-2=53$，边权扣到0为止，0边权的边亦可以走。 考虑如果图中有一个强连通分量，那么这个强连通分量的所有边都可以走完(所有边权都为0)，所以考虑缩点。一个强连通分量的所有对答案贡献转为这个 强连通分量点 的点权。 如何计算边对答案的贡献? 可以二分解决，但是我这里运用了离线，先把所有边权存下来排序，然后一直进行$1+2+3+…$来决定每条边能过多少次及贡献。 然后新图就是一个DAG，在DAG上求个最长路即可，但是这幅图既有边权又有点权，所以不要忘记加上点权。 (btw: 人生第一题CFR div2E)Codeforces Submission #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;stack&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long using namespace std; LL n, m;//Input struct data { LL x, y; }ed[1000000 + 5];//原图中的边 struct data2 { LL x, y, w; }ed2[1000000 + 5];//新图中的边 struct data3 { LL no, hw, w; }wi2[1000000 + 5];//离线处理后的边权 bool cmp1(const data3 &amp;a, const data3 &amp;b) { return a.w &lt; b.w; } bool cmp2(const data3 &amp;a, const data3 &amp;b) { return a.no &lt; b.no; } vector&lt;LL&gt; G[1000000 + 5], R[1000000 + 5];//原图，新图 LL totwi[1000000 + 5];//缩点后每个点的权 LL vis[1000000 + 5], dfn[1000000 + 5], low[1000000 + 5], num[1000000 + 5], tb, en1, en2, totnum, fr, ans; //访问数组，时间戳数组，最小追溯数组，原图每个点对应新图的强连通分量编号，时间戳计数，原图边计数，新图边计数，一共有多少个scc，输入起点，最后答案 stack&lt;LL&gt; s;//Tarjan的stack，存节点 void ins1(LL x, LL y) {en1++, ed[en1] = (data){x, y}, G[x].push_back(en1);}//在原图插入一个新边 void ins2(LL x, LL y, LL w) {en2++, ed2[en2] = (data2){x, y, w}, R[x].push_back(en2);}//在新图插入一个新边 void tarjan(LL u) {//缩点 low[u] = dfn[u] = ++tb; vis[u] = -1, s.push(u); for (LL i = 0; i &lt; (LL)G[u].size(); i++) { LL v = ed[G[u][i]].y; if (vis[v] == -1) low[u] = min(low[u], dfn[v]); else if (vis[v] == 0) tarjan(v), low[u] = min(low[u], low[v]); } if (dfn[u] == low[u]) { LL e; totnum++; do { e = s.top(); s.pop(); num[e] = totnum; vis[e] = 1; } while (e != u); } } void rebuild() { ms(vis, 0); for (LL i = 1; i &lt;= m; i++) { if (num[ed[i].x] == num[ed[i].y]) totwi[num[ed[i].y]] += wi2[i].hw; }//计算强连通分量的边权和 for (LL u = 1; u &lt;= n; u++) { for (LL i = 0; i &lt; (LL)G[u].size(); i++) { LL v = ed[G[u][i]].y; if (num[v] == num[u] || vis[G[u][i]]) continue; vis[G[u][i]] = true; ins2(num[u], num[v], wi2[G[u][i]].w);//强连通分量之间的连边 } } } LL dfs(LL u) { if (vis[u] &gt; 0) return vis[u]; for (LL i = 0; i &lt; (LL)R[u].size(); i++) { LL v = ed2[R[u][i]].y; vis[u] = max(vis[u], dfs(v) + ed2[R[u][i]].w + totwi[v]);//要加上点权 } ans = max(ans, vis[u]); return vis[u]; } void clean() {//清除 ans = totnum = en1 = en2 = tb = 0; for (LL i = 0; i &lt;= n; i++) { totwi[i] = num[i] = vis[i] = dfn[i] = low[i] = 0; G[i].clear(), R[i].clear(); } } void solve() { clean(); for (LL x, y, i = 1; i &lt;= m; i++) { scanf(&quot;%I64d%I64d%I64d&quot;, &amp;x, &amp;y, &amp;wi2[i].w); wi2[i].no = i, ins1(x, y); } scanf(&quot;%I64d&quot;, &amp;fr); LL cnt = 1, i = 1, mdzz = 0, taki = 0; sort(wi2 + 1, wi2 + 1 + m, cmp1); while (i &lt;= m) { mdzz += cnt; taki += mdzz; while (mdzz &gt;= wi2[i].w &amp;&amp; i &lt;= m) { wi2[i].hw = wi2[i].w * cnt - (taki - mdzz), i++; } cnt++; }//离线求每条边贡献 sort(wi2 + 1, wi2 + 1 + m, cmp2); for (LL i = 1; i &lt;= n; i++) if (!vis[i]) tarjan(i); rebuild(); ms(vis, 0), dfs(num[fr]); printf(&quot;%I64d\n&quot;, ans + totwi[num[fr]]); } int main() { scanf(&quot;%I64d%I64d&quot;, &amp;n, &amp;m), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>离线</tag>
        <tag>Codeforces</tag>
        <tag>Tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 898E(思维)]]></title>
    <url>%2FCodeforces898E%2F</url>
    <content type="text"><![CDATA[Codeforces 898E题意：给出一串数字，可以执行操作每次使一个数减一(数字大于0)或加一，问几次操作能使一半数为平方数，一半不是。先记录数字中的平方数，如果正好一半，则不需要操作。否则如果大于一半，则要枚举每个平方数改。注意到除了0要加2才能不是平方数，其他平方数加1都能不是平方数，所以优先修改非0平方数如果小于一半，则要改最接近平方数的数。怎么找？可以考虑开方。$\sqrt a_i$如果小数部分大于0.5，则最接近$a_i$的数是$\sqrt a_i$的整数部分+1，否则是$\sqrt a_i$的整数部分-1.那么全部算出来排序优先改最接近平方数的数就可以了 Codeforces Submission #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long using namespace std; const LL INF = 1000000005; LL n, ai[200000 + 5]; LL cz[200000 + 5]; bool isPf(LL x) { LL a = sqrt(x); if (a * a == x) return true; return false; } LL getCha(LL x) { double a = sqrt((double)x) + 0.5; LL b = (LL)a; return abs(b * b - x); } void clean() { } void solve() { clean(); LL ans = 0, taki = 0; for (LL i = 1; i &lt;= n; i++) { scanf(&quot;%I64d&quot;, &amp;ai[i]); if (isPf(ai[i])) { cz[i] = INF, taki++; } else cz[i] = getCha(ai[i]); } LL z0 = 0, z1 = 0; if (taki &gt; n / 2) { for (LL i = 1; i &lt;= n; i++) { if (cz[i] == INF) { if (ai[i] == 0) z0++; else z1++; } } if (z1 &gt;= taki - n / 2) ans += taki - n / 2; else { if (z1 &lt; taki - n / 2) ans += z1, ans += (taki - n / 2 - z1) * 2; } printf(&quot;%I64d\n&quot;, ans); } else { if (taki == n / 2) {printf(&quot;%I64d\n&quot;, ans); return ;} sort(cz + 1, cz + 1 + n); for (LL i = 1; i &lt;= n; i++) { ans += cz[i], taki++; if (taki == n / 2) break; } printf(&quot;%I64d\n&quot;, ans); } } int main() { scanf(&quot;%I64d&quot;, &amp;n), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 841D(DFS)]]></title>
    <url>%2FCodeforces841D%2F</url>
    <content type="text"><![CDATA[Codeforces 841D题意：给出一个连通图，每个点有一个权值$d_i$, 只有$0,1,-1$三种值。先在在原图中求出一个子边集使得所有点满足$d_i=-1$或者$i$点的度数模$2=d_i$, 输出任何一个方案。 考虑一条边一条边地加。首先如果不选一条边，那么$di=-1$或者$di=0$的点能满足题意，因为度数都为0。而$d_i=1$的不满足。所以我们从任何一个点开始DFS(连通图可以选择任意节点)，如果某个点有一个儿子$d=1$，那么这条边必须要反选(之前选就不选，之前不选就选)，然后把儿子的$d$置为0，这个点的$d$取反。(因为多了一条边或者少了一条边，度数奇偶性变化)。最后就是如果节点1的$d=1$，那么没有父亲给他反选，怎么办？我们找到一个$d=-1$的点，然后把这个点到节点1的路径全部反选。这样只有节点1和这个点的奇偶性发生变化，而$d=-1$无视奇偶问题，所以这样就完美解决了。如果节点1的$d=1$，又没有$d=-1$的点，那么无解Codeforces Submission #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;stack&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long using namespace std; #define mp make_pair #define pll pair&lt;LL, LL&gt; vector&lt;pll&gt; G[300000 + 5]; int n, m, di[300000 + 5], vis[300000 + 5], sel[300000 + 5]; pll fa[300000 + 5]; void ins(int x, int y, int ith) { G[x].push_back(mp(y, ith)), G[y].push_back(mp(x, ith)); } void dfs(int u, int pa) { for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i].first, bh = G[u][i].second; if (v == pa || vis[v]) continue; vis[v] = true, fa[v] = mp(u, bh); dfs(v, u); if (di[v] == 1) { sel[bh] ^= 1; di[v] = 0; di[u] ^= 1; } } } void clean() { for (int i = 1; i &lt;= n; i++) vis[i] = fa[i].first = fa[i].second = 0; for (int i = 1; i &lt;= m; i++) sel[i] = 0; } void solve() { clean(); int nd = 0; for (int i = 1; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;di[i]); if (di[i] == -1) nd = i; } for (int i = 1; i &lt;= m; i++) { int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); ins(u, v, i); } vis[1] = true, dfs(1, -1); if (di[1] == 1) { if (nd == 0) {printf(&quot;-1\n&quot;); return ;} while (nd != 1) { sel[fa[nd].second] ^= 1; nd = fa[nd].first; } } int taki = 0; for (int i = 1; i &lt;= m; i++) if (sel[i]) taki++; printf(&quot;%d\n&quot;, taki); for (int i = 1; i &lt;= m; i++) if (sel[i]) printf(&quot;%d &quot;, i); } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 894D(DFS+二分)]]></title>
    <url>%2FCodeforces894D%2F</url>
    <content type="text"><![CDATA[Codeforces 894D题意：给出一颗带边权完全二叉树，有$m$个询问，每个询问有$A_i,H_i$，求从$A_i$出发分别到其他点$x$的$H_i-dis(A_i,x)$和 待更，这题不好讲Codeforces Submission #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long using namespace std; LL n, m, L[1000000 + 5]; vector&lt;LL&gt; dis[1000000 + 5], qzh[1000000 + 5]; LL query(LL a, LL h) { if (h &lt; 0) return 0; LL p = upper_bound(dis[a].begin(), dis[a].end(), h) - dis[a].begin(); return p * h - qzh[a][p - 1]; } void clean() {} void solve() { clean(); for (LL i = 2; i &lt;= n; i++) scanf(&quot;%I64d&quot;, &amp;L[i]); for (LL x = n; x &gt;= 1; x--) { dis[x].push_back(0); LL lc = (x &lt;&lt; 1), rc = (x &lt;&lt; 1 | 1); if (lc &lt;= n) for (LL i = 0; i &lt; (LL)dis[lc].size(); i++) dis[x].push_back(dis[lc][i] + L[lc]); if (rc &lt;= n) for (LL i = 0; i &lt; (LL)dis[rc].size(); i++) dis[x].push_back(dis[rc][i] + L[rc]); sort(dis[x].begin(), dis[x].end()); qzh[x].resize(dis[x].size()); qzh[x][0] = 0; for (LL i = 1; i &lt; qzh[x].size(); i++) qzh[x][i] = qzh[x][i - 1] + dis[x][i]; } while (m--) { LL a, h; scanf(&quot;%I64d%I64d&quot;, &amp;a, &amp;h); LL ans = 0, lst = 0; while (a) { if (h &lt; 0) break; ans += h; LL lc = (a &lt;&lt; 1), rc = (a &lt;&lt; 1 | 1); if (lc &lt;= n &amp;&amp; lst != lc) ans += query(lc, h - L[lc]); if (rc &lt;= n &amp;&amp; lst != rc) ans += query(rc, h - L[rc]); lst = a, h -= L[a], a &gt;&gt;= 1; } printf(&quot;%I64d\n&quot;, ans); } } int main() { scanf(&quot;%I64d%I64d&quot;, &amp;n, &amp;m), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>DFS</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 879C(Xor+构造)]]></title>
    <url>%2FCodeforces879C%2F</url>
    <content type="text"><![CDATA[Codeforces 879C题意：给出一些位运算操作，求简化位运算。可以发现所有操作都可以用三大操作完成。那么假设输入二进制数全是0($a$代表的数)或者全是1($b$代表的数)那么根据题目模拟一次，最后得到了处理的结果那么可以得到，原二进制数上如果是0或者1，之后的结果有几种情况考虑：1、这一位原来为0时变成了0，原来为1时变成了0：进行$and 1$可以完成2、这一位原来为0时变成了1，原来为1时变成了0：进行$xor 1$可以完成3、这一位原来为0时变成了0，原来为1时变成了1：不用进行4、这一位原来为0时变成了1，原来为1时变成了1：进行$or 1$可以完成(代码注释有对应情况，可以参照)之后再一起操作就行了Codeforces Submission #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long using namespace std; int n; void clean() {} void solve() { clean(); int a = 0, b = 1023; for (int x, i = 1; i &lt;= n; i++) { char s[5]; scanf(&quot;%s %d&quot;, s, &amp;x); switch (s[0]) { case &#39;^&#39; : a ^= x, b ^= x; break; case &#39;|&#39; : a |= x, b |= x; break; case &#39;&amp;&#39; : a &amp;= x, b &amp;= x; break; } } int A = 1023, X = 0, O = 0, bs = 1; for (int i = 0; i &lt; 10; i++) { int taki = a &amp; 1, mitsuha = b &amp; 1; if (taki == 0) { if (mitsuha == 0) A -= bs;//1 if (mitsuha == 1) ;//3 } else if (taki == 1) { if (mitsuha == 0) X += bs;//2 if (mitsuha == 1) O += bs;//4 } a &gt;&gt;= 1, b &gt;&gt;= 1, bs &lt;&lt;= 1; } printf(&quot;3\n| %d\n^ %d\n&amp; %d\n&quot;, O, X, A); } int main() { scanf(&quot;%d&quot;, &amp;n), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>构造</tag>
        <tag>Xor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hdu 4057(AC自动机+状压DP)]]></title>
    <url>%2Fhdu4057%2F</url>
    <content type="text"><![CDATA[hdu 4057一样的思路，设$dp(i,j,S)$为考虑了$i$个字符，在自动机$j$点上，基因状态$S$时的最大权。转移则$dp(i,v,S | zt(v)) = max(dp(i - 1, j, S) + \sum val_i \in zt(v))$注意$\sum val_i \in zt(v))$，$S$如果相应位置有则不用累加 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 100 * 10 + 5; const int fINF = -1000000000; int n, L, sz = 100 * 10; char s[105]; int f[MAXN], val[MAXN], ch[MAXN][10], zt[MAXN], dp[2][MAXN][(1 &lt;&lt; 11) + 100]; int idx(char x) { switch (x) { case &#39;A&#39; : return 0; case &#39;G&#39; : return 1; case &#39;T&#39; : return 2; case &#39;C&#39; : return 3; } return -1; } void insert(char *s, int ith) { int now = 0, len = strlen(s); for (int i = 0; i &lt; len; i++) { int c = idx(s[i]); if (!ch[now][c]) ch[now][c] = ++sz; now = ch[now][c]; if (i == len - 1) zt[now] |= (1 &lt;&lt; (ith - 1)); } } void getFail() { queue&lt;int&gt; q; f[0] = 0; for (int c = 0; c &lt; 4; c++) { int v = ch[0][c]; if (v) q.push(v), f[v] = 0; } while (!q.empty()) { int u = q.front(); q.pop(); for (int c = 0; c &lt; 4; c++) { int v = ch[u][c]; if (!v) {ch[u][c] = ch[f[u]][c]; continue;} q.push(v); int j = f[u]; while (j &amp;&amp; !ch[j][c]) j = f[j]; f[v] = ch[j][c]; zt[v] |= zt[ch[j][c]]; } } } int calscore(int s, int zzt) { int ret = 0, ws = -1, tmpS = s, tmpZ = zzt; do { ws++; if (!(tmpS &amp; 1) &amp;&amp; (tmpZ &amp; 1)) ret += val[ws + 1]; tmpS &gt;&gt;= 1, tmpZ &gt;&gt;= 1; } while (tmpZ != 0); return ret; } void cal() { dp[0][0][0] = 0; int x = 1; for (int i = 1; i &lt;= L; i++) { for (int j = 0; j &lt;= sz; j++) for (int S = 0; S &lt; (1 &lt;&lt; 10); S++) dp[x][j][S] = fINF; for (int j = 0; j &lt;= sz; j++) { for (int S = 0; S &lt; (1 &lt;&lt; 10); S++) { if (dp[x ^ 1][j][S] == fINF) continue; for (int c = 0; c &lt; 4; c++) { int v = ch[j][c]; dp[x][v][S | zt[v]] = max(dp[x][v][S | zt[v]], dp[x ^ 1][j][S] + calscore(S, zt[v])); } } } x ^= 1; } } void clean() { for (int i = 0; i &lt;= sz; i++) { for (int j = 0; j &lt; 4; j++) ch[i][j] = 0; for (int k = 0; k &lt;= (1 &lt;&lt; 10); k++) dp[0][i][k] = dp[1][i][k] = fINF; f[i] = val[i] = zt[i] = 0; } sz = 0; } void solve() { clean(); for (int i = 1; i &lt;= n; i++) { scanf(&quot;%s %d&quot;, s, &amp;val[i]); insert(s, i); } getFail(), cal(); int taki = fINF; for (int j = 0; j &lt;= sz; j++) for (int k = 0; k &lt; (1 &lt;&lt; 10); k++) taki = max(taki, dp[L % 2][j][k]); if (taki &lt; 0) printf(&quot;No Rabbit after 2012!\n&quot;); else printf(&quot;%d\n&quot;, taki); } int main() { while (scanf(&quot;%d%d&quot;, &amp;n, &amp;L) == 2) solve(); return 0; } /* 4 3 A -1 G -4 T 8 C 10 此数据可以验证你的判重对不对 */]]></content>
      <categories>
        <category>Hdu</category>
      </categories>
      <tags>
        <tag>状压DP</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 862C(构造+Xor)]]></title>
    <url>%2FCodeforces862C%2F</url>
    <content type="text"><![CDATA[Codeforces 892C题意：给出$n,x$，求构造$n$个不同的数使得其异或和为$x$.注意两个特判，具体看代码。Xor的性质：$x ⊕ 0 = x, x ⊕ x = 0$那么我们可以构造出$n-3$个数，分别为$1,2,…,n-3$，并记录异或和$a$然后剩下三个数，分别输出两个不同的极大数(比$n$大), 以及他们的异或和与$a$的异或值 这样相当于前面的被后面的异或和抵消(异或和满足右结合律)，然后两个不同的极大数是为了防止异或和重复Codeforces Submission #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; int n, x; void clean() { } void solve() { clean(); if (n == 1) { if (x == 0) printf(&quot;YES\n0&quot;); else printf(&quot;YES\n%d\n&quot;, x); return ; } else if (n == 2) { if (x == 0) printf(&quot;NO\n&quot;); else printf(&quot;YES\n%d 0\n&quot;, x); return ; } printf(&quot;YES\n&quot;); int tmp = 0, tmp1 = (1 &lt;&lt; 17), tmp2 = (1 &lt;&lt; 18); for (int i = 1; i &lt;= n - 3; i++) { printf(&quot;%d &quot;, i); tmp ^= i; } printf(&quot;%d %d %d&quot;, tmp1, tmp2, (tmp1 ^ tmp2 ^ tmp ^ x)); } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;x), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>构造</tag>
        <tag>Xor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hdu 2457(AC自动机)]]></title>
    <url>%2Fhdu2457%2F</url>
    <content type="text"><![CDATA[Hdu 2457和Bzoj 1030思想差不多，就是方程不一样这里方程是设$dp(i,j)$为考虑了$i$个字符，在自动机的$j$点上的最小代价$$dp(i,v) = min(dp(i,v), dp(i-1,j)+(c != S_i))$$其中$v$点是$ch(j, c)$(不存在则走失配边，直到有为止)，即从$j$点转移到$v$点$S$是带修理的主串 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 50 * 20 + 5, INF = 1000000000; int kase = 0, n, m, sz = 50 * 20; char s[1005]; int f[MAXN], ch[MAXN][7], danger[MAXN], dp[1005][MAXN]; int idx(char c) { switch (c) { case &#39;A&#39; : return 0; case &#39;G&#39; : return 1; case &#39;C&#39; : return 2; case &#39;T&#39; : return 3; } return -1; } void insert(char *s) { int now = 0, len = strlen(s); for (int i = 0; i &lt; len; i++) { int c = idx(s[i]); if (!ch[now][c]) ch[now][c] = ++sz; now = ch[now][c]; if (i == len - 1) danger[now] = true; } } void getFail() { queue&lt;int&gt; q; f[0] = 0; for (int c = 0; c &lt; 4; c++) { int v = ch[0][c]; if (v) q.push(v), f[v] = 0; } while (!q.empty()) { int u = q.front(); q.pop(); for (int c = 0; c &lt; 4; c++) { int v = ch[u][c]; if (!v) {ch[u][c] = ch[f[u]][c]; continue;} q.push(v); int j = f[u]; while (j &amp;&amp; !ch[j][c]) j = f[j]; f[v] = ch[j][c]; if (danger[ch[j][c]]) danger[v] = true; } } } void cal() { dp[0][0] = 0; for (int i = 1; i &lt;= m; i++) { for (int j = 0; j &lt;= sz; j++) { if (danger[j] || dp[i - 1][j] == INF) continue; for (int c = 0; c &lt; 4; c++) { int v = ch[j][c]; dp[i][v] = min(dp[i][v], dp[i - 1][j] + (c != idx(s[i]))); } } } } void clean() { for (int i = 0; i &lt;= sz; i++) { for (int j = 0; j &lt; 4; j++) ch[i][j] = 0; f[i] = danger[i] = 0; for (int j = 0; j &lt;= 1000; j++) dp[j][i] = INF;//&lt;= } sz = 0; } void solve() { clean(); for (int i = 1; i &lt;= n; i++) { scanf(&quot;%s&quot;, s); insert(s); } scanf(&quot;%s&quot;, s + 1), m = strlen(s + 1); getFail(), cal(); int taki = INF; for (int i = 0; i &lt;= sz; i++) if (!danger[i]) taki = min(taki, dp[m][i]); if (taki == INF) printf(&quot;Case %d: -1\n&quot;, ++kase); else printf(&quot;Case %d: %d\n&quot;, ++kase, taki); } int main() { while (scanf(&quot;%d&quot;, &amp;n) == 1 &amp;&amp; n) solve(); return 0; }]]></content>
      <categories>
        <category>Hdu</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>AC自动机</tag>
        <tag>Hdu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1030」「JSOI2007」文本生成器 (AC自动机+DP)]]></title>
    <url>%2Fbzoj1030%2F</url>
    <content type="text"><![CDATA[bzoj 1030题意：构造主串长为$m$，使得主串包含所有的$n$个模式串，求主串有多少种可能性。 首先可以转化问题，主串的所有可能性个数$26^m$，所有求出不包含所有的$n$个模式串的主串可能个数，补集转化即可($26^m-$不包含个数)。然后多模式串想到AC自动机，方案数想到DP。先把模式串建一个AC自动机，然后每个点如果是串的末尾，则该点标为危险点(即说明根到这个点路径非法，危险点不转移)，注意如果失配边指着危险点，那这个点也是危险的。然后设$dp(i,j)$为考虑了$i$个字符，现在在AC自动机$j$点上的方案数。$$dp(i,v) = (dp(i,v) + dp(i-1,j))$$其中$v$点是$ch(j, c)$(不存在则走失配边，直到有为止)，即从$j$点转移到$v$点注意$dp(i, x)$中每个$x$互不影响，即没有先后关系，所有$dp(i)$都是从$dp(i - 1)$转移而来的，AC自动机上的点只是作为一个方向指引如果主串字母出现不在AC自动机上的字母，那么v是会到根节点(0) #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MO = 10007, MAXN = 60 * 100 + 10; int n, m, sz = 60 * 100 + 2; int f[MAXN], ch[MAXN][30], danger[MAXN], dp[105][MAXN]; char s[105]; void insert(char *s) { int now = 0, len = strlen(s); for (int i = 0; i &lt; len; i++) { int c = s[i] - &#39;A&#39;; if (!ch[now][c]) ch[now][c] = ++sz; now = ch[now][c]; if (i == len - 1) danger[now] = true; //这个点是危险的 } } void getFail() { queue&lt;int&gt; q; f[0] = 0; for (int c = 0; c &lt; 26; c++) { int v = ch[0][c]; if (v) q.push(v), f[v] = 0; } while (!q.empty()) { int u = q.front(); q.pop(); for (int c = 0; c &lt; 26; c++) { int v = ch[u][c]; if (!v) {ch[u][c] = ch[f[u]][c]; continue;} q.push(v); int j = f[u]; while (j &amp;&amp; !ch[j][c]) j = f[j]; f[v] = ch[j][c]; if (danger[ch[j][c]]) danger[v] = true;//Mistake: danger[v] 而不是 danger[f[v]] //如果失配边指着危险点，那这个点也是危险的 } } } void cal() { dp[0][0] = 1;//初始化，主文本第0个字符在0号点上有一个方案 for (int i = 1; i &lt;= m; i++) {//枚举主文本 for (int j = 0; j &lt;= sz; j++) {//枚举每个点 if (danger[j] || !dp[i - 1][j]) continue; //是危险点，这个节点没有方案就不转移 for (int c = 0; c &lt; 26; c++) {//枚举每条边转移 int v = ch[j][c]; dp[i][v] = (dp[i][v] + dp[i - 1][j]) % MO; //dp[i - 1][j] 转移到 dp[i][v] //注意dp[i][x]中每个x互不影响，即没有先后关系，所有dp[i]都是从dp[i - 1]转移而来的，AC自动机上的点只是作为一个方向指引 //如果主串字母出现不在AC自动机上的字母，那么v是会到根节点(0) } } } } void clean() { for (int i = 0; i &lt;= sz; i++) { for (int j = 0; j &lt; 26; j++) ch[i][j] = 0; for (int j = 0; j &lt;= m; j++) dp[j][i] = 0; f[i] = danger[i] = 0; } sz = 0; } void solve() { clean(); for (int i = 1; i &lt;= n; i++) { scanf(&quot;%s&quot;, s); insert(s); } getFail(), cal(); int taki = 1, whw = 0; for (int i = 1; i &lt;= m; i++) taki = (taki * 26) % MO; for (int i = 0; i &lt;= sz; i++) if (!danger[i]) whw = (whw + dp[m][i]) % MO;//Mistake: 不是危险的状态才累加 printf(&quot;%d\n&quot;, (taki - whw + MO) % MO);//补集转化 } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>计数DP</tag>
        <tag>Bzoj</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 892D(构造)]]></title>
    <url>%2FCodeforces892D%2F</url>
    <content type="text"><![CDATA[Codeforces 892D题意：给出一个$a$数组，要求一个$a$的排列$b$，使得两个数组任意位置元素的和不同。做法：使$b$中每个数都大于$a$(最大值必须对应最小值)，那么就能保证两个数组任意位置元素的和不同。证明：1、$b$中每个数都大于$a$，那么两个数组任意位置元素的和不同2、最大值对应最小值为什么对？因为$k$小于$n$。显然在$a$中不选完所有元素，就算包含了最大值，也不会相同。 Codeforces Submission #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;map&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; int n, a[25], b[25]; map&lt;int, int&gt; whw; void clean() { } void solve() { clean(); for (int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;a[i]), b[i] = a[i]; sort(b, b + n); for (int i = 0; i &lt; n; i++) whw[b[i]] = b[(i + 1) % n]; for (int i = 0; i &lt; n; i++) printf(&quot;%d &quot;, whw[a[i]]); } int main() { scanf(&quot;%d&quot;, &amp;n), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AC自动机 学习笔记]]></title>
    <url>%2FszAC%E8%87%AA%E5%8A%A8%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[模板及讲解AC自动机是什么由Aho-Corasick发明的一种多模式串匹配算法，基本思想为在Trie上KMP。 AC自动机解决什么问题AC自动机解决多模板匹配文本串问题。复杂度$O(\sum len_i \times$ 字符集大小$)$($\sum len_i$ 即为所有模式串总长(可能比Trie树大小大)，字符集大小为出现的字符种类个数) AC自动机的实现例题：Hdu 2222 题意：第一行输入测试数据的组数，然后输入一个整数n，接下来的n行每行输入一个单词，最后输入一个字符串，问在这个字符串中有多少个单词出现过。 原理 (求失配函数)AC自动机是在Trie树上加上失配边完成的。如图所示为加入hers, hehe, he模式串的情况。 可以看出在5到6(已经匹配heh如果)失配，则回到1。6失配同理。与KMP算法有类似之处，所以AC自动机的失配函数与KMP相似。AC自动机失配函数由BFS可以求得。具体可以看下列代码 代码实现程序主要函数：$insert$(插入单词), $find$(进行匹配), $getFail$(求失配函数)其中$insert$(插入单词)为Trie树部分。 坑点：1、 sz初始化为500000不是500000 + 52、ch从0开始清空 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; int n, sz = 500000, ch[500000 + 5][30], val[500000 + 5], tms[500000 + 5], lst[500000 + 5], f[500000 + 5], used[10000 + 5]; //n，节点时间戳，字典树数组，是否是单词, 单词出现个数，上一个单词位置(后缀链接)，失配函数，该单词是否记录过 char s[1000000 + 5]; int ans;//答案 void g(int u) {//统计 if (!used[val[u]] &amp;&amp; u) ans += tms[u], used[val[u]] = true, g(lst[u]); //如果没有记录过并且有单词(u!=0), 则加上数量继续向下递归处理 } void insert(char *s, int u, int ith, int a, int len) {//插入一个单词(递归更新，不建议) int c = s[a] - &#39;a&#39;; if (ch[u][c] == 0) ch[u][c] = ++sz;//新建节点 if (a == len - 1) val[ch[u][c]] = ith, tms[ch[u][c]]++; else insert(s, ch[u][c], ith, a + 1, len); //如果是最后一个要加是单词的标记，并且注意重复的单词 } void insert(char *s, int ith) {//插入一个单词(迭代更新，建议) int now = 0, len = strlen(s); for (int i = 0; i &lt; len; i++) { int c = s[i] - &#39;a&#39;; if (!ch[now][c]) ch[now][c] = ++sz;//新建节点 now = ch[now][c]; if (i == len - 1) val[now] = ith, tms[now]++; //如果是最后一个要加是单词的标记，并且注意重复的单词 } } void find(char *T) {//用字符串T当做文本串找模式串 int len = strlen(T), j = 0;//从0开始 for (int i = 0; i &lt; len; i++) { int c = T[i] - &#39;a&#39;; j = ch[j][c]; if (val[j]) g(j); else if (lst[j]) g(lst[j]);//如果当前位置有单词或者有上一个单词(不会多余, 例子1看代码末行)则处理 } } void getFail() {//得到失配函数 queue&lt;int&gt; q; f[0] = 0;//初始化开始点的失配函数为0 for (int c = 0; c &lt; 26; c++) {//初始化所以与0相连的点 int v = ch[0][c]; if (v) q.push(v), f[v] = 0, lst[v] = 0; } while (!q.empty()) {//bfs更新 int u = q.front(); q.pop(); for (int c = 0; c &lt; 26; c++) { int v = ch[u][c]; if (!v) {ch[u][c] = ch[f[u]][c]; continue;} //Trie上没有这条边 q.push(v); int j = f[u]; while (j &amp;&amp; !ch[j][c]) j = f[j];//沿着失配边走 f[v] = ch[j][c], lst[v] = (val[f[v]]) ? (f[v]) : (lst[f[v]]); //得到失配函数值，求出lst值 } } } void clean() {//清除 for (int i = 0; i &lt;= sz; i++) { for (int j = 0; j &lt; 26; j++) ch[i][j] = 0; f[i] = lst[i] = val[i] = tms[i] = 0; } for (int i = 0; i &lt;= n; i++) used[i] = false; sz = 0; } void solve() { scanf(&quot;%d&quot;, &amp;n); clean(); for (int i = 1; i &lt;= n; i++) { scanf(&quot;%s&quot;, s); //insert(s, 0, i, 0, strlen(s));//递归 insert(s, i);//迭代 } scanf(&quot;%s&quot;, s); getFail(), ans = 0, find(s); printf(&quot;%d\n&quot;, ans); } int main() { int T; scanf(&quot;%d&quot;, &amp;T); while (T--) solve(); return 0; } /* 例子1： 1 2 errd rr errd 如果不执行该语句，rr则不能被算入 */ AC自动机延伸知识介绍 Trie，Trie图，Fail树 将字符串插入 Trie 即可得到下图 将失配函数连上，得到Trie图 Trie图可以将字符串问题转化为图论问题，具体可以看Bzoj 2938 将原边删掉，失配边反向，得到Fail树 Fail树每个点的祖先节点都是这个点失配后可以走到的点。对于AC自动机中的每一个节点，如果节点A的失配边指向节点B，就会发现B对应的字符串一定在A对应的字符串中出现，那么在Fail树上显然可以利用这一性质。Bzoj 2434 常见题型1、多模式串匹配Q: 多模式串匹配解: 用模式串建立AC自动机例题: Hdu 22222、在AC自动机状态图上DPQ: 有多个模式串，要求主串满足一些条件解: 用模式串建立AC自动机，然后再AC自动机上DP例题: Bzoj 1030]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2017 游记]]></title>
    <url>%2FzzNOIP2017%2F</url>
    <content type="text"><![CDATA[$Day 0$晚上什么也没有复习……考试前该复习的也复习了……和学长们一起玩了一晚上…… $Day 1$早上吃完饭就到六中考场了，然而今天的解压密码：Bu%Wangchu&amp;xin!!!不忘初心，好的。t1一看居然不会？smg，赶紧看T2，去年的D1T2是最难的，今年D1T2一看我还以为要写编译器qaq，结果一看是暴力然后毫不犹豫就想DFS了……然后看T3，暴力分可以拿30……然后手速把T3写完过了，不管直接打T2然后写了一大串代码……谁叫我打DFS呢……这不就是stack模拟吗……蠢了然后之后大样例过不了，代码魔改来都看不懂了，然后果断放弃看T1。这个时候考试时间已经过了一大半了看了看T1，毫无思路，然而暴力分也只有30分（今年noip真tm暴力分少啊）然后做死想二分优化暴力，这不是有序数列二分个鬼啊。最后到时间了。Day1期望分数：0+30+30=60完败。出来之后问dalaoT1居然打表找规律？$ab-a-b$??当时我就炸了，然后发现t2的暴力也很多人切了，感觉这次要GG。晚上继续颓。 $Day 1$又来到考场，解压密码stm什么alphaGo……t1什么鬼立体几何？好吧仔细一看就是图论水题。10min秒过。t2这什么鬼怎么连暴力都不会打？跳t3暴力分有40还是50吧，直接就打了，当时脑子炸了什么都想不出来。然后发现t2 10%的数据可以求树的重心，然后就打了(直接暴力都行打什么重心啊)然后就GG了，一直看t2怎么解。中途算暴力复杂度还算错了Day2期望分数：100+10+40=150出来之后T1貌似有人不会？然后居然t2可以prim水……而且据说暴力70？我复杂度算错了没打……真的完败……这次分数线肯定比上次高下午回校。 综测：Day1:35分，Day2:150分连二等都没有，真的是要反省一下了。 Day1T1：不要忘记了水法打表找规律T2：暴力要打过，能枚举解决就不要搜索T3：暴力要做对，不要挂Day2T1：多做题才能见题型T2：暴力的时间复杂度不要误算，谨慎地算T3：要多想正解，不要脑子僵化整体：考场上不要紧张，要沉着，不要患得患失，要好好分析问题，切勿粗心/想当然]]></content>
      <categories>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>杂文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[caioj 1114(树形DP)]]></title>
    <url>%2Fcaioj1114%2F</url>
    <content type="text"><![CDATA[caioj 1114边权型树形DP，选$Q$条边等价于选$Q+1$个点。那么边权转到点权上，做个普通树形背包即可 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 310 + 5; struct data { int v, e_val; }ed[MAXN * 2]; vector&lt;int&gt; G[MAXN]; int en, n, q, v_val[MAXN], dp[MAXN][MAXN]; void ins(int u, int v, int c) { ed[en] = (data){v, c}, G[u].push_back(en++); ed[en] = (data){u, c}, G[v].push_back(en++); } void dfs1(int u, int p) { for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = ed[G[u][i]].v, val = ed[G[u][i]].e_val; if (v != p) { v_val[v] = val; dfs1(v, u); } } } void dfs2(int u, int p) { for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = ed[G[u][i]].v; if (v != p) { dfs2(v, u); for (int j = q - 1; j &gt;= 0; j--) for (int k = 0; k &lt;= j; k++) dp[u][j] = max(dp[u][j], dp[v][k] + dp[u][j - k]); } } for (int j = q; j &gt;= 0; j--) if (j &lt; 1) dp[u][j] = 0; else dp[u][j] = dp[u][j - 1] + v_val[u]; } void clean() { en = 0; for (int i = 0; i &lt;= n; i++) { G[i].clear(), v_val[i] = 0; for (int j = 0; j &lt;= n; j++) dp[i][j] = 0; } } void solve() { clean(); q++; for (int u, v, c, i = 1; i &lt; n; i++) scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;c), ins(u, v, c); dfs1(1, 0); dfs2(1, 0); printf(&quot;%d\n&quot;, dp[1][q]); } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;q), solve(); return 0; } 题目描述有一棵苹果树，如果树枝有分叉，可以是分多叉，分叉数k&gt;=0（就是说儿子的结点数大于等于0）这棵树共有N个结点（叶子点或者树枝分叉点），编号为1~N,树根编号一定是1。我们用一根树枝两端连接的结点的编号来描述一根树枝的位置。下面是一颗有4个树枝的树 现在这颗树枝条太多了，需要剪枝。但是一些树枝上长有苹果。给定需要保留的树枝数量，求出最多能留住多少苹果。输入格式:输入第一行包含两个整数n，k(1&lt;=k 输入接下来的n – 1行，每一行包含三个整数x，y，c，表示节点x和y之间有一条树枝。c表示这根树枝上苹果的数量。输出格式：输出一行，为最多可以保留的苹果数。 Input6 21 3 11 4 101 6 212 3 203 5 20 Output31 数据规模：对于20%的数据，满足1 &lt;= n &lt;=15。对于40%的数据，满足1 &lt;= n &lt;=100。对于100%的数据，满足1 &lt;= n &lt;=310。]]></content>
      <categories>
        <category>caioj</category>
      </categories>
      <tags>
        <tag>树形DP</tag>
        <tag>caioj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[caioj 1107(树形DP)]]></title>
    <url>%2Fcaioj1107%2F</url>
    <content type="text"><![CDATA[caioj 1107二叉树树形DP，设$dp(u, a)​$为$u​$节点所为根的子树保留$a​$条树枝的最优值则 $dp(u, i) = max(dp(lc, i - j - 2) + dp(rc, j) | 1 \leq i \leq Q, 0 \leq j \leq i - 2)$(减二是因为要连接这两个子树所需要的代价)初值$dp(u, 0) = 0$，最后的答案就很显然了 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 100 + 5; struct data { int v, val; }ed[MAXN * 2]; vector&lt;int&gt; G[MAXN]; int n, q, dp[MAXN][MAXN], en; void ins(int u, int v, int c) { ed[en] = (data){v, c}, G[u].push_back(en++); ed[en] = (data){u, c}, G[v].push_back(en++); } void dfs(int u, int p) { int c1 = -1, c2 = -1, v1, v2, flag = true; for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = ed[G[u][i]].v, val = ed[G[u][i]].val; if (v != p) { flag = false; if (c1 == -1) c1 = v, v1 = val; else if (c2 == -1) c2 = v, v2 = val; dfs(v, u); } } if (!flag) for (int j = 1; j &lt;= q; j++) { dp[u][j] = max(dp[u][j], dp[c1][j - 1] + v1); dp[u][j] = max(dp[u][j], dp[c2][j - 1] + v2); for (int k = 0; k &lt;= j - 2; k++) { int l = j - 2; dp[u][j] = max(dp[u][j], dp[c1][l - k] + dp[c2][k] + v1 + v2); } } } void clean() { en = 0; for (int i = 0; i &lt;= n; i++) { G[i].clear(); for (int j = 0; j &lt;= n; j++) dp[i][j] = 0; } } void solve() { clean(); for (int u, v, c, i = 1; i &lt; n; i++) scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;c), ins(u, v, c); dfs(1, 0); printf(&quot;%d\n&quot;, dp[1][q]); } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;q), solve(); return 0; } /* 9 5 1 2 10 1 3 8 2 7 4 2 6 6 7 8 7 7 9 2 3 5 2 3 4 8 */ 题目描述【问题描述】有一棵苹果树，如果树枝有分叉，一定是分2叉（就是说没有只有1个儿子的结点）。这棵树共有N个结点（叶子点或者树枝分叉点），编号为1~N,树根编号一定是1。我们用一根树枝两端连接的结点的编号来描述一根树枝的位置。下面是一颗有4个树枝的树 现在这颗树枝条太多了，需要剪枝。但是一些树枝上长有苹果。给定需要保留的树枝数量，求出最多能留住多少苹果。【输入格式】第1行2个数，N和Q(1&lt;=Q&lt;= N,1&lt;N&lt;=100)。N表示树的结点数，Q表示要保留的树枝数量。接下来N-1行描述树枝的信息。每行3个整数，前两个是它连接的结点的编号。第3个数是这根树枝上苹果的数量。每根树枝上的苹果不超过30000个。【输出格式】一个数，最多能留住的苹果的数量。【样例】输入：5 21 3 11 4 102 3 203 5 20输出：21]]></content>
      <categories>
        <category>caioj</category>
      </categories>
      <tags>
        <tag>树形DP</tag>
        <tag>caioj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 854D(前缀和+二分)]]></title>
    <url>%2FCodeforces854D%2F</url>
    <content type="text"><![CDATA[Codeforces 854D题意：有n+1个城市，每个城市都有一个人，他们要去0城市参加活动，一起待k天，然后再回来，你可以提前去也可以延后回去，问 你能不能使所有人一起待k天，可以的话，最小花费是多少？ 我们维护两个前缀和数组$l_i, r_i$，分别表示$i$前面的航班可以使得所有人到达0城市的最小费用、$i$后前面的航班可以使得所有人回去的最小费用，计算直接再开个数组记录各个城市的最小值即可。然后答案可以合并，是$max(l_i+r_j)$，其中$j$是离$d_i+k+1$天最近的航班。因为有可能回去的$r_i$对应的航班$i$是到达0城市的航班，中途被我continue了(其实其他方法可以避免)，使得单调性被破坏，我们可以进行恢复单调性(看代码注释部分)，所以直接找 离$d_i+k+1$天最近的航班 就是当前最优解。用二分找较为合适，复杂度$O(nlogn)$ Codeforces Submission #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXM = 100000 + 5; const LL INF = 9223372036854775807; struct data { int d, f, t, c; bool operator &lt; (const data &amp;b) const { return d &lt; b.d; } }a[MAXM]; int n, m, k; LL l[MAXM], r[MAXM], cost[MAXM]; void clean() { for (int i = 0; i &lt;= m + 1; i++) l[i] = r[i] = -1; } void solve() { clean(); for (int i = 1; i &lt;= m; i++) scanf(&quot;%d%d%d%d&quot;, &amp;a[i].d, &amp;a[i].f, &amp;a[i].t, &amp;a[i].c); sort(a + 1, a + 1 + m); for (int i = 0; i &lt;= m + 1; i++) cost[i] = INF; int cnt = 0; LL tot = 0; for (int i = 1; i &lt;= m; i++) { if (a[i].f == 0) continue;//单调性被破坏，但是这里无所谓，因为都能被遍历到 if (cost[a[i].f] == INF) cnt++, cost[a[i].f] = (LL)a[i].c, tot += (LL)a[i].c; else if (cost[a[i].f] &gt; a[i].c) tot -= cost[a[i].f], cost[a[i].f] = (LL)a[i].c, tot += (LL)a[i].c; if (cnt == n) l[i] = tot; } for (int i = 0; i &lt;= m + 1; i++) cost[i] = INF; cnt = 0, tot = 0; for (int i = m; i &gt;= 1; i--) { if (a[i].t == 0) continue;//单调性被破坏 if (cost[a[i].t] == INF) cnt++, cost[a[i].t] = (LL)a[i].c, tot += (LL)a[i].c; else if (cost[a[i].t] &gt; a[i].c) tot -= cost[a[i].t], cost[a[i].t] = (LL)a[i].c, tot += (LL)a[i].c; if (cnt == n) r[i] = tot; } for (int i = m - 1; i &gt;= 1; i--) {//恢复单调性 if (r[i] == -1) r[i] = r[i + 1]; } LL sc = INF; for (int i = 1; i &lt;= m; i++) { int ans = 0, dd = a[i].d + k + 1, L = i + 1, R = m + 1; if (l[i] == -1) continue; if (L &gt; R) continue; while (L &lt; R) { int mid = (L + R) &gt;&gt; 1; if (a[mid].d &lt; dd) { L = mid + 1; } else ans = R = mid; } if (r[ans] == -1) continue; sc = min(sc, l[i] + r[ans]); } if (sc == INF) printf(&quot;-1\n&quot;); else printf(&quot;%I64d\n&quot;, sc); } int main() { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>二分</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 855B(枚举)]]></title>
    <url>%2FCodeforces855B%2F</url>
    <content type="text"><![CDATA[Codeforces 855B题意：给一个数组，求$p \cdot a_i + q \cdot a_j + r \cdot a_k$的最大值$(1 \leq i \leq j \leq k \leq n) $维护前缀后缀最大值/最小值，然后我们枚举中间值$j$，算每个$j$作为中间点的值然后$q$的贡献为$q \cdot a_i$而对于$p$, 如果有$p \geq 0$，那么$p$的贡献为$p \cdot lmax_i$，反之$p$的贡献为$p \cdot lmin_i$对于$r$, 如果有$r \geq 0$，那么$r$的贡献为$r \cdot rmax_i$，反之$r$的贡献为$r \cdot rmin_i$然后最后可以得出一个最大的值，即为答案Codeforces Submission #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 100000 + 5; const LL INF = 9223372036854775807; LL n, p, q, r, a[MAXN], lmax[MAXN], lmin[MAXN], rmax[MAXN], rmin[MAXN]; void clean() { for (LL i = 0; i &lt;= n + 1; i++) lmax[i] = rmax[i] = -INF, lmin[i] = rmin[i] = INF; } void solve() { clean(); for (LL i = 1; i &lt;= n; i++) scanf(&quot;%I64d&quot;, &amp;a[i]); for (LL i = 1; i &lt;= n; i++) lmax[i] = max(lmax[i - 1], a[i]), lmin[i] = min(lmin[i - 1], a[i]); for (LL i = n; i &gt;= 1; i--) rmax[i] = max(rmax[i + 1], a[i]), rmin[i] = min(rmin[i + 1], a[i]); LL ans = -INF; for (LL i = 1; i &lt;= n; i++) { LL tot = q * a[i]; if (p &lt; 0) tot += p * lmin[i]; else tot += p * lmax[i]; if (r &lt; 0) tot += r * rmin[i]; else tot += r * rmax[i]; ans = max(ans, tot); } printf(&quot;%I64d\n&quot;, ans); } int main() { scanf(&quot;%I64d%I64d%I64d%I64d&quot;, &amp;n, &amp;p, &amp;q, &amp;r), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 864D(贪心)]]></title>
    <url>%2FCodeforces864D%2F</url>
    <content type="text"><![CDATA[Codeforces 864D题意：给出一个n，以及n个数，这n个数范围为1~n。 现在问最少改变几个数能使这n个数成为1~n的排列，若有多种情况，使排列的字典序最小。 第一问就是不在给的序列中的数的个数，第二问我们考虑贪心。要使得字典序最小，那就得让前面的元素尽量小。我们把不在序列中的数全部由底至上从大到小放到一个栈里(或者小根堆)，然后我们对于重复出现的元素，一定要修改，但要留下一个。那么我们考虑留下哪一个就好了。顺序扫一遍如果当前元素还能被替换(个数大于1), 那么如果当前栈顶比当前元素小，那就直接替换(替换时要出栈以及个数减一)；反之就要跳过这个数不修改(只能跳一次，因为是要构成排列)。这样得到的序列一定是字典序最小的。 Codeforces Submission #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 200000 + 5; int vis[MAXN], cnt[MAXN], n, ai[MAXN], s[MAXN], top; void clean() { ms(cnt, 0), ms(vis, 0), top = 0; } void solve() { clean(); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;ai[i]), cnt[ai[i]]++; for (int i = n; i &gt;= 1; i--) if (cnt[i] == 0) s[++top] = i; printf(&quot;%d\n&quot;, top); for (int i = 1; i &lt;= n; i++) { if (cnt[ai[i]] &gt; 1) { if (vis[ai[i]] || ai[i] &gt; s[top]) cnt[ai[i]]--, ai[i] = s[top--]; else vis[ai[i]] = 1; } } for (int i = 1; i &lt;= n; i++) printf(&quot;%d &quot;, ai[i]); } int main() { scanf(&quot;%d&quot;, &amp;n), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 854C(堆+贪心)]]></title>
    <url>%2FCodeforces854C%2F</url>
    <content type="text"><![CDATA[Codeforces 854C题意：有n架飞机，第i架飞机原本计划在第i分钟起飞，可是由于某种原因整个机场前k分钟是不能起飞的，每分钟只能起飞一架飞机，然后告诉你每架飞机每延误一分钟会造成的损失，问你如何安排飞机的起飞时间才能将损失降到最少（飞机不能提前起飞）。 把所有飞机的延迟时间按照当前时间一一插入，然后每次起飞就飞延迟时间大的那个，因为越往后拖越损失大。 Codeforces Submission #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; struct data { int no, c; bool operator &lt; (const data &amp;b) const { return c &lt; b.c; } }; int n, k, sc[300000 + 5]; priority_queue&lt;data&gt; q; void clean() { } void solve() { clean(); LL ans = 0; for (int i = 1; i &lt;= n + k; i++) { if (i &lt;= n) { int x; scanf(&quot;%d&quot;, &amp;x); q.push((data){i, x}); } if (i &gt; k) { data p = q.top(); q.pop(); ans += (LL)p.c * (LL)(i - p.no); sc[p.no] = i; } } printf(&quot;%I64d\n&quot;, ans); for (int i = 1; i &lt;= n; i++) printf(&quot;%d &quot;, sc[i]); } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;k), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>堆</tag>
        <tag>贪心</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2009 T3(Tarjan缩点+DP / 最短路松弛 / DFS / BFS)]]></title>
    <url>%2FNOIP2009T3%2F</url>
    <content type="text"><![CDATA[这题好多种方法……Orz各路神仙 我先想到的是删与 1 和 n 点都连通的点，然后 Tarjan 缩点之后，枚举每个原图点作为买入点，然后维护和这个点连通的点(scc)权值最大值，减一下就行。删点 DFS 标记一下，不过要建反图。和这个点连通的点(scc)权值最大值可以用 DP 求得，直接记忆化搜索一下。 然后第二种做法是做两次最短路松弛找到每个点$i$的$1,i$最小值，$i,n$最大值，之后枚举点更新即可。 第三种做法是 DFS。我们发现就只有三种情况，1、找一个点买，2、找一个点卖，3、到终点。所以每次 DFS 三种情况，用数组可以判重。 第四种做法是 BFS。和DFS差不多。也可以 DP 思想跑 BFS。 第五种做法是 分层图最短路。这里 fy1234567ok 的思路，非常好，也就是把原图分层3个层，第一层是寻找买入点，第二层是寻找售出点，第三层是寻找n点。中间连边代表操作。对于没有贸易活动，直接连到超级n点处。 缩点+DP做法： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;stack&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 100000 + 5, MAXM = 500000 + 5; struct edge {int u, v, nxt; } ed[MAXM * 2], ed_2[MAXM * 2], ed_scc[MAXM * 2]; int n, m, c[MAXN], D[MAXN]; int en, en_2, en_scc, hd[MAXN], hd_2[MAXN], hd_scc[MAXN]; int lnkn[MAXN], lnk1[MAXN]; int low[MAXN], dfn[MAXN], vis[MAXN], sz, scc_sz, scc_belong[MAXN], scc_max[MAXN]; stack&lt;int &gt; s; void ins(int u, int v) {ed[++en] = (edge){u, v, hd[u]}, hd[u] = en;} void ins_2(int u, int v) {ed_2[++en_2] = (edge){u, v, hd_2[u]}, hd_2[u] = en_2;} void ins_scc(int u, int v) {ed_scc[++en_scc] = (edge){u, v, hd_scc[u]}, hd_scc[u] = en_scc;} void dfs1(int u) { // dfs on ed_2 for (int i = hd_2[u]; i &gt; 0; i = ed_2[i].nxt) { edge &amp;e = ed_2[i]; if (!lnkn[e.v]) lnkn[e.v] = 1, dfs1(e.v); } } void dfs2(int u) { // dfs on ed for (int i = hd[u]; i &gt; 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (!lnk1[e.v]) lnk1[e.v] = 1, dfs2(e.v); } } void tarjan(int u) { // tarjan on ed //if (!lnk1[u] || !lnkn[u]) return ; low[u] = dfn[u] = ++sz, vis[u] = -1, s.push(u); for (int i = hd[u]; i &gt; 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (!vis[e.v]) { //if (!lnk1[u] || !lnkn[u]) continue ; tarjan(e.v); low[u] = min(low[u], low[e.v]); } else if (vis[e.v] == -1) low[u] = min(low[u], dfn[e.v]); } if (dfn[u] == low[u]) { int e; ++scc_sz; do { e = s.top(); s.pop(); scc_belong[e] = scc_sz; scc_max[scc_sz] = max(c[e], scc_max[scc_sz]); vis[e] = 1; } while (e != u); } } int DP(int u) { ///dp on ed_scc if (D[u] &gt;= 0) return D[u]; int tmp = scc_max[u]; for (int i = hd_scc[u]; i &gt; 0; i = ed_scc[i].nxt) { edge &amp;e = ed_scc[i]; tmp = max(tmp, DP(e.v)); } return D[u] = tmp; } void clean() { scc_sz = sz = en = en_2 = en_scc = 0, ms(hd, 0), ms(hd_2, 0), ms(hd_scc, 0); ms(scc_max, 0), ms(D, -1), ms(vis, 0), ms(scc_belong, 0), ms(lnk1, 0), ms(lnkn, 0); } int solve() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;c[i]); clean(); for (int x, y, z, i = 1; i &lt;= m; ++i) { scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z); if (z == 1) ins(x, y), ins_2(y, x); else ins(x, y), ins(y, x), ins_2(x, y), ins_2(y, x); } lnkn[n] = 1, dfs1(n); lnk1[1] = 1, dfs2(1); if(!lnkn[1]) return printf(&quot;0\n&quot;), 0; // for (int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, lnk1[i]); // putchar(&#39;\n&#39;); // for (int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, lnkn[i]); for (int u = 1; u &lt;= n; ++u) if (!lnk1[u] || !lnkn[u]) vis[u] = 1; tarjan(1); // for (int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, scc_belong[i]); for (int u = 1; u &lt;= n; ++u) { if (!lnk1[u] || !lnkn[u]) continue ; for (int i = hd[u]; i &gt; 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (scc_belong[u] != scc_belong[e.v]) ins_scc(scc_belong[u], scc_belong[e.v]); } } DP(scc_belong[1]); // for (int i = 1; i &lt;= scc_sz; ++i) printf(&quot;%d &quot;, D[i]); int ans = 0; for (int st = 1; st &lt;= n; ++st) ans = max(ans, D[scc_belong[st]] - c[st]); printf(&quot;%d\n&quot;, ans); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>BFS</tag>
        <tag>Tarjan</tag>
        <tag>最短路</tag>
        <tag>DFS</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 844C(DFS)]]></title>
    <url>%2FCodeforces844C%2F</url>
    <content type="text"><![CDATA[Codeforces 844C题意：给你一个序列，这个是序列是乱序的，你需要把它给排序，你有k个桶，每个数放入桶以后就会自动排序，然后再把这些数按原来的位置按现在的顺序放入，使得这个序列变得有序。问最大的k为多少？ 先对原数组进行离散化，然后就得到一个1到$n$的排列。每个数要排到相应为位置(即$i=a[i]$)，那么我们逐位DFS，每次DFS到该位上的数值。因为$i$位置上的数$a[i]$是要被操作到$a[i]$位置上的，所以这次选的桶必须要选择$a[i]$。然后到了$a[i]$位置按照此过程继续走，直到之后走到的位置之前走过，就能停止了，这时只需要输出所有经过的节点就行，用set存比较好，自动拍好了序。由于操作次数要第一行输出，所以要用$n$个vector存答案，具体看代码的实现。 Codeforces Submission #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 100000 + 5; int n, a[MAXN], tmp[MAXN], vis[MAXN], ans; vector&lt;int&gt; step[MAXN]; set&lt;int&gt; s; void dfs(int u) { if (vis[a[u]] == -1) return ; //DFS到该位上的数值a[u] if (vis[a[u]] == 0) s.insert(a[u]), vis[a[u]] = 1, dfs(a[u]); else { step[++ans].push_back(s.size()); for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++) { step[ans].push_back(*it), vis[*it] = -1; } s.clear(); } } void clean() { ans = 0, ms(vis, 0); } void solve() { clean(); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]), tmp[i] = a[i]; sort(tmp + 1, tmp + 1 + n); int nx = unique(tmp + 1, tmp + 1 + n) - tmp - 1; for (int i = 1; i &lt;= n; i++) a[i] = lower_bound(tmp + 1, tmp + 1 + nx, a[i]) - tmp; for (int i = 1; i &lt;= n; i++) dfs(i); printf(&quot;%d\n&quot;, ans); for (int i = 1; i &lt;= ans; i++) { for (int j = 0; j &lt; (int)step[i].size(); j++) { printf(&quot;%d &quot;, step[i][j]); } printf(&quot;\n&quot;); } } int main() { scanf(&quot;%d&quot;, &amp;n), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 842D(Trie维护二进制数+Xor)]]></title>
    <url>%2FCodeforces842D%2F</url>
    <content type="text"><![CDATA[Codeforces 842D题意：给你$n(n \leq 3 \times 10^5)$个数，有$m(m \leq 3 \times 10^5)$次询问，每次询问给一个数$x$，要你把整个序列所有数都与$x$异或，然后取$mex$值 考虑Trie树维护序列中每个数的二进制形式值，从左到右由根到叶子插入(比如插入$(100)_2$先插入1边再插入0边)。考虑设一个最大深度$MNL$，所有数的二进制位数都要为$MNL$，不足在左边补0。$MNL$的大小必须大于所有数二进制形式长度。之后我们就得到了一棵维护二进制数的Trie。先不管异或，我们来谈谈$mex$的求法。这是一个贪心过程，因为首位越小数字越小，所以在Trie树中找最小的不存在的数即可以从根开始往下走，如果能走0边，就走0边。不能走的情况是，0边这个方向的子树大小是满的，不会有空，所以子树下的都在集合中，不是$mex$，那么就往1边走。如果向下走出现了没有节点可走，那么下面就直接全部选0边(这里的0边都是不存在的)往下走即可。由于xor满足右结合，$a$异或$b$异或$c= a$异或$(b$异或$c)$。那么我们每次询问只需要把前程的所有$x$异或起来得到$nx$就行了。字典树怎么异或？很麻烦，时间也不保证。我们尝试不修改字典树来进行查询$mex$对于$nx$，如果要求得原序列以后的$mex$，从根向下遍历，类似不异或的情况。但是选边尽量要选和$nx$二进制下的边相同的。因为这样异或以后就是0。然后每次询问就可以了，类似不异或的情况 Trie维护二进制很常用！ Codeforces Submission #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 3 * 100000 + 5, MAX_NODE_LOG = 20; int n, m, sz; struct data { int siz, dep, p, ch[2]; }node[MAX_NODE_LOG * MAXN]; void ins(int u, int x, int ws) { if (ws == 0) node[u].siz = 1; if (ws == 0) return ; int a = x &gt;&gt; (ws - 1) &amp; 1; if (node[u].ch[a] == 0) node[u].ch[a] = ++sz, node[node[u].ch[a]].p = u, node[node[u].ch[a]].dep = node[u].dep + 1; ins(node[u].ch[a], x, ws - 1); node[u].siz = node[node[u].ch[0]].siz + node[node[u].ch[1]].siz + 1; } int flag, ans[MAX_NODE_LOG + 5], yyq; void query(int u, int x) { if (flag) return ; if (yyq == 0) return ; int a = x &gt;&gt; (yyq - 1) &amp; 1; if (node[node[u].ch[a]].siz != (1 &lt;&lt; (MAX_NODE_LOG - node[node[u].ch[a]].dep + 1)) - 1) { ans[yyq--] = a; if (node[u].ch[a] != 0) query(node[u].ch[a], x); else { while (yyq) ans[yyq] = x &gt;&gt; (yyq - 1) &amp; 1, yyq--; flag = true; return ; } } else { ans[yyq--] = !a; if (node[u].ch[!a] != 0) query(node[u].ch[!a], x); else { while (yyq) ans[yyq] = x &gt;&gt; (yyq - 1) &amp; 1, yyq--; flag = true; return ; } } } void clean() { sz = 1; for (int i = 0; i &lt; MAX_NODE_LOG * MAXN; i++) node[i].siz = node[i].dep = node[i].p = node[i].ch[0] = node[i].ch[1] = 0; } void solve() { clean(); int nx = 0; for (int x, i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;x), ins(1, x, MAX_NODE_LOG); for (int x, i = 1; i &lt;= m; i++) { scanf(&quot;%d&quot;, &amp;x), nx ^= x; flag = false, yyq = MAX_NODE_LOG, ms(ans, 0), query(1, nx); int zz = MAX_NODE_LOG, fans = 0; while (zz &gt; 0) { if (ans[zz] != (nx &gt;&gt; (zz - 1) &amp; 1)) fans += 1 &lt;&lt; (zz - 1); zz--; } printf(&quot;%d\n&quot;, fans); } } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>Xor</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 842C(DFS+Set)]]></title>
    <url>%2FCodeforces842C%2F</url>
    <content type="text"><![CDATA[Codeforces 842C题意：给定一棵树和它各个点的权值，对于一个结点它的美丽值是指他到根的路径上所有点权值的最大公约数，对于每个结点到根的路径，可以修改一个点的权值到0，问每个点的最大美丽值 树上暴力即可。暴力每个点改0的情况。进行DFS，维护$now$(根到路径上所有数的$gcd$), $p$($u$的父亲), $s_u$($u$的集合(答案集合))如果当前节点不改0，则当前节点可以和前面改过0或者没改过0的答案结合如果当前节点改0，则当前节点只能和前面没改过0的答案结合($now$的作用) 然后之后输出$s_u$最后一个元素($set$内自动从小到大排序)即可 由于每个数的因子是分散的$\sqrt n$个，所以几个数的$gcd$很快变$1$，即$set$内元素个数不多，所以能很快算出答案Codeforces Submission #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 2 * 100000 + 5; set&lt;int&gt; s[MAXN]; vector&lt;int&gt; G[MAXN]; int n, a[MAXN]; int gcd(int a, int b) { if (a == 0) return b; if (b == 0) return a; return gcd(b, a % b); } void dfs(int u, int p, int now) { for (set&lt;int&gt;::iterator it = s[p].begin(); it != s[p].end(); it++) s[u].insert(gcd(*it, a[u]));//与前面改过或者没改过的答案结合 s[u].insert(now);//与前面没改过的答案结合 now = gcd(now, a[u]), s[u].insert(now);//和前面没改过0的答案结合 for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i]; if (v != p) dfs(v, u, now); } } void clean() {} void solve() { clean(); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]); for (int u, v, i = 1; i &lt; n; i++) scanf(&quot;%d%d&quot;, &amp;u, &amp;v), G[u].push_back(v), G[v].push_back(u); dfs(1, 0, 0); for (int i = 1; i &lt;= n; i++) printf(&quot;%d &quot;, *s[i].rbegin()); } int main() { scanf(&quot;%d&quot;, &amp;n), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>GCD</tag>
        <tag>Codeforces</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Trie 学习笔记]]></title>
    <url>%2FszTrie%2F</url>
    <content type="text"><![CDATA[模板及讲解字典树字典树是前缀树，支持$insert(s)$和$query(s)$操作两个函数按照树结构往下走处理即可 维护二进制 (Xor)poj 3764 给定一棵$n$个点的带权无向树，求树上路径异或和的最大值。 利用 Xor 性质，我们发现路径异或和满足容斥 (即$[l,r]$可由$[1,r]，[1, l-1]$得出)那么我们求根到每个点的异或和$d_i$，然后尝试如何异或出一条路径来我们发现任意两个$d_i,d_j$的异或和为某条路径的异或和，且不漏解那么问题转化为求序列$d_i$两两异或最大值。因为 Xor 常用 Trie 维护，所以我们可以运用 Trie 求这个最大值。将所有$d_i$以二进制形式插入 Trie (高位在上，定一个最大位数，不够在前面补0)，边权为二进制位，然后对于每个二进制下的$d_i$在Trie树上走尽量相反的边，因为这样保证异或后大。树上没有最优边那就只能走另一条边。这样下来的路径就是$d_i$与其他$d_j$的最大异或值。$O(n \cdot len)$操作即可，$len$为二进制最大位数。 Codeforces 842D 常见题型Trie树：1、前缀问题2、翻转字符串，处理后缀 jzoj 5397，bzoj 45673、01Trie：Xor问题 CF 842D，poj 37644、回文相关：Bzoj 1524 (多个回文串拼接问题)Trie图：AC自动机Fail树：bzoj 2938前缀关系树 (Trie树去除虚节点) bzoj 4567 可持久化Trie树相关代码差分版https://www.luogu.org/problem/P4592 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;queue&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 100000 + 3, LEN = 30; int n, Q, vi[MAXN], idx, dfn[MAXN], l[MAXN], r[MAXN], fa[MAXN], pre[MAXN][22], dep[MAXN]; vector&lt;int &gt; G[MAXN]; int rt_1[MAXN], ch_1[MAXN * 33][2], cnt_1, siz_1[MAXN * 33]; int rt_2[MAXN], ch_2[MAXN * 33][2], cnt_2, siz_2[MAXN * 33]; void dfs(int u, int p) { fa[u] = p, dfn[++idx] = u, l[u] = idx; pre[u][0] = p, dep[u] = dep[p] + 1; for (int i = 1; i &lt;= 20; ++i) pre[u][i] = pre[pre[u][i - 1]][i - 1]; for (int i = 0; i &lt; (int)G[u].size(); ++i) { int v = G[u][i]; if (v != p) dfs(v, u); } r[u] = idx; } int LCA(int a, int b) { if (dep[a] &lt; dep[b]) swap(a, b); for (int i = 20; i &gt;= 0; --i) if (dep[pre[a][i]] &gt;= dep[b]) a = pre[a][i]; if (a == b) return a; for (int i = 20; i &gt;= 0; --i) if (pre[a][i] != pre[b][i]) a = pre[a][i], b = pre[b][i]; return pre[a][0]; } void ins_1(int pre, int now, int i, int a) { siz_1[now] = siz_1[pre]; if (i == -1) {siz_1[now]++; return ;} int c = (a &gt;&gt; i) &amp; 1; ch_1[now][c] = ++cnt_1, ch_1[now][c ^ 1] = ch_1[pre][c ^ 1]; ins_1(ch_1[pre][c], ch_1[now][c], i - 1, a); siz_1[now] += siz_1[ch_1[now][0]] + siz_1[ch_1[now][1]]; } void ins_2(int pre, int now, int i, int a) { siz_2[now] = siz_2[pre]; if (i == -1) {siz_2[now]++; return ;} int c = (a &gt;&gt; i) &amp; 1; ch_2[now][c] = ++cnt_2, ch_2[now][c ^ 1] = ch_2[pre][c ^ 1]; ins_2(ch_2[pre][c], ch_2[now][c], i - 1, a); siz_2[now] += siz_2[ch_2[now][0]] + siz_2[ch_2[now][1]]; } int query_1(int pre, int now, int b) { int bs = (1 &lt;&lt; LEN), ret = 0; for (int i = LEN; i &gt;= 0; --i) { int c = (b &gt;&gt; i) &amp; 1, whw = siz_1[ch_1[now][c ^ 1]] - siz_1[ch_1[pre][c ^ 1]]; if (whw) ret += bs, pre = ch_1[pre][c ^ 1], now = ch_1[now][c ^ 1]; else pre = ch_1[pre][c], now = ch_1[now][c]; bs /= 2; } return ret; } int query_2(int u, int v, int lca, int flca, int b) { int bs = (1 &lt;&lt; LEN), ret = 0; for (int i = LEN; i &gt;= 0; --i) { int c = (b &gt;&gt; i) &amp; 1, whw = siz_2[ch_2[u][c ^ 1]] + siz_2[ch_2[v][c ^ 1]] - siz_2[ch_2[lca][c ^ 1]] - siz_2[ch_2[flca][c ^ 1]]; if (whw) ret += bs, u = ch_2[u][c ^ 1], v = ch_2[v][c ^ 1], lca = ch_2[lca][c ^ 1], flca = ch_2[flca][c ^ 1]; else u = ch_2[u][c], v = ch_2[v][c], lca = ch_2[lca][c], flca = ch_2[flca][c]; bs /= 2; } return ret; } void clean() { } int solve() { clean(); cin &gt;&gt; n &gt;&gt; Q; for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;vi[i]); for (int x, y, i = 1; i &lt; n; ++i) scanf(&quot;%d%d&quot;, &amp;x, &amp;y), G[x].push_back(y), G[y].push_back(x); dfs(1, 0); for (int i = 1; i &lt;= n; ++i) { ins_1(rt_1[i - 1], rt_1[i] = ++cnt_1, LEN, vi[dfn[i]]); ins_2(rt_2[fa[i]], rt_2[i] = ++cnt_2, LEN, vi[i]); } while (Q--) { int tp; scanf(&quot;%d&quot;, &amp;tp); if (tp == 1) { int x, gg; scanf(&quot;%d%d&quot;, &amp;x, &amp;gg); printf(&quot;%d\n&quot;, query_1(rt_1[l[x] - 1], rt_1[r[x]], gg)); } else { int x, y, gg; scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;gg); int l = LCA(x, y); printf(&quot;%d\n&quot;, query_2(rt_2[x], rt_2[y], rt_2[l], rt_2[fa[l]], gg)); } } return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>Trie</tag>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jzoj 5397(Trie+LCA+离线)]]></title>
    <url>%2Fjzoj5397%2F</url>
    <content type="text"><![CDATA[我们将所有字符串(包括新加的)全部离线倒着加到一个Trie里，然后发现几个串的 第一个字符在Trie中的位置 的LCA的深度即为每个询问的答案，由于LCA满足结合律，一一合并即可注意数组的大小 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; #define LL long long #define db double #define FN2 &quot;biology&quot; const int logs = 20; struct note { int fa; int ch[26]; int pre[logs + 1]; int dep; }tree[1000000 + 5]; int tb, n, m, wz[100000 + 5], cx[100000 + 5][10 + 5], ctot; char s[10000 + 5]; void insert(char *s, int a, int c, int xh) { if (tree[c].ch[s[a] - &#39;a&#39;] == 0) tree[c].ch[s[a] - &#39;a&#39;] = ++tb, tree[tb].fa = c; if (a == 0) wz[xh] = tree[c].ch[s[a] - &#39;a&#39;]; else insert(s, a - 1, tree[c].ch[s[a] - &#39;a&#39;], xh); } void dfs(int u, int pa) { tree[u].dep = tree[pa].dep + 1; tree[u].pre[0] = pa; for (int i = 1; i &lt;= logs; i++) tree[u].pre[i] = tree[tree[u].pre[i - 1]].pre[i - 1]; for (int i = 0; i &lt; 26; i++) if (tree[u].ch[i] != 0) dfs(tree[u].ch[i], u); } int getlca(int a, int b) { if (tree[a].dep &lt; tree[b].dep) swap(a, b); for (int i = logs; i &gt;= 0; i--) if (tree[tree[a].pre[i]].dep &gt;= tree[b].dep) a = tree[a].pre[i]; if (a == b) return a; for (int i = logs; i &gt;= 0; i--) if (tree[a].pre[i] != tree[b].pre[i]) a = tree[a].pre[i], b = tree[b].pre[i]; return tree[a].pre[0]; } void clean() { tb = 1, ctot = 0; for (int i = 1; i &lt;= 1000000 + 3; i++) { tree[i].dep = 0, tree[i].fa = 0; for (int j = 0; j &lt; 26; j++) tree[i].ch[j] = 0, tree[i].pre[j] = 0; } } void solve() { clean(); for (int i = 1; i &lt;= n; i++) { scanf(&quot;%s&quot;, s); int len = strlen(s); insert(s, len - 1, 1, i); } for (int i = 1; i &lt;= m; i++) { int opt; scanf(&quot;%d&quot;, &amp;opt); if (opt == 1) { scanf(&quot;%s&quot;, s); int len = strlen(s); insert(s, len - 1, 1, ++n); } else { ctot++; scanf(&quot;%d&quot;, &amp;cx[ctot][0]); for (int j = 1; j &lt;= cx[ctot][0]; j++) scanf(&quot;%d&quot;, &amp;cx[ctot][j]); } } dfs(1, 0); for (int i = 1; i &lt;= ctot; i++) { int lca = wz[cx[i][1]]; for (int j = 2; j &lt;= cx[i][0]; j++) { lca = getlca(lca, wz[cx[i][j]]); } printf(&quot;%d\n&quot;, tree[lca].dep - 1); } } int main() { freopen(FN2&quot;.in&quot;, &quot;r&quot;, stdin);freopen(FN2&quot;.out&quot;, &quot;w&quot;, stdout); scanf(&quot;%d%d&quot;, &amp;n, &amp;m), solve(); fclose(stdin), fclose(stdout); return 0; } 题目描述 G 博士发现了新的遗传疾病，这种疾病受到多种基因片段的控制。我们用一个仅由小写字母组成的宇符串S表示一个基因片段，该基因的有效片段为S的所有后缀(包括空串)。根据G 博士的研究,该遗传疾病的患病概率，与基因的有效片段有关，若控制该遗传疾病的基因片段的共有有效片段越长，则患病概率越大。G 博士将所有的发现的基因片段放在了一个数据库中，随着研究的进展，G 博士的数据库中储存的基因片段越来越多，这给G 博士对疾病的研究造成了一定困难。现在G 博士想知道，对于控制某一疾病的一些基因片段，它们的最长共有有效片段为多长? Input第一行两个整数N,M,其中N表示数据库中原本存在的基因片段个数，M表示后来的事件个数接下来N行,每行一个字符串，表示一个已知的基因片段，其中第i行的基因片段编号为i接下来M行，表示M个事件，格式为以下情况之一:1.”1 S”,表示发现了一个新的基因片段加入数据库，编号为已有基因片段数+12.“2 T A1 A2 .. AT“表示询问编号为A1,A.,….AT这T个编号的最长共有有效片段的长度𝟓 𝟓𝒛𝒛𝒋𝒑𝒓𝒊𝒑𝒓𝒊𝒎𝒆𝒊𝒎𝒆𝒐𝒘𝒂𝒔𝒌𝒊𝟐 𝟑 𝟏 𝟑 𝟓𝟐 𝟐 𝟐 𝟑𝟏 𝒂𝒄𝒕𝒓𝒊𝟐 𝟐 𝟑 𝟒𝟐 𝟑 𝟐 𝟔 𝟓 Output对于每个2号操作，输出一行表示最长共有有效片段的长度𝟎𝟎𝟑𝟏 对于前30%的数据，$N \leq 100, M \leq 100,$每段基因片段长度$S \leq 100$对于前50%的数据，$N \leq 10000,M \leq 10000$,每段基因片段长度$\leq 100$接下来20%的数据，$N \leq 20000,M \leq 50000$,每段基因片段长度$\leq 1000$,没有1号操作对于前100%的数据，$N \leq 50000,M \leq 100000,2 \leq T \leq 10,$每段基因片段长度$\leq 10000$, 总字符个数$ \leq 1000000$,数据库中基因型的个数$\leq 100000$不同编号的基因型有可能相同，并且不保证询问不会出现重复元素数据虽然不是完全随机，但依然保留水的本质 Hint𝒛𝒛𝒋，𝒑𝒓𝒊𝒎𝒆，𝒐𝒘𝒂𝒔𝒌𝒊三种基因片段的最长共有有效片段为空 𝒑𝒓𝒊，𝒑𝒓𝒊𝒎𝒆两种基因片段的最长共有效片段为空添加基因片段𝒂𝒄𝒕𝒓𝒊，编号为𝟔𝒑𝒓𝒊𝒎𝒆，𝒊𝒎𝒆两种基因片段的最长共有有效片段为𝒊𝒎𝒆𝒑𝒓𝒊，𝒂𝒄𝒕𝒓𝒊，𝒐𝒘𝒂𝒔𝒌𝒊三种基因片段的最长共有有效片段𝒊]]></content>
      <categories>
        <category>jzoj</category>
      </categories>
      <tags>
        <tag>离线</tag>
        <tag>倍增</tag>
        <tag>Trie</tag>
        <tag>jzoj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jzoj 5396(单调栈)]]></title>
    <url>%2Fjzoj5396%2F</url>
    <content type="text"><![CDATA[暴力做法$O(n^2)$:枚举区间，求区间平均值是否大于$k$正解：设$f(i)=min(j)(1 \leq j \leq i$且$sum_i-sum_{j-1} \geq 0)$如果存在$k &lt; j, sum_k &lt; sum_j$，那么$j$无用，把无用的$j$去掉，单调栈维护即可。然后再判区间和是否大于0(倒序扫$i$,算每个$f(i)$)，然后更新答案即可 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; #define LL long long #define db double #define FN2 &quot;blocks&quot; LL n, m; LL a[1000000 + 5], sum[1000000 + 5], top, st[1000000 + 5]; void clean() { for (LL i = 0; i &lt;= 1000000 + 1; i++) a[i] = sum[i] = 0; } LL work(LL k) { top = 1;//see the reson below LL ret = 0; for (int i = 1; i &lt;= n; i++) { sum[i] = sum[i - 1] + a[i] - k; if (!top || sum[st[top]] &gt; sum[i]) st[++top] = i; } for (int i = n; i &gt;= 1; i--) { while (top &amp;&amp; sum[st[top]] &lt;= sum[i]) top--; ret = max(ret, i - st[top + 1]); //if not to set top to 1, perhaps get st[1] when top became 0 instead of 0 } return ret; } void solve() { clean(); for (LL i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;a[i]); for (LL i = 1; i &lt;= m; i++) { LL opt ; scanf(&quot;%lld&quot;, &amp;opt); printf(&quot;%lld &quot;, work(opt)); } puts(&quot;&quot;); } int main() { freopen(FN2&quot;.in&quot;, &quot;r&quot;, stdin);freopen(FN2&quot;.out&quot;, &quot;w&quot;, stdout); scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m), solve(); fclose(stdin), fclose(stdout); return 0; } 题目描述 给定一个长度为N的正整数序列A,你可以进行如下操作:每次选择一个大于K的正整数a[i]，将a[i]减去1,选择a[i- 1]或a[i + 1]中的一个加上1请问:经过若干次操作之后，最大能够选出多长的一个连续子序列，使得这个子序列的每个数都不小于K本题有M组询问，每次询问一个数K,你需要分别回答 Input第一行两个正整数，表示N,M,含义如题所示。第二行N个正整数，表示a序列。第三行M个正整数表示M次询问的K𝟏𝟎 𝟓𝟏 𝟕 𝟗 𝟗 𝟓 𝟗 𝟑 𝟒 𝟓 𝟖𝟓 𝟕 𝟐𝟎 𝟗 𝟏 Output一行M个整数，表示每次询问的答案，用空格隔开。𝟏𝟎 𝟔 𝟎 𝟐 𝟏𝟎 对于40%的数据，有$1\leq Ai \leq 10^9, 1 \leq K \leq 10^9, 1 \leq m \leq 50, 1 \leq n \leq 10000$对于100%的数据，有$1\leq Ai \leq 10^9, 1 \leq K \leq 10^9, 1 \leq m \leq 50, 1 \leq n \leq 1000000$]]></content>
      <categories>
        <category>jzoj</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
        <tag>jzoj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jzoj 5394(LCA)]]></title>
    <url>%2Fjzoj5394%2F</url>
    <content type="text"><![CDATA[对于一条链直接贪心区间选点问题。把这个问题放到树上做。贪心区间选点是尽量把点选到右边，那么树上思路也如此。首先，DFS序中一条路径最后出现的节点一定是LCA所以按照DFS序正序处理每一个点，如果这个点是某条路径的LCA并且这条路径没有被切，就切掉这条路径。因为 假设一条路径LCA为$l$，所有 经过$l$的儿子的路径 都能经过$l$(这条路径中一定有一个点深度比$l$浅, 而这些路径的LCA的深度都比$l$的深度浅。所以我们要按照DFS序从下到上处理)。因此删除$l$是最划算的做法可以是树链剖分维护区间和，支持区间查询和单点修改，用来维护一条路径上是否有断点(被切掉)。判断路径的时候可以用DFS序排序每条路径的LCA，然后顺序处理即可。时间复杂度$O(klogk+klog^2n)$(排序+处理(树链剖分复杂度是$log^2n$)) #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; using namespace std; #define LL long long #define db double #define FN2 &quot;ping&quot; const int MAXN = 1000000 + 5; int tb, n, m, k, dep[MAXN], top[MAXN], fa[MAXN], siz[MAXN], son[MAXN], p[MAXN], fdfsx[MAXN], dfsx[MAXN], dfstot = 0, ansqj[3 * MAXN]; vector&lt;int&gt; G[MAXN]; struct data { int l, r, lca; bool operator &lt; (const data &amp;b) const { return fdfsx[lca] &lt; fdfsx[b.lca]; } }a[3 * MAXN]; void dfs1(int u, int pa) { dep[u] = dep[pa] + 1, siz[u] = 1, fa[u] = pa; for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i]; if (v != pa) { dfs1(v, u); siz[u] += siz[v]; if (son[u] == -1 || siz[son[u]] &lt; siz[v]) son[u] = v; } } dfsx[++dfstot] = u; } void dfs2(int u, int chn) { top[u] = chn, p[u] = ++tb; if (son[u] != -1) { dfs2(son[u], chn); for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i]; if (v != fa[u] &amp;&amp; v != son[u]) dfs2(v, v); } } } #define lc (o &lt;&lt; 1) #define rc (o &lt;&lt; 1 | 1) #define M ((l + r) &gt;&gt; 1) int sumv[MAXN * 4]; void build(int o, int l, int r) { if (l == r) return ; else sumv[l] = sumv[r] = 0, build(lc, l, M), build(rc, M + 1, r); } void pushup(int o) { sumv[o] = sumv[lc] + sumv[rc]; } void update(int o, int l, int r, int x, int v) { if (l == r) sumv[o] = v; else { if (x &lt;= M) update(lc, l, M, x, v); else if (M &lt; x) update(rc, M + 1, r, x, v); pushup(o); } } int query(int o, int l, int r, int x, int y) { if (x &lt;= l &amp;&amp; r &lt;= y) { return sumv[o]; } int ret = 0; if (x &lt;= M) ret += query(lc, l, M, x, y); if (M &lt; y) ret += query(rc, M + 1, r, x, y); return ret; } int findans(int u, int v) { int ret = 0, f1 = top[u], f2 = top[v]; while (f1 != f2) { if (dep[f1] &lt; dep[f2]) swap(f1, f2), swap(u, v); ret += query(1, 1, n, p[f1], p[u]); u = fa[f1], f1 = top[u]; } if (dep[u] &lt; dep[v]) swap(u, v); return ret + query(1, 1, n, p[v], p[u]); } int getlca(int u, int v) { int f1 = top[u], f2 = top[v]; while (f1 != f2) { if (dep[f1] &lt; dep[f2]) swap(f1, f2), swap(u, v); u = fa[f1], f1 = top[u]; } if (dep[u] &lt; dep[v]) swap(u, v); return v; } void clean() { tb = 0; for (int i = 1; i &lt;= n; i++) G[i].clear(), dep[i] = top[i] = fa[i] = siz[i] = p[i] = fdfsx[i] = dfsx[i] = 0, son[i] = -1; } void solve() { clean(); for (int u, v, i = 1; i &lt;= m; i++) { scanf(&quot;%d%d&quot;, &amp;u, &amp;v); G[u].push_back(v), G[v].push_back(u); }//read edges dfs1(1, 0), dfs2(1, 1); build(1, 1, n); for (int i = 1; i &lt;= n; i++) fdfsx[dfsx[i]] = i;//chuli shulianpoufen scanf(&quot;%d&quot;, &amp;k); for (int i = 1; i &lt;= k; i++) { scanf(&quot;%d%d&quot;, &amp;a[i].l, &amp;a[i].r); a[i].lca = getlca(a[i].l, a[i].r); }//read route int ans = 0; sort(a + 1, a + 1 + k); for (int i = 1; i &lt;= k; i++) { int ret = findans(a[i].l, a[i].r); if (ret == 0) update(1, 1, n, p[a[i].lca], 1), ansqj[++ans] = a[i].lca; } printf(&quot;%d\n&quot;, ans); for (int i = 1; i &lt;= ans; i++) printf(&quot;%d &quot;, ansqj[i]); } int main() { freopen(FN2&quot;.in&quot;, &quot;r&quot;, stdin);freopen(FN2&quot;.out&quot;, &quot;w&quot;, stdout); scanf(&quot;%d%d&quot;, &amp;n, &amp;m), solve(); fclose(stdin), fclose(stdout); return 0; } 题目描述 Tgopknight所连接的网络共有n 个站点，由于经费问题，每两个站点之间有且仅有一条线路，这些站点中有一些损坏了，Tgopknight进行了k次测试，每次测试两个站点之间是否连通，由于Tgopknight 手太好，他每次测试的两个站点之间都不连通。Tgopknight 现在想知道最少有多少个站点损坏了，并想知道一种可能的损坏数最小的损坏情况。 第一行输入两个正整数n,m，表示站点个数和直接连接数后接m行，每行输入两个数u,v,表示u,v直接连接第m + 2行输入一个正整数k，表示Tgopknight进行的测试次数后接k行，每行输入两个数u,v,表示Tgopknight沙试u,v之间是否连通Sample Input5 42 15 33 14 322 43 2 第一行输出一个整数ans,表示最少损坏的站点数后接一行ans个数，表示一种可能的损坏情况。Sample Output12 对于前30% 的数据，$n,m \leq 15$另有20% 的数据，保证网络是一条链另有10% 的数据，$k \leq 3$对于100%的数据，$3 \leq n,m \leq 10^5，0 \leq k \leq 3 \times 10^5$本题有special judge数据有梯度]]></content>
      <categories>
        <category>jzoj</category>
      </categories>
      <tags>
        <tag>倍增</tag>
        <tag>jzoj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jzoj 5392(规律)]]></title>
    <url>%2Fjzoj5392%2F</url>
    <content type="text"><![CDATA[结论1：奇数位开始的233和223可互换，所以判断奇偶性即可结论2：23 是独立的。也就是说我们直接顺序扫23，退两格修改即可 然后扫描一遍即可 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; #define LL long long #define db double #define FN2 &quot;trans&quot; int n, k; char s[1000000 + 5]; void clean() { } void solve() { clean(); scanf(&quot;%s&quot;, s + 1); for (int i = 1; i &lt;= n &amp;&amp; k; i++) { if (i &lt; 1) i = 1; if (s[i] == &#39;2&#39; &amp;&amp; s[i + 1] == &#39;3&#39; &amp;&amp; s[i + 2] == &#39;3&#39; &amp;&amp; i % 2 == 1) k %= 2; if (k &amp;&amp; s[i] == &#39;2&#39; &amp;&amp; s[i + 1] == &#39;3&#39;) s[i] = s[i + 1] = ((i % 2 == 1) ? &#39;2&#39; : &#39;3&#39;), i -= 2, k--; } printf(&quot;%s\n&quot;, s + 1); } int main() { freopen(FN2&quot;.in&quot;, &quot;r&quot;, stdin);freopen(FN2&quot;.out&quot;, &quot;w&quot;, stdout); while (scanf(&quot;%d%d&quot;, &amp;n, &amp;k) == 2) solve(); fclose(stdin), fclose(stdout); return 0; } 题目描述 Tgopknight决定使用他的幸运数字2和3来进行这个游戏，他一开始有$n$个数字，记为${dn}$,需要进行k次操作，每次操作找到最小的$x$使得$d_x = 2$ 并且$d_{x+1}= 3$,此时如果$x$为奇数，则令$d_{x+1}= 2$，反之令$d_x= 3$，若没有这样的$c$,则数字不变。Tgopknight现在想知道进行完所有操作后这些数字变成了什么。 本题有多组数据。每组数据第一行是两个正整数n 和k，分别表示数字个数和操作次数。第二行有n个数字，数字之间没有空格。Sample Input7 223432234 12234 对于每组数据，输出一行，为操作进行完之后的结果。Sample Output22432332334 对于前50% 的数据$n \leq 10^4,k \leq 10^4$对于前70% 的数据$k \leq 10^6$对于100% 的数据$1 \leq n \leq 10^6，0 \leq k \leq 10^9$数据组数不超过$10$ 第一组数据，2343223 - 2243223 - 2243233第二组数据，2234 - 2334]]></content>
      <categories>
        <category>jzoj</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>jzoj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu NOIP 2018 训练]]></title>
    <url>%2FLuoguNOIP2018%2F</url>
    <content type="text"><![CDATA[搜索专题例题 1 给你$ n $张扑克牌，保证这$ n $张来自于同一副。你可以打若干次牌，第一次可以打任意数字，之后每次打的数字，必须是之前打过的数字之和的约数。问是否存在一种打牌方案，使得可以打出所有牌，输出方案。$1 ≤ n ≤ 52$。 本题可以很简单得写出一个爆搜程序，但是如果正搜的话解答树会很大，因为前面的决策多后面的决策少，所以我们可以调换搜索顺序，这样使得前面的决策少后面的决策多。 本题心得：对于这种题目开始决策比较多的，可以考虑倒搜，使得初始决策变少。(就算没有明显的变化也可以尝试倒搜) 例题 2Bzoj 5439 给出一个由a, b, c组成的长度为$n$ 的字符串。定义一个子序列 $T$ 的价值为 $\frac {len^2_T}{c_T}$，其中$ lenT$ 表示$ T$ 的长度，$ c_T $表示$ T $的最小循环节长度。找出价值最大的子序列。$1 ≤ n ≤ 10^4。$ 尝试使用上下界剪枝 (可行性剪枝)。对于本题要关注”由a, b, c组成”的特殊条件。我们想一个理论最小价值。我们找到一个出现最多的字符，他的出现次数一定大于等于$\frac n3$。所以选择这个字符的价值为$(\frac n3)^2$，所以价值无论如何都能取到$\frac {n^2}9$因为$n$比任何子序列长都大，所以循环节长度最大不能超过$9$，即找到一个下界。所以枚举最大不超过$9$的循环节来更新答案即可。 代码：Bzoj 5439 本题心得：对于这种没什么思路的题目可能有结论(比如只有某些情况有解/能剪大量枝(有上下界))来辅助。对于题目的特殊限制要加以思考。 例题 3 给出平面上$ n$ 个点$ (xi, yi)$，要求找到一个点$ (x, y)$，使得这个点到给出的那些点的欧几里得距离之和最短。$1 ≤ n ≤ 1000。$$−10^6 ≤ xi, yi ≤ 10^6。$ 这题与搜索没什么关系。考虑定下这个点的$x$，来找$y$的位置，发现答案与$y$的位置有单峰函数的关系，使用三分找到这个唯一的极值点即为答案。同理$x$的位置也与答案有单峰函数的关系。三分套三分即可。 本题心得：数学题几何题最优化问题二分无法解决可能是三分问题，并且可以用感性的思想来判断一个对应关系是不是单峰函数。 例题 4 定义$ ′ $运算如下：如果 $p = 1， p′ = 0。$如果 $p$ 是质数，$ p′ = 1$否则 $p′ = (a \times b)′ = a′ \times b + a \times b′$给出 $k, r$，求出所有满足 $x′ = kx, 1 ≤ x ≤ r $的$ x。$$1 ≤ k ≤ 30， 1 ≤ r ≤ 2 × 10^{18}。$ 关注”$p$ 是质数，$ p′ = 1$“，“$p′ = (a \times b)′ = a′ \times b + a \times b′$”，提示我们要分解质因数。分解质因数得$p=\prod^t_{i=1} p_i^{q_i}$，则可以得到$p′ =\sum_{i=1}^t\frac{q_ip}{p_i}$这一步可以找规律，设$p=\prod_{i=1}^k$发现$p′ =\sum_{i=1}^k \frac{\prod_{j=1}^k p_j}{p_i}$，易得上一个式子。乘$q_i$是因为每个相等质因子都要加一次。然后就可以使$p′ =\sum_{i=1}^t\frac{q_ip}{p_i}=kp$，约掉$p$，变为$\sum_{i=1}^t\frac{q_i}{p_i}=k$然后我们考虑因为$p_i$都是质数，所以两个$\frac{q_i}{p_i}, \frac{q_j}{p_j}$最简形式是分数的不能合并成整数，所以$q_i$一定是$p_i$整数倍。那么直接预处理质数$p_i$，然后用$p_i^{p_i}$来 DFS 拼 $p$ 即可。 本题心得：本题对于题目的特殊限制/特性加以思考。找规律也是很好的发现式子的方式，如果不能肉眼找，就打表找。 例题 5 给出$ n $杯糖水，第$ i $杯糖水的总质量为$ m_i$，其中糖的质量为$ t_i$。现在给出一个分数$ \frac ba$，问选出若干杯糖水，使得这些杯混合之后，糖的质量占总质量之比为$\frac ba$的方案数。$2 ≤ n ≤ 35。$$1 ≤ t_i ≤ m_i ≤ 10000。$$1 ≤ a ≤ b ≤ 10000。$ 本题可以枚举子集，但是时间复杂度$O(2^n)$，太大了。考虑将子集分开两边枚举。设$m=\frac n2$, 然后再前$m$和后$m$的区间范围内枚举子集，考虑怎么才能快速合并两段答案。原题求$\frac {\sum t_i}{\sum m_i}=\frac ab$ 对于这种分数等式我们转化为乘积式，$a\sum m_i=b \sum t_i$那么我们枚举的两个子集满足题意就是$a(\sum_{i \in S_1} m_i +\sum_{i \in S_2} m_i)=b(\sum_{i \in S_1} t_i +\sum_{i \in S_2} t_i)$移项，则$a\sum_{i \in S_1} m_i-b\sum_{i \in S_1} t_i = -(a\sum_{i \in S_2} m_i-b\sum_{i \in S_2} t_i))$所以我们就可以用 map 维护形如$a\sum_{i \in S_1} m_i-b\sum_{i \in S_1} t_i$的东西，前一半的存进 map，后一半在 map 中查询。然后统计即可。这种方式叫折半搜索。 本题心得：对于这种题目直接搜索慢的，看能不能切成几块然后快速合并。并且这题将分式化为乘积式方便了计算。将关于$i$的式子放一边然后用数据结构维护这一坨的思想很重要。 标程： #include &lt;map&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;climits&gt; #include &lt;iostream&gt; const int MAXN = 40; using namespace std; int n, a, b, x[MAXN], y[MAXN]; long long work() { map&lt;int, int&gt; M; int p = n / 2, q = n - p; long long ans = 0; for(int i = 0; i &lt; (1 &lt;&lt; p); i++) { int curA = 0, curB = 0; for(int j = 1; j &lt;= p; j++) { if(i &gt;&gt; (j - 1) &amp; 1) { curA += x[j], curB += y[j]; } } M[a * curB - b * curA]++; } for(int i = 0; i &lt; (1 &lt;&lt; q); i++) { int curA = 0, curB = 0; for(int j = p + 1; j &lt;= n; j++) { if(i &gt;&gt; (j - p - 1) &amp; 1) { curA += x[j], curB += y[j]; } } int need = a * curB - b * curA; ans += M[-need]; } return ans - 1; } int main() { scanf(&quot;%d %d %d&quot;, &amp;n, &amp;a, &amp;b); // a / b for(int i = 1; i &lt;= n; i++) { scanf(&quot;%d %d&quot;, &amp;x[i], &amp;y[i]); // x[i] / y[i] } long long ans = LLONG_MAX; ans = min(ans, work()); printf(&quot;%lld\n&quot;, ans); return 0; } 我的程序 例题 6Bzoj 5445 Johnny 有若干个玩具，玩具的种类可能相同也可能不同。现在已知他的这些玩具有$ n $个本质不同的子集（包括空集），问玩具的个数可能是多少。输出所有的可能解。$1 ≤ n ≤ 10^9$。 看样例解释可以找到规律，几个数乘起来等于$n$的几个数减一的和为一个答案。DFS 分解因数(用$n$除$n$约数方便快捷)。数学方法证明：$n=\prod_{i=1}^t (a_i+1)$，所以DFS 分解因数(用$n$除$n$约数方便快捷)。 本题心得：要善于从题中找规律，并且 DFS 时也要考虑复杂度如何优化，正向思想和反向思想。 代码： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;stack&gt; #include&lt;set&gt; #include&lt;queue&gt; #include&lt;climits&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; namespace flyinthesky { int n; vector&lt;int &gt; ans; void dfs(int tmp, int tot, int lst) { ans.push_back(tot + tmp - 1);//当前约数加上tmp因子 int gg = (int)sqrt(tmp) + 1; for (int i = lst; i &lt;= gg; i++) if (tmp % i == 0) dfs(tmp / i, tot + i - 1, i); } void clean() { } int solve() { scanf(&quot;%d&quot;, &amp;n); clean(); dfs(n, 0, 2);//n/i方向搜索快 int whw; sort(ans.begin(), ans.end()), whw = unique(ans.begin(), ans.end()) - ans.begin(); printf(&quot;%d\n&quot;, whw); for (int i = 0; i &lt; whw; i++) printf(&quot;%d &quot;, ans[i]); return 0; } } int main() { flyinthesky::solve(); return 0; } 例题 8Bzoj 5049 给出一个$ n$个点$ m $条边的随机生成的无权无向图，有$ q $次询问，每次给出 $x, y(1 ≤ x, y ≤ n, x ≠ y)$，询问$ x $到$ y$的最短路。$n = 10^5, m = 3 × 10^5, q = 10^4。$ 由于题目中随机生成，期望最短路小，所以直接从两点开始双向 BFS 即可。 本题心得：要敢于猜想敢于暴力，就算不知道结论也可以双向优化 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;stack&gt; #include&lt;set&gt; #include&lt;queue&gt; #include&lt;climits&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; namespace flyinthesky { const int MAXN = 100000 + 5, MAXM = 300000 + 5; struct edge {int v, nxt;} ed[MAXM * 2]; struct data {int u, dis, isZ;}; int n, m, Q, hd[MAXN], en, vis[MAXN], dis[MAXN], f[MAXN]; void ins(int x, int y) {ed[++en] = (edge){y, hd[x]}, hd[x] = en;} int find(int x) {return (x == f[x]) ? x : (f[x] = find(f[x]));} int bfs(int ith, int s, int t) { queue&lt;data &gt; q; dis[s] = dis[t] = 0, vis[s] = ith, vis[t] = -ith; q.push((data){s, 0, ith}), q.push((data){t, 0, -ith}); while (!q.empty()) { data p = q.front(); q.pop(); for (int i = hd[p.u]; i &gt; 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (vis[p.u] == -vis[e.v]) return dis[p.u] + dis[e.v] + 1; if (vis[e.v] != p.isZ) vis[e.v] = p.isZ, dis[e.v] = dis[p.u] + 1, q.push((data){e.v, dis[e.v], p.isZ}); } } return -1; } void clean() { en = 0, ms(hd, -1), ms(vis, 0); } int solve() { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;Q); clean(); for (int i = 1; i &lt;= n; i++) f[i] = i; for (int u, v, i = 1; i &lt;= m; i++) { scanf(&quot;%d%d&quot;, &amp;u, &amp;v), ins(u, v), ins(v, u); int x = find(u), y = find(v); if (x != y) f[x] = y; } for (int s, t, i = 1; i &lt;= Q; i++) { scanf(&quot;%d%d&quot;, &amp;s, &amp;t); if (find(s) != find(t)) printf(&quot;-1\n&quot;); else printf(&quot;%d\n&quot;, bfs(i, s, t)); } return 0; } } int main() { flyinthesky::solve(); return 0; } 例题 9 给出一个$ n $个点$ m $条边的无向图连通简单图。每条边的长度为$ 1$；第$ i $个点种有$ v_i $个金币。小偷住在$ 1$ 号点，王宫在$ 2 $号点，小偷需要沿着到王宫的最短路去进贡。在去进贡的途中，对于经过的每个点，他都可以选择偷或不偷。如果偷，他将获得这个点的金币，但是回程时将不能访问这个点。小偷想知道在他能回家的前提下，最多可以进贡多少金币。$2 ≤ n ≤ 36, 1 ≤ m ≤ \frac{n(n^2−1)}{2}$ 结论：对于一个简单无向图来说，两点间的最短路的条数约为$O(e^{\frac ne} ) $级别。我们可以将选择问题转化为删除问题。即本题先搜到一条最短路，然后将所有节点选择，然后再想如何删除使得回程路径能连通。所有我们正向做最短路，然后反向以点权拆成两点一边来做最短路。 本题心得：选择问题转化为删除问题思想很重要，是这题解题的一个关键。以及简单无向图两点间的最短路的条数小。如果要用到点权作为最短路之类的算法，可以将点拆成两点一边，这样通过这条边相当于通过这个点，并且花费这个点的代价。 DP 专题部分分专题图论专题第一场模拟赛T1水题，将一个数固定以后其他数可选可不选，所以这个数对答案的贡献为$2^{n-1} \cdot a_i$或者根据样例解释找规律。 T2求 $\sum_{i=1}^{n} n \mod i$，多组询问，$n \leq 10^7$ 用$a\% b = a-\lfloor \frac ab \rfloor\cdot b$，得出原式等于$\sum_{i=1}^{n} n-\lfloor \frac ni \rfloor\cdot i$即$n^2-\sum_{i=1}^{n} \lfloor \frac ni \rfloor\cdot i$，打表观察或者因为$ \lfloor \frac ni \rfloor$表示的是$n$最多由几个$i$相加而成，$\sum_{i=1}^{n} \lfloor \frac ni \rfloor=\sum_{i=1}^{n}d_0(i)$,$\sum_{i=1}^{n} \lfloor \frac ni \rfloor\cdot i=\sum_{i=1}^{n}d_1(i)$，线性筛$d_1(i)$前缀和即可。 本题心得：数论要会打表。$a\% b = a-\lfloor \frac ab \rfloor\cdot b$。线性筛的新知识 T3毒瘤题。线段树扫描线+倍增处理 本题心得：倍增处理一些较长的距离但是单一能维护信息的操作。扫描线可以扫描平面内的一些东西来储存信息。 第二场模拟赛T1按题意可以将豆子按$x+y$排序(或者$x$为第一关键字，$y$第二关键字)，然后对于两两点之间求路径条数然后相乘。关键在于这个条数怎么求。可以用 DP 递推，也可以使用组合数，我们从$dx+dy$步中选$dx$步出来往下走(反着来也行)，答案为$C^{dx}_{dx+dy}$，然后组合数求解用预处理阶乘和阶乘逆元即可。 知识点：1、数组大小想清楚开2、注意题目中无解输出什么 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;climits&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 100000 + 5, MO = 1000000000 + 7; int n, m, k; LL jc_inv[MAXN * 2], jc[MAXN * 2]; pair&lt;int, int &gt; pnt[MAXN]; LL ksm(LL a, LL b) { LL bs = a, ans = 1ll; while (b) { if (b &amp; 1) ans = (ans * bs) % MO; bs = (bs * bs) % MO; b &gt;&gt;= 1; } return ans; } LL c(LL m, LL n) { if (m &gt; n) return 0; LL tmp = jc[n]; tmp = (tmp * jc_inv[m]) % MO; tmp = (tmp * jc_inv[n - m]) % MO; //cout &lt;&lt; &quot;m=&quot; &lt;&lt; m &lt;&lt; &quot;, n=&quot; &lt;&lt; n &lt;&lt; &quot;, tmp=&quot; &lt;&lt; tmp &lt;&lt; &quot;\n&quot;; return tmp; } void clean() {} int solve() { cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; clean(); jc_inv[0] = jc[0] = 1; jc_inv[1] = jc[1] = 1; for (int i = 2; i &lt;= 200000; i++) { jc[i] = (jc[i - 1] * (LL)i) % MO; jc_inv[i] = (jc_inv[i - 1] * ksm((LL)i, MO - 2)) % MO; } //for (int i = 1; i &lt;= 100; i++) cout &lt;&lt; jc_inv[i] &lt;&lt; &quot; &quot;; for (int i = 1; i &lt;= k; i++) scanf(&quot;%d%d&quot;, &amp;pnt[i].fir, &amp;pnt[i].sec); pnt[k + 1] = mp(1, 1), pnt[k + 2] = mp(n, m), k += 2; sort(pnt + 1, pnt + 1 + k); LL ans = 1ll; for (int i = 2; i &lt;= k; i++) { int dlx = pnt[i].fir - pnt[i - 1].fir; int dly = pnt[i].sec - pnt[i - 1].sec; if (dlx &lt; 0 || dly &lt; 0) return printf(&quot;0\n&quot;), 0; //printf(&quot;dlx=%d, dly=%d\n&quot;, dlx, dly); ans = (ans * c(dlx, dlx + dly)) % MO; } cout &lt;&lt; ans; return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>合并</tag>
        <tag>数学</tag>
        <tag>三分</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 839D(组合数+容斥原理+二项式定理)]]></title>
    <url>%2FCodeforces839D%2F</url>
    <content type="text"><![CDATA[Codeforces 839D考虑枚举$gcd$为$i$.则每个$i​$贡献为$i \times \sum( j \times C^j_k)​$, $i​$为$gcd​$, $k​$为$a_i​$中有$i​$因子的数的个数$\sum( j \times C^j_k) = \sum( j \times C^{j-1}_{k-1} \times k \div j)$$=\sum(C^{j-1}_{k-1} \times k)$$=k \times 2^{k-1}$然后每个$i$贡献为$i \times k \times 2^{k-1}$然后因为$i=y$会重复计算$i=2y,3y…ny$的情况，所以要容斥减一下然后注意longlong，注意溢出，注意数组大小 Codeforces Submission #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const LL MO = 1000000007; LL n, dp[1000000 + 5], bs[1000000 + 5], w[1000000 + 5]; void clean() { ms(w, 0); } void solve() { clean(); for (LL i = bs[0] = 1; i &lt;= n; i++) bs[i] = (bs[i - 1] * 2) % MO; LL mx = 0, ans = 0; for (LL x, i = 1; i &lt;= n; i++) scanf(&quot;%I64d&quot;, &amp;x), w[x]++, mx = max(mx, x); for (LL i = mx; i &gt; 1; i--) { LL k = 0; for (int j = i; j &lt;= mx; j += i) k = (k + w[j]) % MO; if (k == 0) continue; dp[i] = (bs[k - 1] * k) % MO; for (int j = i + i; j &lt;= mx; j += i) dp[i] = (dp[i] - dp[j] + MO) % MO; ans = (dp[i] * i + ans) % MO; } printf(&quot;%I64d\n&quot;, ans); } int main() { scanf(&quot;%I64d&quot;, &amp;n), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>GCD</tag>
        <tag>Codeforces</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 835D(区间DP+字符串DP)]]></title>
    <url>%2FCodeforces835D%2F</url>
    <content type="text"><![CDATA[Codeforces 835D首先我们知道： 第$k$阶的回文串本身是回文串 第$k$阶的回文串左右两边是第$k-1$阶的回文串 那么我们可以DP，设$dp(i,j)$为$[i,j]$为多少阶回文串先判$[i,j]$是否回文，如果不是，那么$[i,j]$不构成任何阶的回文串；否则$dp(i,j)=dp(i, i +\frac{ (j - i + 1)}{2} - 1)+1$，因为第$k$阶的回文串左右两边是第$k-1$阶的回文串然后$[1, k-1]$阶的回文串一定包含了$[k, n]$的回文串，所以累加一下就行然后区间DP用记忆化做 Codeforces Submission #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long using namespace std; const int MAXN = 5000 + 10; char s[MAXN]; int n, f[MAXN][MAXN], ans[MAXN]; int dp(int i, int j) { if (f[i][j] &gt;= 0) return f[i][j]; if (i &gt; j) return f[i][j] = 0; if (i == j) return f[i][j] = 1; if (s[i] != s[j] || (i + 1 &lt;= j - 1 &amp;&amp; dp(i + 1, j - 1) == 0)) return f[i][j] = 0; int a = dp(i, i + (j - i + 1) / 2 - 1); return f[i][j] = a + 1; } void clean() { for (int i = 0; i &lt;= n; i++) { for (int j = 0; j &lt;= n; j++) f[i][j] = -1; ans[i] = 0; } } void solve() { n = strlen(s + 1); clean(); for (int i = 1; i &lt;= n; i++) for (int j = i; j &lt;= n; j++) dp(i, j); for (int i = 1; i &lt;= n; i++) for (int j = i; j &lt;= n; j++) ans[f[i][j]]++; for (int i = n; i &gt; 0; i--) ans[i] += ans[i + 1]; for (int i = 1; i &lt;= n; i++) printf(&quot;%d &quot;, ans[i]); } int main() { scanf(&quot;%s&quot;, s + 1), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>计数DP</tag>
        <tag>区间DP</tag>
        <tag>Codeforces</tag>
        <tag>字符串DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 834D(线段树优化DP)]]></title>
    <url>%2FCodeforces834D%2F</url>
    <content type="text"><![CDATA[Codeforces 834D题意：给你长度为$n$的一个序列，让你将其分成连续的$k$段，每段的价值为其中数字种类的个数，求最大价值总和。 (This solution has been updated in August 14th, 2018.)首先可以设$dp(k,i)$为前$i$个数分了$k$个箱子的最优解显然$dp(k,i)=max(dp(k - 1, j-1) + c_{j, i})$，其中$c_{i, j}$为$[i,j]$中不同颜色的个数 我们可以用线段树维护$c$, 但是这样仍然是$O(kn^2logn)$，过不了 那么我们用线段树(区间下标$[1, j]$)维护$dp(k - 1, j-1) + c_{j, i}$的最大值，这样的话原方程就是$dp(k,i)=query(1, i)$。先用$dp(k - 1)$来建线段树，然后考虑$c_{j, i}$的计算。我们设$lst_i$为第$i$个数前面第一个与这个数相同的数的位置(没有为$0$)。我们一个个让数字加入，对于每一个加入的$i$而言$[lst_i + 1, i]$都需要加一，因为这一部分都被新加进来的$i$所影响了。注意要边$update$边$query$，不然是错的，因为每次加进来的$i$只能影响$[1,i]$的区间值，$[i, n]$中的数不能影响。 Codeforces Submission #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 35000 + 5; int n, k, ai[MAXN], lst[MAXN], pre[MAXN], dp[55][MAXN]; #define lc (o &lt;&lt; 1) #define rc (o &lt;&lt; 1 | 1) #define M ((l + r) &gt;&gt; 1) int maxv[MAXN * 4], lazy[MAXN * 4]; void pushup(int o, int l, int r) { if (l == r) return ; maxv[o] = max(maxv[lc], maxv[rc]); } void pushdown(int o, int l, int r) { if (l == r) return ; if (lazy[o] &gt; 0) { lazy[lc] += lazy[o], lazy[rc] += lazy[o]; maxv[lc] += lazy[o], maxv[rc] += lazy[o]; lazy[o] = 0; } } void build(int o, int l, int r) { if (l == r) lazy[o] = 0, maxv[o] = ai[l]; else { lazy[o] = maxv[o] = 0; build(lc, l, M), build(rc, M + 1, r); pushup(o, l, r); } } void update(int o, int l, int r, int x, int y, int v) { pushdown(o, l, r); if (x &lt;= l &amp;&amp; r &lt;= y) { lazy[o] += v, maxv[o] += v; return ; } if (x &lt;= M) update(lc, l, M, x, y, v); if (M &lt; y) update(rc, M + 1, r, x, y, v); pushup(o, l, r); } int query(int o, int l, int r, int x, int y) { int ret = -1; pushdown(o, l, r); if (x &lt;= l &amp;&amp; r &lt;= y) { return maxv[o]; } if (x &lt;= M) ret = max(ret, query(lc, l, M, x, y)); if (M &lt; y) ret = max(ret, query(rc, M + 1, r, x, y)); return ret; } void clean() { ms(lst, 0), ms(pre, 0), ms(dp, 0); } void solve() { clean(); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;ai[i]); for (int i = 1; i &lt;= n; i++) lst[i] = pre[ai[i]], pre[ai[i]] = i; for (int i = 1; i &lt;= n; i++) dp[1][i] = dp[1][i - 1] + (lst[i] == 0); for (int j = 2; j &lt;= k; j++) { for (int i = 1; i &lt;= n; i++) ai[i] = dp[j - 1][i - 1]; build(1, 1, n); for (int i = 1; i &lt;= n; i++) { update(1, 1, n, lst[i] + 1, i, 1); dp[j][i] += query(1, 1, n, 1, i); } } printf(&quot;%d\n&quot;, dp[k][n]); } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;k), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>线段树</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 832D(LCA)]]></title>
    <url>%2FCodeforces832D%2F</url>
    <content type="text"><![CDATA[Codeforces 832D题意：给定一颗树$n$，并有$q$次询问，每次询问指定三个点$a，b，c$：意思是有两个人任选两个点作为各自起点，剩下的那个点作为终点，两个人各自从起点走向终点，求路径上重合的点数，现在要求在这三个点可能的选择方式中，求重合点数的最大值 (This solution has been updated in August 12th, 2018.) 分6种情况求两条路径交即可。路径交的求法：设$d(a, b)$为$a$到$b$的距离，则路径交为$\frac{d(a, c) +d(b, c) - d(a, b)}{2} +1$ Codeforces Submission #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 100000 + 5, logs = 19; vector&lt;int&gt; G[MAXN]; int n, q, dep[MAXN], pre[MAXN][logs + 1]; void dfs(int u, int pa) { dep[u] = dep[pa] + 1, pre[u][0] = pa; for (int i = 1; i &lt;= logs; i++) pre[u][i] = pre[pre[u][i - 1]][i - 1]; for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i]; if (v != pa) { dfs(v, u); } } } int getLCA(int a, int b) { if (dep[a] &lt; dep[b]) swap(a, b); for (int i = logs; i &gt;= 0; i--) if (dep[pre[a][i]] &gt;= dep[b]) a = pre[a][i]; if (a == b) return a; for (int i = logs; i &gt;= 0; i--) if (pre[a][i] != pre[b][i]) a = pre[a][i], b = pre[b][i]; return pre[a][0]; } int getdist(int a, int b) { return dep[a] + dep[b] - 2 * dep[getLCA(a, b)]; } int getAns(int a, int b, int c) { return (getdist(a, c) + getdist(b, c) - getdist(a, b)) / 2 + 1; } void clean() { for (int i = 1; i &lt;= n; i++) { G[i].clear(), dep[i] = 0; for (int j = 0; j &lt;= logs; j++) pre[i][j] = 0; } } void solve() { clean(); for (int p, i = 2; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;p); G[i].push_back(p), G[p].push_back(i); } dfs(1, 0); while (q--) { int a, b, c, ans = 0; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); ans = max(ans, getAns(a, b, c)); ans = max(ans, getAns(a, c, b)); ans = max(ans, getAns(b, c, a)); ans = max(ans, getAns(b, a, c)); ans = max(ans, getAns(c, a, b)); ans = max(ans, getAns(c, b, a)); printf(&quot;%d\n&quot;, ans); } } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;q), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[caioj 1126(二分图最小点覆盖)]]></title>
    <url>%2Fcaioj1126%2F</url>
    <content type="text"><![CDATA[caioj 1126二分图最小点覆盖行列匹配法经典模型。具体解法看二分图学习笔记 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 500 + 5; int n, k, vis[MAXN], lk[MAXN], cnt; vector&lt;int&gt; G[MAXN]; bool hungary(int u) { for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i]; if (vis[v] != cnt) { vis[v] = cnt; if (!lk[v] || hungary(lk[v])) { lk[v] = u; return true; } } } return false; } void clean() { for (int i = 0; i &lt;= n; i++) G[i].clear(), vis[i] = lk[i] = 0; } void solve() { clean(); for (int r, c, i = 1; i &lt;= k; i++) { scanf(&quot;%d%d&quot;, &amp;r, &amp;c); G[r].push_back(c); } int ans = 0; for (int i = 1; i &lt;= n; i++) { if (hungary(cnt = i)) ans++; } printf(&quot;%d\n&quot;, ans); } int main() { while (scanf(&quot;%d%d&quot;, &amp;n, &amp;k) == 2) solve(); return 0; } 题目描述一个矩阵地图N x N 个格子(1 &lt;= N &lt;= 500)。有K个地雷藏在格子里(1 &lt;= K &lt;= 10,000)。有一种大炮，一击就可以让在同一水平或垂直的地雷清除。求最少击炮次数才可以清除所有地雷。Input第一行两个整数N和K，第2~K+1行：每行两个整数R和C (1 &lt;= R, C &lt;= N)表示一个地雷的横坐标和列坐标。Output输出一行一个整数，最少的炮击次数能消灭所有地雷。 Sample Input3 41 11 32 23 2 Sample Output2 数据解释：如下地雷是”X”，空地是”.” is empty space:X.X.X..X.第一炮：对准第一行，摧毁了两个地雷(1,1)和(1,3),第二炮：对准第二列，摧毁了两个地雷(2,2)和(3,2).]]></content>
      <categories>
        <category>caioj</category>
      </categories>
      <tags>
        <tag>二分图</tag>
        <tag>caioj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[caioj 1125(二分图最小点覆盖)]]></title>
    <url>%2Fcaioj1125%2F</url>
    <content type="text"><![CDATA[caioj 1125二分图最小点覆盖模板题，同样使用最大流dinic做 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 20000 + 10, MAXM = 200000 + 40000 + 10, INF = 2147483647; int en, n, m, k; struct data {int v, cap, flow;}ed[MAXM]; vector&lt;int&gt; G[MAXN]; int s, t, d[MAXN], vis[MAXN], cur[MAXN]; void ins(int u, int v, int c) { ed[en] = (data){v, c, 0}, G[u].push_back(en++); ed[en] = (data){u, 0, 0}, G[v].push_back(en++); } void clean() { en = 0, s = n + m + 1, t = n + m + 2; for (int i = 0; i &lt;= n + m + 2; i++) G[i].clear(); } bool bfs() { queue&lt;int&gt; q; for (int i = 0; i &lt;= n + m + 2; i++) d[i] = INF, vis[i] = false; q.push(s), d[s] = 0, vis[s] = true; while (!q.empty()) { int u = q.front(); q.pop(); for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = ed[G[u][i]].v, cap = ed[G[u][i]].cap, flow = ed[G[u][i]].flow; if (!vis[v] &amp;&amp; cap &gt; flow) { vis[v] = true, d[v] = d[u] + 1; q.push(v); } } } return vis[t]; } int dfs(int u, int a) { if (u == t) return a; if (a == 0) return 0; int retflow = 0; for (int &amp;i = cur[u]; i &lt; (int)G[u].size(); i++) { int v = ed[G[u][i]].v, cap = ed[G[u][i]].cap, flow = ed[G[u][i]].flow; if (d[v] == d[u] + 1) { if (cap &gt; flow) { int f = dfs(v, min(a, cap - flow)); if (f &gt; 0) { a -= f, retflow += f, ed[G[u][i]].flow += f, ed[G[u][i] ^ 1].flow -= f; if (a == 0) break; } } } } return retflow; } int dinic() { int flow = 0; while (bfs()) { for (int i = 0; i &lt;= n + m + 2; i++) cur[i] = 0; flow += dfs(s, INF); } return flow; } void solve() { clean(); for (int i = 1; i &lt;= n; i++) ins(s, i, 1); for (int i = 1; i &lt;= n; i++) ins(i + n, t, 1); for (int u, v, i = 1; i &lt;= k; i++) { scanf(&quot;%d%d&quot;, &amp;u, &amp;v); ins(u, v + n, 1); } printf(&quot;%d\n&quot;, dinic()); } int main() { while (scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k) == 3) solve(); return 0; } 题目描述【题目描述】X集合有n个点（编号1，2，3，……n），Y集合有m个点（编号1，2，3，……m），有k条边（任意一条边的两个端点，一个来自X集合，一个来自Y集合）如果选中一个点（可以来自X集合或Y集合）就是燃烧掉所有与该点相连的边。问：至少选中多少个点，可以摧毁所有边（也就是k条边）【输入】第一行三个整数n, m，k( 0&lt; n, m &lt; 10000，0&lt; k &lt; 100000）。下来k行，每行两个整数 x，y，表示一条边，连接X集合中x点和Y集合的y点。【输出】一个整数，为最少选中的点数目。 输入：4 581 32 12 22 43 34 34 44 5输出：3]]></content>
      <categories>
        <category>caioj</category>
      </categories>
      <tags>
        <tag>二分图</tag>
        <tag>caioj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bzoj 2243(树链剖分+线段树)]]></title>
    <url>%2Fbzoj2243%2F</url>
    <content type="text"><![CDATA[BZOJ 2243这题就是caioj 1102树上版。所以我们树剖然后线段树维护 $lcol$：区间左端点的颜色 $rcol$：区间右端点的颜色 $cnt$：区间线段的条数 然后合并区间的时候如果中间颜色相同，要$cnt-1$查询同理，如果左右区间都更新了，则要判断中间颜色 之后树剖的合并就比较麻烦。要分两边来存上一个区间端点颜色是什么，然后最后$u$到$v$的修改也要讨论，这个仔细想想就行，但是容易写错，建议画一下，详情看代码，不太好讲 注意树往深的方向是右方向，浅的方向是左方向，而且$pushdown$记得子节点要传$lazy$ #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long using namespace std; const int MAXN = 100000 + 5; int n, Q, col[MAXN], dep[MAXN], fa[MAXN], son[MAXN], siz[MAXN], top[MAXN], p[MAXN], np[MAXN], tb; vector&lt;int&gt; G[MAXN]; void dfs1(int u, int pa) { dep[u] = dep[pa] + 1, fa[u] = pa, siz[u] = 1; for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i]; if (v != pa) { dfs1(v, u); siz[u] += siz[v]; if (son[u] == -1 || siz[v] &gt; siz[son[u]]) son[u] = v; } } } void dfs2(int u, int chain) { top[u] = chain; p[u] = ++tb, np[p[u]] = u; if (son[u] != -1) { dfs2(son[u], chain); for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i]; if (v != fa[u] &amp;&amp; v != son[u]) { dfs2(v, v); } } } } #define lc (o &lt;&lt; 1) #define rc (o &lt;&lt; 1 | 1) #define M ((l + r) &gt;&gt; 1) int lcol[MAXN * 4], rcol[MAXN * 4], cnt[MAXN * 4], lazy[MAXN * 4]; void pushup(int o, int l, int r) { if (l == r) return ; lcol[o] = lcol[lc], rcol[o] = rcol[rc], cnt[o] = cnt[rc] + cnt[lc]; if (rcol[lc] == lcol[rc]) cnt[o]--; } void pushdown(int o, int l, int r) { if (l == r) return ; if (lazy[o]) { lazy[lc] = lazy[rc] = lazy[o]; lcol[lc] = lcol[rc] = lazy[o]; rcol[lc] = rcol[rc] = lazy[o]; cnt[lc] = cnt[rc] = 1; lazy[o] = 0; } } void build(int o, int l, int r) { if (l == r) lcol[o] = rcol[o] = col[np[l]], cnt[o] = 1; else { build(lc, l, M), build(rc, M + 1, r); pushup(o, l, r); } } void update(int o, int l, int r, int x, int y, int v) { pushdown(o, l, r); if (x &lt;= l &amp;&amp; r &lt;= y) { lazy[o] = v; lcol[o] = rcol[o] = v, cnt[o] = 1; return ; } if (x &lt;= M) update(lc, l, M, x, y, v); if (M &lt; y) update(rc, M + 1, r, x, y, v); pushup(o, l, r); } int nowl, nowr; int query(int o, int l, int r, int x, int y) { pushdown(o, l, r); int ret = 0, flag = false; if (x &lt;= l &amp;&amp; r &lt;= y) { if (l == x) nowl = lcol[o]; if (r == y) nowr = rcol[o]; return cnt[o]; } if (x &lt;= M) ret += query(lc, l, M, x, y), flag = true; if (M &lt; y) { ret += query(rc, M + 1, r, x, y); if (flag &amp;&amp; rcol[lc] == lcol[rc]) ret--; } return ret; } void change(int u, int v, int c) { int f1 = top[u], f2 = top[v]; while (f1 != f2) { if (dep[f1] &lt; dep[f2]) swap(f1, f2), swap(u, v); update(1, 1, n, p[f1], p[u], c); u = fa[f1], f1 = top[u]; } if (dep[u] &lt; dep[v]) swap(u, v); update(1, 1, n, p[v], p[u], c); } int find(int u, int v) { int ans = 0, f1 = top[u], f2 = top[v], last1l = -1, last1r = -1, last2l = -1, last2r = -1, isu = 1; while (f1 != f2) { if (dep[f1] &lt; dep[f2]) swap(f1, f2), swap(u, v), swap(last1l, last2l), swap(last1r, last2r), isu = !isu; nowl = nowr = -1; int ret = query(1, 1, n, p[f1], p[u]); if (last1l != -1 &amp;&amp; nowr == last1l) ret--; last1l = nowl, last1r = nowr, ans += ret; u = fa[f1], f1 = top[u]; } if (dep[u] &lt; dep[v]) swap(u, v), swap(last1l, last2l), swap(last1r, last2r), isu = !isu; nowl = nowr = -1; int ret = query(1, 1, n, p[v], p[u]); if (last1l != -1 &amp;&amp; nowr == last1l) ret--; if (last2l != -1 &amp;&amp; nowl == last2l) ret--; ans += ret; return ans; } void clean() { tb = 0; for (int i = 0; i &lt;= n * 4; i++) cnt[i] = lazy[i] = lcol[i] = rcol[i] = 0; for (int i = 0; i &lt;= n; i++) G[i].clear(), top[i] = p[i] = np[i] = dep[i] = fa[i] = 0, son[i] = -1; } void solve() { clean(); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;col[i]); for (int x, y, i = 1; i &lt; n; i++) { scanf(&quot;%d%d&quot;, &amp;x, &amp;y); G[x].push_back(y), G[y].push_back(x); } dfs1(1, 0), dfs2(1, 1); build(1, 1, n); char s[10]; while (Q--) { scanf(&quot;%s&quot;, s); if (s[0] == &#39;C&#39;) { int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); change(a, b, c); } else { int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); printf(&quot;%d\n&quot;, find(a, b)); } } } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif scanf(&quot;%d%d&quot;, &amp;n, &amp;Q), solve(); return 0; } /* 20 3 1 2 2 2 1 1 2 2 1 1 2 2 2 2 2 2 1 2 1 2 2 1 3 1 4 3 5 3 6 2 7 1 8 7 9 6 10 2 11 8 12 10 13 11 14 7 15 8 16 4 17 13 18 11 19 7 20 11 C 6 13 2 C 7 15 1 Q 12 13 */]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[caioj 1102(线段树)]]></title>
    <url>%2Fcaioj1102%2F</url>
    <content type="text"><![CDATA[caioj 1102(本题为bzoj 2243弱化版)线段树维护三个值： $lcol$：区间左端点的颜色 $rcol$：区间右端点的颜色 $cnt$：区间线段的条数 然后合并区间的时候如果中间颜色相同，要$cnt-1$查询同理，如果左右区间都更新了，则要判断中间颜色或者把所有区间先找出来再一一合并 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long using namespace std; const int MAXN = 100000 + 5; int n, Q, col[MAXN]; #define lc (o &lt;&lt; 1) #define rc (o &lt;&lt; 1 | 1) #define M ((l + r) &gt;&gt; 1) int lazy[MAXN * 4], lcol[MAXN * 4], rcol[MAXN * 4], cnt[MAXN * 4]; void pushdown(int o, int l, int r) { if (l == r) return ; if (lazy[o]) { lazy[lc] = lazy[rc] = lazy[o]; lcol[lc] = rcol[lc] = lazy[o]; lcol[rc] = rcol[rc] = lazy[o]; cnt[lc] = cnt[rc] = 1; lazy[o] = 0; } } void pushup(int o, int l, int r) { if (l == r) return ; lcol[o] = lcol[lc], rcol[o] = rcol[rc]; cnt[o] = cnt[lc] + cnt[rc]; if (rcol[lc] == lcol[rc]) cnt[o]--; } void build(int o, int l, int r) { if (l == r) lcol[o] = rcol[o] = col[l], cnt[o] = 1; else { build(lc, l, M); build(rc, M + 1, r); pushup(o, l, r); } } void update(int o, int l, int r, int x, int y, int v) { pushdown(o, l, r); if (x &lt;= l &amp;&amp; r &lt;= y) { lcol[o] = rcol[o] = v; cnt[o] = 1; lazy[o] = v; return ; } if (x &lt;= M) update(lc, l, M, x, y, v); if (M &lt; y) update(rc, M + 1, r, x, y, v); pushup(o, l, r); } int inv[MAXN * 4], inv_num; void query(int o, int l, int r, int x, int y) { pushdown(o, l, r); if (x &lt;= l &amp;&amp; r &lt;= y) { inv[++inv_num] = o; return ; } if (x &lt;= M) query(lc, l, M, x, y); if (M &lt; y) query(rc, M + 1, r, x, y); } void clean() { for (int i = 0; i &lt;= n * 4; i++) lazy[i] = lcol[i] = rcol[i] = cnt[i] = 0; } void solve() { clean(); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;col[i]); build(1, 1, n); while (Q--) { int opt; scanf(&quot;%d&quot;, &amp;opt); if (opt == 1) { int x, y, k; scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;k); if (x &gt; y) swap(x, y); update(1, 1, n, x, y, k); } else { int x, y, ans = 0; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); if (x &gt; y) swap(x, y); inv_num = 0, query(1, 1, n, x, y); for (int i = inv_num; i &gt; 0; i--) { ans += cnt[inv[i]]; if (i - 1 &gt; 0) if (rcol[inv[i - 1]] == lcol[inv[i]]) ans--; } printf(&quot;%d\n&quot;, ans); } } } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif scanf(&quot;%d%d&quot;, &amp;n, &amp;Q), solve(); return 0; } 题目描述【题意】有n(1~100000)个连续的格子，编号为1……n，每个格子的颜色有3种（分别是1、2、3）。有m（1~100000）操作，操作有2种：1 x y k：表示第x个格子至第y个格子全染色为k（1&lt;=k&lt;=3)2 x y:表示询问第x个格子至第y个格子有多少条线段（相邻两个格子的颜色相同则同属一条线段）。【输入格式】第一行n和m。第二行n个数，分别表格n个格子的颜色。下来m行，每行表示一个操作。【输出格式】遇到操作2，则输出答案 【样例输入】5 52 1 1 2 12 1 51 4 4 12 1 51 1 1 12 1 5【样例输出】421]]></content>
      <categories>
        <category>caioj</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>caioj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初赛理论知识 学习笔记]]></title>
    <url>%2Fsz%E5%88%9D%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[模板及讲解 1、进制转换整数： 十进制转$n$进制：用短除法。不断地除以$n$，倒序取余数，直到十进制数为0 $n$进制转十进制：按位加权乘积和，第一位权为$n^0$, 第二位权为$n^1$，依此类推 小数： 十进制转$n$进制：不断地乘$n$，正序取整数部分，直到无整数部分。 $n$进制转十进制：按位加权乘积和，小数位第一位权为$n^{-1}$, 小数位第二位权为$n^{-2}$，依此类推 2、原码，反码，补码负数： 原码：一个二进制数，其最前一为为符号位，1为负，0为正 反码：原码各位取反(除符号位) 补码：反码$+1$ 正数：原码 = 反码 = 补码 3、二叉树遍历 先序遍历：根左右 中序遍历：左根右 后序遍历：左右根 4、逻辑符号 非：$¬$ 与(交)：$∧$ 或(并)：$∨$ 异或：$⊕$ 5、前缀、中缀、后缀表达式 中缀表达式：$(3+4) \times 5 - 6$ 前缀表达式：$- \times + 3 4 5 6$，从右往左扫描栈处理 后缀表达式：$3 4 + 5 \times 6 -$，从左往右扫描栈处理]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spoj QTREE3(树剖+线段树)]]></title>
    <url>%2Fspoj-QTREE3%2F</url>
    <content type="text"><![CDATA[spoj QTREE3树剖，然后线段树维护区间第一个出现的黑点。由于单点修改所以很简单了(注意！树剖的$u,p_u,np_u$的意义要弄清楚！树剖时重点检查对象) #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long using namespace std; const int MAXN = 100000 + 5, INF = 1000000000; int n, Q; vector&lt;int&gt; G[MAXN]; void ins(int u, int v) { G[u].push_back(v), G[v].push_back(u); } int fa[MAXN], dep[MAXN], siz[MAXN], son[MAXN], p[MAXN], np[MAXN], top[MAXN], tb; void dfs1(int u, int p) { fa[u] = p, siz[u] = 1, dep[u] = dep[p] + 1; for (int i = 0;i &lt; (int)G[u].size(); i++) { int v = G[u][i]; if (v != p) { dfs1(v, u); siz[u] += siz[v]; if (son[u] == -1 || siz[v] &gt; siz[son[u]]) son[u] = v; } } } void dfs2(int u, int chain) { p[u] = ++tb; np[p[u]] = u; top[u] = chain; if (son[u] != -1) { dfs2(son[u], chain); for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i]; if (v != son[u] &amp;&amp; v != fa[u]) { dfs2(v, v); } } } } #define lc (o &lt;&lt; 1) #define rc (o &lt;&lt; 1 | 1) #define M ((l + r) &gt;&gt; 1) int col[MAXN * 4], tag[MAXN * 4]; void pushup(int o) { tag[o] = min(tag[lc], tag[rc]); } void update(int o, int l, int r, int x) { if (l == r) { col[o] = !col[o]; if (col[o] == 1) tag[o] = l; else tag[o] = INF; return ; } if (x &lt;= M) update(lc, l, M, x); else if (M &lt; x) update(rc, M + 1, r, x); pushup(o); } int query(int o, int l, int r, int x, int y) { int ret = INF; if (x &lt;= l &amp;&amp; r &lt;= y) { return tag[o]; } if (x &lt;= M) ret = min(ret, query(lc, l, M, x, y)); if (M &lt; y) ret = min(ret, query(rc, M + 1, r, x, y)); return ret; } int find(int u, int v) { int f1 = top[u], f2 = top[v], ret = INF; while (f1 != f2) { if (dep[f1] &lt; dep[f2]) swap(u, v), swap(f1, f2); ret = min(ret, query(1, 1, n, p[f1], p[u])); u = fa[f1], f1 = top[u]; } if (dep[u] &lt; dep[v]) swap(u, v); return min(ret, query(1, 1, n, p[v], p[u])); } void clean() { tb = 0; for (int i = 0; i &lt;= 4 * n; i++) col[i] = 0, tag[i] = INF; for (int i = 0; i &lt;= n; i++) { G[i].clear(), np[i] = p[i] = top[i] = fa[i] = dep[i] = 0, son[i] = -1; } } void solve() { clean(); for (int u, v, i = 1; i &lt; n; i++) { scanf(&quot;%d%d&quot;, &amp;u, &amp;v); ins(u, v); } dfs1(1, 0), dfs2(1, 1); while (Q--) { int opt, a; scanf(&quot;%d%d&quot;, &amp;opt, &amp;a); if (opt == 0) { update(1, 1, n, p[a]); } else { int ans = find(1, a); printf(&quot;%d\n&quot;, ans == INF ? -1 : np[ans]); } } } int main() { //freopen(&quot;1.in&quot;, &quot;r&quot;, stdin); freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); scanf(&quot;%d%d&quot;, &amp;n, &amp;Q), solve(); return 0; }]]></content>
      <categories>
        <category>spoj</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
        <tag>spoj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spoj QTREE2(倍增LCA)]]></title>
    <url>%2Fspoj-QTREE2%2F</url>
    <content type="text"><![CDATA[spoj QTREE2把一条路径根据$LCA$拆成两条链，然后判断第$k$个点在哪条链上即可注意求LCA的时候要判断深度大小，以及树上的路径权值和不要误认为是距离了 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define pb push_back using namespace std; const int MAXN = 20000 + 5, logs = 20; struct data {LL v, wi;}ed[MAXN * 2]; LL en, n, fa[MAXN], dep[MAXN], pre[MAXN][logs + 1], far[MAXN]; vector&lt;LL&gt; G[MAXN]; void clean() { en = 0; for (LL i = 0; i &lt;= n; i++) { far[i] = fa[i] = dep[i] = 0, G[i].clear(); for (LL j = 0; j &lt;= logs; j++) pre[i][j] = 0; } } void ins(LL u, LL v, LL c) { en++, ed[en] = (data){v, c}, G[u].pb(en); en++, ed[en] = (data){u, c}, G[v].pb(en); } void dfs(LL u, LL pa) { dep[u] = dep[pa] + 1, fa[u] = pa, pre[u][0] = pa; for (LL i = 1; i &lt;= logs; i++) pre[u][i] = pre[pre[u][i - 1]][i - 1]; for (LL i = 0; i &lt; (LL)G[u].size(); i++) { LL v = ed[G[u][i]].v, wi = ed[G[u][i]].wi; if (v != pa) { far[v] = far[u] + wi; dfs(v, u); } } } LL getlca(LL a, LL b) { if (dep[a] &lt; dep[b]) swap(a, b); for (LL i = logs; i &gt;= 0; i--) if (dep[pre[a][i]] &gt;= dep[b]) a = pre[a][i]; if (a == b) return a; for (LL i = logs; i &gt;= 0; i--) if (pre[a][i] != pre[b][i]) a = pre[a][i], b = pre[b][i]; return pre[a][0]; } LL dist(LL u, LL v) { LL lca = getlca(u, v); return far[u] + far[v] - 2 * far[lca]; } LL pc(LL u, LL k) { LL dt = dep[u] - k + 1; for (LL i = logs; i &gt;= 0; i--) if (dep[pre[u][i]] &gt;= dt) u = pre[u][i]; return u; } LL kth(LL u, LL v, LL w) { LL lca = getlca(u, v); LL dt = dep[u] - dep[lca]; if (dt + 1 &gt;= w) { return pc(u, w); } else return pc(v, dep[u] + dep[v] - 2 * dep[lca] - w + 2); } void solve() { scanf(&quot;%lld&quot;, &amp;n); clean(); for (LL x, y, c, i = 1; i &lt; n; i++) { scanf(&quot;%lld%lld%lld&quot;, &amp;x, &amp;y, &amp;c); ins(x, y, c); } dfs(1, 0); char s[10]; while (true) { scanf(&quot;%s&quot;, s); if (s[1] == &#39;O&#39;) break; if (s[1] == &#39;I&#39;) { LL u, v; scanf(&quot;%lld%lld&quot;, &amp;u, &amp;v); printf(&quot;%lld\n&quot;, dist(u, v)); } else { if (s[1] == &#39;T&#39;) { LL u, v, k; scanf(&quot;%lld%lld%lld&quot;, &amp;u, &amp;v, &amp;k); printf(&quot;%lld\n&quot;, kth(u, v, k)); } } } } int main() { LL T; scanf(&quot;%lld&quot;, &amp;T); while (T--) solve(); return 0; }]]></content>
      <categories>
        <category>spoj</category>
      </categories>
      <tags>
        <tag>倍增</tag>
        <tag>spoj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STL 学习笔记]]></title>
    <url>%2FszSTL%2F</url>
    <content type="text"><![CDATA[STLSTL的容器都为左闭右开区间$[begin(), end())$ vector size()：查询$vector$中元素的个数。 [index]：直接访问$vector$数组第$index$个元素。 push_back(x)：把$x$放在$vector$的表尾。 reverse(begin(), end())：把$begin()$到$end()$之间的元素翻转 reserve()：手动调整$capacity$ rbegin(), rend()：反向迭代器, rbegin()是最后一个元素，rend()是第一个元素 set count()：查询$set$中元素的个数。 insert(x)：把$x$插入$set$. lower_bound(x)：找到第一个大于等于$x$的元素(找不到返回$end()$)。 erase(x)：删除$x$迭代器所指向元素(不能删去$begin()$)。 set&lt;type&gt;::iterator：声明一个迭代器，访问元素使用data-&gt;x来访问，类似指针 rbegin(), rend()：反向迭代器, rbegin()是最后一个元素，rend()是第一个元素 map rbegin(), rend()：反向迭代器, rbegin()是最后一个元素，rend()是第一个元素 string substr(int a, int len)：把$[a,a+len]$提取出来返回值为$string$ length()：得出字符串长度 assign()：给string赋值，具体看使用 rbegin(), rend()：反向迭代器, rbegin()是最后一个元素，rend()是第一个元素 注意所有end()调用即会出错。 pbdsropeP3835 【模板】可持久化平衡树模板：可持久化平衡树 主要用lower_bound和insert(pos, x)注意复制方法new rope&lt;int &gt;(*seq[v]); // luogu-judger-enable-o2 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;map&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; #include&lt;ext/pb_ds/assoc_container.hpp&gt; #include&lt;ext/rope&gt; using namespace __gnu_cxx; namespace flyinthesky { const int MAXN = 500000 + 5; rope&lt;int &gt; *seq[MAXN]; // 指针方便复制 int Q; inline int rd() { register int data = 0, w = 1; register char ch = 0; while (ch != &#39;-&#39; &amp;&amp; (ch &gt; &#39;9&#39; || ch &lt; &#39;0&#39;)) ch = getchar(); if (ch == &#39;-&#39;) w = -1 , ch = getchar(); while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) data = data * 10 + (ch ^ 48), ch = getchar(); return w * data; } void clean() { } int solve() { clean(); cin &gt;&gt; Q; seq[0] = new rope&lt;int &gt;; for (int i = 1; i &lt;= Q; ++i) { int v, op, x; v = rd(), op = rd(), x = rd(); seq[i] = new rope&lt;int &gt;(*seq[v]); if (op == 1) { seq[i]-&gt;insert(lower_bound(seq[i]-&gt;begin(), seq[i]-&gt;end(), x) - seq[i]-&gt;begin(), x); } if (op == 2) { auto it = lower_bound(seq[i]-&gt;begin(), seq[i]-&gt;end(), x); if (it != seq[i]-&gt;end() &amp;&amp; *it == x) seq[i]-&gt;erase(it - seq[i]-&gt;begin(), 1); } if (op == 3) { printf(&quot;%d\n&quot;, lower_bound(seq[i]-&gt;begin(), seq[i]-&gt;end(), x) - seq[i]-&gt;begin() + 1); } if (op == 4) { printf(&quot;%d\n&quot;, *(seq[i]-&gt;begin() + x - 1)); } if (op == 5) { auto it = upper_bound(seq[i]-&gt;begin(), seq[i]-&gt;end(), x); --it; printf(&quot;%d\n&quot;, (int)*it); } if (op == 6) { auto it = upper_bound(seq[i]-&gt;begin(), seq[i]-&gt;end(), x); printf(&quot;%d\n&quot;, (int)*it); } } return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 2028」「SHOI2009」会场预约 (Splay / Set)]]></title>
    <url>%2Fbzoj2028%2F</url>
    <content type="text"><![CDATA[BZOJ 2028luogu免权限地址Set维护不相交区间，lower_bound求前后与当前区间最近的区间，检查是否重合，重合即删除，直到不重合为止。注意set.lower_bound()如果找不到就会返回set.end() #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;set&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; struct data { int l, r; bool operator &lt; (const data &amp;b) const { if (l == b.l) return r &lt; b.r; return l &lt; b.l; } }; set&lt;data&gt; s; int n; int getch() { char ch = getchar(); while (ch != &#39;A&#39; &amp;&amp; ch != &#39;B&#39;) ch = getchar(); return ch == &#39;A&#39; ? 1 : 2; } void clean() {} void solve() { clean(); for (int i = 1; i &lt;= n; i++) { int opt = getch(); if (opt == 2) printf(&quot;%d\n&quot;, (int)s.size()); else { int ans = 0; int l, r; scanf(&quot;%d%d&quot;, &amp;l, &amp;r); data a = (data){l, r}; while (true) { set&lt;data&gt;::iterator p = s.lower_bound(a); if (p-&gt;l &lt;= r &amp;&amp; p-&gt;r &gt;= l) { ans++; s.erase(p); continue; } p = s.lower_bound(a); if (p != s.begin()) { p--; if (p-&gt;l &lt;= r &amp;&amp; p-&gt;r &gt;= l) { ans++; s.erase(p); continue; } } s.insert(a); printf(&quot;%d\n&quot;, ans); break; } } } } int main() { scanf(&quot;%d&quot;, &amp;n), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>Splay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2012 Day2 T2(线段树/二分+前缀和+离线)]]></title>
    <url>%2FNOIP2012tgD2T2%2F</url>
    <content type="text"><![CDATA[线段树做法：裸模板，维护区间增加区间最小值，但是常数大容易T 二分+前缀和做法：每次二分一个通过申请的个数，然后暴力前缀和判断，复杂度与线段树一样，但是常数小 线段树做法： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 1000000 + 5; int n, m, ri[MAXN]; #define lc (o &lt;&lt; 1) #define rc ((o &lt;&lt; 1) | 1) #define M ((l + r) &gt;&gt; 1) int minv[MAXN * 4], addv[MAXN * 4]; void pushup(int o) { minv[o] = min(minv[lc], minv[rc]); } void pushdown(int o) { if (addv[o]) { addv[lc] += addv[o], addv[rc] += addv[o]; minv[lc] += addv[o], minv[rc] += addv[o]; addv[o] = 0; } } void build(int o, int l, int r) { if (l == r) minv[o] = ri[l]; else build(lc, l, M), build(rc, M + 1, r), pushup(o); } void update(int o, int l, int r, int x, int y, int v) { if (x &lt;= l &amp;&amp; r &lt;= y) { minv[o] += v, addv[o] += v; return ; } pushdown(o); if (x &lt;= M) update(lc, l, M, x, y, v); if (M &lt; y) update(rc, M + 1, r, x, y, v); pushup(o); } int query(int o, int l, int r, int x, int y) { int ret = 2000000000; if (x &lt;= l &amp;&amp; r &lt;= y) { return minv[o]; } pushdown(o); if (x &lt;= M) ret = min(ret, query(lc, l, M, x, y)); if (M &lt; y) ret = min(ret, query(rc, M + 1, r, x, y)); pushup(o); return ret; } void clean() { ms(addv, 0); } void solve() { clean(); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;ri[i]); build(1, 1, n); for (int i = 1; i &lt;= m; i++) { int di, si, ti; scanf(&quot;%d%d%d&quot;, &amp;di, &amp;si, &amp;ti); int ret = query(1, 1, n, si, ti); if (ret &lt; di) { printf(&quot;-1\n%d\n&quot;, i); return ; } update(1, 1, n, si, ti, -di); } printf(&quot;0\n&quot;); } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m), solve(); return 0; } 二分+前缀和做法： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 1000000 + 5; int n, m, ri[MAXN]; int di[MAXN], si[MAXN], ti[MAXN]; int ci[MAXN]; bool check(int x) { for (int i = 0; i &lt;= n + 1; i++) ci[i] = 0; for (int i = 1; i &lt;= x; i++) ci[si[i]] += di[i], ci[ti[i] + 1] -= di[i]; for (int i = 1; i &lt;= n + 1; i++) { ci[i] += ci[i - 1]; if (ci[i] &gt; ri[i]) return false; } return true; } void clean() {} void solve() { clean(); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;ri[i]); for (int i = 1; i &lt;= m; i++) { scanf(&quot;%d%d%d&quot;, &amp;di[i], &amp;si[i], &amp;ti[i]); } int ans = 0, l = 0, r = m + 1; while (l &lt; r) { int mid = (l + r) / 2; if (check(mid)) l = mid + 1, ans = mid; else r = mid; } if (ans == m) printf(&quot;0\n&quot;); else printf(&quot;-1\n%d\n&quot;, ans + 1); } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m), solve(); return 0; }]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>离线</tag>
        <tag>线段树</tag>
        <tag>二分</tag>
        <tag>前缀和</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2016 Day2 T2(堆/单调队列)]]></title>
    <url>%2FNOIP2016tgD2T2%2F</url>
    <content type="text"><![CDATA[25分水法：直接模拟，增加$q$直接暴力把堆中的元素取出来加完放进去 65分水法：直接按照题意模拟，但是堆里面存当前蚯蚓长度与 增加量$q$ 的差值(具体看代码),来避免每次使蚯蚓增加$q$. 90分水法：发现很多数据$q=0$，那么等于蚯蚓不会再加了，考虑单调性。用三个队列$q_1,q_2,q_3$，分别代表原始数据，切分第一部分，切分第二部分。然后每次从三个队列里取最大值出来切，然后结果分别放进$q_2,q_3$。这样做是对的，因为这样做数据是单调递减的，前面切的两部分一定比后面切的两部分分别大于。然后加上65分的程序分段，这样就有90分了，注意分段程序千万别打错，不然白打前65分。 100分正解：根据上一个90分做法，我们被暗示了——单调性。$q≠0$也是单调的吗？是的。我们通过反证可以知道：设$a_i$为当前被切割的蚯蚓的原长，$a_j$为$a_i$之前隔了$n$时段被切割的蚯蚓的原长那么假设不单调，即出现：$a_i \times p + n \times q \leq (a_j + n \times q) \times p$那么就是$a_i \times p + n \times q \leq a_j \times p + n \times q \times p$因为$a_j \leq a_i, 0 &lt; p &lt; 1$，那么$a_i \times p + n \times q &gt; a_j \times p + n \times q \times p$成立与之前的假设矛盾，因此是单调的NOIP的部分分都是在暗示正解的方向，不过以后或者其他比赛可能回不会。所以尽可能往部分分想会暗示什么，但是也不要完全依赖部分分提示。上述算法虽然难以证明，但是在想到90分做法以后，联想到$q≠0$，那就可以作一个假设，之后用暴力对拍即可验证正确性(你的暴力肯定要对)。 下面代码给出了3个分数档次(65,90,100)的代码：65分堆水法： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 100000 + 5; struct data { LL len; bool operator &lt; (const data &amp;b) const { return len &lt; b.len; } }; LL n, m, q, t, add; db pi; priority_queue&lt;data&gt; pq; void clean() { add = 0; } void solve() { clean(); for (LL x, i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;x), pq.push((data){x}); data p; for (int i = 1; i &lt;= m; i++) { p = pq.top(); pq.pop(); LL len = p.len + add; if (i % t == 0) printf(&quot;%lld &quot;, len); LL fir = (LL)((db)len * pi); LL sec = len - fir; add += q; pq.push((data){fir - add}), pq.push((data){sec - add}); } printf(&quot;\n&quot;); int tot = 0; while (!pq.empty()) { p = pq.top(); pq.pop(); tot++; LL len = p.len + add; if (tot % t == 0) printf(&quot;%lld &quot;, len); } printf(&quot;\n&quot;); } int main() { LL u, v; scanf(&quot;%lld%lld%lld%lld%lld%lld&quot;, &amp;n, &amp;m, &amp;q, &amp;u, &amp;v, &amp;t), pi = (db)u / (db)v, solve(); return 0; } 90分水法： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 100000 + 5; struct data { LL len; bool operator &lt; (const data &amp;b) const { return len &lt; b.len; } }; LL n, m, q, t, add; db pi; priority_queue&lt;data&gt; pq; void clean() { add = 0; } void solve() { clean(); for (LL x, i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;x), pq.push((data){x}); data p; for (int i = 1; i &lt;= m; i++) { p = pq.top(); pq.pop(); LL len = p.len + add; if (i % t == 0) printf(&quot;%lld &quot;, len); LL fir = (LL)((db)len * pi); LL sec = len - fir; add += q; pq.push((data){fir - add}), pq.push((data){sec - add}); } printf(&quot;\n&quot;); int tot = 0; while (!pq.empty()) { p = pq.top(); pq.pop(); tot++; LL len = p.len + add; if (tot % t == 0) printf(&quot;%lld &quot;, len); } printf(&quot;\n&quot;); } LL q1[10000000 + 5], q2[10000000 + 5], q3[10000000 + 5]; LL h1 = 0, h2 = 0, h3 = 0, t1 = 0, t2 = 0, t3 = 0; bool cmp(const int &amp;a, const int &amp;b) { return a &gt; b; } void solve2() { for (int i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;q1[i]); sort(q1 + 1, q1 + 1 + n, cmp); t1 = n; for (int i = 1; i &lt;= m; i++) { LL maxd = -1, wh = 0; if (h1 &lt; t1) if (maxd &lt; q1[h1 + 1]) maxd = q1[h1 + 1], wh = 1; if (h2 &lt; t2) if (maxd &lt; q2[h2 + 1]) maxd = q2[h2 + 1], wh = 2; if (h3 &lt; t3) if (maxd &lt; q3[h3 + 1]) maxd = q3[h3 + 1], wh = 3; if (wh == 1) h1++; if (wh == 2) h2++; if (wh == 3) h3++; if (i % t == 0) printf(&quot;%lld &quot;, maxd); q2[++t2] = (LL)((db)maxd * pi); q3[++t3] = maxd - (LL)((db)maxd * pi); } printf(&quot;\n&quot;); for (int i = 1; i &lt;= n + m; i++) { LL maxd = -1, wh = 0; if (h1 &lt; t1) if (maxd &lt; q1[h1 + 1]) maxd = q1[h1 + 1], wh = 1; if (h2 &lt; t2) if (maxd &lt; q2[h2 + 1]) maxd = q2[h2 + 1], wh = 2; if (h3 &lt; t3) if (maxd &lt; q3[h3 + 1]) maxd = q3[h3 + 1], wh = 3; if (wh == 1) h1++; if (wh == 2) h2++; if (wh == 3) h3++; if (i % t == 0) printf(&quot;%lld &quot;, maxd); } printf(&quot;\n&quot;); } int main() { LL u, v; scanf(&quot;%lld%lld%lld%lld%lld%lld&quot;, &amp;n, &amp;m, &amp;q, &amp;u, &amp;v, &amp;t), pi = (db)u / (db)v; if (q != 0) solve(); else solve2(); return 0; } 100分正解： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 100000 + 5; LL n, m, q, t, add; db pi; void clean() { add = 0; } bool cmp(const int &amp;a, const int &amp;b) { return a &gt; b; } LL q1[10000000 + 5], q2[10000000 + 5], q3[10000000 + 5]; LL h1 = 0, h2 = 0, h3 = 0, t1 = 0, t2 = 0, t3 = 0; void solve() { clean(); for (int i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;q1[i]); sort(q1 + 1, q1 + 1 + n, cmp); t1 = n; for (int i = 1; i &lt;= m; i++) { LL maxd = -1000000000, wh = 0; if (h1 &lt; t1) if (maxd &lt; q1[h1 + 1]) maxd = q1[h1 + 1], wh = 1; if (h2 &lt; t2) if (maxd &lt; q2[h2 + 1]) maxd = q2[h2 + 1], wh = 2; if (h3 &lt; t3) if (maxd &lt; q3[h3 + 1]) maxd = q3[h3 + 1], wh = 3; if (wh == 1) h1++; if (wh == 2) h2++; if (wh == 3) h3++; maxd += add; if (i % t == 0) printf(&quot;%lld &quot;, maxd); add += q; q2[++t2] = (LL)((db)maxd * pi) - add; q3[++t3] = maxd - (LL)((db)maxd * pi) - add; } printf(&quot;\n&quot;); for (int i = 1; i &lt;= n + m; i++) { LL maxd = -1000000000, wh = 0; if (h1 &lt; t1) if (maxd &lt; q1[h1 + 1]) maxd = q1[h1 + 1], wh = 1; if (h2 &lt; t2) if (maxd &lt; q2[h2 + 1]) maxd = q2[h2 + 1], wh = 2; if (h3 &lt; t3) if (maxd &lt; q3[h3 + 1]) maxd = q3[h3 + 1], wh = 3; if (wh == 1) h1++; if (wh == 2) h2++; if (wh == 3) h3++; if (i % t == 0) printf(&quot;%lld &quot;, maxd + add); } printf(&quot;\n&quot;); } int main() { LL u, v; scanf(&quot;%lld%lld%lld%lld%lld%lld&quot;, &amp;n, &amp;m, &amp;q, &amp;u, &amp;v, &amp;t), pi = (db)u / (db)v, solve(); return 0; }]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>堆</tag>
        <tag>单调队列</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2016 Day2 T3(状压DP/DFS)]]></title>
    <url>%2FNOIP2016tgD2T3%2F</url>
    <content type="text"><![CDATA[$n$小，搜索或者状压。设$g(i, j)$为$i$和$j$组成一条抛物线的可被射的鸟的状态，$dp(S)$为在$S$状态时的最优解，然后转移就是$$dp(S) = min(dp(S-g(i,j))+1)$$初始化$g(i, j)$需要用待定系数法求出抛物线，即解二元一次方程，这个推一推就能推出通解了，复杂度$O(n^3)$然后DP求解的时候是$O(2^nn^2)​$，有一点大，所以会TLE了几个点，有空补补$O(2^nn)​$做法 搜索做法：设$g(i, j)$为$i$和$j$组成一条抛物线的可被射的鸟的状态，然后DFS，加可行性剪枝DFS里每次看正在搜索的点是否已经被前面打了，用二进制优化，不然就和后面的相连或者一炮只打这一只小鸟，然后更新答案即可，这样做是满分的2017.09.03: 搜索剪枝满分 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 18 + 1; const double eps = 1e-12; void jfc(double &amp;x, double &amp;y, double a, double b, double c, double d, double e, double f) { //ax+by=e //cx+dy=f if ((a * d - c * b) == 0 || a == 0) {x = 1, y = 1; return;} y = (a * f - c * e) / (a * d - c * b); x = (e - b * y) / a; } int n, m, p[MAXN][MAXN], f[MAXN][1 &lt;&lt; MAXN], ans; db xi[MAXN], yi[MAXN]; void dfs(int a, int st, int used) { if (a == n + 1) { ans = min(ans, used); return ; } if (used &gt;= ans) return ; if (used &gt;= f[a][st]) return ; f[a][st] = used; if (st &gt;&gt; (a - 1) &amp; 1) dfs(a + 1, st, used); else { for (int i = a + 1; i &lt;= n; i++) { dfs(a + 1, st | p[a][i], used + 1); } dfs(a + 1, st, used + 1); } } void clean() { ans = 1000000000; ms(p, 0), ms(f, 127); } void solve() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); clean(); for (int i = 1; i &lt;= n; i++) { scanf(&quot;%lf%lf&quot;, &amp;xi[i], &amp;yi[i]); } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { if (i == j) continue; p[i][j] = (1 &lt;&lt; (i - 1)); db nowx, nowy; jfc(nowx, nowy, xi[i] * xi[i], xi[i], xi[j] * xi[j], xi[j], yi[i], yi[j]); if (nowx &gt;= 0) continue; p[i][j] += (1 &lt;&lt; (j - 1)); for (int k = 1; k &lt;= n; k++) { if (k != i &amp;&amp; k != j) { db orzx, orzy; jfc(orzx, orzy, xi[i] * xi[i], xi[i], xi[k] * xi[k], xi[k], yi[i], yi[k]); if (fabs(orzx - nowx) &lt;= eps &amp;&amp; fabs(orzy - nowy) &lt;= eps) p[i][j] += (1 &lt;&lt; (k - 1)); } } } } dfs(1, 0, 0); printf(&quot;%d\n&quot;, ans); } int main() { int t; scanf(&quot;%d&quot;, &amp;t); while (t--) solve(); return 0; } $O(2^nn^2)$做法(状压)： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long using namespace std; const int MAXN = 18 + 2; const double eps = 0.000000001; int n, m, g[MAXN][MAXN], dp[1&lt;&lt;MAXN]; double xi[MAXN], yi[MAXN]; void jfc(double &amp;x, double &amp;y, double a, double b, double c, double d, double e, double f) { //ax+by=e //cx+dy=f if ((a*d-c*b)==0||a==0) {x = 1, y = 1; return;}//除0会炸 y = (a*f-c*e)/(a*d-c*b); x = (e-b*y)/a; } void clean() { ms(g, 0), ms(dp, 67); } __attribute__((optimize(&quot;-O2&quot;))) void solve() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); clean(); for (int i=1;i&lt;=n;i++) scanf(&quot;%lf%lf&quot;, &amp;xi[i], &amp;yi[i]); for (int i=1;i&lt;=n;i++) { for (int j=i;j&lt;=n;j++) if (!g[i][j]) { double x, y; if (i==j) {g[i][j] = (1&lt;&lt;(i-1)); continue;}//特判一下一个点 jfc(x, y, xi[i]*xi[i], xi[i], xi[j]*xi[j], xi[j], yi[i], yi[j]); if (x&gt;=0) continue; g[i][j] = (1&lt;&lt;(i-1)); g[i][j] += (1&lt;&lt;(j-1)); for (int k=1;k&lt;=n;k++) if (i!=k&amp;&amp;j!=k) { double dx, dy; jfc(dx, dy, xi[i]*xi[i], xi[i], xi[k]*xi[k], xi[k], yi[i], yi[k]); if (dx&gt;=0) continue; if (fabs(dx-x)&lt;=eps&amp;&amp;fabs(dy-y)&lt;=eps) g[i][j] += (1&lt;&lt;(k-1)); } g[j][i] = g[i][j]; } } dp[0] = 0; for (int S=1;S&lt;(1&lt;&lt;n);S++) { if (S==(1&lt;&lt;n)-1) dp[0] = dp[0]; for (int i=1;i&lt;=n;i++) { if (S&amp;(1&lt;&lt;(i-1))) { for (int j=1;j&lt;=n;j++) { if ((S&amp;(1&lt;&lt;(j-1)))&amp;&amp;((S&amp;g[i][j])==g[i][j])) { dp[S] = min(dp[S], dp[S^g[i][j]]+1); } } } } } printf(&quot;%d\n&quot;, dp[(1&lt;&lt;n)-1]); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif int T; scanf(&quot;%d&quot;, &amp;T); while (T--) solve(); return 0; }]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>状压DP</tag>
        <tag>DFS</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2016 Day1 T3(概率期望DP)]]></title>
    <url>%2FNOIP2016tgD1T3%2F</url>
    <content type="text"><![CDATA[设$dp(i,j,0)$为前$i$个课程申请$j$次，第$j$次成功的最小体力期望，$dp(i,j,1)$为前$i$个课程申请$j$次，第$j$次不成功的最小体力期望。转移方程具体看代码，太长了，不在这里重复打注意double别用memset并且赋值考虑是否会溢出 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 2000 + 5, MAXV = 300 + 5; int n, m, v, e, ci[MAXN], di[MAXN], G[MAXV][MAXV]; db ki[MAXN], dp[MAXN][MAXN][2]; void clean() { for (int i = 1; i &lt;= v; i++) for (int j = 1; j &lt;= v; j++) if (i == j) G[i][j] = 0; else G[i][j] = 1000000000.0; } void solve() { clean(); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;ci[i]); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;di[i]); for (int i = 1; i &lt;= n; i++) scanf(&quot;%lf&quot;, &amp;ki[i]); for (int x, y, w, i = 1; i &lt;= e; i++) { scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;w); G[x][y] = min(G[x][y], w); G[y][x] = min(G[y][x], w);//注意邻接矩阵重边处理 } for (int k = 1; k &lt;= v; k++) for (int i = 1; i &lt;= v; i++) for (int j = 1; j &lt;= v; j++) if (i != j &amp;&amp; i != k &amp;&amp; j != k) G[i][j] = min(G[i][j], G[i][k] + G[k][j]); for (int i = 0; i &lt;= n; i++) for (int j = 0; j &lt;= m; j++) dp[i][j][0] = dp[i][j][1] = 1000000000.0; db ans = dp[1][0][0]; dp[1][0][0] = 0, dp[1][1][0] = 0, dp[1][1][1] = 0; for (int i = 2; i &lt;= n; i++) { for (int j = 0; j &lt;= m; j++) { dp[i][j][0] = min(dp[i][j][0], min(dp[i - 1][j][0] + (db)G[ci[i - 1]][ci[i]], dp[i - 1][j][1] + (db)G[di[i - 1]][ci[i]] * ki[i - 1] + G[ci[i - 1]][ci[i]] * (1 - ki[i - 1]))); if (j - 1 &gt;= 0) dp[i][j][1] = min(dp[i][j][1], min(dp[i - 1][j - 1][0] + (db)G[ci[i - 1]][ci[i]] * (1 - ki[i]) + G[ci[i - 1]][di[i]] * ki[i],dp[i - 1][j - 1][1] + (db)G[ci[i - 1]][ci[i]] * (1 - ki[i]) * (1 - ki[i - 1]) + G[di[i - 1]][ci[i]] * (1 - ki[i]) * ki[i - 1] +G[di[i - 1]][di[i]] * ki[i] * ki[i - 1] + G[ci[i - 1]][di[i]] * ki[i] * (1 - ki[i - 1]))); } } for (int i = 0; i &lt;= m; i++) { ans = min(ans, min(dp[n][i][1], dp[n][i][0])); } printf(&quot;%.2f\n&quot;, ans); } int main() { scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;v, &amp;e), solve(); return 0; }]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>概率DP</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1001」「BeiJing2006」狼抓兔子 (最小割)]]></title>
    <url>%2Fbzoj1001%2F</url>
    <content type="text"><![CDATA[BZOJ 1001直接建图dinic，注意这题坑多1 存边不要用vector，vector自动申请内存在不够的时候会申请多一倍，所以换数组或者reserve2 原图是无向图，所以反向弧容量也是$c$而不是03 注意$n,m$和点就行 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 1000 * 1000 + 5, MAXM = 3 * 1000 * 1000 + 5, INF = 2147483647; struct data {int v, cap, flow;}ed[MAXM * 2]; //vector&lt;data&gt; ed; vector&lt;int&gt; G[MAXN]; int n, m, s, t; int getIDbyPos(int x, int y) {return y + (x - 1) * m;} int en, cur[MAXN], d[MAXN], vis[MAXN]; void ins(int u, int v, int c) { /*ed.push_back((data){v, c, 0}), G[u].push_back(en++); ed.push_back((data){u, c, 0}), G[v].push_back(en++);*/ //vector存边会MLE，解决方案看下面 ed[en] = ((data){v, c, 0}), G[u].push_back(en++); ed[en] = ((data){u, c, 0}), G[v].push_back(en++); } bool bfs() { queue&lt;int&gt; q; for (int i = 0; i &lt;= n * m; i++) vis[i] = false; d[s] = 0, vis[s] = true, q.push(s); while (!q.empty()) { int u = q.front(); q.pop(); for (int i = 0; i &lt; G[u].size(); i++) { int v = ed[G[u][i]].v, cap = ed[G[u][i]].cap, flow = ed[G[u][i]].flow; if (!vis[v] &amp;&amp; cap &gt; flow) { vis[v] = true, d[v] = d[u] + 1, q.push(v); } } } return vis[t]; } int dfs(int u, int a) { if (u == t) return a; if (a == 0) return 0; int retflow = 0; for (int &amp;i = cur[u]; i &lt; G[u].size(); i++) { int v = ed[G[u][i]].v, cap = ed[G[u][i]].cap, flow = ed[G[u][i]].flow; if (cap &gt; flow) { if (d[v] == d[u] + 1) { int f = dfs(v, min(a, cap - flow)); if (f &gt; 0) { a -= f, retflow += f, ed[G[u][i]].flow += f, ed[G[u][i] ^ 1].flow -= f; if (a == 0) break; } } } } return retflow; } int dinic() { int flow = 0; while (bfs()) { for (int i = 0 ; i &lt;= n * m; i++) cur[i] = 0; flow += dfs(s, INF); } return flow; } void clean() { //ed.reserve(MAXM); //vector申请空间太大，用这个调整就不会MLE en = 0; for (int i = 0; i &lt;= n * m; i++) G[i].clear(); } void solve() { clean(); for (int i = 1; i &lt;= n; i++) { for (int x, j = 1; j &lt;= m - 1; j++) { scanf(&quot;%d&quot;, &amp;x); ins(getIDbyPos(i, j), getIDbyPos(i, j + 1), x); } } for (int i = 1; i &lt;= n - 1; i++) { for (int x, j = 1; j &lt;= m; j++) { scanf(&quot;%d&quot;, &amp;x); ins(getIDbyPos(i, j), getIDbyPos(i + 1, j), x); } } for (int i = 1; i &lt;= n - 1; i++) { for (int x, j = 1; j &lt;= m - 1; j++) { scanf(&quot;%d&quot;, &amp;x); ins(getIDbyPos(i, j), getIDbyPos(i + 1, j + 1), x); } } s = 1, t = n * m; printf(&quot;%d\n&quot;, dinic()); } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>最小割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO 5.4.3(最小割+拆点)]]></title>
    <url>%2FUSACO-5.4.3%2F</url>
    <content type="text"><![CDATA[本题如果是删边就是裸最小割，但是是删点我们就要考虑拆点了。我们把一个点$i$拆成$i$(入点)，$i+n$(出点)。入点专门负责接受其他节点的入边，出点专门负责连出边。然后我们使$i-&gt;i+n$，容量为1，意义为删掉一个点的需要的价值，这样就可以删点了然后为了连通，如果原图$i-&gt;j$，那么就连$i+n-&gt;j, j+n-&gt;i$，容量为$INF$，因为这些边不能影响流量。然后从$s+n$到$t$做最大流即为答案。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 100 + 5, MAXM = 600 + 5, INF = 2147483647; struct data {int v, cap, flow;}; vector&lt;data&gt; ed; vector&lt;int&gt; G[MAXN * 2]; int n, m, s, t; int en, cur[MAXN * 2], vis[MAXN * 2], d[MAXN * 2]; void ins(int u, int v, int c) { ed.push_back((data){v, c, 0}), G[u].push_back(en++); ed.push_back((data){u, 0, 0}), G[v].push_back(en++); } bool bfs() { queue&lt;int&gt; q; for (int i = 1; i &lt;= n * 2; i++) vis[i] = false; vis[s] = true, d[s] = 0, q.push(s); while (!q.empty()) { int u = q.front(); q.pop(); for (int i = 0; i &lt; G[u].size(); i++) { int v = ed[G[u][i]].v, cap = ed[G[u][i]].cap, flow = ed[G[u][i]].flow; if (!vis[v] &amp;&amp; cap &gt; flow) { vis[v] = true, d[v] = d[u] + 1, q.push(v); } } } return vis[t]; } int dfs(int u, int a) { if (u == t) return a; if (a == 0) return 0; int retflow = 0; for (int &amp;i = cur[u]; i &lt; G[u].size(); i++) { int v = ed[G[u][i]].v, cap = ed[G[u][i]].cap, flow = ed[G[u][i]].flow; if (cap &gt; flow &amp;&amp; d[v] == d[u] + 1) { int f = dfs(v, min(a, cap - flow)); if (f &gt; 0) { retflow += f, a -= f, ed[G[u][i]].flow += f, ed[G[u][i] ^ 1].flow -= f; if (a == 0) break; } } } return retflow; } int dinic() { int flow = 0; while (bfs()) { for (int i = 0; i &lt;= n * 2; i++) cur[i] = 0; flow += dfs(s, INF); } return flow; } void clean() { en = 0; for (int i = 0; i &lt;= n * 2; i++) G[i].clear(); ed.clear(); } void solve() { clean(); for (int i = 1; i &lt;= n; i++) ins(i, i + n, 1); for (int u, v, i = 1; i &lt;= m; i++) { scanf(&quot;%d%d&quot;, &amp;u, &amp;v); ins(u + n, v, INF), ins(v + n, u, INF); } s += n; printf(&quot;%d\n&quot;, dinic()); } int main() { scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;s, &amp;t), solve(); return 0; }]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>USACO月赛</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络流 学习笔记]]></title>
    <url>%2Fsz%E7%BD%91%E7%BB%9C%E6%B5%81%2F</url>
    <content type="text"><![CDATA[模板及讲解最大流问题 容量：一条边$(u,v)$的上限记为$c(u,v)$.(如果边不存在，值为0) 流量：一条边$(u,v)$运送的物品记为$f(u,v)$, $f(u,v)=-f(v, u)$(斜对称性) 流量平衡：$\sum_{(u,v) \in E} f(u,v)=0$ (并且$f(u,v) \leq c(u,v))​$ 最大流$Dinic$算法$O(n^2m)$ 残量网络：图中每条边上容量和流量之差构成一张新图，称为残量网络(反向弧也要计算) 增广路：增广路是一条从源点到汇点路径上的剩余容量都大于$0$的简单路径 增广路定理(最大流定理)：如果残量网络不存在增广路，则当前流为最大流 分层图：以从原点到某点的最短距离分层的图，距离相等的为一层 多路增广：一次BFS进行多次增广。 最大可改进量：此次增广最大可以使得增广路的流量增加的量。 Dinic算法的大致思路：1 先BFS对残量网络进行分层(根据从$S$到点$i$的距离分层，这些和$S$距离相等的点$i$都是一层的)。(初始的图也算一个残量网络)2 然后再DFS进行多路增广(好处是如果两条不同增广路很长，但是重合了一大半，就不用两次BFS)，如果增广到了$T$或者当前最大可改进量(最小残量)等于0就要终止DFS，否则在残量网络上进行增广，必须按照层次来增广，如果路径可以增广，那么路径上的边流量加去最大可改进量(最小残量)，反向弧减去最大可改进量(最小残量)，因为流量平衡。 还可以进行优化，当前弧优化。如果一个点已经增广了一些边，那么这些边在下次DFS的时候不需要再被考虑。 Dinic模板代码见相关代码部分。loj #101相关学习文章 写时注意：1 边数组大小。(有一次ins就得乘一次2，最好用vector存)2 拆点后点数组大小。3 加边的时候如果无向，则反向弧容量为$c$，否则为$0$ 最小割最小割的流量$f(s,t)$=最大流 在找不到增广路之后，分层了的节点就是 $S$，没分层的点就是 $V-S=T$，即$s-t$割中的两个不相交集合${S, T}$ 最大流$flow$是$s-t$最大流，$(S, T)$是$s-t$最小割 最小割的题目：USACO 5.4.3 Dinic求最大流，loj #101 //2019.1.11 upd: 使 cap 只表示残量 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;bits/stdc++.h&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 1000000 + 5, MAXM = 4000000 + 5, INF = 2147483647; struct data { int v, cap;//终点，残量 }ed[MAXM * 2]; int n, m, s, t, maxd; vector&lt;int&gt; G[MAXN]; int en, cur[MAXN], d[MAXN];//边数，当前弧(用于优化)，距离S的距离，访问标记 void ins(int u, int v, int c) {//加双向边 ed[en] = (data){v, c}, G[u].push_back(en++); ed[en] = (data){u, 0}, G[v].push_back(en++);//反向弧容量为0！不是-c，流量才是守恒的 } bool bfs() {//求分层图 queue&lt;int&gt; q; for (int i = 0; i &lt;= maxd; i++) d[i] = INF; d[s] = 0, q.push(s); while (!q.empty()) { int u = q.front(); q.pop(); for (int i = 0; i &lt; G[u].size(); i++) { int v = ed[G[u][i]].v, cap = ed[G[u][i]].cap; if (d[v] == INF &amp;&amp; cap) {//没被分层并且可以改进 d[v] = d[u] + 1;//分层 q.push(v); } } } return d[t] != INF;//如果存在增广路则t会被访问 } LL dfs(int u, int a) {//多路增广 if (u == t) return a;//增广到终点 if (a == 0) return 0;//没有可改进量 LL retflow = 0; for (int &amp;i = cur[u]; i &lt; G[u].size(); i++) { int v = ed[G[u][i]].v, cap = ed[G[u][i]].cap; if (d[u] + 1 == d[v]) {//按层次增广 int f = dfs(v, min(a, cap)); //继续增广 if (f &gt; 0) {//能够改进 retflow += f, a -= f, ed[G[u][i]].cap -= f, ed[G[u][i] ^ 1].cap += f;//改进 if (a == 0) break;//优化：没有可改进量时此点应该不再访问 } } } return retflow; } LL dinic() {//求最大流 LL flow = 0; while (bfs()) { for (int i = 0; i &lt;= maxd; i++) cur[i] = 0; //DFS完以后要清空当前弧 flow += dfs(s, INF); } return flow; } void clean() { en = 0; for (int i = 0; i &lt;= n; i++) G[i].clear(); } void solve() { clean(); maxd = n; for (int u, v, c, i = 1; i &lt;= m; i++) { scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;c); ins(u, v, c); } printf(&quot;%lld\n&quot;, dinic()); } int main() { scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;s, &amp;t), solve(); return 0; } 费用流现在给出的网络每天边有单位流量的代价，那么有以下问题： 最小费用最大流：就是在最大流的前提下的最小费用的流 最大费用最大流：就是在最大流的前提下的最大费用的流 可以使用 EK+Spfa 求费用流。即用 Spfa 找到一条代价最小的增广路不断增广。代码：loj #102 写时注意： 1、Spfa 记得取消 vis的标记2、反向弧的价值相反，否则死循环 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;stack&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 400 + 5; const int INF = 2147483647; struct edge { int u, v, cap, w, nxt; } ed[30000 + 5]; int n, m, hd[MAXN], en, s, t; int dis[MAXN], incf[MAXN], pre[MAXN], vis[MAXN], flow, cost; // dis[i]: s 到 i 最短路。incf[i]：s 到 i 可改进量。pre[i]：i 的前驱边。 void ins_c(int u, int v, int cap, int w) { // 加一条边 ed[++en] = (edge){u, v, cap, w, hd[u]}, hd[u] = en; ed[++en] = (edge){v, u, 0, -w, hd[v]}, hd[v] = en; // 对称费用 } queue&lt;int &gt; q; bool spfa() { // Spfa 找到一条增广路 for (int i = 0; i &lt;= n; ++i) dis[i] = INF, incf[i] = INF, vis[i] = 0, pre[i] = -1; vis[s] = 1, dis[s] = 0, q.push(s); while (!q.empty()) { int u = q.front(); q.pop(); vis[u] = 0; // 不要忘记 for (int i = hd[u]; i &gt;= 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (dis[u] != INF &amp;&amp; dis[e.v] &gt; dis[u] + e.w &amp;&amp; e.cap) { dis[e.v] = dis[u] + e.w; pre[e.v] = i; incf[e.v] = min(incf[u], e.cap); if (!vis[e.v]) vis[e.v] = 1, q.push(e.v); } } } return dis[t] != INF; } void update() { // 有增广路则更新流量并且统计流量和费用 int now = pre[t]; while (now != -1) { ed[now].cap -= incf[t]; ed[now ^ 1].cap += incf[t]; // 注意对称 now = pre[ed[now].u]; } flow += incf[t]; cost += dis[t] * incf[t]; } void clean() { en = -1, ms(hd, -1), cost = flow = 0; } int solve() { clean(); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); s = 1, t = n; for (int u, v, cap, w, i = 1; i &lt;= m; ++i) { scanf(&quot;%d%d%d%d&quot;, &amp;u, &amp;v, &amp;cap, &amp;w); ins_c(u, v, cap, w); } while (spfa()) update(); printf(&quot;%d %d\n&quot;, flow, cost); return 0; } } int main() { flyinthesky::solve(); return 0; } 网络流相关模型点拆成边点权转边权1、poj 3422 K-方格取数 拆边边权只有一次流量有效1、Loj 6224「网络流 24 题」深海机器人问题2、poj 3422 K-方格取数 网格图网格图问题1、Loj 6224「网络流 24 题」深海机器人问题2、poj 3422 K-方格取数 最短路利用容量限制1、poj 3422 来回最短路问题 资源资源调配1、Loj 6008 「网络流 24 题」餐巾计划 二分图所有二分图最大匹配，完美匹配问题类二分图1、带匹配限制的二分图：Poj 3189 最小割相关最大权闭合子图有一个有向图，每一个点都有一个权值$w_i$（可以为正或负或$0$），选择一个权值和最大的子图，使得每个点的后继都在子图里面，这个子图就叫最大权闭合子图。 这些点可以抽象为一个个事件互相依赖的关系。 求法：正权点连边$(S, i)$容量为$w_i$，负权点连边$(i, T)$容量为$|w_i|$，将原图边保留，容量为$INF$。然后对图最小割$c[S, T]$，最后答案即为$\sum\limits_{1 \leq i \leq n, w_i \leq 0} w_i - c[S, T]$ 对图最小割本质上就是如果切断$S​$与点的边，即为不要这个点，减去这个点的收益如果切断$T$与点的边，即为要这个点，加上不必要的成本 1、Bzoj 1497 「NOI2006」最大获利=CF 1082G]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>最大流</tag>
        <tag>费用流</tag>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1717」「Usaco2006 Dec」Milk Patterns 产奶的模式 (Hash/后缀数组)]]></title>
    <url>%2Fbzoj1717%2F</url>
    <content type="text"><![CDATA[BZOJ 1717字符串Hash做法：每次二分一个答案，然后Hash每一个答案长度的子串，比较看有没有$k$个相同的Hash值即可.Hash做法TLE了两个点. 后缀数组做法：每次二分一个答案，然后在$height$数组里分组，看有没有连续$k$个相同长度的$height$即可. 字符串Hash： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define ull unsigned long long using namespace std; const int MAXN = 1000000 + 5; const ull MO1 = 19260817, MO2 = 19660813, bs = 10007; struct data { ull a, b; bool operator &lt; (const data &amp;y) const { if (a == y.a) return b &lt; y.b; return a &lt; y.a; } }h[MAXN]; int n, k, a[MAXN]; ull hash1(int st, int len) { ull ret = 0; for (int i = st; i &lt; st + len; i++) { ret = (ret * bs + a[i]) % MO1; } return ret; } ull hash2(int st, int len) { ull ret = 0; for (int i = st; i &lt; st + len; i++) { ret = (ret * bs + a[i]) % MO2; } return ret; } bool check(int x) { for (int i = 1; i &lt;= n - x + 1; i++) h[i].a = hash1(i, x), h[i].b = hash2(i, x); sort(h + 1, h + 1 + n - x + 1); int tot = 0; for (int i = 2; i &lt;= n - x + 1; i++) { if (h[i].a == h[i - 1].a &amp;&amp; h[i].b == h[i - 1].b) tot++; else { tot++; if (tot &gt;= k) return true; tot = 0; } } tot++; if (tot &gt;= k) return true; return false; } void clean() { } void solve() { clean(); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]); int l = 0, r = n + 1, ans = 0; while (l &lt; r) { int mid = (l + r) / 2; if (check(mid)) ans = mid, l = mid + 1; else r = mid; } printf(&quot;%d\n&quot;, ans); } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;k), solve(); return 0; } 后缀数组(很久没打。。已经不太会了)： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define ull unsigned long long using namespace std; const int MAXN = 1000000 + 5; int n, m, k, a[MAXN]; int rk[MAXN], tp[MAXN], tax[MAXN], SA[MAXN], height[MAXN]; bool cmp(int *f, int i, int k) {return f[SA[i - 1]] == f[SA[i]] &amp;&amp; f[SA[i - 1] + k] == f[SA[i] + k];} void getSA() { for (int i = 0; i &lt; m; i++) tax[i] = 0; for (int i = 0; i &lt; n; i++) tax[rk[i] = a[i]]++; for (int i = 1; i &lt; m; i++) tax[i] += tax[i - 1]; for (int i = n - 1; i &gt;= 0; i--) SA[--tax[rk[i]]] = i; int p; for (int k = 1; k &lt;= n; k *= 2) { p = 0; for (int i = n - k; i &lt; n; i++) tp[p++] = i; for (int i = 0; i &lt; n; i++) if (SA[i] &gt;= k) tp[p++] = SA[i] - k; for (int i = 0; i &lt; m; i++) tax[i] = 0; for (int i = 0; i &lt; n; i++) tax[rk[tp[i]]]++; for (int i = 1; i &lt; m; i++) tax[i] += tax[i - 1]; for (int i = n - 1; i &gt;= 0; i--) SA[--tax[rk[tp[i]]]] = tp[i]; swap(rk, tp), rk[SA[0]] = 0, p = 0; for (int i = 1; i &lt; n; i++) { rk[SA[i]] = cmp(tp, i, k) ? p : ++p; } if (++p &gt;= n) break; m = p; } } void getHeight() { int j, k = 0; for (int i = 0; i &lt; n; i++) { if (k) k--; j = SA[rk[i] - 1]; while (a[i + k] == a[j + k]) k++; height[rk[i]] = k; } } bool check(int x) { int tot = 0; for (int i = 1; i &lt; n; i++) { if (height[i] &gt;= x) { tot++; if (tot + 1 &gt;= k) return true; } else tot = 0; } return false; } void clean() {} void solve() { clean(); for (int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;a[i]); m = 1000010, a[n] = 0, n++; getSA(), getHeight(); int ans = 0, l = 0, r = n + 1; while (l &lt; r) { int mid = (l + r) / 2; if (check(mid)) ans = mid, l = mid + 1; else r = mid; } printf(&quot;%d\n&quot;, ans); } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;k), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>字符串Hash</tag>
        <tag>USACO月赛</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj 1947(树形DP)]]></title>
    <url>%2Fpoj1947%2F</url>
    <content type="text"><![CDATA[poj 1947之前不知道怎么规划状态……看了题解才知道……定义状态定义需要的就行了设$dp(u, j)$为以$u$点为根的子树剩$j$个点的最小操作数则初始化$dp(u, 1)=|son \in u|(u$不是叶子)$dp(u, 1)=0(u$是叶子)转移简单了，$dp(u, j)=min(dp(u, j -k) + dp(v, k)-1)$减一是因为之前$(u,v)$是断开的，把$(u,v)$连上就少一次操作 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 150 + 5; int n, p, f[MAXN][MAXN], fa[MAXN]; vector&lt;int&gt; G[MAXN]; void dp(int u, int pa) { int flag = true; fa[u] = pa; f[u][1] = G[u].size() - (bool)(pa); for (int i = 0; i &lt; G[u].size(); i++) { int v = G[u][i]; if (v != pa) { flag = false; dp(v, u); for (int j = p; j &gt; 1; j--) { for (int k = 1; k &lt; j; k++) { f[u][j] = min(f[u][j], f[u][j - k] + f[v][k] - 1); } } } } if (flag) { f[u][1] = 0; } } void clean() { ms(f, 24); for (int i = 0; i &lt;= n; i++) fa[i] = 0, G[i].clear(); } void solve() { clean(); for (int u, v, i = 1; i &lt; n; i++) { scanf(&quot;%d%d&quot;, &amp;u, &amp;v); G[u].push_back(v), G[v].push_back(u); } dp(1, 0); int ans = 1000000000; for (int i = 1; i &lt;= n; i++) { ans = min(ans, f[i][p] + (bool)(fa[i])); } printf(&quot;%d\n&quot;, ans); } int main() { while (scanf(&quot;%d%d&quot;, &amp;n, &amp;p) == 2) solve(); return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>树形DP</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1690」「Usaco2007 Dec」奶牛的旅行 (最优比率环)]]></title>
    <url>%2Fbzoj1690%2F</url>
    <content type="text"><![CDATA[BZOJ 1690最优比率环模板，一条边的花费定为$f_{v}-x \times E_w$，其中$E=(u,v)，E_w$为边权具体看这里 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 1000 + 5, MAXM = 5000 + 5; struct data { int v, wi; db p; }ed[MAXM]; int n, m, en, fi[MAXN]; vector&lt;int&gt; G[MAXN]; int flag, vis[MAXN]; db dis[MAXN]; void spfa(int u) { if (flag) return ; vis[u] = true; for (int i = 0; i &lt; G[u].size(); i++) { int v = ed[G[u][i]].v; db p = ed[G[u][i]].p; if (dis[u] + p &gt; dis[v]) { dis[v] = dis[u] + p; if (vis[v]) {flag = true; return ;} spfa(v); } } vis[u] = false; } bool check() { flag = false; for (int i = 1; i &lt;= n; i++) dis[i] = vis[i] = 0; for (int i = 1; i &lt;= n; i++) { spfa(i); if (flag) return true; } return false; } void rebuild(double x) { for (int i = 1; i &lt;= m; i++) ed[i].p = (db)fi[ed[i].v] - (db)ed[i].wi * x; } void ins(int u, int v, int c) { en++, ed[en] = (data){v, c, 0}, G[u].push_back(en); } void clean() { en = 0; for (int i = 0; i &lt;= n; i++) G[i].clear(); } void solve() { clean(); int totc = 0; for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;fi[i]); for (int i = 1; i &lt;= m; i++) { int u, v, c; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;c); ins(u, v, c), totc += c; } double l = 0.0, r = (db)totc + 1.0; for (int i = 1; i &lt;= 100; i++) { double mid = (l + r) / 2.0; rebuild(mid); if (check()) l = mid; else r = mid; } printf(&quot;%.2f\n&quot;, l); } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>USACO月赛</tag>
        <tag>分数规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分数规划 学习笔记]]></title>
    <url>%2Fsz%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[模板及讲解推荐入门文章分数规划就是求$\sum A_i / \sum B_i$最大/最小。$\sum A_i / \sum B_i$最大/最小问题我们设$C(x)$为$\sum A_i / \sum B_i \geq x$是否成立(或者是$\sum A_i / \sum B_i \leq x$)$\sum A_i / \sum B_i \geq x$去分母$ \sum A_i \geq \sum B_i \times x$移项$\sum A_i - \sum B_i \times x \geq 0$合并同类项$\sum (A_i - B_i \times x) \geq 0$那么我们进行二分，每次二分一个$x$，如果$C(x)=true$，那么$l=mid$，否则$r=mid$$C(x)$的计算就是把$(A_i - B_i \times x)$排序，取最大的那几个 最优比率生成树进行二分，每次二分一个$x$，每条边的边权设为$A_i - B_i \times x$，然后跑MST检验答案即可(根据$\sum (A_i - B_i \times x) \geq 0$)。 最优比率环进行二分，每次二分一个$x$，每条边的边权设为$A_i - B_i \times x$，然后DFS版的SPFA检测是否存在正/负环(根据$\sum (A_i - B_i \times x) \geq 0$) 常见题型：1、$\sum A_i / \sum B_i$最大/最小问题Q：见解析解：见解析例题：poj 29762、最优比率生成树Q：见解析解：见解析例题：poj 2728//强行Prim不想写……明年再说吧qaq3、最优比率环Q：见解析解：见解析例题：Bzoj 1960]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>分数规划</tag>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj 2976(分数规划)]]></title>
    <url>%2Fpoj2976%2F</url>
    <content type="text"><![CDATA[poj 2976分数规划简单题，具体看这里 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 1000 + 5; int n, k, ai[MAXN], bi[MAXN]; double p[MAXN]; bool check(double x) { for (int i = 1; i &lt;= n; i++) p[i] = (db)ai[i] - (db)bi[i] * x; sort(p + 1, p + 1 + n); double tot = 0; for (int i = k + 1; i &lt;= n; i++) tot += p[i]; return tot &gt;= 0; } void clean() {} void solve() { clean(); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;ai[i]); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;bi[i]); double l = 0, r = 1; for (int i = 1; i &lt;= 100; i++) { double mid = (l + r) / 2.0; if (check(mid)) l = mid; else r = mid; } printf(&quot;%.0f\n&quot;, l * 100); } int main() { while (scanf(&quot;%d%d&quot;, &amp;n, &amp;k) == 2 &amp;&amp; (n || k)) solve(); return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>分数规划</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1559」「JSOI2009」密码 (AC自动机+状压DP+爆搜结论)]]></title>
    <url>%2Fbzoj1559%2F</url>
    <content type="text"><![CDATA[BZOJ 1559题意：见上。 很容易想到这是一个AC自动机(经典题，多模式串)上的状压DP(数据范围)，那么列出方程即为$dp(i,st,u)$为密码前$i$位包含模式串状态$st$，在AC自动机上$u$点的方案。 那么转移很显然，即刷表$$dp(i+1,st|zt[v], v)= \sum dp(i,st,u)$$ 然后考虑如何输出方案。因为这个数字小于等于$42$才输出方案，可以考虑爆搜(方案DP不好记录前驱) 重要结论 字符串都是紧密结合的，不存在自由的可以填$26$种字母的位置 证明很显然，因为如果存在这个，那么会对答案产生$26$的贡献，而字符串可以交换位置，那么一定方案数大于$42$，那么我们只需要预处理两个模式串组合最少的字符长度，$O(n!)$枚举模式串排列即可，注意要舍掉不合法的，即长度大于$L$的。 知识点：1、发现有阻碍的地方，要从这里下手，在纸上应该多写写 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 102; int n, m, ch[MAXN][26], f[MAXN], zt[MAXN], sz; char s[11][11]; LL dp[30][1025][MAXN]; void insert(char *s, int ith) { int now = 0, len = strlen(s); for (int i = 0; i &lt; len; ++i) { int c = s[i] - &#39;a&#39;; if (!ch[now][c]) ch[now][c] = ++sz; now = ch[now][c]; if (i == len - 1) zt[now] = (1 &lt;&lt; (ith - 1)); } } void getFail() { queue&lt;int &gt; q; f[0] = 0; for (int c = 0; c &lt; 26; ++c) { int v = ch[0][c]; if (v) q.push(v), f[v] = 0; } while (!q.empty()) { int u = q.front(); q.pop(); for (int c = 0; c &lt; 26; ++c) { int v = ch[u][c]; if (!v) {ch[u][c] = ch[f[u]][c]; continue ;} q.push(v); int j = f[u]; while (j &amp;&amp; !ch[j][c]) j = f[j]; f[v] = ch[j][c], zt[v] |= zt[f[v]]; } } } int gg[20], vis[20], orz[20][20], tot = 0; string pt[50], tmp; void dfs(int a) { if (a == m + 1) { tmp.clear(); for (int i = 1; i &lt;= m; ++i) { int st = 0, whw = strlen(s[gg[i]]); if (i != 1) st = orz[gg[i - 1]][gg[i]]; for (int j = st; j &lt; whw; ++j) { tmp += s[gg[i]][j]; } } if ((LL)tmp.size() == n) pt[++tot] = tmp; return ; } for (int i = 1; i &lt;= m; ++i) { if (!vis[i]) gg[a] = i, vis[i] = 1, dfs(a + 1), vis[i] = 0, gg[a] = 0; } } void clean() { ms(ch, 0), ms(f, 0), ms(zt, 0), sz = 0, ms(dp, 0), ms(vis, 0), ms(gg, 0), ms(orz, 0); } int solve() { clean(); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; ++i) { scanf(&quot;%s&quot;, s[i]); insert(s[i], i); } getFail(); dp[0][0][0] = 1; for (int i = 0; i &lt;= n; ++i) { for (int st = 0; st &lt; (1 &lt;&lt; m); ++st) { for (int u = 0; u &lt;= sz; ++u) if (dp[i][st][u]) { for (int c = 0; c &lt; 26; ++c) { int v = ch[u][c]; dp[i + 1][st | zt[v]][v] += dp[i][st][u]; } } } } LL ans = 0; for (int u = 0; u &lt;= sz; ++u) ans += dp[n][(1 &lt;&lt; m) - 1][u]; printf(&quot;%lld\n&quot;, ans); if (ans &lt;= 42) { for (int x = 1; x &lt;= m; ++x) { for (int y = 1; y &lt;= m; ++y) if (x != y) { int lx = strlen(s[x]), ly = strlen(s[y]); for (int len = min(lx, ly); len &gt;= 0; --len) { int fl = 0; for (int i = 0; i &lt; len; ++i) { int j = lx - len + i; if (s[x][j] != s[y][i]) {fl = 1; break;} } if (!fl) { orz[x][y] = len; break; } } } } dfs(1); sort(pt + 1, pt + 1 + ans); for (int i = 1; i &lt;= ans; ++i) cout &lt;&lt; pt[i] &lt;&lt; endl; } return 0; } } int main() { flyinthesky::solve(); return 0; } /* 10 2 abcd bc 2 2 a b 1 1 a 6 2 good day 3 2 go oe */]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>状压DP</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1596」「Usaco2008 Jan」电话网络 (树形DP/贪心)]]></title>
    <url>%2Fbzoj1596%2F</url>
    <content type="text"><![CDATA[BZOJ 1596本题可以贪心做，如果一个节点他的孩子没被覆盖，并且这个点和他的父亲没覆盖，就覆盖这个点的父亲，这里主要用树形DP来做。设$f(u, 0)$为不在$u$建基站，$u$与$u$的子树都有信号$f(u, 1)$为在$u$建基站，$u$与$u$的子树都有信号$f(u, 2)$为不在$u$建基站，$u$没有信号，$u$的子树都有信号 以上这种状态是非常常用的 我们看转移(很容易推出来):$f(u,0)=min(f(j,1)+\sum min(f(son, 0/1)))$$f(u,1)=\sum min(f(son, 0/1/2))$$f(u,2)=\sum f(son, 0)$ #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 10000 + 5, INF = 100000000; vector&lt;int&gt; G[MAXN]; int n, f[MAXN][3]; void dp(int u, int p) { int sum = 0; f[u][1] = 1, f[u][0] = INF, f[u][2] = 0; for (int i = 0; i &lt; G[u].size(); i++) { int v = G[u][i]; if (v != p) { dp(v, u); f[u][1] += min(min(f[v][0], f[v][1]), f[v][2]); f[u][2] += f[v][0]; sum += min(f[v][0], f[v][1]); } } for (int i = 0; i &lt; G[u].size(); i++) { int v = G[u][i]; if (v != p) { f[u][0] = min(f[u][0], f[v][1] + sum - min(f[v][0], f[v][1])); } } } void clean() { for (int i = 0; i &lt;= n; i++) G[i].clear(); } void solve() { clean(); for (int i = 1; i &lt; n; i++) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); G[x].push_back(y), G[y].push_back(x); } dp(1, 0); printf(&quot;%d\n&quot;, min(min(f[1][0], f[1][1]), f[1][2] + 1)); } int main() { scanf(&quot;%d&quot;, &amp;n), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>Bzoj</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bzoj 2442(区间DP+单调队列)]]></title>
    <url>%2Fbzoj2442%2F</url>
    <content type="text"><![CDATA[BZOJ 2442设$dp(i)$为$i$不选，之前的选择合法时损失的最小效率则$dp(i)=min(dp(j))+e_i$而这是$O(n^2)$的，我们发现$min(dp(j))$满足单调性，且是一段区间的最小值，所以可以用单调队列来优化 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 100000 + 5; int n, k; LL tot, ei[MAXN], dp[MAXN], que[MAXN * 2]; void clean() { tot = 0; ms(dp, 0), ms(que, 0); } void solve() { clean(); for (int i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;ei[i]), tot += ei[i]; int l = 1, r = 1; dp[0] = 0; for (int i = 1; i &lt;= n; i++) { while (l &lt;= r &amp;&amp; que[l] &lt; i - k - 1) l++;//单调队列左边是之前的 dp[i] = dp[que[l]] + ei[i]; while (l &lt;= r &amp;&amp; dp[que[r]] &gt;= dp[i]) r--;//单调队列右边是之后的 que[++r] = i; } LL mn = 1000000000000000000; for (int i = n - k; i &lt;= n; i++) mn = min(mn, dp[i]); printf(&quot;%lld\n&quot;, tot - mn); } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;k), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>Bzoj</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bzoj 3378(树状数组)]]></title>
    <url>%2Fbzoj3378%2F</url>
    <content type="text"><![CDATA[BZOJ 3378$O(n^2)$算法肯定不行，我们尝试拆公式对于$max(V_i, V_j)$，我们把牛按$V$排序，然后就可以消除$V$的影响，不再考虑这部分对于$|X_i-X_j|$,我们不妨把他分成两部分，$(X_i-X_j) +(X_j-X_i)$然后$\sum((X_i-X_j) +(X_j-X_i))=NUM_l \times X_i - SUM_l +SUM_r - NUM_r \times X_i$其中$SUM_l$是在$X_i$左边的牛到起点的距离和，$SUM_r$同理$NUM_l$是在$X_i$左边的牛的头数，$NUM_r$同理 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 20000 + 5; struct data { LL x, v; bool operator &lt; (const data &amp;b) const { return v &lt; b.v; } }cow[MAXN]; LL sum[MAXN], num[MAXN], MaxX; int n; int lowbit(int x) {return x &amp; (-x);} void update(LL *a, int x, LL v) { for (int i = x; i &lt;= MaxX; i += lowbit(i)) { a[i] += v; } } LL query(LL *a, int x) { LL ret = 0; for (int i = x; i &gt; 0; i -= lowbit(i)) { ret += a[i]; } return ret; } void clean() { ms(sum, 0), ms(num, 0); } void solve() { clean(); for (int i = 1; i &lt;= n; i++) scanf(&quot;%lld%lld&quot;, &amp;cow[i].v, &amp;cow[i].x), MaxX = max(MaxX, cow[i].x); sort(cow + 1, cow + 1 + n); LL ans = 0; for (int i = 1; i &lt;= n; i++) { LL x = cow[i].x, v = cow[i].v; LL SUMl = query(sum, x - 1), SUMr = query(sum, MaxX) - query(sum, x); LL NUMl = query(num, x - 1), NUMr = query(num, MaxX) - query(num, x); ans += v * (NUMl * x - SUMl + SUMr - NUMr * x); update(sum, x, x); update(num, x, 1); } printf(&quot;%lld\n&quot;, ans); } int main() { scanf(&quot;%d&quot;, &amp;n), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>树状数组</tag>
        <tag>USACO月赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hash 学习笔记]]></title>
    <url>%2FszHash%2F</url>
    <content type="text"><![CDATA[模板及讲解字符串Hash的核心就是把原本$O(n)$比较两个字符串变成$O(1)$比较两个Hash值(整数)。 Hash的方法取决于是否会冲突，这里运用不同模数巧妙解决冲突因为字符串相等、字符串ASCII码前缀和具有单调性，所以经常用固定左端点二分右端点来解决问题(有时用二分查找、map、桶、排序等解决问题) BASE 选取：1、不要将任何数对应到 0 ，例如将 A对应到0 则无法区分AB、B2、大于$max($对应数$)$ 双Hash两个模数$MO1,MO2$(最好为质数，$19260817, 19660813$)，只有两个模数的值都相同才判定Hash值相同BASE：大于所有字符串取值的一个数，不能包含模数的质因子求Hash值：$$Hash=(s_1 \times BASE^{n-1}+ s_2 \times BASE^{n-2} + … + s_n) \mod MO$$ 快速hash一个字符串的所有子串：先对串的所有前缀Hash，记为$Hash_i$，设$p_i=BASE^i$，则$$Hash_i=(Hash_{i-1} \times s_i) \mod MO$$$$Hash_{i, j}=(Hash_{r} - Hash_{l-1} \times p_{r-l+1}) \mod MO$$$Hash_{i, j}$即为答案。 const ULL BS = 300; ULL hsh[MAXN], p[MAXN]; p[0] = 1; for (int i = 1; i &lt;= n; i++) p[i] = p[i - 1] * BS, hsh[i] = hsh[i - 1] * BS + (s[i] - &#39;a&#39;); inline ULL getH(int x, int y) {return hsh[y] - hsh[x - 1] * p[y - x + 1];} 运用 unsigned long long 的自然溢出完成取模(能双Hash就双Hash，自然溢出很容易被卡)。 二维 Hash例题：Bzoj 2351 给行列分别hash一次，行先hash，然后将hash值再hash一次，即hash列 然后查询子矩阵Hash值直接像二维前缀和一样做即可，类比于一维的 Hash 方法 树 Hash对于有根树的 Hash。无根树找重心当根。 $h[x]$表示$x$为根的子树的hash​，$g[x]$表示$x$为根时全树的​hash​。$$h[x] = 1 + \sum_{y \in \text{son}(x)} h[y] \times p[\text{siz}[y]] \\g[x] = (g[fa] - h[x] \times p[\text{siz}[x]]) \times p[n-\text{siz}[x]] + h[x]$$ 例题1: BJOI2015 树的同构例题2: JSOI2016 独特的树叶 相关代码Luogu 3370，双Hash模板 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define ull unsigned long long using namespace std; const int MAXN = 10000 + 5; ull BASE = 300, MO1 = 19260817, MO2 = 19660813; struct data { ull a, b; bool operator &lt; (const data &amp;y) const { return a &lt; y.a; } }a[MAXN]; int n; char ch[1500 + 5]; int hash1(char *s) { int len = strlen(s); ull ret = 0; for (int i = 0; i &lt; len; i++) ret = (ret * BASE + (ull)s[i]) % MO1; return ret; } int hash2(char *s) { int len = strlen(s); ull ret = 0; for (int i = 0; i &lt; len; i++) ret = (ret * BASE + (ull)s[i]) % MO2; return ret; } void clean() { } void solve() { clean(); for (int i = 1; i &lt;= n; i++) { scanf(&quot;%s&quot;, ch); a[i].a = hash1(ch), a[i].b = hash2(ch); } sort(a + 1, a + 1 + n); int ans = 1; for (int i = 2; i &lt;= n; i++) { if (a[i].a != a[i - 1].a || a[i].b != a[i - 1].b) ans++; } printf(&quot;%d\n&quot;, ans); } int main() { scanf(&quot;%d&quot;, &amp;n), solve(); return 0; }]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>字符串Hash</tag>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 3223」文艺平衡树 (非旋Treap / Splay)]]></title>
    <url>%2Fbzoj3223%2F</url>
    <content type="text"><![CDATA[BZOJ 3223平衡树模板题，处理区间问题，本题用下标来做$key$，区间翻转直接交换两棵子树，因为$key$按中序遍历有序。而交换两棵子树虽然破坏了排序二叉树的性质，但是并不影响解题，只需要知道当前节点在区间的某个位置就行了 Splay做法： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;vector&gt; #include&lt;utility&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 100000 + 5; int n, m; int ch[MAXN][2], val[MAXN], siz[MAXN], fa[MAXN], lazy[MAXN], ncnt, rt; bool rel(int x) {return ch[fa[x]][1] == x;} void pushup(int x) {siz[x] = siz[ch[x][0]] + siz[ch[x][1]] + 1;} void pushdown(int x) {if (lazy[x]) swap(ch[x][0], ch[x][1]), lazy[ch[x][0]] ^= 1, lazy[ch[x][1]] ^= 1, lazy[x] = 0;} void rotate(int x) { pushdown(fa[x]), pushdown(x); int y = fa[x], z = fa[y], k = rel(x), w = ch[x][k ^ 1]; ch[z][rel(y)] = x, fa[x] = z; ch[y][k] = w, fa[w] = y; ch[x][k ^ 1] = y, fa[y] = x; pushup(y), pushup(x); } void splay(int x, int gl = 0) { while (fa[x] != gl) { pushdown(fa[x]); pushdown(x); int y = fa[x], z = fa[y]; if (z != gl) { if (rel(x) == rel(y)) rotate(y); else rotate(x); } rotate(x); } if (gl == 0) rt = x; } void insert(int x) { int cur = rt, p = 0; while (cur &amp;&amp; val[cur] != x) p = cur, cur = (pushdown(cur), ch[cur][x &gt; val[cur]]); cur = ++ncnt; ch[cur][0] = ch[cur][1] = 0, val[cur] = x, siz[cur] = 1, fa[cur] = p; ch[p][x &gt; val[p]] = cur; splay(cur); } int kth(int k) { int cur = rt; while (1) { pushdown(cur); if (k &lt;= siz[ch[cur][0]]) cur = ch[cur][0]; else if (k &gt; siz[ch[cur][0]] + 1) k -= siz[ch[cur][0]] + 1, cur = ch[cur][1]; else return cur; } } void rev(int l, int r) { int lb = kth(l), rb = kth(r + 2); splay(lb), splay(rb, lb); lazy[ch[rb][0]] ^= 1; } void print(int x) { pushdown(x); if (ch[x][0]) print(ch[x][0]); if (1 &lt;= val[x] &amp;&amp; val[x] &lt;= n) printf(&quot;%d &quot;, val[x]); if (ch[x][1]) print(ch[x][1]); } void clean() { ms(ch, 0), ms(val, 0), ms(siz, 0), ms(fa, 0), ms(lazy, 0), ncnt = rt = 0; } int solve() { clean(); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 0; i &lt;= n + 1; ++i) insert(i); //0, n+1 相当于最大最小值 while (m--) { int l, r; scanf(&quot;%d%d&quot;, &amp;l, &amp;r); rev(l, r); } print(rt); return 0; } } int main() { flyinthesky::solve(); return 0; } 非旋转Treap： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 100000 + 5; int n; struct Treap *null, *root, *pit; struct Treap { int val, key, s, rev; Treap *lc, *rc; void init(int key) {rev = 0, this-&gt;key = key, val = rand(), s = 1, lc = rc= null;} void maintain() {s = lc-&gt;s + rc-&gt;s + 1;} }pool[MAXN]; Treap* newNode(int key) { pit-&gt;init(key); return pit++; } void pushdown(Treap *&amp;o) { if (o-&gt;rev) { o-&gt;lc-&gt;rev ^= 1, o-&gt;rc-&gt;rev ^= 1; swap(o-&gt;lc, o-&gt;rc); o-&gt;rev = 0; } } Treap* merge(Treap *a, Treap *b) { if (a == null) return b; if (b == null) return a; pushdown(a), pushdown(b); if (a-&gt;val &lt; b-&gt;val) { a-&gt;rc = merge(a-&gt;rc, b), a-&gt;maintain(); return a; } else { b-&gt;lc = merge(a, b-&gt;lc), b-&gt;maintain(); return b; } } void split(Treap *o, int k, Treap *&amp;x, Treap *&amp;y) { if (o == null) x = y = null; else { pushdown(o); if (k &lt;= o-&gt;lc-&gt;s) { y = o, split(o-&gt;lc, k, x, o-&gt;lc); } else x = o, split(o-&gt;rc, k - o-&gt;lc-&gt;s - 1, o-&gt;rc, y); o-&gt;maintain(); } } void insert(int x) { root = merge(root, newNode(x));//由于插入是从小到大的，所以直接合并 } void reverse(int l, int r) { Treap *a, *b; split(root, r, a, b); Treap *c, *d; split(a, l - 1, c, d); d-&gt;rev = 1; a = merge(c, d), root = merge(a, b); } void print(Treap *o) { if (o == null) return ; pushdown(o); print(o-&gt;lc); printf(&quot;%d &quot;, o-&gt;key); print(o-&gt;rc); } void initTreap() { srand(19260817); pit = pool; null = newNode(0), null-&gt;s = 0; root = null; } void clean() { } void solve() { clean(); int Q; scanf(&quot;%d%d&quot;, &amp;n, &amp;Q); initTreap(); for (int i = 1; i &lt;= n; i++) insert(i); while (Q--) { int l, r; scanf(&quot;%d%d&quot;, &amp;l, &amp;r); reverse(l, r); } print(root); } int main() { solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>Treap</tag>
        <tag>Splay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO 精选试题 水题大杂烩]]></title>
    <url>%2FUSACO-Water-Plus%2F</url>
    <content type="text"><![CDATA[USACO 精选试题解题报告……水题不再另开文章，有意义的题目还是要另开的第1题 利润 (Profits, USACO 2011 Jan)(没在Bzoj上找到这题)解法：DP最大子段和复杂度：$O(n)$代码：略 第2题 购买饲料二 (Buying Feed II, USACO 2010 Jan)解法：DP(还有时间复杂度更优秀的贪心，但是DP也能过，贪心是把每个店的单价都硬求)设$dp(i,j)$为走了$i$公里，买了$j$吨饲料的最小费用，转移分该坐标有没有商店来做，注意这样做有一个坑一个点上有很多商店，所以复杂度多加一个$n$复杂度：$O(EK^2N)$代码： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; int k, e, n; struct data { int x, c, f; }d[105]; LL dp[355][105]; void clean() { ms(dp, 127); } void solve() { clean(); for (int i = 1; i &lt;= n; i++) { scanf(&quot;%d%d%d&quot;, &amp;d[i].x, &amp;d[i].f, &amp;d[i].c); } dp[0][0] = 0; for (int i = 1; i &lt;= e; i++) { for (int j = 0; j &lt;= k; j++) { int flag = false; for (int oo = 1; oo &lt;= n; oo++) if (d[oo].x == i) { flag = true; for (int orz = 0; orz &lt;= min(j, d[oo].f); orz++) dp[i][j] = min(dp[i][j], dp[i - 1][j - orz] + d[oo].c * orz + j - orz); } else if (!flag) dp[i][j] = dp[i - 1][j] + j; } } printf(&quot;%lld\n&quot;, dp[e][k]); } int main() { scanf(&quot;%d%d%d&quot;, &amp;k, &amp;e, &amp;n), solve(); return 0; } 第3题 奶牛杂技 (Cow Acrobats, USACO 2006 Nov)解法：贪心，排序比较函数为$w+s$复杂度：$O(nlogn)$代码：略 第4题 抓苹果 (Apple Catching, USACO 2004 Nov)解法：DP代码：略 第5题 抢购干草 (Hay For Sale, USACO 2008 Dec)解法：裸背包DP代码：略 第6题 建造栅栏 (Building A Fence, USACO 2008 Oct)解法：DP，四边形三边之和大于第四边代码：略 第7题 建造道路 (Building Roads, USACO 2007 Dec)解法：裸最小生成树代码：略 第8题 青铜莲花池 (Bronze Lilypad Pond, USACO 2007 Feb) 解法：基础BFS代码：略 第9题 滑雪课程 (Ski Lessons, USACO 2009 Open)解法：DP代码：略 第10题 奶牛飞盘队 (Cow Frisbee Team, USACO 2009 Mar)解法：DP设$dp(i,j)​$为前$i​$个物品，组成和模$f​$的方案数$dp(i,j)+=dp(i-1,j), dp(i,(j+a_i)\%f) +=dp(i-1,j)$代码： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 2000 + 5, MAXF = 1000 + 5, MO = 1e8; int n, f, dp[MAXN][MAXF], a[MAXN]; void clean() { ms(dp, 0); } void solve() { clean(); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]); for (int i = 1; i &lt;= n; i++) { dp[i][a[i] % f] = 1; for (int j = 0; j &lt; f; j++) { dp[i][j] = (dp[i][j] + dp[i - 1][j]) % MO; dp[i][(j + a[i]) % f] = (dp[i][(j + a[i]) % f] + dp[i - 1][j]) % MO; } } printf(&quot;%d\n&quot;, dp[n][0]); } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;f), solve(); return 0; } 第11题 奶牛博览会 (Cow Exhibition, USACO 2003 Fall)解法：背包DP，最好用一维数组代码：略 第12题 最近回文 (Cheapest Palindrome, USACO 2007 Open)解法：区间DP设$dp(i,j)$为把区间$[i,j]$变为回文串的最小花费。观察到删除一个数和加上一个数是等价操作，因为要构成回文串，不是将对应的字母补上，就是将这个字母删掉，所以取$cst_i=min(addv, delv)$，即转移方程：当$s_i==s_j$时，$dp(i,j)=min(dp(i+1,j-1))$否则$dp(i,j)=min(dp(i+1,j)+cst_{s_i}, dp(i,j-1)+cst_{s_j})$代码： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXM = 2000 + 5, INF = 1000000000; int n, m, cst[30], f[MAXM][MAXM]; char s[MAXM]; char getc() { char ch = getchar(); while (!(&#39;a&#39; &lt;= ch &amp;&amp; ch &lt;= &#39;z&#39;)) ch = getchar(); return ch; } int dp(int l, int r) { if (f[l][r] &gt;= 0) return f[l][r]; if (l &gt;= r) return f[l][r] = 0; int tmp = INF; if (s[l] == s[r]) tmp = min(tmp, dp(l + 1, r - 1)); tmp = min(tmp, dp(l + 1, r) + cst[s[l] - &#39;a&#39;]); tmp = min(tmp, dp(l, r - 1) + cst[s[r] - &#39;a&#39;]); return f[l][r] = tmp; } void clean() { ms(f, -1); } void solve() { clean(); scanf(&quot;%s&quot;, s + 1); for (int i = 1; i &lt;= n; i++) { int x = getc() - &#39;a&#39;; int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); cst[x] = min(a, b); } printf(&quot;%d\n&quot;, dp(1, m)); } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m), solve(); return 0; } 第13题 安慰奶牛 (Cheering up the Cows, USACO 2008 Nov)解法：最小生成树，边权改为两端节点权+边权$\times 2$，然后最后答案还要加上起点，在$n$个点里找一个最小的即可。代码：略 第14题 玉米迷宫 (Corn Maze, USACO 2011 Open)解法：裸Bfs代码：略 第15题 奶牛集会 (MooFest, USACO 2004 Open)解法：Bzoj 3378代码：Bzoj 3378 第16题 奶牛文字 (Cowlphabet, USACO 2011 Feb)解法：DP设$dp(i,j,k)$为小写$i$个，大写$j$个的方案数初值$dp(1,0,k)=1$，$k$是小写字母，$dp(0,1,k)=1$，$k$是大写字母$dp(i,j,k)=\sum dp(i-1,j,s)(k$是小写字母)$dp(i,j,k)=\sum dp(i,j-1,s)(k$是大写字母)然后注意细节打就是了代码： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MO = 97654321; vector&lt;int&gt; G[60]; int u, l, p; LL f[255][255][60]; int getIDfromChar(char ch) { if (&#39;a&#39; &lt;= ch &amp;&amp; ch &lt;= &#39;z&#39;) return ch - &#39;a&#39;; if (&#39;A&#39; &lt;= ch &amp;&amp; ch &lt;= &#39;Z&#39;) return ch - &#39;A&#39; + 26; } char getc() { char ch = getchar(); while (!(&#39;a&#39; &lt;= ch &amp;&amp; ch &lt;= &#39;z&#39;) &amp;&amp; !(&#39;A&#39; &lt;= ch &amp;&amp; ch &lt;= &#39;Z&#39;)) ch = getchar(); return getIDfromChar(ch); } int dp(int i, int j, int k) { if (i &lt; 0 || j &lt; 0) return 0; if (f[i][j][k] &gt;= 0) return f[i][j][k]; int tmp = 0; for (int orz = 0; orz &lt; G[k].size(); orz++) { int s = G[k][orz]; if (k &lt; 26) tmp = (tmp + dp(i - 1, j, s)) % MO; else tmp = (tmp + dp(i, j - 1, s)) % MO; } return f[i][j][k] = tmp; } void clean() { for (int i = 0; i &lt; 60; i++) G[i].clear(); ms(f, -1); } void solve() { clean(); for (int i = 1; i &lt;= p; i++) { int a = getc(), b = getc(); G[a].push_back(b); } for (int i = 0; i &lt; 26; i++) f[1][0][i] = 1; for (int i = 26; i &lt; 52; i++) f[0][1][i] = 1; LL ans = 0; for (int i = 0; i &lt; 52; i++) ans = (ans + dp(l, u, i)) % MO; printf(&quot;%lld\n&quot;, ans); } int main() { scanf(&quot;%d%d%d&quot;, &amp;u, &amp;l, &amp;p), solve(); return 0; } 第17题 奶牛跨栏 (Cow Hurdles, USACO 2007 Nov)解法：Bzoj 1641代码：Bzoj 1641 第18题 工作安排 (Work Scheduling, USACO 2009 Open)解法：贪心+堆和有题射兔子的差不多，但是效仿那个做法复杂度不对，这里时间戳$10^9$，只有75分我们考虑把工作按结束时间从小到大排序，然后分别把每个工作都放进一个小根堆里，如果堆满了，考虑把当前工作和堆顶比较替换代码： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 1e5 + 5; struct data { int d, p; bool operator &lt; (const data &amp;b) const { return p &gt; b.p; } }jb[MAXN]; bool cmp(const data &amp;a, const data &amp;b) { return a.d &lt; b.d; } int n; void clean() { } void solve() { clean(); for (int i = 1; i &lt;= n; i++) { scanf(&quot;%d%d&quot;, &amp;jb[i].d, &amp;jb[i].p); } sort(jb + 1, jb + 1 + n, cmp); LL ans = 0; priority_queue&lt;data&gt; pq; pq.push(jb[1]), ans += jb[1].p; for (int i = 2; i &lt;= n; i++) { if (pq.size() &gt;= jb[i].d) { if (jb[i].p &gt; pq.top().p) { ans += jb[i].p - pq.top().p, pq.pop(), pq.push(jb[i]); } } else pq.push(jb[i]), ans += jb[i].p; } printf(&quot;%lld\n&quot;, ans); } int main() { scanf(&quot;%d&quot;, &amp;n), solve(); return 0; } 第19题 手机网络 (Cell Phone Network, USACO 2008 Jan)解法：Bzoj 1596代码：Bzoj 1596 第20题 提交作业 (Turning in Homework, USACO 2004 Open)//暂放 第21题 滑雪缆车 (Ski Lift, USACO 2006 Mar)//暂放 第22题 派发巧克力 (Chocolate Giving, USACO 2010 Feb)解法：SPFA代码：略 第23题 赞助学费 (Financial Aid, USACO 2004 Mar)解法：堆+贪心先把原数组按照$C$排序，然后用堆维护前$k$小的值的和，求出每个数的左右两边$n/2$个数的最小费用$ls, rs$，然后枚举一下答案，可以二分，但是并无多大用处，注意这题$n$和$c$，之前就把$c$的范围搞错了代码： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXC = 200000 + 5; struct data { LL ci, fi; bool operator &lt; (const data &amp;b) const { return ci &lt; b.ci; } }cow[MAXC]; int n, c, f, ws; LL ls[MAXC], rs[MAXC]; priority_queue&lt;int&gt; pq; void clean() { ms(ls, 127), ms(rs, 127); } void solve() { clean(); ws = n / 2; for (int i = 1; i &lt;= c; i++) scanf(&quot;%lld%lld&quot;, &amp;cow[i].ci, &amp;cow[i].fi); sort(cow + 1, cow + 1 + c); while (!pq.empty()) pq.pop(); int s = 0; for (int i = 1; i &lt;= ws; i++) pq.push(cow[i].fi), s += cow[i].fi; for (int i = ws + 1; i &lt;= c; i++) { ls[i] = s; if (cow[i].fi &lt; pq.top()) { s -= pq.top(), s += cow[i].fi; pq.pop(), pq.push(cow[i].fi); } } while (!pq.empty()) pq.pop(); s = 0; for (int i = c - ws + 1; i &lt;= c; i++) pq.push(cow[i].fi), s += cow[i].fi; for (int i = c - ws; i &gt; 0; i--) { rs[i] = s; if (cow[i].fi &lt; pq.top()) { s -= pq.top(), s += cow[i].fi; pq.pop(), pq.push(cow[i].fi); } } LL ans = -1; /*int l = 1, r = c + 1; while (l &lt; r) { int mid = (l + r) / 2; if (ls[mid] + cow[mid].fi + rs[mid] &lt;= f) { ans = max(ans, cow[mid].ci); l = mid + 1; } else r = mid; }*/ for (int i = c; i &gt; 0; i--) { if (ls[i] + cow[i].fi + rs[i] &lt;= f) { ans = max(ans, cow[i].ci); break; } } printf(&quot;%lld\n&quot;, ans); } int main() { while (scanf(&quot;%d%d%d&quot;, &amp;n, &amp;c, &amp;f) == 3) solve(); return 0; } 第24题 白银莲花池 (Silver Lilypad Pond, USACO 2007 Feb)//暂放 第25题 地震 (Earthquake, USACO 2001 Open)//到处都找不到这题，先暂放 第26题 股票市场 (Stock Market, USACO 2009 Feb)解法：代码： 第27题 奶牛赛车 (Cow Cycling, USACO Feb 2002)解法：代码： 第28题 奶牛观光 (Sightseeing Cows, USACO 2007 Dec)解法：Bzoj 1960代码：Bzoj 1960 第29题 道路重建 (Rebuilding Roads, USACO Feb 2002)解法：Poj 1947代码：Poj 1947]]></content>
      <categories>
        <category>比赛</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[非旋转Treap 学习笔记]]></title>
    <url>%2FszTreap%2F</url>
    <content type="text"><![CDATA[模板及讲解非旋转Treap：Treap=Tree+heap，即键值$key$(满足排序二叉树性质(左小右大)，并且按照中序遍历有序)，附加值$val$(满足堆性质(孩子都比父节点小))核心操作$O(nlogn)$： $newNode(x)$ 新建一个以$x$为权值的点 $merge(a, b)$ 把$a$树和$b$树合并，必须满足$\forall key_a &lt; \forall key_b$ $split_v(a,v,x,y)$把$a$树按权值$v$分成$x,y$两棵树，一棵树小于等于$v$，一棵树大于$v$ $split_k(a,v,x,y)$把$a$树按前$k$个分配成$x,y$两棵树 能够实现的操作$O(nlogn)$： $rank(x)$ 查询$x$的排名 $kth(x)$ 查询第$x$大的数 $pre(x)$ 查询$x$的前驱 $succ(x)$ 查询$x$的后继 $insert(x)$ 插入一个数权值为$x$ $del(x)$ 删除一个权值为$x$的数 具体可以看相关代码写时注意：1 不要忘了srand(19260817)2 $split$里$x, y$用*&amp;3 主程序记得加$initTreap()$4 $merge$前面记得加赋值 可持久化Treap：暂略 常见题型1、直接使用操作完成Q: 求第$k$大\求$x$的排名……解: 直接套模板。例题: bzoj32242、操作区间Q: 翻转某个区间解: 非旋Treap处理区间。例题: bzoj3223 相关代码bzoj3224非旋转Treap模板：包括基本操作 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 100000 + 5; struct Treap *null, *pit, *root;//自建的null节点，内存池指针 struct Treap { int key, val, s;//键值(满足排序二叉树性质)，附加值(满足堆性质)，以本节点为根的子树大小 Treap *lc, *rc;//Treap 左右结点 Treap() {}; void init(int key) {this-&gt;key = key, val = rand(), lc = rc = null, s = 1;}//初始化 void maintain() {s = lc-&gt;s + rc-&gt;s + 1;}//更新，维护以本节点为根的子树大小 }pool[MAXN];//内存池 Treap* newNode(int key) { pit-&gt;init(key); return pit++; } Treap* merge(Treap *a, Treap *b) {//合并两棵Treap，所有key(a)&lt;key(b)才能合并，为了满足排序二叉树性质 if (a == null) return b; if (b == null) return a; if (a-&gt;val &lt; b-&gt;val) { a-&gt;rc = merge(a-&gt;rc, b), a-&gt;maintain(); //a小自然a要在b的上面，满足堆性质 return a; } if (a-&gt;val &gt;= b-&gt;val) { b-&gt;lc = merge(a, b-&gt;lc), b-&gt;maintain(); //a大自然a要在b的下面，满足堆性质 return b; } } void split_v(Treap *o, int v, Treap *&amp;x, Treap *&amp;y) {//用权值分开一棵Treap，分开的第一棵根为x，第二棵根为y。x，y可以称为左右子树“下一个”位置，也就是如果还有满足左边的，就放在x或者y的位置 if (o == null) x = y = null; else { if (o-&gt;key &lt;= v) { x = o, split_v(o-&gt;rc, v, o-&gt;rc, y);//x = o说明o左边全部放进x，递归右子树 } else y = o, split_v(o-&gt;lc, v, x, o-&gt;lc); o-&gt;maintain(); } } void split_k(Treap *o, int k, Treap *&amp;x, Treap *&amp;y) {//按前k个分配分开一棵Treap，分开的第一棵根为x，第二棵根为y。x，y可以称为左右子树“下一个”位置，也就是如果还有满足左边的，就放在x或者y的位置 if (o == null) x = y = null; else { if (k &lt;= o-&gt;lc-&gt;s) { y = o, split_k(o-&gt;lc, k, x, o-&gt;lc);//y = o说明o右边全部放进y，递归左子树 } else x = o, split_k(o-&gt;rc, k - o-&gt;lc-&gt;s - 1, o-&gt;rc, y); o-&gt;maintain(); } } void insert(int v) {//插入一个数 Treap *a, *b; split_v(root, v, a, b); root = merge(merge(a, newNode(v)), b); } void del(int v) {//删除一个数 Treap *a, *b; split_v(root, v, a, b); Treap *c, *d; split_v(a, v - 1, c, d); d = merge(d-&gt;lc, d-&gt;rc); a = merge(c, d), root = merge(a, b); } int kth(int k) {//查询排名为k的数 Treap *a, *b; split_k(root, k - 1, a, b); Treap *c, *d; split_k(b, 1, c, d); int ret = c-&gt;key; b = merge(c, d), root = merge(a, b); return ret; } int rk(int x) {//查询x的排名 Treap *a, *b; split_v(root, x - 1, a, b); int ret = a-&gt;s + 1; root = merge(a, b); return ret; } int pre(int x) {//求x的前驱 Treap *a, *b; split_v(root, x - 1, a, b); Treap *c, *d; split_k(a, a-&gt;s - 1, c, d); int ret = d-&gt;key; a = merge(c, d), root = merge(a, b); return ret; } int succ(int x) {//求x的后继 Treap *a, *b; split_v(root, x, a, b); Treap *c, *d; split_k(b, 1, c, d); int ret = c-&gt;key; b = merge(c, d), root = merge(a, b); return ret; } void initTreap() { srand(19260827);//置随机数种子 pit = pool;//指针指向内存池 null = newNode(0), null-&gt;s = 0;//初始化自建的null节点 root = null;//初始化树根 } void clean() {} void solve() { clean(); initTreap(); int Q; scanf(&quot;%d&quot;, &amp;Q); while (Q--) { int opt, x; scanf(&quot;%d%d&quot;, &amp;opt, &amp;x); switch (opt) { case 1: insert(x); break; case 2: del(x); break; case 3: printf(&quot;%d\n&quot;, rk(x)); break; case 4: printf(&quot;%d\n&quot;, kth(x)); break; case 5: printf(&quot;%d\n&quot;, pre(x)); break; case 6: printf(&quot;%d\n&quot;, succ(x)); break; } } } int main() { solve(); return 0; }]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>Treap</tag>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 3224」普通平衡树 (非旋Treap)]]></title>
    <url>%2Fbzoj3224%2F</url>
    <content type="text"><![CDATA[BZOJ 3224平衡树模板题，注意相同元素的处理。2017-8-22：非旋转Treap： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 100000 + 5; struct Treap *null, *pit, *root;//自建的null节点，内存池指针 struct Treap { int key, val, s;//键值(满足排序二叉树性质)，附加值(满足堆性质)，以本节点为根的子树大小 Treap *lc, *rc;//Treap 左右结点 Treap() {}; void init(int key) {this-&gt;key = key, val = rand(), lc = rc = null, s = 1;}//初始化 void maintain() {s = lc-&gt;s + rc-&gt;s + 1;}//更新，维护以本节点为根的子树大小 }pool[MAXN];//内存池 Treap* newNode(int key) { pit-&gt;init(key); return pit++; } Treap* merge(Treap *a, Treap *b) {//合并两棵Treap，所有key(a)&lt;key(b)才能合并 if (a == null) return b; if (b == null) return a; if (a-&gt;val &lt; b-&gt;val) { a-&gt;rc = merge(a-&gt;rc, b), a-&gt;maintain(); return a; } if (a-&gt;val &gt;= b-&gt;val) { b-&gt;lc = merge(a, b-&gt;lc), b-&gt;maintain(); return b; } } void split_v(Treap *o, int v, Treap *&amp;x, Treap *&amp;y) {//用权值分开一棵Treap，分开的第一棵根为x，第二棵根为y if (o == null) x = y = null; else { if (o-&gt;key &lt;= v) { x = o, split_v(o-&gt;rc, v, o-&gt;rc, y); } else y = o, split_v(o-&gt;lc, v, x, o-&gt;lc); o-&gt;maintain(); } } void split_k(Treap *o, int k, Treap *&amp;x, Treap *&amp;y) {//按前k个分配分开一棵Treap，分开的第一棵根为x，第二棵根为y if (o == null) x = y = null; else { if (k &lt;= o-&gt;lc-&gt;s) { y = o, split_k(o-&gt;lc, k, x, o-&gt;lc); } else x = o, split_k(o-&gt;rc, k - o-&gt;lc-&gt;s - 1, o-&gt;rc, y); o-&gt;maintain(); } } void insert(int v) {//插入一个数 Treap *a, *b; split_v(root, v, a, b); root = merge(merge(a, newNode(v)), b); } void del(int v) {//删除一个数 Treap *a, *b; split_v(root, v, a, b); Treap *c, *d; split_v(a, v - 1, c, d); d = merge(d-&gt;lc, d-&gt;rc); a = merge(c, d), root = merge(a, b); } int kth(int k) {//查询排名为k的数 Treap *a, *b; split_k(root, k - 1, a, b); Treap *c, *d; split_k(b, 1, c, d); int ret = c-&gt;key; b = merge(c, d), root = merge(a, b); return ret; } int rk(int x) {//查询x的排名 Treap *a, *b; split_v(root, x - 1, a, b); int ret = a-&gt;s + 1; root = merge(a, b); return ret; } int pre(int x) {//求x的前驱 Treap *a, *b; split_v(root, x - 1, a, b); Treap *c, *d; split_k(a, a-&gt;s - 1, c, d); int ret = d-&gt;key; a = merge(c, d), root = merge(a, b); return ret; } int succ(int x) {//求x的后继 Treap *a, *b; split_v(root, x, a, b); Treap *c, *d; split_k(b, 1, c, d); int ret = c-&gt;key; b = merge(c, d), root = merge(a, b); return ret; } void initTreap() { srand(19260827);//置随机数种子 pit = pool;//指针指向内存池 null = newNode(0), null-&gt;s = 0;//初始化自建的null节点 root = null;//初始化树根 } void clean() {} void solve() { clean(); initTreap(); int Q; scanf(&quot;%d&quot;, &amp;Q); while (Q--) { int opt, x; scanf(&quot;%d%d&quot;, &amp;opt, &amp;x); switch (opt) { case 1: insert(x); break; case 2: del(x); break; case 3: printf(&quot;%d\n&quot;, rk(x)); break; case 4: printf(&quot;%d\n&quot;, kth(x)); break; case 5: printf(&quot;%d\n&quot;, pre(x)); break; case 6: printf(&quot;%d\n&quot;, succ(x)); break; } } } int main() { solve(); return 0; } Splay : #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;vector&gt; #include&lt;utility&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 200005, INF = 2000000005; int ch[MAXN][2], fa[MAXN], val[MAXN], cnt[MAXN], siz[MAXN], ncnt, rt, n; // splay 数组，父亲节点，节点值，节点值个数，节点子树大小，节点总数，根 bool rel(int x) {return ch[fa[x]][1] == x;} // x 点在父亲点的位置 (x 点是不是父亲点的右孩子) void pushup(int x) {siz[x] = siz[ch[x][0]] + siz[ch[x][1]] + cnt[x];} void rotate(int x) { // 旋转操作 int y = fa[x], z = fa[y], k = rel(x), w = ch[x][k ^ 1]; ch[z][rel(y)] = x, fa[x] = z; // 将爷爷节点与自己相连 ch[y][k] = w, fa[w] = y; // 将自己的孩子给父节点 ch[x][k ^ 1] = y, fa[y] = x; // 将父节点接到自己孩子 pushup(y), pushup(x); // 破坏了结构记得 pushup } void splay(int x, int gl = 0) { // splay 操作 -&gt; 将 x 节点转到 gl 节点孩子 ，并且可以用作更新信息 while (fa[x] != gl) { // 一直旋转到目标节点的儿子 int y = fa[x], z = fa[y]; if (z != gl) { // 爷爷节点不是目标节点，否则直接旋转 if (rel(x) == rel(y)) rotate(y); else rotate(x); // 自身、父亲、爷爷三点一线，则先旋转父亲节点 } rotate(x); // 旋转自身 } if (!gl) rt = x; // 如果旋转到根则更新 rt } void insert(int x) { // 插入一个值为 x 的节点并转到根 int cur = rt, p = 0; // cur 当前节点， p 为 cur 父亲 while (cur &amp;&amp; val[cur] != x) p = cur, cur = ch[cur][x &gt; val[cur]]; // 找插入位置 if (cur) cnt[cur]++; else { // 找到插入位置，如果已经有数则 cnt 加一即可，否则新建节点 cur = ++ncnt; ch[p][x &gt; val[p]] = cur; ch[cur][0] = ch[cur][1] = 0; fa[cur] = p; val[cur] = x; cnt[cur] = siz[cur] = 1; } splay(cur); // splay 到根，以免加入节点后拉出一条链 + 更新信息 } void find(int x) { // 找一个值为 x 的节点转到根，不存在则返回当前数的前驱或后继 int cur = rt; while (ch[cur][x &gt; val[cur]] &amp;&amp; x != val[cur]) cur = ch[cur][x &gt; val[cur]]; splay(cur); } int kth(int k) { // 找值第 k 大数 int cur = rt; while (1) { if (k &lt;= siz[ch[cur][0]]) cur = ch[cur][0]; else if (k &gt; siz[ch[cur][0]] + cnt[cur]) k -= siz[ch[cur][0]] + cnt[cur], cur = ch[cur][1]; else return cur; } } int rnk(int x) { // 值 x 的排名 find(x); // splay 值为 x 的节点到根后左子树的大小即为值 x 排名 return siz[ch[rt][0]]; } int pre(int x) { // 值前驱 find(x); // 先将值为 x 的节点 splay 到根 if (val[rt] &lt; x) return rt; // 找不到这样的节点则直接返回根 int cur = ch[rt][0]; // 找根左子树最右边的值即为前驱 while (ch[cur][1]) cur = ch[cur][1]; return cur; } int succ(int x) { // 值后继 find(x); // 先将值为 x 的节点 splay 到根 if (val[rt] &gt; x) return rt; // 找不到这样的节点则直接返回根 int cur = ch[rt][1]; // 找根右子树最左边的值即为前驱 while (ch[cur][0]) cur = ch[cur][0]; return cur; } void remove(int x) { // 删除一个值为 x 的节点 int last = pre(x), next = succ(x); splay(last), splay(next, last); // 前驱转到根，后继转到根的右孩子 int del = ch[next][0]; if (cnt[del] &gt; 1) --cnt[del], splay(del); else ch[next][0] = 0, pushup(next), pushup(last); // 记得信息的更新上传 } void clean() { ms(fa, 0), ms(cnt, 0), ms(val, 0), ms(siz, 0), rt = ncnt = 0; } int solve() { clean(); scanf(&quot;%d&quot;, &amp;n); insert(INF), insert(-INF); // 插入最大最小值 while (n--) { int opt, x; scanf(&quot;%d%d&quot;, &amp;opt, &amp;x); switch (opt) { case 1: insert(x); break; case 2: remove(x); break; case 3: printf(&quot;%d\n&quot;, rnk(x)); break; case 4: printf(&quot;%d\n&quot;, val[kth(x + 1)]); break; case 5: printf(&quot;%d\n&quot;, val[pre(x)]); break; case 6: printf(&quot;%d\n&quot;, val[succ(x)]); break; } } return 0; } } int main() { flyinthesky::solve(); return 0; } 旋转Treap： #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;vector&gt; #define ms(i,j) memset(i,j, sizeof i); using namespace std; struct node { node *ch[2];//左右孩子 int v, r;//值，优先级 int s;//附加值：以当前节点为根的结点数量 int w;//附加值：和当前节点相同值的结点数 void mt() { s = w; if (ch[0]!=NULL) s += ch[0]-&gt;s; if (ch[1]!=NULL) s += ch[1]-&gt;s; } }; int ans; struct treap { node *root; void rotate(int d, node *&amp;o)//d=0则左旋 d=1则右旋 { node *k = o-&gt;ch[d^1]; o-&gt;ch[d^1] = k-&gt;ch[d]; k-&gt;ch[d] = o; o-&gt;mt(); k-&gt;mt(); o = k; } void insert(int x, node *&amp;o)//插入一个数 { if (o==NULL) { o = new node(); o-&gt;v = x; o-&gt;r = rand(); o-&gt;s = o-&gt;w = 1; o-&gt;ch[0] = o-&gt;ch[1] = NULL; //初值 } else if (o-&gt;v==x) o-&gt;w++; //有相同直接w++ else { int d = (x &lt; o-&gt;v ? 0 : 1); insert(x, o-&gt;ch[d]); if (o-&gt;ch[d]-&gt;r &gt; o-&gt;r) rotate(d^1, o); } o-&gt;mt(); } void del(int x, node *&amp;o)//删除一个数 { int d = (x &lt; o-&gt;v ? 0 : 1); if (o-&gt;v==x)//找到 { if (o-&gt;w&gt;1) {o-&gt;w--; o-&gt;s--;} else//不止一个数就直接w--，s-- if (o-&gt;ch[0]==NULL) o = o-&gt;ch[1]; else if (o-&gt;ch[1]==NULL) o = o-&gt;ch[0]; else { int d2 = (o-&gt;ch[0]-&gt;r &gt; o-&gt;ch[1]-&gt;r ? 1 : 0); rotate(d2,o); del(x, o-&gt;ch[d2]); } } else { del(x, o-&gt;ch[d]); } if (o!=NULL) o-&gt;mt(); } int rank(int x, node *o)//求x的排名 { int tmp; if (o-&gt;ch[0]==NULL) tmp = 0; else tmp=o-&gt;ch[0]-&gt;s;//求s if (o-&gt;v==x) return tmp+1;//找到了 else if (o-&gt;v &gt;x) return rank(x,o-&gt;ch[0]); else return tmp+o-&gt;w+rank(x,o-&gt;ch[1]); } int kth(int k, node *o)//求第k小 { if (o==NULL||o-&gt;s&lt;k||k&lt;=0) return -1;//不符合要求 int tmp; if (o-&gt;ch[0]==NULL) tmp = 0; else tmp = o-&gt;ch[0]-&gt;s;//求s if (k&lt;=tmp) return kth(k,o-&gt;ch[0]); else if (k &gt; tmp+o-&gt;w) return kth(k - tmp - o-&gt;w,o-&gt;ch[1]); else return o-&gt;v;//找到了 } void pred(int x, node *o)//求前驱 { if(o==NULL)return; if(o-&gt;v&lt;x) { ans = o-&gt;v; pred(x, o-&gt;ch[1]); } else pred(x, o-&gt;ch[0]); } void succ(int x, node *o)//求后继 { if(o==NULL)return; if(o-&gt;v&gt;x) { ans = o-&gt;v; succ(x, o-&gt;ch[0]); } else succ(x, o-&gt;ch[1]); } }; treap tree; int n; int main() { scanf(&quot;%d&quot;, &amp;n); int opt,x; for (int i=1;i&lt;=n;i++) { scanf(&quot;%d%d&quot;, &amp;opt, &amp;x); switch(opt) { case 1: tree.insert(x, tree.root); break; case 2: tree.del(x, tree.root); break; case 3: printf(&quot;%d\n&quot;, tree.rank(x, tree.root)); break; case 4: printf(&quot;%d\n&quot;, tree.kth(x, tree.root)); break; case 5: tree.pred(x,tree.root); printf(&quot;%d\n&quot;, ans); break; case 6: tree.succ(x,tree.root); printf(&quot;%d\n&quot;, ans); break; } } return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>Treap</tag>
        <tag>Splay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1222」「HNOI2001」产品加工 (DP)]]></title>
    <url>%2Fbzoj1222%2F</url>
    <content type="text"><![CDATA[BZOJ 1222设$f(i)$为A在$i$时时B在$f(i)$时，并且$f(i)$最小那么分3种情况转移：1、第$i$个物品放A2、第$i$个物品放B3、第$i$个物品放AB #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int INF = 10000000, MAXN = 6000 + 5, MAXM = 30000 + 5; int n, m, a[MAXN], b[MAXN], c[MAXN], f[MAXM]; void clean() {} void solve() { clean(); for (int i = 1; i &lt;= n; i++) { scanf(&quot;%d%d%d&quot;, &amp;a[i], &amp;b[i], &amp;c[i]); if (!a[i]) a[i] = INF;if (!b[i]) b[i] = INF;if (!c[i]) c[i] = INF; m += min(min(a[i], b[i]), c[i]);//直接顺序加工 } for (int i = 1; i &lt;= n; i++) { for (int j = m; j &gt;= 0; j--) { int t = INF; if (j - a[i] &gt;= 0) t = min(t, f[j - a[i]]); t = min(t, f[j] + b[i]); if (j - c[i] &gt;= 0) t = min(t, f[j - c[i]] + c[i]); f[j] = t; } } int ans = INF; for (int i = 1; i &lt;= m; i++) ans = min(ans, max(i, f[i])); printf(&quot;%d\n&quot;, ans); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif scanf(&quot;%d&quot;, &amp;n), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>Bzoj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bzoj 2190(欧拉函数)]]></title>
    <url>%2Fbzoj2190%2F</url>
    <content type="text"><![CDATA[Bzoj 2190由题意可知，能看见的人是对角线对称的斜率相同的直线中只有一条能被看见，也就是说$\frac{y_1}{x_1}=\frac{y_2}{x_2}$的直线只有一条能被看见。如果$gcd(x, y)=d≠1$的话，$\frac{y}{x}$可约分，就肯定被前面的点$(\frac{x}{d},\frac{y}{d})$挡住盖了，所以$gcd(x, y)=1$的点才能被看见。我们这里用欧拉函数求。因为欧拉函数$\varphi(x)$就是小于$x$与$x$互质的数，那这里求出$2\sum_{i=1}^{n-1}\varphi(i)+1$即为答案 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 40000 + 5; int n; int phi[MAXN]; void getphi(int n) { for (int i = 1; i &lt;= n; i++) phi[i] = 0; phi[1] = 1; for (int i = 2; i &lt;= n; i++) if (!phi[i]) { for (int j = i; j &lt;= n; j += i) { if (!phi[j]) phi[j] = j; phi[j] = phi[j] / i * (i - 1); } } } void clean() {} void solve() { clean(); getphi(n); int tot = 0; for (int i = 1; i &lt; n; i++) tot += phi[i]; printf(&quot;%d\n&quot;, tot * 2 + 1); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif while (scanf(&quot;%d&quot;, &amp;n) == 1) solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>欧拉函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bzoj 3211(线段树/树状数组+并查集)]]></title>
    <url>%2Fbzoj3211%2F</url>
    <content type="text"><![CDATA[BZOJ 32112017.8.19:本题就是线段树模板题，但是sqrt慢，并且点也只能一个个sqrt，不能一起sqrt，维护一个lazy标记区间是否全是1或0，然后写就行了(并不知道之前写的并查集是什么东西。。) #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 100000 + 5; int n, Q, data[MAXN]; int flag[MAXN * 4]; LL sumv[MAXN * 4]; #define lc (o &lt;&lt; 1) #define rc (o &lt;&lt; 1 | 1) #define M ((l + r) &gt;&gt; 1) void pushup(int o) { sumv[o] = sumv[lc] + sumv[rc]; flag[o] = (flag[lc] &amp;&amp; flag[rc]);//记得传，不然TLE } void build(int o, int l, int r) { if (l == r) { sumv[o] = data[l]; if (sumv[o] == 0 || sumv[o] == 1) flag[o] = true;//对这个(点)开方已经没有意义 } else flag[o] = sumv[o] = 0, build(lc, l, M), build(rc, M + 1, r), pushup(o); } void update(int o, int l, int r, int x, int y) { if (flag[o]) return ;//这个区间都是1或0 if (l == r) { sumv[o] = sqrt(sumv[o]); if (sumv[o] == 0 || sumv[o] == 1) flag[o] = true;//对这个(点)开方已经没有意义 return ; } if (x &lt;= M) update(lc, l, M, x, y); if (M &lt; y) update(rc, M + 1, r, x, y); pushup(o); } LL query(int o, int l, int r, int x, int y) { LL ret = 0; if (x &lt;= l &amp;&amp; r &lt;= y) { return sumv[o]; } if (x &lt;= M) ret += query(lc, l, M, x, y); if (M &lt; y) ret += query(rc, M + 1, r, x, y); return ret; } void clean() {} void solve() { clean(); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;data[i]); build(1, 1, n); scanf(&quot;%d&quot;, &amp;Q); while (Q--) { int x, l, r; scanf(&quot;%d%d%d&quot;, &amp;x, &amp;l, &amp;r); if (x == 1) { printf(&quot;%lld\n&quot;, query(1,1,n,l,r)); } else { update(1,1,n,l,r); } } } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif scanf(&quot;%d&quot;, &amp;n), solve(); return 0; } 树状数组裸题，但是因为sqrt的速度很慢，所以我们在一个数为1或者为0就删掉它(用并查集维护)ps:交题时注意文件声明部分要注释掉！坑死了 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #include&lt;iostream&gt; #define ms(i,j) memset(i, j, sizeof i); #define ll long long using namespace std; const int MAXN = 100000 + 5; ll a[MAXN], f[MAXN]; int data[MAXN]; int n,m; int lowbit(ll x) {return x&amp;(-x);} int find(int x) { if (f[x]==x) return x; else return f[x] = find(f[x]); } ll sum(int x) { ll ret = 0; for (ll i=x;i&gt;0;i-=lowbit(i)) { ret += (ll)a[i]; } return ret; } int update(int x, int c) { for (ll i=x;i&lt;=n;i+=lowbit(i)) { a[i] += c; } } int main() { //freopen(&quot;bzoj3211.in&quot;, &quot;r&quot;, stdin); freopen(&quot;bzoj3211.out&quot;, &quot;w&quot;, stdout); scanf(&quot;%d\n&quot;, &amp;n); ms(a, 0); for (int i=1;i&lt;=n+1;i++) f[i] = i; for (int i=1;i&lt;=n;i++) { scanf(&quot;%lld&quot;, &amp;data[i]); if (data[i]==1||data[i]==0) f[i] = find(i+1); update(i, data[i]); } scanf(&quot;%d&quot;, &amp;m); for (int i=1;i&lt;=m;i++) { int x, l, r; scanf(&quot;%d%d%d&quot;, &amp;x, &amp;l, &amp;r); if (x==1) printf(&quot;%lld\n&quot;, sum(r)-sum(l-1)); else if (x==2) { for (int j=find(l);j&lt;=r;j=find(j+1)) { update(j, (ll)(sqrt(data[j]))-data[j]); data[j] = (ll)(sqrt(data[j])); if(data[j]==1) { f[j] = find(j+1); } } } } return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>Bzoj</tag>
        <tag>线段树</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1054」「HAOI2008」移动玩具 (BFS+状压判重)]]></title>
    <url>%2Fbzoj1054%2F</url>
    <content type="text"><![CDATA[Bzoj 1054每个状态当做一个点，然后BFS每次BFS在状态里找1然后遍历即可，判重就存一个16位的二进制就行了，而不需要哈希二维数组转16位的二进制，16位的二进制转二维数组的方法具体实现看代码。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int dx[4] = {1, 0, -1, 0}; const int dy[4] = {0, 1, 0, -1}; struct data {int st, d;}; int gl[5][5]; int a[5][5]; char s[5]; bool vis[1 &lt;&lt; 17]; int cura[5][5]; int getIntByArray() { int st = 0, ret = 0; for (int i = 1; i &lt;= 4; i++) for (int j = 1; j &lt;= 4; j++) ret += cura[i][j] * (1 &lt;&lt; st), st++; return ret; } void getArrayByInt(int a) { int st = 0; for (int i = 1; i &lt;= 4; i++) for (int j = 1; j &lt;= 4; j++) cura[i][j] = (a &gt;&gt; st) &amp; 1, st++; } void clean() { ms(vis, false); } void solve() { clean(); for (int i = 1; i &lt;= 4; i++) { scanf(&quot;%s&quot;, s + 1); for (int j = 1; j &lt;= 4; j++) { cura[i][j] = a[i][j] = s[j] - &#39;0&#39;; } } for (int i = 1; i &lt;= 4; i++) { scanf(&quot;%s&quot;, s + 1); for (int j = 1; j &lt;= 4; j++) { gl[i][j] = s[j] - &#39;0&#39;; } } queue&lt;data&gt; q; q.push((data){getIntByArray(), 0}); for (int x = 1; x &lt;= 4; x++) for (int y = 1; y &lt;= 4; y++) cura[x][y] = gl[x][y]; int gl_ = getIntByArray(); while (!q.empty()) { data p = q.front(); q.pop(); if (p.st == gl_) { printf(&quot;%d\n&quot;, p.d); return ; } getArrayByInt(p.st); int nowa[5][5]; for (int x = 1; x &lt;= 4; x++) for (int y = 1; y &lt;= 4; y++) nowa[x][y] = cura[x][y]; for (int x = 1; x &lt;= 4; x++) for (int y = 1; y &lt;= 4; y++) if (nowa[x][y] == 1) for (int i = 0; i &lt; 4; i++) { int tx = x + dx[i], ty = y + dy[i]; if (tx &gt; 0 &amp;&amp; ty &gt; 0 &amp;&amp; tx &lt;= 4 &amp;&amp; ty &lt;= 4 &amp;&amp; nowa[tx][ty] == 0) { swap(cura[x][y], cura[tx][ty]); int tt = getIntByArray(); if (!vis[tt]) { q.push((data){tt, p.d + 1}); vis[tt] = true; } swap(cura[x][y], cura[tx][ty]); } } } } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1088」「SCOI2005」扫雷Mine (模拟)]]></title>
    <url>%2Fbzoj1088%2F</url>
    <content type="text"><![CDATA[Bzoj 1088bzoj上的图被吃掉了。。搞的我题意弄错这题答案只可能在$[0,2]$，因为不然第一行无法满足条件。观察发现，因为第二列的数值是第一列的三个值相加，所以先确定了第一行的前两格，后面就可以减一下推了，然后判断一下 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 10000 + 5; int n, l1[MAXN], l2[MAXN]; int cl() { for (int i = 2; i &lt;= n; i++) l1[i + 1] = l2[i] - l1[i] - l1[i - 1]; for (int i = 1; i &lt;= n; i++) if (l1[i] &gt; 1) return 0; if (l1[n + 1] &gt;= 1) return 0; return 1; } void clean() {} void solve() { clean(); int ans = 0; for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;l2[i]); for (int i = 0; i &lt;= l2[1]; i++) { ms(l1, 0), l1[1] = i, l1[2] = l2[1] - i; ans += cl(); } printf(&quot;%d\n&quot;, ans); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif scanf(&quot;%d&quot;, &amp;n), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bzoj 2761(STL)]]></title>
    <url>%2Fbzoj2761%2F</url>
    <content type="text"><![CDATA[BZOJ 2761先按照数值排序，然后unique去重，然后再按编号排序，输出即可。本题练习STL不错，本题set也能做。注意：sort的cmp必须加const，unique返回值要记得减 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 50000 + 5; struct data { int num, v; bool operator == (const data &amp;b) const { return v == b.v; } }ai[MAXN]; bool cmp1(const data &amp;a, const data &amp;b) { if (a.v == b.v) return a.num &lt; b.num; return a.v &lt; b.v; } bool cmp2(const data &amp;a, const data &amp;b) { return a.num &lt; b.num; } int n; void clean() { } void solve() { scanf(&quot;%d&quot;, &amp;n); clean(); for (int i = 1; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;ai[i].v); ai[i].num = i; } sort(ai + 1, ai + 1 + n, cmp1); int len = unique(ai + 1, ai + 1 + n) - ai; sort(ai + 1, ai + len, cmp2); for (int i = 1; i &lt; len; i++) { printf(&quot;%d&quot;, ai[i].v); if (i == len - 1) printf(&quot;\n&quot;); else printf(&quot; &quot;); } } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif int T; scanf(&quot;%d&quot;, &amp;T); while (T--) solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1085」「SCOI2005」骑士精神 (IDA*)]]></title>
    <url>%2Fbzoj1085%2F</url>
    <content type="text"><![CDATA[Bzoj 1085这种限制步数的题目可以用迭代加深搜索做。并且这种只有一个空格的题目，一般就是用空格的坐标去遍历其他有东西的坐标，然后相当于东西的移动。本题直接DFS超时严重，样例都过不了。我们考虑加一个估价函数剪枝：当前步数$+$当前状态和目标状态棋盘上的差异数(具体看代码)$&lt;$迭代加深的步数之后就很快了 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 5; const int gl[MAXN + 2][MAXN + 2] = { {1, 1, 1, 1, 1}, {0, 1, 1, 1, 1}, {0, 0, 2, 1, 1}, {0, 0, 0, 0, 1}, {0, 0, 0, 0, 0} }; const int dx[8] = {1, 2, -1, 2, -2, 1, -1, -2}; const int dy[8] = {2, 1, 2, -1, 1, -2, -2, -1}; int a[MAXN + 2][MAXN + 2]; int kx, ky, flag; char s[MAXN]; bool check() { if (a[2][2] != 2) return false; for (int i = 0; i &lt; MAXN; i++) for (int j = 0; j &lt; MAXN; j++) if (gl[i][j] != a[i][j]) return false; return true; } bool gv(int st, int k) { int tot = 0; for (int i = 0; i &lt; MAXN; i++) for (int j = 0; j &lt; MAXN; j++) if (gl[i][j] != a[i][j]) tot++; if (st + tot &gt; k) return false; return true; } void dfs(int x, int y, int st, int k) { if (flag) return ; if (check()) {flag = true; return ;} if (st &gt;= k) return ; for (int i = 0; i &lt; 8; i++) { int tx = x + dx[i], ty = y + dy[i]; if (tx &gt;= 0 &amp;&amp; ty &gt;= 0 &amp;&amp; tx &lt; MAXN &amp;&amp; ty &lt; MAXN) { swap(a[x][y], a[tx][ty]); if (gv(st, k)) dfs(tx, ty, st + 1, k); swap(a[x][y], a[tx][ty]); } } } void clean() { flag = kx = ky = 0, ms(a, 0); } void solve() { clean(); for (int i = 0; i &lt; MAXN; i++) { scanf(&quot;%s&quot;, s); for (int j = 0; j &lt; MAXN; j++) { if (s[j] == &#39;0&#39;) a[i][j] = 0; else if (s[j] == &#39;1&#39;) a[i][j] = 1; else if (s[j] == &#39;*&#39;) a[i][j] = 2, kx = i, ky = j; } } for (int i = 1; i &lt;= 15; i++) { dfs(kx, ky, 0, i); if (flag) { printf(&quot;%d\n&quot;, i); return ; } } if (!flag) printf(&quot;-1\n&quot;); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif int T; scanf(&quot;%d&quot;, &amp;T); while (T--) solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>IDA*</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 3175」「网络流 24 题」骑士共存问题(二分图最大独立集)]]></title>
    <url>%2Fbzoj3175%2F</url>
    <content type="text"><![CDATA[bzoj 3175网络流24题 骑士共存问题本来认为连边只连下面然后就是是DAG上的最小路径覆盖。。但是这样做有BUG。。想想也知道Bzoj 2150都保证不能返回才构成DAG，否则也不行 但是这其实是求二分图最大独立集，8个方向连边，然后答案就是 总结点数 $-$ (最大匹配$/2$) 注意到这题$n=200, n^2=40000$，$40000^2$很容易TLE，如果用匈牙利时间复杂度很悬，vector存正向边会TLE，只能反向。。注意G[u].size()是unsigned int，先用int类型的siz存下来，再循环，否则等于0的时候减一就溢出了匈牙利算法： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int dx[4] = {1, 2, 1, 2}; const int dy[4] = {-2, -1, 2, 1}; const int MAXN = 200 + 5; int n, mp[MAXN][MAXN], num[MAXN][MAXN]; vector&lt;int&gt; G[MAXN * MAXN]; int cnt, newn, lk[MAXN * MAXN], vis[MAXN * MAXN]; char s[MAXN]; bool hungary(int u) { int siz = G[u].size(); for (int i = siz - 1; i &gt;= 0; i--) { int v = G[u][i]; if (vis[v] != cnt) { vis[v] = cnt; if (!lk[v] || hungary(lk[v])) { lk[v] = u; return true; } } } return false; } void clean() { newn = 0; for (int i = 0; i &lt;= n * n; i++) lk[i] = vis[i] = 0, G[i].clear(); } void solve() { clean(); for (int i = 1; i &lt;= n; i++) { scanf(&quot;%s&quot;, s + 1); for (int j = 1; j &lt;= n; j++) { if (s[j] == &#39;0&#39;) mp[i][j] = 0, num[i][j] = ++newn; else mp[i][j] = 1; } } for (int x = 1; x &lt;= n; x++) { for (int y = 1; y &lt;= n; y++) if (!mp[x][y]) { for (int i = 0; i &lt; 4; i++) { int tx = x + dx[i], ty = y + dy[i]; if (tx &amp;&amp; ty &amp;&amp; tx &lt;= n &amp;&amp; ty &lt;= n &amp;&amp; !mp[tx][ty]) G[num[x][y]].push_back(num[tx][ty]), G[num[tx][ty]].push_back(num[x][y]); } } } int ans = 0; for (int i= 1; i &lt;= newn; i++) { if (hungary(cnt = i)) ans++; } printf(&quot;%d\n&quot;, newn - ans / 2); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif scanf(&quot;%d&quot;, &amp;n), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 3170」「Tjoi2013」松鼠聚会(切比雪夫距离转曼哈顿距离)]]></title>
    <url>%2Fbzoj3170%2F</url>
    <content type="text"><![CDATA[bzoj 3170题意：有$N$个小松鼠，它们的家用一个点$x,y$表示，两个点的距离定义为：点$(x,y)$和它周围的$8$个点即上下左右四个点和对角的四个点，距离为$1$。现在$N$个松鼠要走到一个松鼠家去，求走过的最短距离。 只走八个方向的距离为切比雪夫距离。切比雪夫距离转曼哈顿距离：将原来的$(x,y)$转化为$(x+y,x-y)$曼哈顿距离转切比雪夫距离：将原来的$(x,y)$转化为$(\frac{x+y}{2},\frac{x-y}{2})$可用曼哈顿的展开式证明 所以这题转化以后，就变为了求一个点到其他点的曼哈顿距离和最小是多少。考虑枚举这个点，然后分别对于$x,y$拆绝对值式子算值，然后取$\min$即可。这里要先将坐标转化为$(x+y,x-y)$，然后最后答案除以二即可。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL MAXN = 100000 + 5; struct xx { LL x, pos; bool operator &lt; (const xx &amp;rhs) const {return x &lt; rhs.x;} } x[MAXN]; struct yy { LL y, id; bool operator &lt; (const yy &amp;rhs) const {return y &lt; rhs.y;} } y[MAXN]; LL n, pre_x[MAXN], pre_y[MAXN]; void clean() { ms(pre_x, 0), ms(pre_y, 0); } int solve() { clean(); scanf(&quot;%lld&quot;, &amp;n); for (LL i = 1; i &lt;= n; ++i) { scanf(&quot;%lld%lld&quot;, &amp;x[i].x, &amp;y[i].y); LL tmp1 = x[i].x + y[i].y, tmp2 = x[i].x - y[i].y; x[i].x = tmp1, y[i].y = tmp2; y[i].id = i; } sort(y + 1, y + 1 + n); for (LL i = 1; i &lt;= n; ++i) x[y[i].id].pos = i; sort(x + 1, x + 1 + n); for (LL i = 1; i &lt;= n; ++i) pre_x[i] = pre_x[i - 1] + x[i].x, pre_y[i] = pre_y[i - 1] + y[i].y; LL ans = 2223372036854775808ll; for (LL p = 1; p &lt;= n; ++p) { LL tmp1 = p * x[p].x - pre_x[p]; tmp1 += pre_x[n] - pre_x[p] - (n - p) * x[p].x; LL py = x[p].pos; LL tmp2 = py * y[py].y - pre_y[py]; tmp2 += pre_y[n] - pre_y[py] - (n - py) * y[py].y; tmp1 += tmp2; ans = min(ans, tmp1); } cout &lt;&lt; ans / 2ll; return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>前缀和</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bzoj 2150(DAG的最小不相交路径覆盖)]]></title>
    <url>%2Fbzoj2150%2F</url>
    <content type="text"><![CDATA[Bzoj 2150用二分图最大匹配求DAG的最小不相交路径覆盖，答案为 原图的节点数 $-$ 新图的二分图最大匹配。算是模板题，注意高山不能算点，要注意特判，具体解法看这里 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define Uint unsigned int #define db double using namespace std; const int MAXN = 50 + 5; int dx[4], dy[4]; int mp[MAXN][MAXN], num[MAXN][MAXN], m, n, R, C; char s[MAXN]; int cnt, newn, lk[MAXN * MAXN], vis[MAXN * MAXN]; vector&lt;int&gt; G[MAXN * MAXN]; bool hungary(int u) { for (Uint i = 0; i &lt; G[u].size(); i++) { int v = G[u][i]; if (vis[v] != cnt) { vis[v] = cnt; if (!lk[v] || hungary(lk[v])) { lk[v] = u; return true; } } } return false; } void clean() { newn = 0, ms(mp, 0), ms(num, 0); for (int i = 0; i &lt;= n * n; i++) G[i].clear(), lk[i] = vis[i] = 0; } void solve() { clean(); for (int i = 1; i &lt;= m; i++) { scanf(&quot;%s&quot;, s + 1); for (int j = 1; j &lt;= n; j++) { if (s[j] == &#39;x&#39;) mp[i][j] = 1; else num[i][j] = ++newn; //坐标转顶点编号新技巧，这里不能再用坐标转编号的数学方法了，因为是高山的话这里在新图中不算是一个点 } } dx[0] = R, dx[1] = R, dx[2] = C, dx[3] = C; dy[0] = -C, dy[1] = C, dy[2] = -R, dy[3] = R;//偏移坐标 for (int i = 1; i &lt;= m; i++) { for (int j = 1; j &lt;= n; j++) { if (!mp[i][j]) for (int qaq = 0; qaq &lt; 4; qaq++) { int tx = dx[qaq] + i, ty = dy[qaq] + j; if (tx &gt; 0 &amp;&amp; ty &gt; 0 &amp;&amp; tx &lt;= m &amp;&amp; ty &lt;= n &amp;&amp; !mp[tx][ty]) G[num[i][j]].push_back(num[tx][ty]); } } } int ans = 0; for (int i = 1; i &lt;= newn; i++) { if (hungary(cnt = i)) ans++; } printf(&quot;%d\n&quot;, newn - ans); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif scanf(&quot;%d%d%d%d&quot;, &amp;m, &amp;n, &amp;R, &amp;C), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1059」「ZJOI2007」矩阵游戏 (二分图最大匹配)]]></title>
    <url>%2Fbzoj1059%2F</url>
    <content type="text"><![CDATA[Bzoj 1059想算法的时候自己多搞几个数据找一找规律和结论，特别是这种看起来就会有规律和结论的题目，很重要！通过搞几个数据，发现：在同行同列的两个$1$，它们对答案的贡献是相同的，因为无论怎么调换，这两个$1$都会在同行同列。又因为要对角线上都是$1$，所以问题转化为：找到$n$个点使得这$n$个点不在同行同列上。这样我们把$x$坐标弄到左边，$y$坐标弄到右边，如果$(i,j)=1$，在左边$i$连一条边到右边$j$，然后做一个二分图最大匹配，如果不能全部都匹配，就不能完成了 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 200 + 5; vector&lt;int&gt; G[MAXN]; int cnt, n, lk[MAXN], vis[MAXN]; bool hungary(int u) { for (int i = 0; i &lt; G[u].size(); i++) { int v = G[u][i]; if (vis[v] != cnt) { vis[v] = cnt; if (!lk[v] || hungary(lk[v])) { lk[v] = u; return true; } } } return false; } void clean() { for (int i = 0; i &lt;= n; i++) lk[i] = vis[i] = 0, G[i].clear(); } void solve() { scanf(&quot;%d&quot;, &amp;n); clean(); for (int i = 1; i &lt;= n; i++) { for (int x, j = 1; j &lt;= n; j++) { scanf(&quot;%d&quot;, &amp;x); if (x == 1) G[i].push_back(j); } } for (int i = 1; i &lt;= n; i++) { if (!hungary(cnt = i)) { printf(&quot;No\n&quot;); return ; } } printf(&quot;Yes\n&quot;); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif int T; scanf(&quot;%d&quot;, &amp;T); while (T--) solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分图 学习笔记]]></title>
    <url>%2Fsz%E4%BA%8C%E5%88%86%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[模板及讲解二分图相关定义二分图：对于某无向图 ，若它的顶点可以划分为两个互不相交的子集 ，且每条边的两端点分别属于两子集 ，则称该图为二分图（二分图）匹配：选择一个 边集 ，使得任意边 不存在重复的顶点 ，称该边集为该（二分）图的一个 匹配 。极大匹配：对于一个匹配，若无法在原图中找到任意边加入匹配，则称该匹配为一个极大匹配。最大匹配：一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配 。交替路：从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边 …形成的路径叫 交替路 。增广路：对于一条路径，从一个未匹配点出发，走交替路，终止于另一个未匹配点 ，则这条交替路称为增广路 增广路的性质：1、具有奇数条边2、起点和终点均为未配对点3、整条路径上奇数边均不在原匹配中，偶数边均在原匹配中 二分图的最大匹配普通网络流做法$O(n \sqrt{m})$：dinic虽是$O(n^2m)$的，但是做二分图被证明了复杂度为$O(n \sqrt{m})$，详情做法看最大流最小割 算法笔记 匈牙利算法做法$O(nm)$：算法思路大致为(具体实现看相关代码)：先枚举每个左边点DFS找右边点匹配，如果当期右边点没有被匹配，就匹配；如果被匹配了，就继续DFS这个右边点匹配的左边点找另外的点匹配，如果找得到，就完成匹配；找不到，就不能够匹配了比较”专业”的说法：找到一未配对点$ u$，从 $u $为端点的边中任选一条尝试配对（令其另一端点为$ v$），若此时$ v$ 未配对，则配对成功，答案更新。若点$ v$ 已经被配对，就尝试从$ v $出发“扩展”该交替路，执行递归操作，尝试找到一条增广路，若成功，对该增广路取反，即回溯更新配对关系。若失败，则尝试换一条以 $u$ 为端点的边重复操作，直至$ u$ 配对成功或全部尝试过为止。对所有剩下的未配对点进行操作，直至尝试完毕所有点，找不到增广路为止，此时找到原图最大匹配~ 二分图的最小点覆盖定义：假如选了一个点就相当于覆盖了以它为端点的所有边。最小顶点覆盖就是选择最少的点来覆盖所有的边。解法：二分图最大匹配 $=$ 二分图最小点覆盖(König 定理)因为如果该图还会有边没覆盖到，二分图的当前匹配就不是最大匹配。因为二分图匹配必须有一条边的两端都能让出位置才能匹配。二分图的最大独立集定义：选出一些顶点使得这些顶点两两不相邻，则这些点构成的集合称为独立集。找出一个包含顶点数最多的独立集称为最大独立集。解法：最大独立集 $=$ 所有顶点数 $-$ 最小顶点覆盖(匈牙利算法：最大独立集 $=$ 所有顶点数 $-$最小顶点覆盖$/2$，因为匈牙利算法是针对有向边的而最大独立集的边是无向边)这个比较显然， 最小顶点覆盖把所有边的一个顶点都算上了，其他点不会再有相邻的二分图的最大团定义：对于一般图来说，团是一个顶点集合，且由该顶点集合诱导的子图是一个完全图，简单说，就是选出一些顶点，这些顶点两两之间都有边。最大团就是使得选出的这个顶点集合最大。对于二分图来说，我们默认为左边的所有点之间都有边，右边的所有顶点之间都有边。那么，实际上，我们是要在左边找到一个顶点子集X，在右边找到一个顶点子集Y，使得X中每个顶点和Y中每个顶点之间都有边。解法：二分图的最大团 $=$ 补图的最大独立集补图的定义：对于二分图中左边一点$x$和右边一点$y$，若$x$和$y$之间有边，那么在补图中没有，否则有。因为最大独立集是两两不相邻，所以最大独立集的补图两两相邻。DAG的最小不相交路径覆盖定义：在一个有向图中，找出最少的路径，使得这些路径经过了所有的点，且这些路径不可以相交。不相交即任何一个顶点有且只有一条路径与之关联。解法：把一个点$A$拆成$A_1, A_2$，如果$A-&gt;B$，那么$A_1-&gt;B_2$。然后对新图进行二分图最大匹配，答案为 原图的节点数 $-$ 新图的二分图最大匹配因为先假设图中的点都是独立的一条路径，而二分图最大匹配的过程就是把这些路径连起来。DAG的最小可相交路径覆盖定义：在一个有向图中，找出最少的路径，使得这些路径经过了所有的点，这些路径可以相交。解法：算出图的连通性$G$，把一个点$A$拆成$A_1, A_2$，如果$G(A, B) = 1$，那么$A_1-&gt;B_2​$，转化为DAG的最小不相交路径覆盖(以上部分内容转自此处或此处) Dilworth 定理参见Luogu 4934 模型行列匹配法(连边代表点思想)有很多箭，每根箭可以杀死一行或者一列的敌人，我们要杀死所有的敌人至要用到几根箭？解：每个敌人的坐标$(x, y)$建图，由左边$x$连向右边$y$，然后求最小顶点覆盖即可。因为这个图中的一条边$(x, y)$相当于原来的$(x, y)$处的敌人，所以覆盖所有边即可以全部杀死。例题: Bzoj 1059, caioj 1126 黑白染色法(匹配思想)给出一个网格图，棋盘有些格子是不能放东西的。现在要判断在所以可以放东西的格子上是否能用$1 \times 2$的小方块填满。解：将图黑白染色，即相邻的格子颜色不同(黑白相间)。本题就是相当于将白格和黑格进行匹配，连边二分图，然后求出最大匹配即可。但是最大匹配后可能还会有$1 \times 1$的小方块不在匹配中，要验证答案。例题: poj 2446 反建法(逆向思维)也就是依据题目要求的答案反着建图。 拆点法见最小路径覆盖。 一行变多行，一列变多列法例题: Hdu 1045 常见题型1、求二分图的最大匹配Q: 给定一个二分图，求它的最大匹配解: 见解析例题:Bzoj 11912、求二分图最小点覆盖Q: 给定一个二分图，求它的最小点覆盖解: 见解析例题:caioj 11253、求二分图的最大独立集Q: 给定一个二分图，求它的最大独立集解: 见解析例题:4、二分图的最大团Q: 给定一个二分图，求它的最大团解: 见解析例题:5、DAG的最小不相交路径覆盖(拆点)Q: 给定一个DAG图，求它最小不相交路径覆盖解: 见解析例题:Bzoj 21506、DAG的最小可相交路径覆盖(拆点)Q: 给定一个DAG图，求它最小可相交路径覆盖解: 见解析例题:7、行列匹配法(模型, 以上题型为基础题型)Q: 有很多箭，每根箭可以杀死一行或者一列的敌人，我们要杀死所有的敌人至要用到几根箭？解: 见解析例题: Bzoj 1059, caioj 11267、黑白染色法Q: 见解析解: 见解析例题: poj 24468、反建法Q: 见解析解: 见解析例题:9、拆点法Q: 见解析解: 见解析例题: Bzoj 215010、一行变多行，一列变多列法Q: 见解析解: 见解析例题: Hdu 1045二分图匈牙利算法(Bzoj 1191)： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 1000 + 5; int cnt, n, m, lk[MAXN], vis[MAXN]; //lk[u]=i: 右边的u点被左边的i点匹配 //vis[u]=i: 第i轮左边的u点被尝试更改(不设为bool是因为这样免去每次重置数组) vector&lt;int&gt; G[MAXN]; //记录左边点-&gt;右边点的边 bool hungary(int u) { for (int i = 0; i &lt; G[u].size(); i++) {//枚举每个右边的点匹配 int v = G[u][i]; if (vis[v] != cnt) {//尝试修改过的节点就不需要遍历了 vis[v] = cnt; if (!lk[v] || hungary(lk[v])) { //如果枚举的右边点没被匹配，就可以直接匹配。如果已经被匹配了，那么就让之前 //匹配这个右边点的左边点去匹配另一个点，让这个点去匹配这个右边点。 //这里运用了||的性质，||左边如果为true就不在执行||右边的表达式 lk[v] = u; return true;//成功匹配 } } } return false; } void clean() { for (int i=0;i&lt;=max(n, m);i++) vis[i] = lk[i] = 0, G[i].clear(); } void solve() { clean(); for (int a, b, i = 1; i &lt;= m; i++) {//可以把u, v压行qwq scanf(&quot;%d%d&quot;, &amp;a, &amp;b); G[i].push_back(a), G[i].push_back(b); } int ans = 0; for (int i = 1; i &lt;= m; i++) { if (hungary(cnt = i)) ans++; else break;//枚举每个左边的点匹配，如果一道题不能做出来就要break，因为不能进入下一关了，而正常二分图最大匹配这样写是不行的 } printf(&quot;%d\n&quot;, ans); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif scanf(&quot;%d%d&quot;, &amp;n, &amp;m), solve(); return 0; }]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>二分图</tag>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1191」「HNOI2006」超级英雄Hero (二分图最大匹配)]]></title>
    <url>%2Fbzoj1191%2F</url>
    <content type="text"><![CDATA[Bzoj 1191二分图最大匹配裸题，具体看这里 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 1000 + 5; int cnt, n, m, lk[MAXN], vis[MAXN]; //lk[u]=i: 右边的u点被左边的i点匹配 //vis[u]=i: 第i轮左边的u点被尝试更改(不设为bool是因为这样免去每次重置数组) vector&lt;int&gt; G[MAXN]; //记录左边点-&gt;右边点的边 bool hungary(int u) { for (int i = 0; i &lt; G[u].size(); i++) {//枚举每个右边的点匹配 int v = G[u][i]; if (vis[v] != cnt) {//尝试修改过的节点就不需要遍历了 vis[v] = cnt; if (!lk[v] || hungary(lk[v])) { //如果枚举的右边点没被匹配，就可以直接匹配。如果已经被匹配了，那么就让之前 //匹配这个右边点的左边点去匹配另一个点，让这个点去匹配这个右边点。 //这里运用了||的性质，||左边如果为true就不在执行||右边的表达式 lk[v] = u; return true;//成功匹配 } } } return false; } void clean() { for (int i=0;i&lt;=max(n, m);i++) vis[i] = lk[i] = 0, G[i].clear(); } void solve() { clean(); for (int a, b, i = 1; i &lt;= m; i++) {//可以把u, v压行qwq scanf(&quot;%d%d&quot;, &amp;a, &amp;b); G[i].push_back(a), G[i].push_back(b); } int ans = 0; for (int i = 1; i &lt;= m; i++) { if (hungary(cnt = i)) ans++; else break;//枚举每个左边的点匹配，如果一道题不能做出来就要break，因为不能进入下一关了，而正常二分图最大匹配这样写是不行的 } printf(&quot;%d\n&quot;, ans); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif scanf(&quot;%d%d&quot;, &amp;n, &amp;m), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1090」「SCOI2003」字符串折叠 (区间DP)]]></title>
    <url>%2Fbzoj1090%2F</url>
    <content type="text"><![CDATA[Bzoj 1090这题和Bzoj 1068差不多，但是简单一些，1068的一个M对应很多R，而1090括号一一对应，使得这题的转移变得非常简单了。设$f(i,j)$为$[i,j]$折叠后的长度(包括括号的长度)考虑枚举中间点，$f(i,j)=min(f(i,k)+f(k+1,j))$而只压缩前后的情况，由于括号一一对应，所以这些情况都在上面的情况之中了，不同于1068而整个区间压缩，$f(i,j)=min(f(i,i+k-1)+cal(len/k)$，其中$len=j-i+1$.当且仅当$[i,j]$为长为$k$的子串循环而来，$cal(k)$用来计算括号的长度边界值：$f(i,i)=1$，所有$f(i,j)$初始化为$j-i+1$然后就可以DP了，同样记忆化搜索好写一些，用记忆化，不用考虑枚举顺序 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 100 + 5; char s[MAXN]; int n, f[MAXN][MAXN]; int cal(int x) {//返回括号占位 if (x == 1) return 0; if (x &lt; 10) return 1 + 2; if (x &lt; 100) return 2 + 2; return 3 + 2; } bool check(int i, int j, int k) {//是否是长为k的子串循环而来 int len = j - i + 1; if (len % k != 0 || i + k - 1 &gt; n) return false; for (int a = 1; a &lt; len / k; a++) { for (int b = 1; b &lt;= k; b++) { if (s[i + b - 1] != s[i + b + a * k - 1]) return false; } } return true; } int dp(int i, int j) { int len = j - i + 1, tmp = len; if (f[i][j] &gt;= 0) return f[i][j]; if (len == 1) return f[i][j] = 1; for (int k = i; k &lt; j; k++) tmp = min(tmp, dp(i, k) + dp(k + 1, j)); for (int k = 1; k &lt;= len / 2; k++) if (check(i, j, k)) tmp = min(tmp, dp(i, i + k - 1) + cal(len / k)); return f[i][j] = tmp; } void clean() { ms(f, -1); } void solve() { clean(); n = strlen(s + 1); printf(&quot;%d\n&quot;, dp(1, n)); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif scanf(&quot;%s&quot;, s + 1), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1068」「SCOI2007」压缩 (区间DP)]]></title>
    <url>%2Fbzoj1068%2F</url>
    <content type="text"><![CDATA[Bzoj 1068区间划分DP，按照压缩前后，只压缩前，只压缩后，压缩整个的思路来做，具体看下面图片，代码中也有注释。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 50 + 5; char s[MAXN]; int n, f[MAXN][MAXN][2]; //f(i,j,0/1)表示[i,j]中不含有/可能含有&quot;M&quot;, 且i和i-1之间有一个&quot;M&quot;(&quot;M&quot;的长度不计入当前状态)时的压缩长度 bool isTheSame(int a, int b) {//是否满足 [a, M] = [M+1, b] int len = b - a + 1; if (len &amp; 1) return false; for (int i=1;i&lt;=len/2;i++) { if (s[i + a - 1] != s[i + a - 1 + len / 2]) return false; } return true; } int dp(int i, int j, int t) { int len = j - i + 1, tmp = len; if (f[i][j][t] &gt;= 0) return f[i][j][t]; if (len == 1) return f[i][j][t] = 1; //前一段 后一段 都压缩 if (t) for (int k=i;k&lt;j;k++) tmp = min(tmp, dp(i, k, 1) + 1 + dp(k + 1, j, 1)); //只压缩前一段 for (int k=i;k&lt;j;k++) tmp = min(tmp, dp(i, k, t) + j - k); if (t) for (int k=i;k&lt;j;k++) tmp = min(tmp, dp(i, k, 0) + j - k);//可写可不行，dp(i,k,0)包含在了dp(i,k,1)中 //只压缩后一段 if (t) for (int k=i;k&gt;j;k++) tmp = min(tmp, dp(i, j, 1) + 1 + k - i + 1);//可写可不行，这种情况包含在了 都压缩 的情况中 //特殊 if (isTheSame(i, j)) tmp = min(tmp, dp(i, i + len / 2 - 1, 0) + 1);//串是由相同的两段组成的，直接放R return f[i][j][t] = tmp; } void clean() { ms(f, -1); } void solve() { clean(); n = strlen(s + 1); printf(&quot;%d\n&quot;, dp(1, n, 1)); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif scanf(&quot;%s&quot;, s + 1), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[背包DP 学习笔记]]></title>
    <url>%2Fsz%E8%83%8C%E5%8C%85DP%2F</url>
    <content type="text"><![CDATA[模板及讲解大部分文字来自 背包九讲。 完全背包问题 有$ N $种物品和一个容量为$ V $的背包，每种物品都有无限件可用。放入第$ i $种物品的费用是$ C_i $，价值是$ W_i $。求解：将哪些物品装入背包，可使这些物品的耗费的费用总和不超过背包容量，且价值总和最大。 基本方程令$ F [i, v] $表示前$ i $种物品恰放入一个容量为$ v $的背包的最大权值。$F [i, v] = max(F [i − 1, v − kC_i] + kW_i |0 ≤ kC_i ≤ v)$ 转化 01 背包把第$ i $种物品拆成费用为$ C_i2^k$、价值为$ W_i2^k $的若干件物品$(C_i2^k ≤ V)$这是二进制的思想。因为，不管最优策略选几件第$ i $种物品，其件数写成二进制后，总可以表示成若干个$ 2^k $件物品的和。这样一来就把每种物品拆成$ O(log ⌊V /Ci⌋) $件物品然后可以运用这些物品做 01 背包。 O(VN) 算法$F [i, v] = max(F [i − 1, v], F [i, v − C_i] + W_i)$ 多重背包问题 有$N$种物品和一个容量为$V $的背包。第$i$种物品最多有$M_i$件可用，每件耗费的空间是$C_i$，价值是$W_i$。求解将哪些物品装入背包可使这些物品的耗费的空间总和不超过背包容量，且价值总和最大。 基本方程令$F [i, v]​$表示前$i​$种物品恰放入一个容量为$v​$的背包的最大价值$F [i, v] = max(F [i − 1, v − kC_i] + kW_i | 0 ≤ k ≤ M_i)$ 转化 01 背包把每个物品拆成带权$2^0,2^1,2^2,……,2^{k-1},M_i-2^k+1$的物品，然后做 01 背包即可。 O(VN) 算法单调队列优化混合三种背包问题for (int i = 1; i &lt;= n; i++) { if (i 是 01 背包) 做 01 背包; else if (i 是 完全背包) 做完全背包; else if (i 是 多重背包) 做多重背包; } 分组背包基本方程解决什么问题每组之间独立，每组只选一个。那么如果我们做 01 背包时发现有物品不止一个值，并且这个值可以全部暴力算出来，那么我们可以暴力算出来一个物品所有取值，然后分组地取。 例题：CF 946D 意思就是逃课。怎样逃课才能使得最后上完课的时间减去最开始的上课的时间最短。这里是按$0$和$1$来代表有没有课，$1$代表有课，可以逃。但是最多只能逃$k$节课。 发现可以 DP，但是真心不会转移怎么办？我们看每天，逃不同数量的课有不同的收益。所以我们把一天看成一组，预处理逃不同数量的课有不同的收益，做一个分组背包即可。]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>背包DP</tag>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1079」「SCOI2008」着色方案 (DP+乘法原理)]]></title>
    <url>%2Fbzoj1079%2F</url>
    <content type="text"><![CDATA[Bzoj 1079这种题目还是往DP和排列组合想。直接存颜色用了多少是$5^{15}$的，会炸。我们选择把剩余可涂次数相等的分为一类，考虑因为只要剩余可涂次数相等，那么其实这些颜色并没有什么区别，因为我们涂颜色的时候只需要考虑涂的这种颜色剩余次数即可，并不需要考虑具体是什么颜色（先不考虑相邻颜色不能相等的限制）。那么令$f(a1, a2, a3, a4, a5)$表示剩余可涂一次的颜色种类数为$a1$，涂二次颜色种类数为$a2$…这样的情况的方案数。 显然如果我们当前这次选的是剩余次数为$x$次的颜色，那么剩余次数为$x$次的颜色有多少种，就有多少种情况可以转移过来，只需要乘以数量就可以了（相当于每个格都可以填这些颜色）。 但是我们还没考虑相邻不能相等的情况，那么我们必须要少算一次，比如说如果上次填的是颜色剩余次数为2的，意味着颜色中剩余次数为1的多了一个，那么这一次并不能再选这种颜色，这次可以选填1的就要少1。以上转自此处2018/12/29 ：重写 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;set&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const LL MO = 1000000007; LL k, whw[20]; LL f[16][16][16][16][16][6], vis[16][16][16][16][16][6]; LL dp(LL a, LL b, LL c, LL d, LL e, LL lst) { if (a == 0 &amp;&amp; b == 0 &amp;&amp; c == 0 &amp;&amp; d == 0 &amp;&amp; e == 0) return 1ll; if (vis[a][b][c][d][e][lst]) return f[a][b][c][d][e][lst]; if (a &gt; 0) f[a][b][c][d][e][lst] += (a - (lst == 2)) * dp(a - 1, b, c, d, e, 1) % MO, f[a][b][c][d][e][lst] %= MO; if (b &gt; 0) f[a][b][c][d][e][lst] += (b - (lst == 3)) * dp(a + 1, b - 1, c, d, e, 2) % MO, f[a][b][c][d][e][lst] %= MO; if (c &gt; 0) f[a][b][c][d][e][lst] += (c - (lst == 4)) * dp(a, b + 1, c - 1, d, e, 3) % MO, f[a][b][c][d][e][lst] %= MO; if (d &gt; 0) f[a][b][c][d][e][lst] += (d - (lst == 5)) * dp(a, b, c + 1, d - 1, e, 4) % MO, f[a][b][c][d][e][lst] %= MO; if (e &gt; 0) f[a][b][c][d][e][lst] += (e) * dp(a, b, c, d + 1, e - 1, 5) % MO, f[a][b][c][d][e][lst] %= MO; vis[a][b][c][d][e][lst] = 1; return f[a][b][c][d][e][lst]; } void clean() { ms(whw, 0), ms(f, 0), ms(vis, 0); } int solve() { clean(); cin &gt;&gt; k; for (LL x, i = 1; i &lt;= k; ++i) cin &gt;&gt; x, ++whw[x]; cout &lt;&lt; dp(whw[1], whw[2], whw[3], whw[4], whw[5], 0); return 0; } } int main() { flyinthesky::solve(); return 0; } #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MO = 1000000007; int k, xi[6], mk[16][16][16][16][16][6]; LL dp[16][16][16][16][16][6]; LL dfs(int a1, int a2, int a3, int a4, int a5, int last) { if (!(a1 || a2 || a3 || a4 || a5)) return 1; if (mk[a1][a2][a3][a4][a5][last]) return dp[a1][a2][a3][a4][a5][last]; LL tot = 0; if (a1) tot = (tot + (a1 - (last == 2)) * dfs(a1 - 1, a2, a3, a4, a5, 1)) % MO; if (a2) tot = (tot + (a2 - (last == 3)) * dfs(a1 + 1, a2 - 1, a3, a4, a5, 2)) % MO; if (a3) tot = (tot + (a3 - (last == 4)) * dfs(a1, a2 + 1, a3 - 1, a4, a5, 3)) % MO; if (a4) tot = (tot + (a4 - (last == 5)) * dfs(a1, a2, a3 + 1, a4 - 1, a5, 4)) % MO; if (a5) tot = (tot + a5 * dfs(a1, a2, a3, a4 + 1, a5 - 1, 5)) % MO;//-(last == x)就是防止两种颜色涂在一起 mk[a1][a2][a3][a4][a5][last] = true; return dp[a1][a2][a3][a4][a5][last] = tot; } void clean() { ms(mk, false), ms(dp, 0), ms(xi, 0); } void solve() { clean(); for (int i=1;i&lt;=k;i++) { int x; scanf(&quot;%d&quot;, &amp;x); xi[x]++; } printf(&quot;%lld\n&quot;, dfs(xi[1], xi[2], xi[3], xi[4], xi[5], 0)); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif scanf(&quot;%d&quot;, &amp;k), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>计数DP</tag>
        <tag>计数原理</tag>
        <tag>Bzoj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj 1655(树形DP求重心)]]></title>
    <url>%2Fpoj1655%2F</url>
    <content type="text"><![CDATA[poj 1655求树的重心，具体解法看这里之前题看错了，以为第一个要求重心的个数，其实不是。。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 20000 + 5, INF = 1000000000; vector&lt;int&gt; G[MAXN]; int n, ans1, ans2, siz[MAXN]; void dfs(int u, int fa) { int blc = 0; siz[u] = 1; for (int i=0;i&lt;G[u].size();i++) { int v = G[u][i]; if (v != fa) { dfs(v, u); siz[u] += siz[v]; blc = max(blc, siz[v]); } } blc = max(blc, n - siz[u]); if (ans2 &gt; blc) ans2 = blc, ans1 = u; } void clean() { ans2 = INF; for (int i=0;i&lt;=n;i++) G[i].clear(); } void solve() { clean(); scanf(&quot;%d&quot;, &amp;n); for (int i=1;i&lt;n;i++) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); G[x].push_back(y), G[y].push_back(x); } dfs(1, 0); printf(&quot;%d %d\n&quot;, ans1, ans2); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif int T; scanf(&quot;%d&quot;, &amp;T); while (T--) solve(); return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>树形DP</tag>
        <tag>树的重心</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1040」「ZJOI2008」骑士 (基环树DP)]]></title>
    <url>%2Fbzoj1040%2F</url>
    <content type="text"><![CDATA[bzoj 1040环套树DP相关解法本题$n$个点$n$条边，显然是基环树DP。然而没有保证整幅图都是连通的，所以这要处理一个基环树森林，每棵树树形DP后的答案累加即可，dp方程类似于没有丧尸上司的舞会 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 1000000 + 5; struct edge { int v; }ed[MAXN * 2]; int n, en, wi[MAXN], Pu, Pv, PE, vi[MAXN]; LL dp[MAXN][2]; vector&lt;int&gt; G[MAXN]; void ins(int a, int b) { en++, ed[en].v = b, G[a].push_back(en); } void tdp(int u, int fa) { dp[u][0] = 0, dp[u][1] = wi[u]; for (int i=0;i&lt;G[u].size();i++) { if (G[u][i] == PE || G[u][i] == (PE ^ 1)) continue;//已经断开，不能通过，否则有后效性 edge p = ed[G[u][i]]; int v = p.v; if (v != fa) { tdp(v, u); dp[u][0] += max(dp[v][0], dp[v][1]); dp[u][1] += dp[v][0]; } } } void dfs(int u, int fa) { for (int i=0;i&lt;G[u].size();i++) { edge p = ed[G[u][i]]; int v = p.v; if (v != fa) { if (!vi[v]) vi[v] = true, dfs(v, u); else Pu = u, Pv = v, PE = G[u][i];//找断开不构成环的边 } } } void clean() { en = -1;//边从0开始，方便找出该边的反边 for (int i=0;i&lt;=n;i++) vi[i] = false, G[i].clear(); } void solve() { clean(); for (int i=1;i&lt;=n;i++) { int x; scanf(&quot;%d%d&quot;, &amp;wi[i], &amp;x); ins(x, i), ins(i, x);//看似有向实质无向 } LL ans = 0; for (int i=1;i&lt;=n;i++) {//基环树森林一一处理 if (!vi[i]) { dfs(i, -1); tdp(Pu, -1); LL tmp = dp[Pu][0]; tdp(Pv, -1); tmp = max(tmp, dp[Pv][0]); ans += tmp; } } printf(&quot;%lld\n&quot;, ans); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif scanf(&quot;%d&quot;, &amp;n), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>树形DP</tag>
        <tag>基环树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树形DP 学习笔记]]></title>
    <url>%2Fsz%E6%A0%91%E5%BD%A2DP%2F</url>
    <content type="text"><![CDATA[模板及讲解树上背包问题：给$n$个物品，物品之间有依赖关系，每个物品有重量$w_i$和价值$v_i$，求取物品的最大价值。解：给定的是一个森林，我们要把森林的根节点全部连到$0$号节点，然后树形DP，设$dp(u, i)$为以$u$为根的子树必选$u$选$i$重量的物品时的最大价值，那么$dp(u, i) = dp(u, i-j) + dp(v, j)$，之后因为要必选$u$，所以大于$w_u$的$i$的$dp(u, i) = dp(u, i-w_u) + v_u$，小于$w_u$的$i$的$dp(u,i) = 0$. 树的重心(质心)问题：求出一棵无根树的某个点，使得这个点当做根以后最大子树的节点数最小解：求出每棵树的子树节点数$siz_u$，每个节点作为根时深度$blc=max(siz_v, n-siz_u)$，$v \in son(u)$,然后答案就是$min(blc)$ 性质：1把两个树通过一条边相连得到一个新的树，那么新的树的重心在连接原来两个树的重心的路径上。(用于合并信息的性质)2把一个树添加或删除一个叶子，那么它的重心最多只移动一条边的距离3去掉任意一个重心后，生成的各个块的节点数的最大值一定小于等于原树的节点数除以2。4以一棵树的重心为根的子树的节点个数，一定大于等于该树节点总数的一半。5在一棵树的所有子树中，找到某一子树，使得其节点数恰好大于等于原树节点总数一半，那么该子树的根一定是一个重心。(如果该节点不是重心，也就是把它去掉后产生的连通块中至少有一个节点个数大于原树节点个数的一半。) 45互逆 树的直径(最长路径, 最远点对)问题：求出树上最长的一条链解：两次 BFS。第一次随便找一个点 BFS 找到离这个点最远的那个点$u$，用$u$继续 BFS 找离这个点最远的那个点$v$，则链$uv$为树的直径 性质(直径常用反证矛盾法)：1距离树上任意节点最远的点 一定是树点直径的两个端点之一2以树的直径中点上的一点为根，将这颗无根树转化为有根树的话，这样做会使树的深度最小，且为树的直径的一半（向上取整）(因为如果有一个叶子节点比直径更深的话，那么就可以构成一个更长的直径，与假设矛盾。)3所有直径的中心相同，这个中心可以是一个顶点，也可以在一条边上。所有点到他的最远点都要通过这个中心4树的直径的端点必然是他的子树直径的端点(用于合并信息的性质)5有两棵树，如果把它们随意连一条边，会变成一棵树，新树的直径的端点一定是之前两棵树的直径的共4个端点的两个 树的最大独立集问题：解： 环套树DP基本思路：1、有可能是断环边后树处理：Bzoj 1040，NOIP2018Day2T12、有可能是找到唯一环后将这个环作为一个广义根，然后再结合环一起计算：Bzoj 1791 问题1：给定$n$个点，$n$条边，保证任意两点间至少存在一条路径。其中每个点均有其权值$v_i$，问如何选择点，使得在保证任意直接相连的两点不会同时被选中的情况下，被选中的点的权值和最大？解：对于一棵$n$个节点的树，必然有$n-1$条边，对于一个$n$个点$n$条边构成环的图，我们可以断开这条使得树变成环的边，然后用树形DP设$dp(u,0)$为以$u$为根的子树的最大权和并且不能选$u$, $dp(u,0)$为以$u$为根的子树的最大权和并且必选$u$。然后就对这条边的两个顶点进行两次树形DP，答案就是$max(dp(u, 0), dp(v, 0))$。(第一个是第一次DP的结果，第二个是第二次DP的结果)。为什么要进行两次DP呢，因为如果我们只DP$u$，那么选$u$的方案就不能得到(如果取01最大值，那样会有可能$u, v$同选，不满足题意)，就会漏解。 注意以下数据： 常见题型1、常规树形DPQ: 在树上的DP。解: 通常用dfs完成，从叶子推到根。例题: Bzoj 13692、树上背包Q: 见讲解解: 见讲解例题: Bzoj 24273、求树的重心Q: 见讲解解: 见讲解例题: Poj 16554、求树的直径Q: 见讲解解: 见讲解例题: 5、求树的最大独立集Q: 见讲解解: 见讲解例题: 6、环套树DP(标志：$n$个点$n$条边)Q: 见讲解解: 见讲解例题: Bzoj 10407、树上选点覆盖Q: Bzoj 1596解:$f(u, 0)$为不在$u$建基站，$u$与$u$的子树都有信号。$f(u, 1)$为在$u$建基站，$u$与$u$的子树都有信号。$f(u, 2)$为不在$u$建基站，$u$没有信号，$u$的子树都有信号。例题: Bzoj 1596]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>树形DP</tag>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1007」「HNOI2008」水平可见直线 (计算几何+单调栈)]]></title>
    <url>%2Fbzoj1007%2F</url>
    <content type="text"><![CDATA[BZOJ 1007其实是求一个半凸包(从左到右依次观察每条边和每个顶点，发现其斜率不断增大，顶点的横坐标也不断增大)，我们把直线按斜率$k$从小到大排，$k$一样$b$从大到小排。只处理$b$最大的那条直线，因为这样和之前的直线交点尽可能右。 我们维护一个单调栈$S$，如果当前直线i能完全覆盖栈顶直线$S_{top}$，则$i$与$S_{top}$的交点一定在$S_{top}$与$S_{top-1}$的交点左边或者重合。若在它左边或者重合，则弹出栈顶，直到交点在右边后，扔进栈里。最后栈中元素就是答案。 程序实现时，不直接放两个直线不用复杂判斜率相同！ 2019.1.5 重打： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 50000 + 5; const db eps = 1e-8; struct data { int k, b, id; bool operator &lt; (const data &amp;rhs) const { return (k == rhs.k) ? b &gt; rhs.b : k &lt; rhs.k; } }zx[MAXN]; db getCross(int a, int b) { return 1.0 * (zx[b].b - zx[a].b) / (zx[a].k - zx[b].k); } int n, top, s[MAXN], ans[MAXN]; void clean() { top = 0; ms(ans, 0); } int solve() { clean(); scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d%d&quot;, &amp;zx[i].k, &amp;zx[i].b), zx[i].id = i; sort(zx + 1, zx + 1 + n); s[++top] = 1; // 不直接放两个直线不用复杂判斜率 for (int i = 2; i &lt;= n; ++i) { if (fabs(zx[i].k - zx[i - 1].k) &lt; eps) continue ; if (top &lt;= 1) {s[++top] = i; continue ;} // 不直接放两个要特判 while ((top &gt; 1 &amp;&amp; getCross(s[top], s[top - 1]) - getCross(s[top], i) &gt; -eps)) --top; s[++top] = i; } for (int i = 1; i &lt;= top; ++i) ans[zx[s[i]].id] = 1; for (int i = 1; i &lt;= n; ++i) if (ans[i]) printf(&quot;%d &quot;, i); return 0; } } int main() { flyinthesky::solve(); return 0; } #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 50000 + 5; const db eps = 1e-8; int abss(int x) {return x &gt; 0 ? x : -x;} struct data { int k, b, id; bool operator &lt; (const data &amp;y) const { if (k == y.k) return b &gt; y.b; return k &lt; y.k; } }e[MAXN]; db getXPos(int a, int b) { return (db)(e[b].b - e[a].b) / (db)(e[a].k - e[b].k); } int n, top = 0, s[MAXN], ans[MAXN]; void clean() { top = 0, ms(s, 0), ms(ans, 0); } void solve() { clean(); for (int i=1;i&lt;=n;i++) scanf(&quot;%d%d&quot;, &amp;e[i].k, &amp;e[i].b), e[i].id = i; sort(e + 1, e + 1 + n); s[++top] = 1; for (int i=2;i&lt;=n;i++) { if (fabs(e[i].k - e[i - 1].k) &lt; eps) continue; while (top &gt; 1 &amp;&amp; getXPos(i, s[top]) &lt;= getXPos(s[top], s[top - 1])) top--; s[++top] = i; } while (top) ans[e[s[top--]].id] = 1; for (int i=1;i&lt;=n;i++) if (ans[i]) printf(&quot;%d &quot;, i); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif scanf(&quot;%d&quot;, &amp;n), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>计算几何</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1016」「JSOI2008」最小生成树计数 (最小生成树+乘法原理)]]></title>
    <url>%2Fbzoj1016%2F</url>
    <content type="text"><![CDATA[Bzoj 1016先看定理(转自discuss, 证明看原文)：定理一：如果 $A, B$ 同为 $G$ 的最小生成树，且 $A$ 的边权从小到大为 $w(a_1), w(a_2), w(a_3), \cdots w(a_n)$，$B$ 的边权从小到大为 $w(b_1), w(b_2), w(b_3), \cdots w(b_n)$，则有 $w(a_i) = w(b_i)$。定理二：如果 $A, B$ 同为 $G$ 的最小生成树，如果 $A, B$ 都从零开始从小到大加边（$A$ 加 $A$ 的边，$B$ 加 $B$ 的边）的话，每种权值加完后图的联通性相同。定理三：如果在最小生成树 $A$ 中权值为 $v$ 的边有 $k$ 条，用任意 $k$ 条权值为 $v$ 的边替换 $A$ 中的权为 $v$ 的边且不产生环的方案都是一棵合法最小生成树。 那么这题我们先做一次最小生成树，然后统计各种权值用的边数(用权值分组)，然后每组再dfs找出相应边数的边使得每一条边都可以使图的连通分量减少。然后每组的方案再乘法原理求。一个组的搜完了，还要把这个权值的边都连上，再搜下一次。 注意这时并查集不要路径压缩，因为dfs要回溯，此时并查集复杂度为$O(nlogn)$。还有图不连通的情况，这种情况不存在最小生成树，然后注意这题还要取模 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 100 + 5, MAXM = 1000 + 5, MO = 31011; struct data { int x, y, w; bool operator &lt; (const data &amp;b) const { return w &lt; b.w; } }e[MAXM], a[MAXM]; int cnt, n, m, f[MAXN]; LL sum; int find(int x) {return f[x] == x ? x : find(f[x]);}//不要路径压缩 void dfs(int tt, int a, int ed, int ys) { if (ys == tt) { sum++; return ; } if (a &gt; ed) return ; int x = find(e[a].x), y = find(e[a].y); if (x != y) { f[x] = y; dfs(tt, a + 1, ed, ys + 1); f[x] = x, f[y] = y;//并查集恢复 } dfs(tt, a + 1, ed, ys); } void clean() { cnt = 0; for (int i=1;i&lt;=n;i++) f[i] = i; } void solve() { clean(); for (int i=1;i&lt;=m;i++) scanf(&quot;%d%d%d&quot;, &amp;e[i].x, &amp;e[i].y, &amp;e[i].w); sort(e + 1, e + 1 + m); int tot = 0; for (int i=1;i&lt;=m;i++) { if (e[i].w != e[i - 1].w) a[++cnt].x = i, a[cnt - 1].y = i - 1; int x = find(e[i].x), y = find(e[i].y); if (x != y) f[x] = y, tot++, a[cnt].w++; } a[cnt].y = m; if (tot != n - 1) {printf(&quot;0\n&quot;); return ;}//图不连通，不构成最小生成树 for (int i=1;i&lt;=n;i++) f[i] = i; LL ans = 1; for (int i=1;i&lt;=cnt;i++) { sum = 0; dfs(a[i].w, a[i].x, a[i].y, 0); ans = (ans * sum % MO) % MO; for (int j=a[i].x;j&lt;=a[i].y;j++) { int x = find(e[j].x), y = find(e[j].y); if (x != y) f[x] = y; } } printf(&quot;%lld\n&quot;, ans); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif scanf(&quot;%d%d&quot;, &amp;n, &amp;m), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>计数原理</tag>
        <tag>Bzoj</tag>
        <tag>生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1015」「JSOI2008」星球大战starwar (并查集+离线逆向思维)]]></title>
    <url>%2Fbzoj1015%2F</url>
    <content type="text"><![CDATA[Bzoj 1015连通性问题可以用并查集做。不要总想着tarjan什么的。。况且tarjan也是有向图的 这题并查集正着做很麻烦，因为并查集并不支持删除，只支持添加。所以我们先把所有询问存下来离线，先把不会删的点先加上，之后再从最后开始一直加点(加了的点之间的连边也是要连的)，然后每次询问统计答案即可，这里统计答案不要用$O(n)$的算法，用一个$tot$来维护答案值。 刚开始做的时候忘记加过的点标记了。。。而且输出6行我输出5行认为对了。。其实还要输出一开始图的连通分量。。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 400000 + 5; int k, n, m, f[MAXN], tot, vi[MAXN], ans[MAXN], p[MAXN]; vector&lt;int&gt; G[MAXN]; int find(int x) {return f[x] == x ? x : f[x] = find(f[x]);} void addEdge(int u) { for (int i=0;i&lt;G[u].size();i++) { int v = G[u][i]; if (!vi[v]) continue; int x = find(u), y = find(v); if (x != y) tot--, f[x] = y; } } void clean() { for (int i=0;i&lt;=n;i++) G[i].clear(), f[i] = i, vi[i] = true; } void solve() { clean(); for (int i=1;i&lt;=m;i++) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); G[x].push_back(y), G[y].push_back(x); } scanf(&quot;%d&quot;, &amp;k), tot = n - k; for (int i=1;i&lt;=k;i++) { scanf(&quot;%d&quot;, &amp;p[i]); vi[p[i]] = false; } int kase = k + 1; for (int i=1;i&lt;=n;i++) if (vi[i]) addEdge(i); ans[kase--] = tot; for (int i=k;i&gt;=1;i--) { tot++, addEdge(p[i]), vi[p[i]] = true; ans[kase--] = tot; } for (int i=1;i&lt;=k+1;i++) printf(&quot;%d\n&quot;, ans[i]); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif scanf(&quot;%d%d&quot;, &amp;n, &amp;m), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>Bzoj</tag>
        <tag>离线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1087」「SCOI2005」互不侵犯King (状压DP)]]></title>
    <url>%2Fbzoj1087%2F</url>
    <content type="text"><![CDATA[Bzoj 1087设$dp(i,j,st(S))$为前$i$行安放了$j$个国王，$i$行使用$st(S)$状态的方案数。$$dp(i,j,st(S))=\sum dp(i-1.j-num_s, st(k))$$其中$st(S)$与$st(k)$不冲突。初值：$dp(1, num(S), st(S)) = 1$，其中$S$是合法状态，其他值设为$0$。然后求解即可，注意答案只在最后一行，累加不要加错了，然后dp数组也要开longlong，否则WA #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 9 + 2, MAXK = 100 + 5; int n, m, st[1 &lt;&lt; MAXN], num[1 &lt;&lt; MAXN], tot; LL dp[MAXN][MAXK][1 &lt;&lt; MAXN]; int count(int S) { int ret = 0, t = S; while (t) ret++, t &amp;= (t - 1); return ret; } bool check(int S) { if (S &amp; (S &gt;&gt; 1)) return false; return true; } bool check2(int a, int b) { int ta = a, x = 1; while (ta) { if (ta &amp; 1 == 1) { if (x &lt; n &amp;&amp; ((b &gt;&gt; (x)) &amp; 1) == 1) return false; if (x - 1 &gt;= 0 &amp;&amp; ((b &gt;&gt; (x - 1)) &amp; 1) == 1) return false; if (x - 2 &gt;= 0 &amp;&amp; ((b &gt;&gt; (x - 2)) &amp; 1) == 1) return false; } ta &gt;&gt;= 1, x++; } return true; } void clean() { ms(num, 0), ms(st, 0), ms(dp, 0), tot = 0; } void solve() { clean(); for (int S=0;S&lt;(1&lt;&lt;n);S++) if (check(S)) st[++tot] = S, num[tot] = count(S); for (int i=1;i&lt;=tot;i++) dp[1][num[i]][i] = 1; for (int i=2;i&lt;=n;i++) { for (int j=0;j&lt;=m;j++) { for (int k=1;k&lt;=tot;k++) { for (int l=1;l&lt;=tot;l++) { if (!check2(st[l], st[k])) continue; dp[i][j][k] += dp[i - 1][j - num[k]][l]; } } } } LL ans = 0; for (int j=1;j&lt;=tot;j++) { ans += dp[n][m][j]; } printf(&quot;%lld\n&quot;, ans); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif scanf(&quot;%d%d&quot;, &amp;n, &amp;m), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1076」「SCOI2008」奖励关 (状压概率期望DP)]]></title>
    <url>%2Fbzoj1076%2F</url>
    <content type="text"><![CDATA[Bzoj 1076采取最优策略很关键，这会使每一步都要取$max$或者$min$然后再相加设$dp(i,S)$为前$i$次投掷，当前吃的种类集合状态为$S$时到游戏结束的得分期望。那么如果一个$S$不符合某个物品$j$的前提集合，那么$dp(i, S) = \frac{1}{n}dp(i +1, S)$否则$dp(i, S) = \sum \frac{1}{n}max(dp(i+1, s), dp(i+1, S \cup j)+p_j)$然后注意方向。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXK = 100 + 5, MAXN = 15 + 2; int K, n, p[MAXN], s[MAXN]; db dp[MAXK][1 &lt;&lt; MAXN]; void clean() { ms(s, 0); } void solve() { clean(); for (int i=1;i&lt;=n;i++) { scanf(&quot;%d&quot;, &amp;p[i]); int x; scanf(&quot;%d&quot;, &amp;x); while (x != 0) s[i] += (1 &lt;&lt; (x - 1)), scanf(&quot;%d&quot;, &amp;x); } for (int i=K;i&gt;0;i--) { for (int S=0;S&lt;(1&lt;&lt;n);S++) { for (int j=1;j&lt;=n;j++) { if ((S &amp; s[j]) == s[j]) { dp[i][S] += max(dp[i + 1][S], dp[i + 1][S | (1 &lt;&lt; (j - 1))] + p[j]); } else dp[i][S] += dp[i + 1][S]; } dp[i][S] /= (db)n; } } printf(&quot;%.6f\n&quot;, dp[1][0]); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif scanf(&quot;%d%d&quot;, &amp;K, &amp;n), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>概率DP</tag>
        <tag>Bzoj</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1821」「JSOI2010」部落划分 Group (最小生成树)]]></title>
    <url>%2Fbzoj1821%2F</url>
    <content type="text"><![CDATA[BZOJ 1821平面上给点询问边权问题一般是最小生成树。我们把点一一存边，然后最小生成树加边，加到有$k$个连通分量后，输出下一条能够使联通分量增加的边的边权即可。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 1000 + 5; int en, n, k, f[MAXN]; struct pos {int x, y;}p[MAXN]; struct data { int u, v; db dist; bool operator &lt; (const data &amp;b) const { return dist &lt; b.dist; } }e[MAXN * MAXN]; int find(int x) {return x == f[x] ? x : f[x] = find(f[x]);} db getDist(pos &amp;a, pos &amp;b) { return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y)); } void clean() { en = 0; for (int i=1;i&lt;=n;i++) f[i] = i; } void solve() { clean(); for (int i=1;i&lt;=n;i++) { scanf(&quot;%d%d&quot;, &amp;p[i].x, &amp;p[i].y); } for (int i=1;i&lt;=n;i++) { for (int j=1;j&lt;=n;j++) { en++; e[en].u = i, e[en].v = j, e[en].dist = getDist(p[i], p[j]); } } sort(e + 1, e + 1 + en); int tot = 0; for (int i=1;i&lt;=en;i++) { int x = find(e[i].u), y = find(e[i].v); if (x == y) continue; f[x] = y; tot++; if (tot &gt; n - k) {printf(&quot;%.2f\n&quot;, e[i].dist); return ;} } } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif scanf(&quot;%d%d&quot;, &amp;n, &amp;k), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bzoj 3109(DFS)]]></title>
    <url>%2Fbzoj3109%2F</url>
    <content type="text"><![CDATA[bzoj 3109直接DFS就行，这题比较麻烦，打了一下午，不过幸好也没有什么错，跑了2860ms，还算不错。注意一下行末空格是不允许存在的 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; int hang_rl[20][20], lie_rl[20][20], mp[20][20], hang_used[20][20], lie_used[20][20], gong_used[20][20]; char getch() { char x = getchar(); while (x != &#39;v&#39; &amp;&amp; x != &#39;&lt;&#39; &amp;&amp; x != &#39;&gt;&#39; &amp;&amp; x != &#39;^&#39;) x = getchar(); return x; } int getGongByPos(int x, int y) { if (x &lt;= 3) {//the 1st row if (y &lt;= 3) return 1; if (y &lt;= 6) return 2; return 3; } else if (x &lt;= 6) {//the 2nd row if (y &lt;= 3) return 4; if (y &lt;= 6) return 5; return 6; } else {//the 3rd row if (y &lt;= 3) return 7; if (y &lt;= 6) return 8; return 9; } return -1; } void inputHang(int h) { for (int i=0;i&lt;3;i++) { char c1 = getch(), c2 = getch(); hang_rl[h][i * 3 + 1] = (c1 == &#39;&lt;&#39; ? 0 : 1); hang_rl[h][i * 3 + 2] = (c2 == &#39;&lt;&#39; ? 0 : 1); } } void inputLie(int l) { for (int i=0;i&lt;3;i++) { char c1 = getch(), c2 = getch(), c3 = getch(); lie_rl[l][i * 3 + 1] = (c1 == &#39;v&#39; ? 0 : 1); lie_rl[l][i * 3 + 2] = (c2 == &#39;v&#39; ? 0 : 1); lie_rl[l][i * 3 + 3] = (c3 == &#39;v&#39; ? 0 : 1); } } void dfs(int h, int l) { if (h == 10) { for (int i=1;i&lt;=9;i++) { for (int j=1;j&lt;=9;j++) { printf(&quot;%d&quot;, mp[i][j]); if (j != 9) putchar(&#39; &#39;); } putchar(&#39;\n&#39;); } exit(0); } int gong = getGongByPos(h, l); for (int i=1;i&lt;=9;i++) { if (hang_used[h][i] || lie_used[l][i] || gong_used[gong][i]) continue; if (lie_rl[h - 1][l] == 1) if (i &lt;= mp[h - 1][l]) continue; if (lie_rl[h - 1][l] == 0) if (i &gt; mp[h - 1][l]) continue; if (hang_rl[h][l - 1] == 1) if (i &gt; mp[h][l - 1]) continue; if (hang_rl[h][l - 1] == 0) if (i &lt;= mp[h][l - 1]) continue; mp[h][l] = i, hang_used[h][i] = lie_used[l][i] = gong_used[gong][i] = true; if (l + 1 &gt; 9) dfs(h + 1, 1); else dfs(h, l + 1); mp[h][l] = 0, hang_used[h][i] = lie_used[l][i] = gong_used[gong][i] = false; } } void clean() { ms(hang_rl, -1), ms(lie_rl, -1), ms(mp, 0), ms(hang_used, false), ms(lie_used, false), ms(gong_used, false); } void solve() { clean(); int h = 0, l = 0; for (int i=1;i&lt;=3;i++) { inputHang(++h); inputLie(++l); inputHang(++h); inputLie(++l); inputHang(++h); l++; } dfs(1, 1); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1295」「SCOI2009」最长距离 (最短路)]]></title>
    <url>%2Fbzoj1295%2F</url>
    <content type="text"><![CDATA[BZOJ 1295逆向思维，设$g(i,j)$为$i$到$j$最少穿过的障碍物。每个点做一次SPFA。然后之后枚举点对，如果$g(i,j)&lt;=T$，那么就统计答案。这里代码使用了点标号，比较麻烦，看题解似乎可以直接BFS，就不用连边了。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 30 + 5, INF = 1000000000; const int dx[4] = {1, 0, -1, 0}; const int dy[4] = {0, 1, 0, -1}; struct data { int v, w; }e[MAXN * MAXN * 8]; int en, n, m, T, dis[MAXN * MAXN][MAXN * MAXN], vi[MAXN * MAXN]; char s[MAXN][MAXN]; vector&lt;int&gt; G[MAXN * MAXN]; void ins(int x, int y, int c) { en++, e[en].v = y, e[en].w = c, G[x].push_back(en); } int getIDbyPos(int x, int y) { return (x - 1) * m + y; } void getPosbyID(int x, int &amp;a, int &amp;b) { if (x % m == 0) a = x / m; else a = x / m + 1; b = x - m * (a - 1); } db dist(int x, int y, int i, int j) { return (x - i) * (x - i) + (y - j) * (y - j); } void spfa(int x) { queue&lt;int&gt; q; int xx, xy; getPosbyID(x, xx, xy); ms(vi, false), dis[x][x] = s[xx][xy] - &#39;0&#39;, vi[x] = true, q.push(x); while (!q.empty()) { int u = q.front(); q.pop(), vi[u] = false; for (int i=0;i&lt;G[u].size();i++) { int v = e[G[u][i]].v, w = e[G[u][i]].w; if (dis[x][v] &gt; dis[x][u] + w) { dis[x][v] = dis[x][u] + w; if (!vi[v]) vi[v] = true, q.push(v); } } } } void clean() { en = 0; for (int i=0;i&lt;=n*n;i++) { G[i].clear(); for (int j=0;j&lt;=n*n;j++) dis[i][j] = INF; } } void solve() { clean(); for (int i=1;i&lt;=n;i++) scanf(&quot;%s&quot;, s[i] + 1); for (int i=1;i&lt;=n;i++) { for (int j=1;j&lt;=m;j++) { int nowID = getIDbyPos(i, j); for (int orz=0;orz&lt;4;orz++) { int tx = i + dx[orz], ty = j + dy[orz]; if (tx &gt; 0 &amp;&amp; ty &gt; 0 &amp;&amp; tx &lt;= n &amp;&amp; ty &lt;= m) { int curID = getIDbyPos(tx, ty); if (s[i][j] == &#39;0&#39; &amp;&amp; s[tx][ty] == &#39;0&#39;) ins(nowID, curID, 0), ins(curID, nowID, 0); if (s[i][j] == &#39;1&#39; &amp;&amp; s[tx][ty] == &#39;1&#39;) ins(nowID, curID, 1), ins(curID, nowID, 1); if (s[i][j] == &#39;0&#39; &amp;&amp; s[tx][ty] == &#39;1&#39;) ins(nowID, curID, 1), ins(curID, nowID, 0); if (s[i][j] == &#39;1&#39; &amp;&amp; s[tx][ty] == &#39;0&#39;) ins(nowID, curID, 0), ins(curID, nowID, 1); } } } } for (int i=1;i&lt;=n*n;i++) spfa(i); db ans = 0; for (int i=1;i&lt;=n*n;i++) { for (int j=1;j&lt;=n*n;j++) { if (dis[i][j] &gt; T) continue; int ix, iy, jx, jy; getPosbyID(i, ix, iy), getPosbyID(j, jx, jy); ans = max(ans, dist(ix, iy, jx, jy)); } } printf(&quot;%.6f\n&quot;, sqrt(ans)); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif scanf(&quot;%d%d%d&quot;, &amp;n ,&amp;m, &amp;T), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1096」「ZJOI2007」仓库建设 (斜率优化DP)]]></title>
    <url>%2Fbzoj1096%2F</url>
    <content type="text"><![CDATA[Bzoj 1096题意：给定$n$个点间的距离,每个点的物品数和建仓库的花费,每个点的物品可以放在该点建的仓库或它后面点建的仓库,运输的费用为距离乘以物品数 设$dp(i)$为在$i$建仓库的最优解。由$\sum_{k=j+1}^{i-1}p_k(x_i-x_k)=x_i \sum_{k=j+1}^{i-1}p_k-\sum_{k=j+1}^{i-1}x_kp_k$，得$dp(i)=min(dp(j)+x_i \sum_{k=j+1}^{i-1}p_k-\sum_{k=j+1}^{i-1}x_kp_k)$设$G_i=\sum p_k, E_i=\sum x_kp_k$，则$$dp(i)=dp(j)+x_iG_{i-1}-x_iG_j-E_{i-1}+E_j$$然后发现又有$i$又有$j$这种的，想到斜率优化。决策单调性证明略。假设$i$前有两个决策$j,k$，且$k$比$j$优，则$$dp(j)+x_iG_{i-1}-x_iG_j-E_{i-1}+E_j &gt; dp(k)+x_iG_{i-1}-x_iG_k-E_{i-1}+E_k$$将$x_i$移到右边，得$$x_i &gt; \frac{dp(k)-dp(j)+E_k-E_j}{G_k-G_j}$$ 设$k=\frac{dp(k)-dp(j)+E_k-E_j}{G_k-G_j}$，则算出两点斜率方程，当$x_i &gt; k_{kj}$满足时，说明$i$时$k$比$j$优易错点：1、que[l]与l分清楚！ #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 1000000 + 5; LL n, xi[MAXN], pi[MAXN], ci[MAXN], G[MAXN], E[MAXN], dp[MAXN], que[MAXN * 4], l, r; db getK(LL k, LL j) {return (db)(dp[k] - dp[j] + E[k] - E[j]) / (db)(G[k] - G[j]);} void clean() {} int solve() { clean(); G[0] = E[0] = 0; for (LL i = 1; i &lt;= n; i++) scanf(&quot;%lld%lld%lld&quot;, &amp;xi[i], &amp;pi[i], &amp;ci[i]), G[i] = G[i - 1] + pi[i], E[i] = E[i - 1] + xi[i] * pi[i]; l = 1, r = 1, dp[0] = 0; for (LL i = 1; i &lt;= n; i++) { while (l &lt; r &amp;&amp; getK(que[l], que[l + 1]) &lt;= xi[i]) l++; dp[i] = dp[que[l]] + xi[i] * (G[i - 1] - G[que[l]]) - (E[i - 1] - E[que[l]]) + ci[i]; while (l &lt; r &amp;&amp; getK(que[r - 1], que[r]) &gt;= getK(que[r], i)) r--; que[++r] = i; } printf(&quot;%lld\n&quot;, dp[n]); return 0; } int main() { scanf(&quot;%lld&quot;, &amp;n), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1477」青蛙的约会 (扩展欧几里得算法解不定方程)]]></title>
    <url>%2Fbzoj1477%2F</url>
    <content type="text"><![CDATA[BZOJ 1477luogu免权限地址扩展欧几里得算法，由题可列$(x+m*t)\equiv (y+n*t)\pmod L$，其中$t$为所求由同余性质得：$(x+m*t)-(y+n*t)=Lk$变形得：$(n-m)t+lk=x-y$，则转换为$ax+by=c$的形式 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; LL x, y, m, n, L; LL gcd(LL a, LL b) {return b == 0 ? a : gcd(b, a % b);} LL abss(LL a) {return a &gt;= 0 ? a : -a;} void exgcd(LL a, LL b, LL &amp;x, LL &amp;y) { if (b == 0) { x = 1, y = 0; return ; } exgcd(b, a % b, x, y); int tmp = x; x = y, y = tmp - a / b * y; } void clean() {} void solve() { clean(); LL xi = m - n, yi = L, c = y - x, g = gcd(xi, yi); if (c % g != 0) {printf(&quot;Impossible\n&quot;); return ;} c /= g, xi /= g, yi /= g; LL a, b; exgcd(xi, yi, a, b); yi = abss(yi); a = ((a * c) % yi + yi) % yi; printf(&quot;%lld\n&quot;, a); } int main() { scanf(&quot;%lld%lld%lld%lld%lld&quot;, &amp;x, &amp;y, &amp;m, &amp;n, &amp;L), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>扩展欧几里得算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数论基础 学习笔记]]></title>
    <url>%2Fsz%E6%95%B0%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[模板及讲解数论常用方法1、$a\% b = a-\lfloor \frac ab \rfloor\cdot b$2、设$p=ki+r$，$k=\lfloor \frac pi \rfloor, r = p \mod i$3、$a|c \Leftrightarrow a \equiv 0 \pmod c \Leftrightarrow c \% a = 0 \Leftrightarrow c = ka$4、设出最小素因子 积性函数积性函数：对于正整数$n$的一个算术函数$f(n)$，若$f(1)=1$，且当$a,b$互质时$f(ab)=f(a)f(b)$。完全积性函数：所有对于任何$a,b$都有性质$f(ab)=f(a)f(b)$的函数。 积性函数有：$\varphi(n), \mu(n),d(n),\gcd(n,k),\sigma(n)$ 等 性质：1、若$n=p_{1}^{a_{1}}p_{2}^{a_{2}}p_{3}^{a_{3}}…p_{n}^{a_{n}}$, 则$f(n)=f(p_{1}^{a_{1}})f(p_{2}^{a_{2}})f(p_{3}^{a_{3}})…f(p_{n}^{a_{n}})$2、若$f$为积性函数且$f(p^{n})=f^{n}(p)$，则$f$为完全积性函数 积性函数可以由线性筛$O(n)$筛出。 欧几里得算法求$\gcd(a, b)$，即$a$和$b$的最大公倍数 欧几里得算法： $$\gcd(a, b) = \gcd(b, a \% b)$$ int gcd(int a, int b) { if (b == 0) return a; gcd(b, a % b); } 性质： 1、$\gcd(a,b)=c$则$a=k_1c, b=k_2c \Leftrightarrow c | a, c | b, c|(a +b)$2、$ab/ \gcd(a,b)=\operatorname{lcm}(a,b)$3、$\gcd(a,b)=\gcd(a+bp,b), p \in N$4、$a,b$互质$\Leftrightarrow \gcd(a,b)=1 \Leftrightarrow \exists x, ax+by=1$5、对于两个正整数$a,b$设$\gcd(a,b)=k$则存在$\gcd(\frac ak, \frac bk)=1$。推论$m\cdot \gcd(a, b)=\gcd(ma, mb)$6、设$b | ac, \gcd(b, c)= 1$，则$b|a$7、更相减损法：$\gcd(a,b)=\gcd(a, a-b)=\gcd(b, a-b) , a \leq b$8、因为$\gcd(n, x)=\gcd(n, n - x)$，所以如果$x, n$互质，则$n-x, n$互质，即与$n$互质的数成对出现 引理： 当所有数不全部相同时，$\gcd\left ( i_1, i_2, \dots, i_N \right ) \leq \max\left ( i_1, i_2, \dots, i_N \right ) - \min\left ( i_1, i_2, \dots, i_N \right )$ 证明：设$d = \gcd\left ( i_1, i_2, \dots, i_N \right ), a = \min\left ( i_1, i_2, \dots, i_N \right ), b = \max\left ( i_1, i_2, \dots, i_N \right )$显然$a = k_1d (k_1 \in \mathbb{Z}^+), b = k_2d (k_2 \in \mathbb{Z}^+, k_2 &gt; k_1)$， 所以$b - a \geq d$，证毕。 扩展欧几里得算法求$ax+by=\gcd(a,b)$的解$x,y$ 已求出下一个状态一组解$x1,y1$使得$b\cdot x1+(a\% b) \cdot y1=\gcd(a,b)$由$a\%b=a-\lfloor \frac ab \rfloor\cdot b$,得$b \cdot x1 +(a-\lfloor \frac ab \rfloor\cdot b) \cdot y1 = \gcd(a,b)$$b \cdot x1 + a \cdot y1 - b \cdot y1 \cdot \lfloor \frac ab \rfloor = \gcd(a,b)$$a \cdot y1 + b\cdot (x1-y1\cdot \lfloor \frac ab \rfloor)= \gcd(a,b)$对照$ax+by=\gcd(a,b)$，可得$x = y1, y= x1-y1\cdot \lfloor \frac ab\rfloor$由欧几里得算法终止条件$a=\gcd(a,b), b=0$得，$a \times 1+b \times 0=\gcd(a,b)$所以$x,y$的边界值是$1，0$ 通解：$$x = x_1 + \frac {b}{\gcd(a,b)} \cdot n\\ y = y_1 – \frac {a}{\gcd(a,b)} \cdot n$$证明： 在原有方程左右两侧同除一个$g=\gcd(a,b)$, 得$x \cdot \frac{a}{g}+y \cdot \frac{b}{g}=1$$x \cdot \frac{a}{g} + \frac{ab}{g^2} +y \cdot \frac{b}{g} - \frac{ab}{g^2} =1$合并同类项，$\frac ag(x+\frac bg) + \frac bg (y - \frac ag)=1$所以$(x+\frac bg, y-\frac ag), (x+2\cdot\frac bg, y-2 \cdot \frac ag)$都是原不定方程的解，这个方程的解具有周期性由此可得$x$的周期为$b/g$, $y$的周期为$a/g$，得出通解 int exgcd(int a, int b, int &amp;x, int &amp;y) { if (b == 0) { x = 1, y = 0;//边界值 return a;//求最大公倍数 } int ans = exgcd(b, a % b, x, y); int tmp = x; x = y; y = tmp - y * a / b;//公式计算 return ans; } (3) 求不定方程$ax+by=c$的最小一组解$x,y$, (Bzoj 1477) 先求出$g = \gcd(a,b)$如果$c\%g≠0$,无解否则，将不定方程两边同时除以$g$，得$a_1x+b_1y=c_1$此时$\gcd(a_1,b_1)=1$,可用扩展欧几里得算法求出$a_1x_1+b_1y_1=1$的解$x_1,y_1$即$a_1x+b_1y=c_1$的一组解为$x1\cdot c1, y1\cdot c1$求最小解可用一组特解模$b/\gcd(a, b)$即可得到(由通解周期性可以得知) (4) 求$a $关于$ n $的乘法逆元, NOIP2012 D2 T1 $(a / b) \% k = (a \cdot b^{-1}) \% k$，$b^{-1}$是$b$的乘法逆元，只有 $ a, k$ 互质($\gcd(a,k)=1$)，才有逆元 $ax\equiv 1\pmod n$由同余性质得，$ax-1=ny$变形，得 $ax-ny=1$，此时$\gcd(a,n)$必须为$1$且只有唯一解, 否则无解即可使用扩展欧几里得算法求解，最后使解在$[0, n-1]$之间求最小解可用一组特解模$n/\gcd(a, n)=n$(此时$\gcd(a, n)=1$, 否则无解)即可得到(由通解周期性可以得知) 同余设$m$为正整数，$a,b$是整数，如果$(a \mod m) =(b \mod m)$(或者$a-b$是$m$的整数倍)，那么就说$a$和$b$关于$m$同余。 (1) 同余定理: 如果$a\equiv b\pmod m$，那么$(a - b) = my(y$是常数，且为整数)(2) $a\equiv a\pmod m$(3) 如果$a\equiv b\pmod m$，那么$b\equiv a\pmod m$(4) 如果$a\equiv b\pmod m, b\equiv c\pmod m$，那么$a\equiv c\pmod m$ 中国剩余定理设正整数$m_1,m_2,…,m_k$两两互素，则同余方程组$$\begin{cases} x&amp;\equiv&amp;a_1&amp;\pmod{m_1}\\ x&amp;\equiv&amp;a_2&amp;\pmod{m_2}\\ &amp;&amp;&amp;\vdots\\ x&amp;\equiv&amp;a_k&amp;\pmod {m_k} \end{cases}$$有整数解。并且在模$M = m_1 \cdot m_2 \cdot …\cdot mk$下有唯一解，解为$$x \equiv (a_1M_1M_1^{-1}+a_2M_2M_2^{-1}+…+a_kM_kM_k^{-1}) \pmod M$$其中$M_i= \frac M{m_i}，M_i^{-1}$是$M_i$模$m_i$下的逆元 解法：先$O(n)$的时间求出$M$，然后求出$M_i$, 用扩展欧几里得算法求出$M_i^{-1}$，根据公式进行计算 证明： 我们先考虑只求出满足一个方程的解$x_i$，其他$a_i$都为$0$, 如下(使这个$x$​只在这一维中有余数)$$\begin{cases} x&amp;\equiv&amp;0&amp;\pmod{m_1}\\ x&amp;\equiv&amp;0&amp;\pmod{m_2}\\ &amp;&amp;&amp;\vdots\\ x&amp;\equiv&amp;a_i&amp;\pmod {m_i}\\ &amp;&amp;&amp;\vdots\\ x&amp;\equiv&amp;0&amp;\pmod {m_k}\end{cases}$$这样有些困难，我们先求$$\begin{cases} x&amp;\equiv&amp;0&amp;\pmod{m_1}\\ x&amp;\equiv&amp;0&amp;\pmod{m_2}\\ &amp;&amp;&amp;\vdots\\ x&amp;\equiv&amp;1&amp;\pmod {m_i}\\ &amp;&amp;&amp;\vdots\\ x&amp;\equiv&amp;0&amp;\pmod {m_k}\end{cases}$$然后再乘回$a_i$就能得到前面的解了，现在来解$x \equiv 1 \pmod {m_i}$设$M=m_1 \cdot m_2 \cdot …\cdot mk, M_i= \frac M{m_i}$，显然$Mi|x$，所以我们可以设$x=yMi$那么$x \equiv 1 \pmod {m_i} \Leftrightarrow yMi \equiv 1 \pmod {m_i}$注意到这里$y$为$Mi$在模$m_i$的意义下的逆元，即$y=Mi^{-1}$，那么$x=MiMi^{-1}$ 那么这个方程组的一个方程的解就算出来了，我们算前面的方程组的那个方程的解，为$x=a_iMiMi^{-1}$由于这个只能满足一个方程，所以我们要把所有的方程解都算出来求和即可，然后模$M$就能得到最终解，即$x \equiv (a_1M_1M_1^{-1}+a_2M_2M_2^{-1}+…+a_kM_kM_k^{-1}) \pmod M$ Poj 1006 int crt(int n, int *a, int *m) { int ans = 0; int M = 1; for (int i = 1; i &lt;= n; i++) M *= m[i]; for (int i = 1; i &lt;= n; i++) { int Mi = M / m[i]; int x, y; e_gcd(Mi, m[i], x, y);//求Mi的逆元x ans = (ans + a[i] * Mi * x) % M; } return (ans + M) % M; } 扩展中国剩余定理对于正整数$m_1,m_2,…,m_k$不满足两两互素，那就需要每个方程两两合并。合并过程如下 $$\begin{cases} x&amp;\equiv&amp;a_1&amp;\pmod{m_1}(1)\\ x&amp;\equiv&amp;a_2&amp;\pmod{m_2}(2)\\ &amp;&amp;&amp;\vdots\\ x&amp;\equiv&amp;a_k&amp;\pmod {m_k}\end{cases}$$由(1)(2)，得$x=a_1+m_1x_1(3)$$x=a_2+m_2x_2(4)$联立，$a_1+m_1x_1=a_2+m_2x_2$移项，$m_1x_1+m_2x_2=a_2-a_1$用exgcd判是否有解并解出一个特解$x_0$(只要$x_0$不要$y_0$)将$x_0$带入(3), 得$x=a_1+m_1x_0$用通解表示为(其中$g=\gcd(m_1, m_2)$)$x=a_1+m_1(x_0+\frac{m_2}{g} \cdot n)=m_1x_0+a_1+n \cdot \frac{m_1m_2}{g}$因为$\operatorname{lcm}(a1, a2)=\frac{m_1m_2}{g}$, 所以得到$x \equiv (m_1x_0+a_1) \pmod{\operatorname{lcm}(m1, m2)}$用这个方程继续和下面的方程合并即可 Hdu 3579 求正约数的个数/正约数和给出n的唯一分解式 $n = p^{a1}_1p^{a2}_2p^{a3}_3…p^{ak}_k$ , 求出 $n$ 的正约数的个数，并且求出正约数和根据乘法原理，$n$ 的正约数的个数为$$\prod_{i=1}^{k}(a_i+1)​$$ 正约数个数的前缀和$\sum_{i=1}^{n} \lfloor \frac ni \rfloor ≈ n\sum_{i=1}^{n} \frac 1i ≈ n(lnn+\gamma )$ 根据乘法原理，$n$ 的正约数和为$$\prod_{i=1}^{k}(\sum_{j=0}^{a_i} p_i^j)$$ 线性筛线性筛可以筛出积性函数。 欧拉筛求质数时间复杂度 $O(n\log(\log n))$，大约能跑$n=10^7$的数据 int vis[n]; int sx() { int m = sqrt(n + 0.5); ms(vis,0); for (int i = 2; i &lt;= n; i++) if (!vis[i]) for (int j = i * i; j &lt;= n; j += i) vis[j] = 1; } 线性筛质数Luogu 3383 考虑每个合数被它的最小素因子筛去，所以枚举的每个$i$之后枚举质数来筛去对应合数，并且如果$pri|i$就要break了，这样做到不重不漏。时间复杂度 $O(n)$ vis[1] = 1; for (int i = 2; i &lt;= n; ++i) { if (!vis[i]) pri[++tot] = i; for (int j = 1; j &lt;= tot &amp;&amp; (LL)i * (LL)pri[j] &lt;= (LL)n; ++j) { vis[i * pri[j]] = 1; if (i % pri[j] == 0) break; } } 线性筛因数个数函数 $d_0(n)$$d_k(n)$表示$n$因数$k$次方的和。$d_0(n)$即为因数个数 我们筛选需要$3$个数组，$pri(i)$当前质数数组，$d(i)$因数个数函数，$e(i)$最小质因子个数。由$n=\prod_{i=1}^{k}(a_i+1)$，我们可以用这个正约数公式来筛选。 对于当前枚举的$i, pri$ ，$pri$不超过$i$, 我们用$pri \cdot i$来顶掉$pri \cdot i$使其不会成为质数。$e(pri \cdot i)=1$为$pri$.当前数是素数，则$d(i)=2, e(i)=1$如果$pri\nmid i$，由于$pri$为质数所以$pri,i$互质，利用积性函数性质：$d(i \cdot pri)=d(i)d(pri)=2d(i), e(pri \cdot i)=1$如果$pri\mid i$，由于$d(i)=\prod_{i=1}^{k}(a_i+1)$，其中$e_i=pri$，所以要把$(a_1+1)$除掉之后再乘上$(a_1+2)$，即$d(i \cdot pri)=d(i)/(e(i)+1)\cdot (e(i)+2)$，显然此时$e(pri \cdot i)=e(i)+1$ 线性筛因数和函数 $d_1(n)$$d_k(n)$表示$n$因数$k$次方的和。$d_1(n)$即为因数和运用公式和前因数个数面的推导，不难写出以下程序 vis[1] = 1, d[0] = 0, d[1] = 1; for (LL i = 2; i &lt;= MAX_N; i++) { if (!vis[i]) pri[++tot] = i, e[i] = i + 1, d[i] = i + 1; for (LL j = 1; j &lt;= tot &amp;&amp; pri[j] * i &lt;= MAX_N; j++) { vis[pri[j] * i] = 1; if (i % pri[j] == 0) { d[pri[j] * i] = d[i] / e[i] * (e[i] * pri[j] + 1); e[pri[j] * i] = e[i] * pri[j] + 1; break; } else d[pri[j] * i] = d[pri[j]] * d[i], e[pri[j] * i] = 1 + pri[j]; } } 分解质因数给出$n$，求出$n=A^{B_1}_1 \times A^{B_2}_2 \times … \times A^{B_k}_k$的$A_i$及$B_i$($A_i$为质数)从1到$\sqrt n$进行找$n$的因子，找到就除干净，注意最后可能$n$还会大于1，特判即可$\sqrt n$判断可以是$i^2 \leq x$，$x$是当前的$n$ for (LL i = 2; i * i &lt;= x; i++) { if (x % i == 0) { //i 是质因数 while (x % i == 0) x /= i; } } if (x != 1) //x 是质因数 分解因数for (int i = 1; i &lt;= n; i++) { // 从1开始 for (int j = 1; j * j &lt;= a[i]; j++) if (a[i] % j == 0) { //j 是因数 if (j != a[i] / j) //a[i] / j 是因数 } } 线性求所有逆元$O(n)$求$i$的逆元$i^{-1}=-\lfloor \frac pi \rfloor \cdot (p \mod i)^{-1}$证明： 设$p=ki+r$, 则$p \equiv 0\pmod p \Leftrightarrow ki+r \equiv 0\pmod p$两边乘以$i^{-1}r^{-1}$, 得$k \cdot r^{-1}+i^{-1}=0$移项，得$i^{-1}=-k \cdot r^{-1}$因为$k=\lfloor \frac pi \rfloor, r = p \mod i$所以$i^{-1}=-\lfloor \frac pi \rfloor \cdot (p \mod i)^{-1}$ 欧拉定理当$\gcd(a,n)=1$ 时，有$$a^{\varphi(n)} \equiv 1 \pmod n$$ 推论 当$\gcd(a,n)=1$$$a^b \equiv a^{b \mod \varphi(n)} \pmod n$$当$a, n$不一定互质时，有$$a^b \equiv a^{b \mod \varphi(n) + \varphi(n)} \pmod n$$ 费马小定理当$p$为质数时(欧拉定理的特殊情况，$\varphi(n)=n-1$当且仅当$n$为质数)：$$a^{p-1} \equiv 1 \pmod p$$(1) 快速幂求逆元$a^{-1}=a^{(p-2)} \mod p$ ($a, p$互质) 因为$a^{(p-1)} \equiv 1 \pmod p$所以$a^{(p-1)} \mod p = 1 \mod p​$所以$a^{(p-2)} \mod p = a^{-1} \mod p$所以$a^{(p-2)} \mod p$是$a$的逆元。 大步小步算法(BSGS)给出$x^y \equiv z \pmod p$中的$x, z, p(p$为质数)，求$y$.($log$过程, 快速幂逆过程，离散对数) 根据费马小定理，$y$只需要枚举到$p-1$，否则会产生循环设$m=\sqrt n, y=am+b$, 那么$x^{am+b} \equiv z \pmod p$, 只用枚举$a,b$即可把$a,b$放两边，得$x^b \equiv x^{-ma}z \pmod p$显然$x^b$最多只有$m$个，那么我们把$x^b$放进map里供查询接着枚举$a$判断即可。 poj 2417 x %= p;//要先取模 if (!x &amp;&amp; !z) return printf(&quot;1\n&quot;);//注意要特判 if (!x) return printf(&quot;no solution\n&quot;);//注意要特判 LL m = (LL)ceil(sqrt(p - 1)), whw = x;//必须ceil取大，否则会小 a[1] = m + 1; for (LL i = 1; i &lt; m; i++) {//求左边的x^b if (!a.count(whw)) a[whw] = i; whw = (whw * x) % p; } LL ni = ksm(x, m, p); ni = ksm(ni, p - 2, p);//x^{-m} for (LL i = 0; i &lt; m; i++) {//枚举a LL j = a[z]; if (j) { if (j == m + 1) return printf(&quot;%lld\n&quot;, i * m), 0; else return printf(&quot;%lld\n&quot;, i * m + j), 0; } z = (z * ni) % p; } printf(&quot;no solution\n&quot;); 扩展大步小步算法Lucas 定理对于$C^m_n \mod p$, 当$n, m$大$p$小且$p$为质数时，不能通过阶乘等方式求解，我们可以运用 Lucas 定理把$n, m$写成$p$进制数的样子，形如$m = (a_0a_1…a_k)_p, n = (b_0b_1…b_k)_p$那么有 Lucas 定理：$$C^m_n \equiv \prod_{i=0}^kC^{a_i}_{b_i} \pmod p$$也可写作(递推 / 递归式)，相当于求上面$p$进制表示的过程 ：$$C^m_n \equiv C^{\lfloor\frac mp\rfloor}_{\lfloor\frac np\rfloor}C^{ m \% p}_{ n \% p} \pmod p$$ 例题：Bzoj 2982 预处理阶乘和阶乘逆元，然后 $ O(1) $ 求得 $C^m_n$ LL lucas(LL n, LL m) { if (m == 0) return 1; return (C(n % MO, m % MO) * lucas(n / MO, m / MO)) % MO; } 扩展 Lucas 定理快速乘解决 $a \cdot b \mod c$中间变量爆 long long 的情况。 思路与快速幂类似。快速幂运用性质 $a^{x+y}=a^x \cdot a^y$，快速乘运用$a \cdot (b + c)=a \cdot b +a\cdot c$ LL ksc(LL a, LL b, LL c) { //快速乘 LL ans = 1, bs = a; while(b){ if(b &amp; 1) ans = (ans + bs) % c; bs = (bs + bs) % c; b &gt;&gt;= 1; } return ans; } 常见题型见讲解]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计蒜客NOIP模拟赛-1 Day1 T2(乘法原理)]]></title>
    <url>%2F%E8%AE%A1%E8%92%9C%E5%AE%A2NOIP%E6%A8%A1%E6%8B%9F%E8%B5%9B-1Day1T2%2F</url>
    <content type="text"><![CDATA[题目链接这题居然没有想到乘法原理…还是要多想想乘法原理啊… 先dfs出$siz_i$为每个点子树大小。然后对每个边算次数。根据乘法原理，次数为$siz_i \times (n-siz_i)$，那么这条边对答案的贡献为$val \times siz_i \times (n-siz_i)$，然后就可以求了。 注意开long long，而且乘法会溢出所以要在中途每个强制转换 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 100000 + 5; struct data {int v, w;}ed[MAXN * 2]; int en, n, siz[MAXN], val[MAXN]; vector&lt;int&gt; G[MAXN]; void ins(int x, int y, int c) { en++, ed[en].v = y, ed[en].w = c, G[x].push_back(en);//边权实际上不需要存，但是这存了就不改了 } void dfs(int u, int pa) { siz[u] = 1; for (int i=0;i&lt;G[u].size();i++) { data p = ed[G[u][i]]; int v = p.v, w = p.w; if (v != pa) { dfs(v, u); siz[u] += siz[v]; } } } void clean() { en = 0; for (int i=0;i&lt;=n;i++) siz[i] = val[i] = 0, G[i].clear(); } void solve() { clean(); for (int i=1;i&lt;n;i++) { int x; scanf(&quot;%d%d&quot;, &amp;x, &amp;val[i + 1]); ins(x, i+1, val[i + 1]); } dfs(1, 0); LL ans = 0; for (int i=1;i&lt;=n;i++) { ans += (LL)val[i] * (LL)(n - siz[i]) * (LL)siz[i];//防乘法溢出 } printf(&quot;%lld\n&quot;, ans); int Q; scanf(&quot;%d&quot;, &amp;Q); while (Q--) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); ans += (LL)(y - val[x]) * (LL)(n - siz[x]) * (LL)siz[x];//防乘法溢出 val[x] = y; printf(&quot;%lld\n&quot;, ans); } } int main() { scanf(&quot;%d&quot;, &amp;n), solve(); return 0; }]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>计数原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计蒜客NOIP模拟赛-1 Day1 T1(旋转+前缀和)]]></title>
    <url>%2F%E8%AE%A1%E8%92%9C%E5%AE%A2NOIP%E6%A8%A1%E6%8B%9F%E8%B5%9B-1Day1T1%2F</url>
    <content type="text"><![CDATA[题目链接原图要求一个分值最大的斜正方形，斜着不好弄，那就倒过来。把矩阵旋转$45^{\circ}$，然后就可以直接水平求正方形了。具体怎么旋转看我的另一个博文。这里注意旋转以后的数组有些地方不可用，可能会敲到棋盘外，也有可能敲到边上，在输入的时候用一个数组记录一下就好，注意数组比较大，不要MLE了.顺便附上使用了前缀和优化的暴力，考试时拿了90分，不能相信…正解： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;ctime&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 2000 + 5; int n, k, ma[4005][4005], s[4005][4005], vi[4005][4005]; void clean() { ms(s, 0), ms(vi, 0); } void solve() { clean(); for (int i=1;i&lt;=n;i++) { for (int j=1;j&lt;=n;j++) { int T = i + j - 1, P = n - i + j; scanf(&quot;%d&quot;, &amp;ma[T][P]); vi[T][P] = true;//避免打到不是棋盘的地方 } } for (int i=0;i&lt;=n*2;i++) { for (int j=0;j&lt;=n*2;j++) { s[i][j] = ma[i][j]; if (i - 1 &gt;= 0) s[i][j] += s[i - 1][j]; if (j - 1 &gt;= 0) s[i][j] += s[i][j - 1]; if (i - 1 &gt;= 0 &amp;&amp; j - 1 &gt;= 0) s[i][j] -= s[i - 1][j - 1]; } } int ans = 0; for (int i=0;i&lt;=n*2;i++) { for (int j=0;j&lt;=n*2;j++) { if (!vi[i][j]) continue; //避免打到不是棋盘的地方 int tot = 0; tot = s[i][j]; if (i - 2 * k + 1 &gt;= 0) tot -= s[i - 2 * k + 1][j]; if (j - 2 * k + 1 &gt;= 0) tot -= s[i][j - 2 * k + 1]; if (i - 2 * k + 1 &gt;= 0 &amp;&amp; j - 2 * k + 1 &gt;= 0) tot += s[i - 2 * k + 1][j - 2 * k + 1]; ans = max(ans, tot); } } printf(&quot;%d\n&quot;, ans); } int main() { scanf(&quot;%d%d&quot;, &amp;n ,&amp;k), solve(); return 0; } 暴力： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;ctime&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 2000 + 5; int n, k, ma[MAXN][MAXN], s[MAXN][MAXN]; void clean() { ms(s, 0); } void solve() { clean(); for (int i=1;i&lt;=n;i++) { for (int j=1;j&lt;=n;j++) { scanf(&quot;%d&quot;, &amp;ma[i][j]); s[i][j] = s[i][j-1] + ma[i][j]; } } int ans = 0; for (int i=1;i&lt;=n;i++) { for (int j=1;j&lt;=n;j++) { int tot = 0; for (int l=0;l&lt;k&amp;&amp;i+l&lt;=n&amp;&amp;i-l&gt;0;l++) { if (i + l == i - l) tot += s[i + l][min(j+k-1-l, n)] - s[i + l][max(j-k+1+l, 1) - 1], ts++; else { tot += s[i + l][min(j+k-1-l, n)] - s[i + l][max(j-k+1+l, 1) - 1]; tot += s[i - l][min(j+k-1-l, n)] - s[i - l][max(j-k+1+l, 1) - 1]; } } ans = max(ans, tot); } } printf(&quot;%d\n&quot;, ans); } int main() { scanf(&quot;%d%d&quot;, &amp;n ,&amp;k), solve(); return 0; }]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1084」「SCOI2005」最大子矩阵 (DP+前缀和)]]></title>
    <url>%2Fbzoj1084%2F</url>
    <content type="text"><![CDATA[Bzoj 1084$m$只有$1, 2$，分情况讨论：$m=1​$时，就是一个简单的最大连续子段和，设$dp(i,j)​$为前$i​$个数分了$j​$段的最优值则有$dp(i,j)=max(dp(i-1, j), dp(k,j-1)+S_{i}-S_{k})$，其中$S$是前缀和。$m=2$时，我们设$dp(i,j,k)​$为第一列前$i$个数第二列前$j$个数分了$k$个矩阵的最优值则$dp(i,j,k)=max(dp(i-1,j,k), dp(i,j-1,k), dp(l, j, k-1)+S1_i - S1_l, $$dp(i, l, k-1)+S2_i - S2_l)$，其中$S1$是第一列前缀和，$S2$是第二列前缀和。当$i=j$时，还可以选择两列一起的大矩阵，则$dp(i,j,k)=max(dp(l,l,k-1)+S1_i+S2_j-S1_l-S2_l)$初始都要赋值为$-INF$，但是当$j=0$时要赋值为$0$，不然就会导致答案负数。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 100 + 5, MAXK = 10 + 5, INF = 1000000000; int n, m, k, dp1[MAXN][MAXK], dp2[MAXN][MAXN][MAXK], s1[MAXN], s2[MAXN]; void clean() { s1[0] = s2[0] = 0; } void solve() { clean(); if (m == 1) { for (int i=0;i&lt;=n;i++) { for (int j=1;j&lt;=k;j++) {//1开始，否则没有初值了 dp1[i][j] = -INF; } } for (int i=1;i&lt;=n;i++) { int x; scanf(&quot;%d&quot;, &amp;x); s1[i] = s1[i - 1] + x; } for (int i=1;i&lt;=n;i++) { for (int j=1;j&lt;=k;j++) { dp1[i][j] = dp1[i - 1][j];//不选 for (int i1=0;i1&lt;i;i1++) { dp1[i][j] = max(dp1[i][j], dp1[i1][j - 1] + s1[i] - s1[i1]); } } } printf(&quot;%d\n&quot;, dp1[n][k]); } else { for (int i=0;i&lt;=n;i++) { for (int j=0;j&lt;=n;j++) { for (int l=1;l&lt;=k;l++) {//1开始，否则没有初值了 dp2[i][j][l] = -INF; } } } for (int i=1;i&lt;=n;i++) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); s1[i] = s1[i - 1] + x; s2[i] = s2[i - 1] + y; } for (int i=1;i&lt;=n;i++) { for (int j=1;j&lt;=n;j++) { for (int l=1;l&lt;=k;l++) { dp2[i][j][l] = max(dp2[i - 1][j][l], dp2[i][j - 1][l]);//不选 for (int i1=0;i1&lt;i;i1++) dp2[i][j][l] = max(dp2[i][j][l], dp2[i1][j][l - 1] + s1[i] - s1[i1]); for (int j1=0;j1&lt;j;j1++) dp2[i][j][l] = max(dp2[i][j][l], dp2[i][j1][l - 1] + s2[j] - s2[j1]); if (i == j) {//可以选两排一起的一个大矩阵 for (int ij=0;ij&lt;min(i, j);ij++) dp2[i][j][l] = max(dp2[i][j][l], dp2[ij][ij][l - 1] + s1[i] + s2[j] - s1[ij] - s2[ij]); } } } } printf(&quot;%d\n&quot;, dp2[n][n][k]); } } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>Bzoj</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1491」「NOI2007」社交网络 (最短路+乘法原理)]]></title>
    <url>%2Fbzoj1491%2F</url>
    <content type="text"><![CDATA[BZOJ 1491之前一直想dij/SPFA，被次短路的思路越扯越远…看见$n$才$100$那就应该想Floyd啊。。题目挺水虽然说NOI原题。。Floyd时顺便求路径条数，用乘法原理$num(i,j)=num(i,k) \times num(k,j)$，相同的时候不要忘了加上$num(i,k) \times num(k,j)$之后再扫一次，找每个中转点$k$，然后继续用乘法原理，经过$k$点的路径总数为$num(i,k) \times num(k,j)$，然后统计一下就出来了 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 100 + 5; const int INF = 1000000000; int n, m; int G[MAXN][MAXN]; double num[MAXN][MAXN], imp[MAXN]; void clean() { for (int i=1;i&lt;=n;i++) { for (int j=1;j&lt;=n;j++) G[i][j] = INF, num[i][j] = 1.0; imp[i] = 0.0; } } void solve() { clean(); for (int i=1;i&lt;=m;i++) { int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); G[a][b] = G[b][a] = c; } for (int k=1;k&lt;=n;k++) for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=n;j++) if (i != j &amp;&amp; i != k &amp;&amp; j != k &amp;&amp; G[i][k] != INF &amp;&amp; G[k][j] != INF) { if (G[i][j] &gt; G[i][k] + G[k][j]) { G[i][j] = G[i][k] + G[k][j]; num[i][j] = num[i][k] * num[k][j];//乘法原理 } else if (G[i][j] == G[i][k] + G[k][j]) num[i][j] += num[i][k] * num[k][j];//加法原理，不要忘了加 } for (int k=1;k&lt;=n;k++) for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=n;j++) if (i != j &amp;&amp; i != k &amp;&amp; j != k &amp;&amp; G[i][k] != INF &amp;&amp; G[k][j] != INF &amp;&amp; G[i][j] != INF) { if (G[i][j] == G[i][k] + G[k][j]) imp[k] += (num[i][k] * num[k][j]) / num[i][j]; } for (int i=1;i&lt;=n;i++) printf(&quot;%.3f\n&quot;, imp[i]); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif scanf(&quot;%d%d&quot;, &amp;n, &amp;m), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>计数原理</tag>
        <tag>Bzoj</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并查集 学习笔记]]></title>
    <url>%2Fsz%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[模板及讲解一份资料 拆点把一个点拆成两个点比较简单不多说例题: NOIP2010 T3 带权例题: NOIP2010 T3并查集维护一个$r$数组，表示$i-&gt;father(i)$的权值。定理：一个并查集中从一个点出发，沿着它所指向的边一直走，并累加下路上的权值(如果边是反的那么就取权值的负数)，走一圈回来，累加的和模 最大值$+1$ 结果一定是$0$路径压缩：由图，根据敌人的敌人是朋友(多于两个阵营不适合带权并查集)，新的$r_x$的值就是$(r_x+r_{f_r})\%(MaxWeight+1)$ 合并的情况：$father(y)=x$，$x$是$a$的根，$y$是$b$的根 由图，$(k+r_b+r_y-r_a)\%(MaxWeight+1)=0$，因为$y$合并至$x$，所以$r_y$变了，那么我们就算出$r_y$即可，$r_y=(-k-r_b+r_a+MaxWeight+1)\%(MaxWeight+1)$，其中加上$MaxWeight+1$是为了防止负数。查询的情况(在一个集合) 由图，如果$(k+r_b-r_a+MaxWeight+1)\%(MaxWeight+1)=0$的话，那么$a-&gt;b$就是$k$，我们就可以这样判断关系。 可撤销并查集可以回退的并查集，复杂度大约$(logn)$不能路径压缩，所以只能按秩合并 (启发式合并，siz小的合并到大的)每次合并记录合并的两个点放到栈中，然后撤销时用栈顶来依次撤销 按秩合并: void mg(int a, int b) { int x = a, y = b; if (sz[x] &gt; sz[y]) swap(x, y); f[x] = y, sz[y] += sz[x], s.push(mp(x, y)); } 撤销操作： void cc(int tms) { while (tms-- &amp;&amp; !s.empty()) { pair&lt;int, int &gt; p = s.top(); s.pop(); int x = p.fir, y = p.sec; f[x] = x, sz[y] -= sz[x]; } } 维护信息一般可以维护$size$等信息。例题：Luogu 1196本题需要维护$d_i$表示$i$到根有多少个战舰和$size$。查询输出$abs(d_x - d_y)-1$即可。 维护只删除链表 ( 跳过序列某一个值 )通过让$x$成为$x-1$的儿子来删掉$x$位置，查询时$x$的根为他左边的第一个位置。例题：Poj 1456通过让$x$成为$x+1$的儿子来删掉$x$位置，查询时$x$的根为他右边的第一个位置。例题：Bzoj 2054 维护数组(维护差分约束)在$find$时，先递归$t=find(f(x))$，然后维护值，然后再使$f(x)=t$差分约束：用并查集维护$c_i=s_i-s_{rt}$例题: BZOJ 1202 网格图维护行列在维护行列的并查集中，如果$r_i$与$c_i$连通则网格这个点被染色，整个图是连通的网格则所有点都被染色。例题: Codeforces 1013D 相关代码]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1202」「HNOI2005」狡猾的商人 (并查集+前缀和/差分约束+前缀和)]]></title>
    <url>%2Fbzoj1202%2F</url>
    <content type="text"><![CDATA[BZOJ 1202方法一：用并查集维护前缀和的差值。设前缀和$s_i$，$c_i$为$s_i-s_{rt}$的值($rt$是这个并查集的根)。 每次查询，如果$x-1,y$属于一个集合，那么直接查询$c_y-c_{x-1}$。证明：$s_y=c_y+s_{rt}, s_{x-1}=c_{x-1}+s_{rt}$，那么$s_y-s_{x-1}=c_y+s_{rt}-(c_{x-1}+s_{rt})=c_y-c_{x-1}$。 如果不在一个集合，那么直接合并，$father(rtx)=rty$，($rtx$是$x-1$的根, $rty$是$y$的根)，这个时候$c_{rtx}$改变了，$c_{rtx}=c_y-c_{x-1}-v$。证明：$s_{rty}=s_y-c_y, s_{rtx}=s_{x-1}-c_{x-1}$$c_{rtx}=s_{rtx}-s_{rty}$$=s_{x-1}-c_{x-1} - (s_y-c_y)$$=-(c_{x-1}-c_y)-(s_{y}-s_{x-1})$$=c_y-c_{x-1}-v$ 方法二：用差分约束维护前缀和，设前缀和$s_i$。由题意得$s_y-s_{x-1}=v$将不等式规范化，得$s_y-s_{x-1}\leq v, s_y-s_{x-1}\geq v$即$s_y-s_{x-1}\leq v, s_{x-1}-s_{y}\leq -v$然后用SPFA检查是否有解 并查集维护前缀和： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 100 + 5; int n, m, flag, f[MAXN], c[MAXN]; void clean() { flag = 0; for (int i=0;i&lt;=n;i++) f[i] = i, c[i] = 0; } int find(int x) { if (x == f[x]) return x; int t = find(f[x]); c[x] += c[f[x]]; return f[x] = t; } void ins(int a, int b, int v) { int x = find(a), y = find(b); if (x != y) { f[x] = y; c[x] = c[b] - c[a] - v; } else if (c[b] - c[a] != v) flag = 1; } void solve() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); clean(); while (m--) { int s, t, v; scanf(&quot;%d%d%d&quot;, &amp;s, &amp;t, &amp;v); ins(s - 1, t, v); } if (!flag) printf(&quot;true\n&quot;); else printf(&quot;false\n&quot;); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif int T; scanf(&quot;%d&quot;, &amp;T); while (T--) solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>Bzoj</tag>
        <tag>前缀和</tag>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1303」「CQOI2009」中位数图 (前缀和+乘法原理)]]></title>
    <url>%2Fbzoj1303%2F</url>
    <content type="text"><![CDATA[BZOJ 1303因为题目是$1-n$排列，所以$b$只会出现一次，那么我们记录$b$的位置$p$，然后我们不难发现当$b$旁边连续的几个数中大于$b$和小于$b$的数的个数相同就会对答案作出贡献。我们记录左边大于$b$的数为$1$，小于$b$的数为$-1$，也就是差分序列(括号序列)，然后从$p-1$到$1$求前缀和，记录在$sum$中，然后$l$数组就是记录某个前缀和出现的次数。右边同理，但是大于$b$的数为$-1$，小于$b$的数为$1$。然后根据乘法原理，左边有$l_i$个可匹配，右边有$r_i$个可匹配，答案就是$\sum_{i=-n}^n l_ir_i$，负数要处理一下，加一个常数，但是注意数组的大小就要乘以二了. #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 100000 + 5, N = 100000; int n, b, p, a[MAXN], l[MAXN*2], r[MAXN*2]; void clean() {} void solve() { clean(); for (int i=1;i&lt;=n;i++) { scanf(&quot;%d&quot;, &amp;a[i]); if (a[i] == b) p = i; } int sum = 0; l[N] = r[N] = 1; for (int i=p-1;i&gt;0;i--) sum += (a[i] &gt; b) ? 1 : -1, l[sum + N]++; sum = 0; for (int i=p+1;i&lt;=n;i++) sum += (a[i] &lt; b) ? 1 : -1, r[sum + N]++; int ans = 0; for (int i=N-n;i&lt;=N+n;i++) ans += l[i] * r[i]; printf(&quot;%d\n&quot;, ans); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif scanf(&quot;%d%d&quot;, &amp;n, &amp;b), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>计数原理</tag>
        <tag>Bzoj</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1192」「HNOI2006」鬼谷子的钱袋 (找规律)]]></title>
    <url>%2Fbzoj1192%2F</url>
    <content type="text"><![CDATA[Bzoj 1192很容易发现把$m$转为二进制，所需要的袋数就是二进制的位数这里有一个特别重要的：二进制下两个$2$的平方数的位数是不变的。并且这中间的所有数都可以由这几位二进制表示。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; LL m; void clean() {} void solve() { clean(); LL ans = 0; while (m) ans++, m &gt;&gt;= 1; printf(&quot;%lld\n&quot;, ans); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif scanf(&quot;%lld&quot;, &amp;m), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1003」「ZJOI2006」物流运输 (最短路+DP)]]></title>
    <url>%2Fbzoj1003%2F</url>
    <content type="text"><![CDATA[BZOJ 1003这种最优性很难考虑的优先思考DP。我们可以算出$c(i,j)$为$i$天到$j$天都能走过的最短路。读入不可以走的数据可以存在一个数组里(类似桶)直接查询，然后每次SPFA的时候预处理出哪些点不可以走，之后再做最短路，然后设$dp(i)$为前$i$天的最小费用，则转移方程$dp(i)=min(dp(j)+c(j+1,i)+k)$其中初值定为$dp(i)=c(1,i)$，然后本题就解决了，注意$n$和$m$所表示的数量意义，不要把顶点数弄成$n$了。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 100 + 5, MAXM = 20 + 5, MAXE = 1000 + 5, INF = 1000000000; struct node {int u, w;}; struct data { int v, w; }e[MAXE * 2];//no init int n, m, K, E;//no init int en, bk[MAXM][MAXN], c[MAXN][MAXN], vi[MAXM], flag[MAXM], dis[MAXM], dp[MAXN]; vector&lt;int&gt; G[MAXM]; void ins(int a, int b, int w) { en++, e[en].v = b, e[en].w = w, G[a].push_back(en); en++, e[en].v = a, e[en].w = w, G[b].push_back(en); } int spfa() { for (int i=1;i&lt;=m;i++) dis[i] = INF, vi[i] = false; queue&lt;node&gt; q; dis[1] = 0, vi[1] = true, q.push((node){1, 0}); while (!q.empty()) { node p = q.front(); q.pop(), vi[p.u] = false; for (int i=0;i&lt;G[p.u].size();i++) { data orz = e[G[p.u][i]]; int v = orz.v, w = orz.w; if (flag[v] &amp;&amp; dis[v] &gt; dis[p.u] + w) { dis[v] = dis[p.u] + w; if (!vi[v]) q.push((node){v, dis[v]}); } } } return dis[m]; } void clean() { en = 0; for (int i=0;i&lt;=m;i++) { G[i].clear(); } ms(c, 0), ms(bk, 0); } void solve() { clean(); for (int i=1;i&lt;=E;i++) { int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c), ins(a, b, c); } int d; scanf(&quot;%d&quot;, &amp;d); while (d--) { int P, a, b; scanf(&quot;%d%d%d&quot;, &amp;P, &amp;a, &amp;b); for (int i=a;i&lt;=b;i++) bk[P][i] = true; } for (int i=1;i&lt;=n;i++) { for (int j=i;j&lt;=n;j++) { for (int k=1;k&lt;=m;k++) { flag[k] = true; for (int l=i;l&lt;=j;l++) { if (bk[k][l]) { flag[k] = false; break; } } } c[i][j] = spfa(); } } for (int i=1;i&lt;=n;i++) for (int j=i;j&lt;=n;j++) if (c[i][j] != INF) c[i][j] *= (j - i + 1); for (int i=1;i&lt;=n;i++) dp[i] = c[1][i]; for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;i;j++) dp[i] = min(dp[i], dp[j] + c[j+1][i] + K); printf(&quot;%d\n&quot;, dp[n]); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;K, &amp;E), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>Bzoj</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1002」「FJOI2007」轮状病毒 (递推+高精度)]]></title>
    <url>%2Fbzoj1002%2F</url>
    <content type="text"><![CDATA[BZOJ 1002由基尔霍夫矩阵树定理推出递推式$$dp(n)=3dp(n-1)-dp(n-2)+2$$初值$dp(1)=1, dp(2)=5$，然后答案很大需要高精度，这题也作为一个练习高精度的题目了 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; struct data { int len, a[105]; }; data mul(data a, int b) {//* for (int i=1;i&lt;=a.len;i++) { a.a[i] *= b; } int jw = 0; for (int i=1;i&lt;=a.len+1;i++) { a.a[i] = a.a[i] + jw; jw = a.a[i] / 10; a.a[i] %= 10; } if (a.a[a.len+1] != 0) a.len++; return a; } data sub(data a, data b) {//- a.a[1] += 2; for (int i=1;i&lt;=a.len;i++) { if (a.a[i] - b.a[i] &lt; 0) { a.a[i] += 10, a.a[i+1]--; } b.a[i] = a.a[i] - b.a[i]; } b.len = a.len; while (b.a[b.len] == 0) b.len--; return b; } int n; void clean() { } void solve() { clean(); if (n &lt;= 2) { if (n == 1) printf(&quot;1\n&quot;); else printf(&quot;5\n&quot;); } data a, b, c; ms(a.a, 0), ms(b.a, 0), a.a[1] = 5, b.a[1] = 1, a.len = b.len = 1; for (int i=3;i&lt;=n;i++) { c = sub(mul(a, 3), b); b = a, a = c; } for (int i=a.len;i&gt;0;i--) printf(&quot;%d&quot;, a.a[i]); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif scanf(&quot;%d&quot;, &amp;n), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>高精度</tag>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1601」「Usaco2008 Oct」灌水 (最小生成树)]]></title>
    <url>%2Fbzoj1601%2F</url>
    <content type="text"><![CDATA[BZOJ 1601Luogu 1550最小生成树上的花费最小。但是这里还有开井的费用，怎么办?我们设一个0点到所有连边，边权为开井的费用，那么就可以最小生成树求解了 想算法的时候多思考一下算法的正确性，多试试样例，想一下极端情况，不要直接就开始编写程序。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 300 + 5, MAXM = 200000 + 5; struct data { int u, v, wi; bool operator &lt; (const data &amp;b) const { return wi &lt; b.wi; } }e[MAXM]; int en, wi[MAXN], n, f[MAXN]; int find(int x) {return f[x] == x ? x : f[x] = find(f[x]);} void clean() { en = 0; for (int i=1;i&lt;=n;i++) f[i] = i; } void solve() { clean(); for (int i=1;i&lt;=n;i++) { scanf(&quot;%d&quot;, &amp;wi[i]); en++, e[en].u = 0, e[en].v = i, e[en].wi = wi[i]; } for (int i=1;i&lt;=n;i++) { for (int j=1;j&lt;=n;j++) { int x; scanf(&quot;%d&quot;, &amp;x); if (j &gt; i) { en++, e[en].u = i, e[en].v = j, e[en].wi = x; } } } sort(e + 1, e + 1 + en); int tot = 0; for (int i=1;i&lt;=en;i++) { int x = find(e[i].u), y = find(e[i].v); if (x != y) f[x] = y, tot += e[i].wi; } printf(&quot;%d\n&quot;, tot); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif scanf(&quot;%d&quot;, &amp;n), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>生成树</tag>
        <tag>USACO月赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1083」「SCOI2005」繁忙的都市 (最小瓶颈路)]]></title>
    <url>%2Fbzoj1083%2F</url>
    <content type="text"><![CDATA[Bzoj 1083模板题，第一个答案$n-1$第二个答案边在最小生成树上注意这里没有给出$m$的范围，那么我们只能按完全图来算最大可能为$\frac{n(n-1)}{2}$ #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 300 + 5, MAXM = 100000 + 5; struct data { int u, v, wi; bool operator &lt; (const data &amp;b) const { return wi &lt; b.wi; } }e[MAXM]; int n, m, en, f[MAXN], ans; int find(int x) {return f[x] == x ? x : f[x] = find(f[x]);} void clean() { en = 0; for (int i=1;i&lt;=n;i++) f[i] = i; } void solve() { clean(); for (int i=1;i&lt;=m;i++) en++, scanf(&quot;%d%d%d&quot;, &amp;e[en].u, &amp;e[en].v, &amp;e[en].wi); sort(e + 1, e + 1 + m); for (int i=1;i&lt;=m;i++) { int x = find(e[i].u), y = find(e[i].v); if (x != y) f[x] = y, ans = e[i].wi; } printf(&quot;%d %d\n&quot;, n - 1, ans); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif scanf(&quot;%d%d&quot;, &amp;n, &amp;m), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1008」「HNOI2008」越狱 (找规律+快速幂/乘法原理+快速幂)]]></title>
    <url>%2Fbzoj1008%2F</url>
    <content type="text"><![CDATA[BZOJ 1008方法1：这种要求方案数而且范围大的，一般都是打表找规律题。通过暴力打表，发现$m=2$的时候答案就是$2^n-2$，所以按照这个继续找规律，发现$m=3$的时候答案是$3^n$减一些有倍数关系的数，然后可以得出答案是$m^n-m(m-1)^{n-1}$方法2：对于$1-n​$等类似的排列计数问题，以动态规划和组合数学2种大方向为基本解决方向。每个格子有$m$种选择，有$n$个格子，所以总方案数为$m^n$。然后第一个格可以有$m$个宗教可以填，后面的格子只能有$m-1$总选择，因为不能和前面的宗教相同，根据乘法原理，答案是$m^n-m(m-1)^{n-1}$正解： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MO = 100003; LL m, n; LL poww(LL a, LL b) { LL ret = 1, s = a; while (b) { if (b &amp; 1) ret = (ret * s) % MO; s = (s * s) % MO; b &gt;&gt;= 1; } return ret; } void clean() {} void solve() { clean(); LL a1 = poww(m, n), a2 = poww(m-1, n-1), a3 = (m * a2) % MO; printf(&quot;%lld\n&quot;, (a1 - a3 + MO) % MO); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif while (scanf(&quot;%lld%lld&quot;, &amp;m, &amp;n)==2) solve(); return 0; } 暴力： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MO = 100003; int n, m, h[1000], ans; void dfs(int a) { if (a == n + 1) { // printf(&quot;\n&quot;); // for (int i=1;i&lt;=n;i++) printf(&quot;%d &quot;, h[i]); for (int i=1;i&lt;=n;i++) if (h[i] == h[i - 1]) {ans++; return ;} } else { for (int i=1;i&lt;=m;i++) { h[a] = i; dfs(a + 1); h[a] = 0; } } } void clean() { ans = 0, ms(h, 0); } void solve() { clean(); dfs(1); printf(&quot;%d\n&quot;, ans % MO); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;2.out&quot;, &quot;w&quot;, stdout); #endif while(scanf(&quot;%d%d&quot;, &amp;m, &amp;n)==2) solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>计数原理</tag>
        <tag>Bzoj</tag>
        <tag>数学</tag>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1050」「HAOI2006」旅行comf (最小瓶颈路)]]></title>
    <url>%2Fbzoj1050%2F</url>
    <content type="text"><![CDATA[Bzoj 1050求$s-​&gt;t$的路径上最大边权与最小边权的比值最小，就是让最小边权尽量接近最大边权。我们枚举每一边作为最小边权，然后我们将边权大于该边权的边按边权大小依次连上，直到$s$与$t$连通，那么这样$s-&gt;t$的路径上的最大边权一定是最后加的这个边，因为加了这条边使得$s$与$t$连通。这条路径上的边权都是大于等于最小边权小于等于最大边权，而最小生成树保证最大边权最小，也就是最小瓶颈路，所以这样就解决了问题。注意可能有最小边就是最大边的情况，这种情况下答案为$1$ 求两点问题，用一点去求另一点，是一个很好的方法 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 500 + 5, MAXM = 5000 + 5; struct data { int u, v, wi; bool operator &lt; (const data &amp;b) const { return wi &lt; b.wi; } }e[MAXM]; int ans1, ans2, s, t, en, n, m, f[MAXN]; db ans; int gcd(int a, int b) {return (b == 0) ? a : gcd(b, a % b);} int find(int x) {return f[x] == x ? x : f[x] = find(f[x]);} void clean() { ans1 = ans2 = en = 0, ans = 1000000000.0; } void solve() { clean(); for (int i=1;i&lt;=m;i++) { en++, scanf(&quot;%d%d%d&quot;, &amp;e[en].u, &amp;e[en].v, &amp;e[en].wi); } scanf(&quot;%d%d&quot;, &amp;s, &amp;t); sort(e + 1, e + 1 + m); for (int i=1;i&lt;=m;i++) { for (int j=1;j&lt;=n;j++) f[j] = j; int maxi = 0; //不要先连这边，因为有最小边和最大边相同的情况 for (int j=i;j&lt;=m;j++) { int x = find(e[j].u), y = find(e[j].v); if (x != y) f[x] = y, maxi = e[j].wi; x = find(s), y = find(t); if (x == y) { int tmp = e[i].wi; if (maxi &lt; tmp) swap(maxi, tmp); if (ans &gt; (db)maxi / (db)tmp) { ans = (db)maxi / (db)tmp; ans1 = maxi, ans2 = tmp; } break; } } } if (ans1 == 0) printf(&quot;IMPOSSIBLE\n&quot;); else if (ans1 % ans2 == 0) printf(&quot;%d\n&quot;, ans1 / ans2); else { int g = gcd(ans1, ans2); printf(&quot;%d/%d\n&quot;, ans1 / g, ans2 / g); } } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif scanf(&quot;%d%d&quot;, &amp;n, &amp;m), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FZYZOJ 1773(最短路)]]></title>
    <url>%2FFZYZOJ1773%2F</url>
    <content type="text"><![CDATA[FJYZOJ 1773一个点无法到达后使一条路径的最短路径变化，那么这个点一定在这条路径的“中转点”上，所以我们FLoyd，找出最终的中转点，就是重要的点。但是如果有几个点都可以作为最终的中转点，那么这几个点都不是重要的。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 200 + 5, INF = 1000000000; int G[MAXN][MAXN], upt[MAXN][MAXN], n, m, mk[MAXN]; void clean() { for (int i=1;i&lt;=n;i++) { mk[i] = 0; for (int j=1;j&lt;=n;j++) G[i][j] = INF, upt[i][j] = 0; } } void solve() { clean(); for (int i=1;i&lt;=m;i++) { int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); if (G[a][b] &gt; c) G[a][b] = G[b][a] = c; } for (int k=1;k&lt;=n;k++) { for (int j=1;j&lt;=n;j++) { for (int i=1;i&lt;=n;i++) { if (k != i &amp;&amp; k != j &amp;&amp; i != j) { if (G[i][j] &gt; G[i][k] + G[k][j]) { G[i][j] = G[i][k] + G[k][j]; upt[i][j] = k; } else if (G[i][j] == G[i][k] + G[k][j]) upt[i][j] = INF; } } } } for (int i=1;i&lt;=n;i++) { for (int j=1;j&lt;=n;j++) { if (upt[i][j] == INF) continue; mk[upt[i][j]] = 1; } } bool flag = false; for (int i=1;i&lt;=n;i++) if (mk[i]) printf(&quot;%d &quot;, i), flag = true; if (!flag) printf(&quot;No important cities.&quot;); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin); freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif scanf(&quot;%d%d&quot;, &amp;n, &amp;m), solve(); fclose(stdin); fclose(stdout); return 0; } 题目描述 小A的老师给小A布置了这样一份作业:某个城市x是“重要”的，当且仅当x不能通过时a-&gt;b的最短路径的值改变了(ab不等于x)，现在告诉你N个城市和M条连接城市之间的路径，求出哪些点是重要的。小A忙着去找小N所以没空做作业。请帮助小A算出哪些城市是重要的。如果不存在就输出”No important cities.”给出的是一个无向图。 输入格式 第一行两个整数N, M，N表示城市数，M表示城市间的道路数。 以下N行，每行三个整数a,b,c。表示城市a到城市b之间存在一条长度为c的道路。 两个城市间可能存在多条道路。 输出格式 一行，按升序输出哪些城市是重要的，2个数中间用空格分开 输入样例 4 41 2 12 3 14 1 24 3 2输出样例 2数据规模与约定 60%数据中N&lt;=100 100%数据中N&lt;=200,M&lt;=N* N,1&lt;=c&lt;=10000]]></content>
      <categories>
        <category>FZYZOJ</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>FZYZOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1369」「Baltic2003」Gem (树形DP)]]></title>
    <url>%2Fbzoj1369%2F</url>
    <content type="text"><![CDATA[BZOJ 1369FJYZOJ 1432按奇偶层染色是错误的，可以举出反例证明颜色不止2种那么我们考虑树形DP，设$dp(i,j)​$为点$i​$染$j​$颜色时$i​$及其子树的最小权和$$dp(i,j)=\sum_{v\in son(i)} min(dp(v,k)|k≠j)$$然后dfs一遍求解就行了 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 10000 + 5, INF = 1000000000; int n, dp[MAXN][11]; vector&lt;int&gt; G[MAXN]; void dfs(int u, int pa) { for (int i=1;i&lt;=10;i++) dp[u][i] = i; for (int i=0;i&lt;G[u].size();i++) { int v = G[u][i]; if (v != pa) dfs(v, u); } for (int j=1;j&lt;=10;j++) { if (G[u].size() == 1) return ; for (int i=0;i&lt;G[u].size();i++) { int mini = INF; int v = G[u][i]; if (v == pa) continue; for (int k=1;k&lt;=10;k++) { if (j == k) continue; mini = min(mini, dp[v][k]); } dp[u][j] += mini; } } } void clean() { for (int i=0;i&lt;=n;i++) { G[i].clear(); } } void solve() { clean(); for (int i=1;i&lt;n;i++) { int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); G[a].push_back(b), G[b].push_back(a); } dfs(1, 0); int ans = INF; for (int i=1;i&lt;=10;i++) { ans = min(ans, dp[1][i]); } printf(&quot;%d\n&quot;, ans); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin); freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif scanf(&quot;%d&quot;, &amp;n), solve(); fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>树形DP</tag>
        <tag>FZYZOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 235B(概率DP+组合数)]]></title>
    <url>%2FCodeforces235B%2F</url>
    <content type="text"><![CDATA[Codeforces 235B这题可能一开始连状态都不知道怎么设，这里先给出一个结论，如果有一个O，那么分数加$1$，如果有两个O且之间没有X，那么分数加$2$. 我们来证明：由$2C^2_n+n=n^2$分两种情况1 一个O的情况在一个全是O序列中，O有$n$个那么这些O对答案的贡献是$1$这样完成就完成了一个O的情况的贡献2 两个O的情况在一个全是O序列中，两个O的情况有$C^2_n$种我们设$event(j,i)$为$\prod_i^jp_x$，即$[j,i]$都是O的概率因为这两个O之间不能有X，所以这两个O之间都必须是O，概率为$event(j,i)$设$dp(i)=\sum_{j=1}^{i-1}event(j,i)$，每个$i$对答案的贡献为$dp(i) \times 2$而算$dp(i)​$是平方级算法，并且这个$dp(i)​$没有充分利用前面的状态，我们试着推导：$\sum_{j=1}^{i-1}event(j,i) = p_1 \times p_2 \times … \times p_i + p_2 \times p_3 \times … \times p_i + … + p_{i-1} \times p_i$所以$dp(i)=(dp(i-1)+p_{i-1} \times p_i)$，就是把原式结合律这样完成就完成了两个O的情况的贡献 然后把答案相加就是最后的答案。可以直接DP。然后观察方程，$dp(i)$只和$dp(i-1)$有关，所以数组都可以省了Codeforces Submission #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; int n; void clean() {} void solve() { clean(); db tem = 0.0, p = 0.0, ans = 0.0; for (int i=1;i&lt;=n;i++) { tem += p; scanf(&quot;%lf&quot;, &amp;p); tem *= p; ans += p + tem * 2; } printf(&quot;%.15f\n&quot;, ans); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif scanf(&quot;%d&quot;, &amp;n), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>概率DP</tag>
        <tag>Codeforces</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOI 2017-07-20集训 T2(线段树/树状数组)]]></title>
    <url>%2FBZOI%202017-07-20%E9%9B%86%E8%AE%AD-t2%2F</url>
    <content type="text"><![CDATA[此题线段树模板题，但是据说这题本来要卡线段树但是失败了，正解是树状数组，树状数组快一半，常数小，树状数组区间修改区间查询看我的算法笔记中的解释。线段树： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define FN2 &quot;MoSQL&quot; using namespace std; const int MAXN = 1e6 + 5; int n, Q; LL a[MAXN * 4], sumv[MAXN * 4], addv[MAXN * 4]; #define lc (o&lt;&lt;1) #define rc (o&lt;&lt;1|1) #define M ((l+r)&gt;&gt;1) void pushup(int o) { sumv[o] = sumv[lc] + sumv[rc]; } void build(int o, int l, int r) { if (l == r) sumv[o] = a[l]; else build(lc, l, M), build(rc, M + 1, r), pushup(o); } void pushdown(int o, int len) { if (addv[o]) { sumv[lc] += addv[o] * (len - len / 2), sumv[rc] += addv[o] * (len / 2); addv[lc] += addv[o], addv[rc] += addv[o]; addv[o] = 0; } } void update(int o, int l, int r, int x, int y, LL w) { if (x &lt;= l &amp;&amp; r &lt;= y) { sumv[o] += w * (r - l + 1); addv[o] += w; return ; } pushdown(o, r - l + 1); if (x &lt;= M) update(lc, l, M, x, y, w); if (M &lt; y) update(rc, M + 1, r, x, y, w); pushup(o); } LL query(int o, int l, int r, int x, int y) { LL ret = 0; if (x &lt;= l &amp;&amp;r &lt;= y) { return sumv[o]; } pushdown(o, r - l + 1); if (x &lt;= M) ret += query(lc, l, M, x, y); if (M &lt; y) ret += query(rc, M + 1, r, x, y); return ret; } void clean() { for (int i=0;i&lt;=n*4;i++) sumv[i] = addv[i] = 0; } void solve() { clean(); for (int i=1;i&lt;=n;i++) scanf(&quot;%I64d&quot;, &amp;a[i]); build(1, 1, n); scanf(&quot;%d&quot;, &amp;Q); char ch[20]; for (int i=1;i&lt;=Q;i++) { scanf(&quot;%s&quot;, ch); if (ch[0] == &#39;Q&#39;) { int l, r; scanf(&quot;%d%d&quot;, &amp;l, &amp;r); if (l &gt; r) swap(l, r); printf(&quot;%I64d\n&quot;, query(1, 1, n, l, r)); } else if (ch[0] == &#39;A&#39;) { int l, r; LL x; if (l &gt; r) swap(l, r); scanf(&quot;%d%d%I64d&quot;, &amp;l, &amp;r, &amp;x); update(1, 1, n, l, r, x); } } } int main() { freopen(FN2&quot;.in&quot;, &quot;r&quot;, stdin); freopen(FN2&quot;.out&quot;, &quot;w&quot;, stdout); scanf(&quot;%d&quot;, &amp;n), solve(); fclose(stdin); fclose(stdout); return 0; } 树状数组： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define FN2 &quot;MoSQL&quot; using namespace std; const int MAXN = 1e6 + 5; int n, Q; LL a[MAXN], c1[MAXN], c2[MAXN]; int lowbit(int x) {return x&amp;(-x);} void add(int x, LL w) { for (int i=x;i&lt;=n;i+=lowbit(i)) { c1[i] += w, c2[i] += (LL)x * (LL)w; } } LL query(int x) { LL ret = 0; for (int i=x;i&gt;0;i-=lowbit(i)) { ret += (x + 1) * c1[i] - c2[i]; } return ret; } void clean() { ms(c1, 0), ms(c2, 0); } void solve() { clean(); for (int i=1;i&lt;=n;i++) scanf(&quot;%I64d&quot;, &amp;a[i]), add(i, a[i]), add(i + 1, -a[i]); scanf(&quot;%d&quot;, &amp;Q); char ch[20]; for (int i=1;i&lt;=Q;i++) { scanf(&quot;%s&quot;, ch); if (ch[0] == &#39;Q&#39;) { int l, r; scanf(&quot;%d%d&quot;, &amp;l, &amp;r); printf(&quot;%I64d\n&quot;, query(r) - query(l - 1)); } else if (ch[0] == &#39;A&#39;) { int l, r; LL x; scanf(&quot;%d%d%I64d&quot;, &amp;l, &amp;r, &amp;x); add(l, x), add(r + 1, -x); } } } int main() { freopen(FN2&quot;.in&quot;, &quot;r&quot;, stdin); freopen(FN2&quot;.out&quot;, &quot;w&quot;, stdout); scanf(&quot;%d&quot;, &amp;n), solve(); fclose(stdin); fclose(stdout); return 0; } mogician 的 SQL]]></content>
      <categories>
        <category>模拟题/训练题</category>
      </categories>
      <tags>
        <tag>模拟题/训练题</tag>
        <tag>线段树</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 768D(概率DP)]]></title>
    <url>%2FCodeforces768D%2F</url>
    <content type="text"><![CDATA[Codeforces 768D设$dp(i,j)$为前$i$天生产了$j$种不同的水晶的概率，转移方程：$$dp(i,j)=dp(i-1,j) \times \frac{j}{k} + dp(i-1,j-1) \times \frac{k-j+1}{k}$$之后判断$dp(i,k)$是否大于给定条件，答案为$i$然后因为$p&lt;=1000$，所以把所有情况先预处理出来，直接输出即可。此题可以把第一维压掉，注意$eps=1e-7$不要写作$eps=1e7$Codeforces Submission #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXQ = 1000 + 5; const db eps = 1e-7; int now, k, Q, ans[MAXQ]; db dp[MAXQ]; void clean() { ms(dp, 0), dp[0] = 1.0, now = 1; } void solve() { clean(); for (int i=1;now&lt;=1000;i++) { for (int j=k;j&gt;0;j--) dp[j] = (dp[j] * (db)j + dp[j-1] * (db)(k-j+1)) / (db)k; while (now &lt;= 1000 &amp;&amp; dp[k] * 2000.0 &gt;= (now - eps)) { ans[now] = i, now++; } dp[0] = 0.0; } for (int i=1;i&lt;=Q;i++) { int p; scanf(&quot;%d&quot;, &amp;p); printf(&quot;%d\n&quot;, ans[p]); } } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif scanf(&quot;%d%d&quot;, &amp;k, &amp;Q), solve(); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>概率DP</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AHSOFNU NOIP模拟题-13 T2(概率DP)]]></title>
    <url>%2FAHSOFNU-NOIP%E6%A8%A1%E6%8B%9F-13-t2%2F</url>
    <content type="text"><![CDATA[设$dp(i,j,k)$为前$i$个挑战赢了$j$场，当前背包容量为$k$的状态存在的概率。注意，背包容量超过$n$即无意义，所以要一直取$min$状态转移方程：$dp(i+1,j,k)=dp(i,j,k) \times (1 - P_{i+1})$$dp(i+1,j+1,k+a_{i+1})=dp(i,j,k) \times P_{i+1}$在转移的过程中不要忘了取$min$。我们在DP前需要把挑战按背包容量排序，这样先打掉背包多的怪物，再打要装碎片的怪物，可以避免本来够但安排不合理，而不够背包装碎片的情况 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define FN2 &quot;guard&quot; using namespace std; const int MAXN = 200 + 5; db dp[MAXN][MAXN][MAXN]; struct data { int ai; db pi; bool operator &lt; (const data &amp;b) const { return ai &gt; b.ai; } }a[MAXN]; int n, L, K; void clean() { ms(dp, 0); } void solve() { clean(); for (int i=1;i&lt;=n;i++) scanf(&quot;%lf&quot;, &amp;a[i].pi), a[i].pi /= 100.0; for (int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;, &amp;a[i].ai); sort(a + 1, a + 1 + n); dp[0][0][min(K, n)] = 1.0; for (int i=0;i&lt;=n;i++) { for (int j=0;j&lt;=i;j++) { for (int k=0;k&lt;=n;k++) { dp[i + 1][j][k] += dp[i][j][k] * (1 - a[i + 1].pi); int t = min(k + a[i + 1].ai, n); if (t &lt; 0) continue; dp[i + 1][j + 1][t] += dp[i][j][k] * a[i + 1].pi; } } } db ans = 0.0; for (int i=L;i&lt;=n;i++) { for (int j=0;j&lt;=n;j++) { ans += dp[n][i][j]; } } printf(&quot;%.6f\n&quot;, ans); } int main() { freopen(FN2&quot;.in&quot;, &quot;r&quot;, stdin); freopen(FN2&quot;.out&quot;, &quot;w&quot;, stdout); scanf(&quot;%d%d%d&quot;, &amp;n, &amp;L, &amp;K), solve(); fclose(stdin); fclose(stdout); return 0; } 守卫者的挑战(guard.pas/c/cpp)题目描述打开了黑魔法师 Vani 的大门，队员们在迷宫般的路上漫无目的地搜寻着关押 applepi 的监狱的所在地。突然，眼前一道亮光闪过。“我， Nizem，是黑魔法圣殿的守卫者。如果你能通过我的挑战，那么你可以带走黑魔法圣殿的地图„„”瞬间，队员们被传送到了一个擂台上，最初身边有一个容量为 K 的包包。擂台赛一共有 N 项挑战，各项挑战依次进行。第i 项挑战有一个属性 ai ，如果ai   ，表示这次挑战成功后可以再获得一个容量为 ai 的包包；如果 ai  ，则表示这次挑战成功后可以得到一个大小为 1 的地图残片。地图残片必须装在包包里才能带出擂台，包包没有必要全部装满，但是队员们必须把获得的所有的地图残片都带走（没有得到的不用考虑，只需要完成所有 N 项挑战后背包容量足够容纳地图残片即可），才能拼出完整的地图。并且他们至少要挑战成功 L 次才能离开擂台。队员们一筹莫展之时，善良的守卫者 Nizem 帮忙预估出了每项挑战成功的概率，其中第 i 项挑战成功的概率为pi 。现在，请你帮忙预测一下，队员们能够带上他们获得的地图残片离开擂台的概率。输入格式第一行三个整数 N , L , K 。第二行 N 个实数，第i 个实数 pi 表示第i 项挑战成功的百分比。第三行 N 个整数，第i 个整数 ai 表示第i 项挑战的属性值.输出格式一个整数，表示所求概率，四舍五入保留 6 位小数。样例输入 13 1 010 20 30-1 -1 2样例输出 10.300000样例输入 25 1 236 44 13 83 63-1 2 -1 2 1样例输出 20.980387样例说明在第一个样例中， 若第三项挑战成功，如果前两场中某场胜利，队员们就有空间来容纳得到的地图残片，如果挑战失败，根本就没有获得地图残片，不用考虑是否能装下；若第三项挑战失败，如果前两场有胜利，没有包来装地图残片，如果前两场都失败，不满足至少挑战成功 L 次（L 1）的要求。因此所求概率就是第三场挑战获胜的概率。数据范围与约定对于 100% 的数据，保证  K  ，   N  ，  ai  ，   L  N ，  p]]></content>
      <categories>
        <category>模拟题/训练题</category>
      </categories>
      <tags>
        <tag>模拟题/训练题</tag>
        <tag>概率DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AHSOFNU NOIP模拟题-13 T1(并查集)]]></title>
    <url>%2FAHSOFNU-NOIP%E6%A8%A1%E6%8B%9F-13-t1%2F</url>
    <content type="text"><![CDATA[可以观察样例发现规律，对于每一条加进来的边$(u, v)$，如果$u, v$连通，则$ans = ans \times 2 -1(ans = 1 when init)$，不连通就连边即可，显然用并查集维护。 有一个易懂的证明：题目中每个点的度数大于零且都是偶数的子图等于这个子图就是几个环(它们之间不一定连通)，对于每一条加进来的边$(u, v)$，如果$u, v$连通，那么$(u, v)$连上以后会形成一个环。而如果有一条路径$L$连接$u,v$，那么可以用边$(u, v)$替换掉$L$，则之前的每个方案都可以替换，那么答案自然就多一倍了。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define FN2 &quot;magician&quot; using namespace std; const int MAXN = 200000 + 5, MO = 1000000009; int n, m, fa[MAXN]; int read() { int x = 0; char ch = getchar(); while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) ch = getchar(); while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) x = x * 10 + ch - &#39;0&#39;, ch = getchar(); return x; } int find(int x) {return (fa[x] == x) ? (x) : (fa[x] = find(fa[x]));} void clean() { for (int i=1;i&lt;=n;i++) fa[i] = i; } void solve() { clean(); int ans = 1; for (int i=1;i&lt;=m;i++) { int a = read(), b = read(); int x = find(a), y = find(b); if (x != y) fa[x] = y; else ans = (ans * 2) % MO; printf(&quot;%d\n&quot;, ans - 1); } } int main() { freopen(FN2&quot;.in&quot;, &quot;r&quot;, stdin); freopen(FN2&quot;.out&quot;, &quot;w&quot;, stdout); n = read(), m = read(), solve(); fclose(stdin); fclose(stdout); return 0; } 黑魔法师之门(magician.pas/c/cpp)题目描述经过了 16 个工作日的紧张忙碌，未来的人类终于收集到了足够的能源。然而在与 Violet星球的战争中，由于 Z 副官的愚蠢，地球的领袖 applepi 被邪恶的黑魔法师 Vani 囚禁在了Violet 星球。为了重启 Nescafé这一宏伟的科技工程，人类派出了一支由 XLk、 Poet_shy 和lydrainbowcat 三人组成的精英队伍，穿越时空隧道，去往 Violet 星球拯救领袖 applepi。applepi 被囚禁的地点只有一扇门，当地人称它为“黑魔法师之门”。这扇门上画着一张无向无权图，而打开这扇门的密码就是图中每个点的度数大于零且都是偶数的子图的个数对 1000000009 取模的值。此处子图 (V, E) 定义为：点集 V 和边集 E 都是原图的任意子集，其中 E 中的边的端点都在 V 中。但是 Vani 认为这样的密码过于简单，因此门上的图是动态的。起初图中只有 N 个顶点而没有边。 Vani 建造的门控系统共操作 M 次，每次往图中添加一条边。你必须在每次操作后都填写正确的密码，才能够打开黑魔法师的牢狱，去拯救伟大的领袖 applepi。输入格式第一行包含两个整数 N 和 M。接下来 M 行，每行两个整数 A 和 B，代表门控系统添加了一条无向边 (A, B)。输出格式输出一共 M 行，表示每次操作后的密码。样例输入4 83 13 22 12 11 31 42 42 3样例输出0 0 13 7 71531样例说明第三次添加之后，存在一个满足条件的子图 {1, 2, 3}（其中 1, 2, 3 是数据中边的标号）。第四次添加之后，存在三个子图 {1, 2, 3}， {1, 2, 4}， {3, 4}。„„数据范围与约定对于 30% 的数据， N, M≤10。对于 100% 的数据， N≤200000， M≤300000。]]></content>
      <categories>
        <category>模拟题/训练题</category>
      </categories>
      <tags>
        <tag>模拟题/训练题</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 540D(概率DP)]]></title>
    <url>%2FCodeforces540D%2F</url>
    <content type="text"><![CDATA[Codeforces 540D设$dp(i,j,k)$为石头有$i$人，剪刀有$j$人，纸有$k$人的状态存在的概率。则转移方程为$$dp(i,j,k)= dp(i+1,j,k) \times P_1 + dp(i,j+1,k) \times P_2 + dp(i,j,k+1) \times P_3$$$dp(r, s, p) = 1.0$但是这样不好转移，因为概率是很难算的，那我们改一下原方程：设$sum=ij+ik+jk$$dp(i-1, j, k)=dp(i, j, k) \times \frac{ik}{sum}​$$dp(i, j-1, k)=dp(i, j, k) \times \frac{ij}{sum}​$$dp(i, j, k-1)=dp(i, j, k) \times \frac{jk}{sum}​$这样就方便转移了，最后的答案累加一下必胜的状态的存在概率即可。Codeforces Submission #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 100 + 5; int r, s, p; db dp[MAXN][MAXN][MAXN]; void clean() { ms(dp, 0); } void solve() { clean(); dp[r][s][p] = 1.0; for (int i=r;i&gt;=1;i--) { for (int j=s;j&gt;=1;j--) { for (int k=p;k&gt;=1;k--) { db sum = (db)(i * j) + (db)(i * k) + (db)(j * k); dp[i-1][j][k] += dp[i][j][k] * ((db)(i * k) / sum); dp[i][j-1][k] += dp[i][j][k] * ((db)(i * j) / sum); dp[i][j][k-1] += dp[i][j][k] * ((db)(j * k) / sum); } } } db ans1 = 0.0, ans2 = 0.0, ans3 = 0.0; for (int i=1;i&lt;=100;i++) { for (int j=0;j&lt;=100;j++) { ans1 += dp[i][j][0]; ans2 += dp[0][i][j]; ans3 += dp[j][0][i]; } } printf(&quot;%.12f %.12f %.12f\n&quot;, ans1, ans2, ans3); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin); freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif scanf(&quot;%d%d%d&quot;, &amp;r, &amp;s, &amp;p), solve(); fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>概率DP</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AHSOFNU NOIP模拟题-11 T2(堆+贪心)]]></title>
    <url>%2FAHSOFNU-NOIP%E6%A8%A1%E6%8B%9F-11-t2%2F</url>
    <content type="text"><![CDATA[把所有地鼠按消失时间$t$排序，然后维护一个小根堆，每次不断地插入，直到当前时间大于插入的时间，那就把堆顶拿出来比较，如果小于当前的，就替换掉。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define FN2 &quot;mouse&quot; using namespace std; const int MAXN = 100000 + 5; int n, maxt; struct data { int t, v; bool operator &lt; (const data &amp;b) const { return v &gt; b.v; } }a[MAXN]; bool cmp(data a, data b) { return a.t &lt; b.t; } void clean() { } void solve() { clean(); for (int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;, &amp;a[i].t); for (int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;, &amp;a[i].v); sort(a+1, a+1+n, cmp); priority_queue&lt;data&gt; q; int now = 0, ans = 0; for (int i=1;i&lt;=n;i++) { if (now &lt; a[i].t) { now++; ans += a[i].v; q.push(a[i]); } else { data p = q.top(); if (p.v &gt; a[i].v) continue; ans = ans - p.v + a[i].v; q.pop(); q.push(a[i]); } } printf(&quot;%d\n&quot;, ans); } int main() { freopen(FN2&quot;.in&quot;, &quot;r&quot;, stdin); freopen(FN2&quot;.out&quot;, &quot;w&quot;, stdout); scanf(&quot;%d&quot;, &amp;n), solve(); fclose(stdin); fclose(stdout); return 0; } 打地鼠游戏（mouse.pas/.c/.cpp）时间限制：1s 空间限制：128MB题目描述：伟大的2320学长特别喜欢打地鼠游戏，这个游戏开始后，会在地板上冒出一些地鼠来，你可以用榔头去敲击这些地鼠，每个地鼠被敲击后，将会增加相应的游戏分值。可是，所有地鼠只会在地上出现一段时间（而且消失后再也不会出现），每个地鼠都在0时刻冒出，但停留的时间可能是不同的，而且每个地鼠被敲击后增加的游戏分值也可能是不同。最近2320学长经常玩这个游戏，以至于敲击每个地鼠只要1秒。他在想如何敲击能使总分最大。输入描述：输入包含3行，第一行包含一个整数n（1&lt;=n&lt;=100000）表示有n个地鼠从地上冒出来，第二行n个用空格分隔的整数表示每个地鼠冒出后停留的时间（Maxt&lt;=50000），第三行n个用空格分隔的整数表示每个地鼠被敲击后会增加的分值v（v&lt;=1000）。每行中第i个数都表示第i个地鼠的信息。样例输入：55 3 6 1 47 9 2 1 5样例输出：24数据范围：30%的数据保证n&lt;=100, t&lt;=500,v&lt;=5060%的数据保证 n&lt;=10000,t&lt;=3000,v&lt;=500100%的数据保证 n&lt;=100000,t&lt;=5000,v&lt;=1000]]></content>
      <categories>
        <category>模拟题/训练题</category>
      </categories>
      <tags>
        <tag>模拟题/训练题</tag>
        <tag>堆</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zoj 3640(概率期望DP)]]></title>
    <url>%2Fzoj3640%2F</url>
    <content type="text"><![CDATA[zoj 3640设$dp(u)$为力气值为$u$时的逃离期望。当$u \leq c(i)$时可以转移到$dp(u+c(i))$，否则$dp(u)$可以直接加上$t(i)$显然记忆化搜索好写，直接写记忆化搜索即可，递推其实也可以的。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 10000 + 5; const db xs = (1.0 + sqrt(5)) / 2.0; int n, f, ci[MAXN]; db dp[MAXN*2]; db dfs(int u) { if (dp[u]&gt;=0) return dp[u]; dp[u] = 0; for (int i=1;i&lt;=n;i++) { if (u &gt; ci[i]) { dp[u] += (int)(ci[i] * ci[i] * xs); } else dp[u] += dfs(u + ci[i]) + 1; } dp[u] *= 1.0 / (db)n; return dp[u]; } void clean() { ms(dp, -1); } void solve() { clean(); for (int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;, &amp;ci[i]); printf(&quot;%.3f\n&quot;, dfs(f)); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin); freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif while (scanf(&quot;%d%d&quot;, &amp;n, &amp;f)==2) solve(); fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>zoj</category>
      </categories>
      <tags>
        <tag>概率DP</tag>
        <tag>zoj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组合数学 学习笔记]]></title>
    <url>%2Fsz%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[知识点讲解排列组合圆周排列从$n$个不同元素中无重复地取出$k(1≤k≤n)$个元素排在一个圆周上，称为$n$个不同元素的一个圆周排列，简称k-圆排列圆周排列个数为$$\frac{A^k_n}{k} = \frac{n!}{k\cdot(n-k)!}$$ 1 重复组合从$n$个不同元素中无序但可重复取出$k(1≤k≤n)$个元素，称为$n$个不同元素中取出$k$个元素的一个重复组合，简称k-可重组合重复组合个数为$$C^{k}_{n+k-1}$$ 2 组合数性质$C^k_n = C^{n-k}_n$$C^k_n = C^{k-1}_{n-1} + C^{k}_{n-1}$$C^k_n = C^{k-1}_{n-1} \times n \div k$ 3、求组合数方法1、阶乘 (定义法)2、杨辉三角二维递推 (递推式$C^m_n=C_{n-1}^{m-1}+C_{n-1}^{m}$)3、一维递推 3 个公式 (易从定义式推出)：$C^m_n=\frac{n}{n-m} C^m_{n-1}$$C^m_n=\frac{n-m+1}{m} C^{m-1}_n$$C^m_n = \frac nm C^{m-1}_{n-1}$4、优化：$C^m_n = C^{n-m}_n$ 卡特兰数Catalan数递推公式：$f(n)=\sum_{i=0}^{n-1}f(i)f(n-i-1)$(用于乘法原理寻找规律)通项公式：$\text{Catalan}_n=\frac{1}{n+1}C^n_{2n}$性质：$\text{Catalan}_n=C_{2n}^n-C_{2n}^{n-1}$, 证明直接用组合数定义通分即可 常见题型： 1 由$n$个1和$n$个$0$构成$2n$项的数列$a_i$其满足任意前缀$1$个数不比$0$少，这样的数列个数为$\text{Catalan}_n$ 变式1：括号正确匹配序列个数是$\text{Catalan}_n$变式2：$n$个数入栈后的出栈的排列总数是$\text{Catalan}_n$变式3：对于一个$n \times n$的正方形网格，每次只能向右或者向上移动一格，那么从左下角到右上角所有在副对角线(下图中虚线)右下方的路径总数为$\text{Catalan}_n$变式4：对于集合$[1,n], n \in \text{Z}$，将集合元素两两分为$n$个子集，若任意两个子集都不交叉，那么我们称此划分为一个不交叉划分, 不交叉的划分数就是$\text{Catalan}_n$变式5：$n$层的阶梯切割为$n$个矩形的切法数是$\text{Catalan}_n$ 2 $dp(i)=dp(i) \cdot dp(n-i-1)$ 变式1：三角剖分数为$\text{Catalan}_n$变式2：$2n$个点均匀排列在圆上，两两连线不相交的方案数为$\text{Catalan}_n$变式3：平面上连接可以形成凸包的$2n$个点分成$2$个一组连成$n$条线段，两两线段之间不相交的情况总数是$\text{Catalan}_n$ 错位排列错位排列Bzoj 4517错位排列可以递推出来，设$n$个数的错位排列是$D(n)$，则有$$D(n)=(n-1)(D(n-1)+D(n-2))$$证明：考虑$n$这个数放到了$k$位置，有$n-1$种情况。然后考虑$k$这个数放在哪1、$k$这个数放在$n$位置，那么显然$n,k$全部被排完，变成了$D(n-2)$的局面2、$k$这个数不放在$n$位置，那么现在先不放$k$，然后现在我们已经少了一个$n$数和$k$位置，那么其实$k$数等价于现在的$n$数，变成了$D(n-1)$的局面 这里还有一个通项式子$$D(n) = n! \left( 1 - \frac{1}{1!} + \frac{1}{2!} - \frac{1}{3!} \cdots + (-1)^n \frac{1}{n!} \right)$$证明即使用容斥原理。 还有一种容斥的方法，即先考虑有几个人站在了原来的位置，然后可以容斥 即考虑选出人出来在原来的位置，可以得到$$\text{Ans} = \sum_{k = 0}^{n}{(-1)^k\binom{n}{k} (n - k)!}$$ 容斥原理容斥基本思想就是题目所求的东西有多个限制，我们只满足或者不满足某些限制，然后其他的不管，然后再进行容斥。 容斥套路1、全部 - 至少一个 + 至少两个 - …… = 一个也没有 (也就是最基础的容斥)2、所有 - 一个也没有 = 至少有一个 (一些补集转化)3、恰好有 k 个的：二项式反演 (广义容斥)4、与质因子相关的容斥用$\mu$为容斥系数。5、直接求不方便的，而求至少却很容易的 最基础的容斥即为全部 - 至少一个 + 至少两个 - …… = 一个也没有这样的容斥，是广义容斥恰好有 $k$ 个的$k=0$的特例例题：Bzoj 4665，多重集的组合数 广义容斥 (二项式反演)一般题目是求恰好有 k 个的即若有$$F(i)= \sum \limits_{j=i}^{n} C^{i}_{j} \times g(j)$$则有$$g(i)= \sum \limits_{j=i}^{n} (-1)^{j-i} \times C^{i}_{j} \times F(j)$$例题：Bzoj 3622 已经没有什么好害怕的了 ，SDOI spring，CF 285E 容斥系数有$n$种属性，若干物品。假设我们可以容易地计算出，$g(S)$表示包含$S$集合的物品个数。且给定$w(k)$表示，当物品拥有$k$个属性时它的价值是多少。求所有物品的价值和。 我们需要确定一个容斥系数$f(k)$，使得$Ans=\sum \limits_{s\in S}g(s)f(|s|)$。 同上，考虑令每个物品被算入的贡献等于我们想要的数。即对于一个拥有$k$种属性的物品，需要满足$$\sum_{i=1}^kC_k^if(i)=w(k)$$$f(i)$ 是可以$O(n^2)$递推的。假设已知$f(1)…f(k−1)$$$\sum_{i=1}^kC_k^if(i)=w(k) \Rightarrow f(k)=w(k)-\sum_{i=1}^{k-1}C_k^if(i)$$大部分题中是用$O(n^2)$/手推来找规律算的。 最基本的容斥原理的$w(k)$即为$[k=0]$ 例题1：“玲珑杯” 线上赛 Round#17 B 当咸鱼也要按照基本法 给定$m$个数$A_i$和$n$。求$[1,n]$中有多少个数能被奇数个$A_i$整除。$T≤1000$组数据，$n≤10^5$, $m≤15$。 发现$m$很小，可以枚举子集，然后我们很方便求出每个子集在$[1,n]$的整除个数, 然后可以考虑容斥，这里只需要整除个数为奇数的，所以我们可以列出$$\sum_{i=1}^kC_k^if(i)=k \mod 2$$然后可以计算容斥系数。也可以打表后发现容斥系数的规律 例题2： 求出错位排列中，如果有$k$个人在原来的位置，价值为$w(k)$，求所有排列的价值 $$\sum_{i=1}^kC_k^if(i)=w(k)$$ $\mu$函数为容斥系数Bzoj 2440 求区间$[1,n]$不是完全平方数的正整数倍的数的个数。 是完全平方数的正整数倍的数是很好计数的，我们可以考虑容斥。我们发现这个容斥就是用$\mu$作为容斥系数的，具体可以看本博客莫比乌斯反演的部分然后答案就是$$\sum_{i=1}^{\sqrt n} \left \lfloor \frac{n}{i^2} \right \rfloor \times \mu(i)$$ 类似的题还有Codeforces 439E 计数题技巧思考容斥按顺序计数，不重不漏「Loj 6185」烷基计数 (按子树大小)「CH 5302」金字塔画烷烃的同分异构体 (枚举直径) 补集转化当正着做不方便时就补集转化。例如一些概率的计算 DP大部分计数题都和DP递推有关 划分子问题方法1、正常方法划分此类问题比较多 2、以0、1划分1、Catalan数(栈、只向上向右)2、「poj 1737」Connected Graph]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>计数原理</tag>
        <tag>组合数学</tag>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj 2151(概率DP)]]></title>
    <url>%2Fpoj2151%2F</url>
    <content type="text"><![CDATA[poj 2151设$dp(i, j, k)$为选手$i$在前$j$题中做对$k$题的概率，则转移方程为$$dp(i,j,k)=dp(i,j-1,k-1) \times p(i,j) + dp(i,j-1,k) \times (1-p(i,j))$$初始化的时候$dp(i,0,0)=1, dp(i,j,0)=dp(i,j-1,0) \times (1-p(i,j))$然后因为我们要求出所有选手做对一题且有选手做出大于等于$n$题，所以这是个容斥问题，即可以用所有选手至少做对一题的概率$P_1$减去所有选手做对题目个数在$[1, n-1]$之间的概率$P_2$的差即为答案，怎么求呢？设$s(i,j)$为选手$i$做对至多$j$题的概率，则$s(i,j)= \sum_{k=0}^{j} dp(i, k)$则$P_1= \prod_{i=1}^{t}(1-s(m, 0)) $$P_2= \prod_{i=1}^{t}(s(m, n-1)-s(m, 0)) $$P_1 - P_2$即为答案(容斥原理) #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXM = 50 + 5, MAXT = 1000 + 10; int m, t, n; db p[MAXT][MAXM], dp[MAXT][MAXM][MAXM], s[MAXT][MAXM]; void clean() { ms(dp, 0); } void solve() { clean(); for (int i=1;i&lt;=t;i++) for (int j=1;j&lt;=m;j++) scanf(&quot;%lf&quot;, &amp;p[i][j]); for (int i=1;i&lt;=t;i++) { dp[i][0][0] = 1; for (int j=1;j&lt;=m;j++) dp[i][j][0] = dp[i][j-1][0] * (1 - p[i][j]); for (int j=1;j&lt;=m;j++) { for (int k=1;k&lt;=j;k++) { dp[i][j][k] = dp[i][j-1][k-1] * p[i][j] + dp[i][j-1][k] * (1 - p[i][j]); } } } for (int i=1;i&lt;=t;i++) { s[i][0] = 0; for (int j=0;j&lt;=m;j++) s[i][j] = s[i][j - 1] + dp[i][m][j]; } db p1 = 1, p2 = 1; for (int i=1;i&lt;=t;i++) p1 *= (1 - s[i][0]); for (int i=1;i&lt;=t;i++) p2 *= (s[i][n-1] - s[i][0]); printf(&quot;%.3f\n&quot;, p1 - p2); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin); freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif while (scanf(&quot;%d%d%d&quot;, &amp;m, &amp;t, &amp;n)&amp;&amp;(m||t||n)) solve(); fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>概率DP</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 148D(概率DP)]]></title>
    <url>%2FCodeforces148D%2F</url>
    <content type="text"><![CDATA[Codeforces 148D设$dp(i, j)$为轮到王妃选鼠的时候白鼠有$i$只，黑鼠有$j$只时赢的概率。分4种情况.1、王妃选到白，则概率为$\frac{i}{i+j}$2、龙选到白，王妃输了，则概率为$0$3、王妃选到黑，龙选到黑，逃了黑，转移到$dp(i, j-3)$，则概率为$\frac{j}{i+j} \times \frac{j-1}{i+j-1} \times \frac{j-2}{i+j-2}$4、王妃选到黑，龙选到黑，逃了白，转移到$dp(i-1, j-2)$，则概率为$\frac{j}{i+j} \times \frac{j-1}{i+j-1} \times \frac{i}{i+j-2}$那么综上所述可以得到状态转移方程$dp(i,j) = \frac{i}{i+j} + \frac{j}{i+j} \times \frac{j-1}{i+j-1} \times \frac{j-2}{i+j-2} \times dp(i, j-3)+\frac{j}{i+j} \times \frac{j-1}{i+j-1} \times \frac{i}{i+j-2} \times dp(i-1, j-2)$注意不要一起乘，不然溢出。Codeforces Submission #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 1000 + 5; int w, b; db dp[MAXN][MAXN]; void clean() { ms(dp, 0); } void solve() { clean(); for (int i=1;i&lt;=w;i++) dp[i][0] = 1.0; for (int i=1;i&lt;=w;i++) { for (int j=1;j&lt;=b;j++) { dp[i][j] += (db)i / (db)(i + j); db p1, p2; if (j-3&gt;=0) p1 = (db)j / (db)(i+j) * (db)(j-1) / (db)(i+j-1) * (db)(j-2) / (db)(i+j-2), dp[i][j] += dp[i][j-3] * p1; if (j-2&gt;=0) p2 = (db)j / (db)(i+j) * (db)(j-1) / (db)(i+j-1) * (db)i / (db)(i+j-2), dp[i][j] += dp[i-1][j-2] * p2; } } printf(&quot;%.9f\n&quot;, dp[w][b]); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif while(scanf(&quot;%d%d&quot;, &amp;w, &amp;b)==2) solve(); return 0; } 记忆化搜索写法：Codeforces Submission #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define FN2 &quot;cf148d&quot; using namespace std; const int MAXN = 1000 + 5; db dp[MAXN][MAXN]; int w, b; db dfs(int i, int j) { if (i &lt;= 0) return 0; if (j &lt;= 0) return 1; if (dp[i][j]&gt;=0) return dp[i][j]; dp[i][j] = 0; dp[i][j] += (db)i / (db)(i + j); if (j - 3 &gt;= 0) { dp[i][j] += ((db)j / (db)(i + j) * (db)(j - 1) / (db)(i + j - 1) * (db)(j - 2) / (db)(i + j - 2)) * dfs(i, j - 3); } if (i - 1 &gt;= 0 &amp;&amp; j - 2 &gt;= 0) { dp[i][j] += ((db)j / (db)(i + j) * (db)(j - 1) / (db)(i + j - 1) * (db)(i) / (db)(i + j - 2)) * dfs(i - 1, j - 2); } return dp[i][j]; } void clean() { ms(dp, -1); } void solve() { clean(); printf(&quot;%.9f\n&quot;, dfs(w, b)); } int main() { #ifndef ONLINE_JUDGE freopen(FN2&quot;.in&quot;, &quot;r&quot;, stdin); freopen(FN2&quot;.out&quot;, &quot;w&quot;, stdout); #endif scanf(&quot;%d%d&quot;, &amp;w, &amp;b), solve(); fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>概率DP</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hdu 4405(概率期望DP)]]></title>
    <url>%2Fhdu4405%2F</url>
    <content type="text"><![CDATA[hdu 4405设$dp(i)$为$i$到$n$的步数期望。则$$dp(i) = \sum \frac{1}{6}dp(i+j)$$其中$i+j \leq n+5$或者$i+j \leq n$。如果$i$处有航线，那么直接$dp(i) = dp(lst(i))$答案为$dp(0)​$ #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 100000 + 5; int n, m, lst[MAXN]; db dp[MAXN]; void clean() { ms(dp, 0), ms(lst, -1); } void solve() { clean(); for (int i=1;i&lt;=m;i++) { int xi, yi; scanf(&quot;%d%d&quot;, &amp;xi, &amp;yi); lst[xi] = yi; } for (int i=n-1;i&gt;=0;i--) { if (lst[i]&gt;=0) dp[i] = dp[lst[i]]; else { for (int j=1;j&lt;=6;j++) { if (i+j&lt;=n+5) dp[i] += (db)(1.0/6.0)*dp[i+j]; } dp[i]++; } } printf(&quot;%.4f\n&quot;, dp[0]); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif while (scanf(&quot;%d%d&quot;, &amp;n, &amp;m)==2&amp;&amp;(n||m)) solve(); return 0; }]]></content>
      <categories>
        <category>Hdu</category>
      </categories>
      <tags>
        <tag>概率DP</tag>
        <tag>Hdu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hdu 3853(概率期望DP)]]></title>
    <url>%2Fhdu3853%2F</url>
    <content type="text"><![CDATA[hdu 3853设$dp(i,j)$为$(i,j)$到$(r,c)$的步数期望，那么可以列出下列状态转移方程：$$dp(i,j)=\frac{dp(i,j+1) \times P_2 + dp(i+1,j) \times P_3}{1-P_1}$$但是当$P_1=1$时，$dp(i,j)=0$，因为这个点肯定无法到达终点，设为$0$表示该点不影响其他点。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 1000 + 5, P1 = 0, P2 = 1, P3 = 2; const db eps = 1e-9; db p[MAXN][MAXN][3], dp[MAXN][MAXN]; int r, c; void clean() { ms(dp, 0); } void solve() { clean(); for (int i=1;i&lt;=r;i++) { for (int j=1;j&lt;=c;j++) { scanf(&quot;%lf%lf%lf&quot;, &amp;p[i][j][P1], &amp;p[i][j][P2], &amp;p[i][j][P3]); } } for (int i=r;i&gt;=1;i--) { for (int j=c;j&gt;=1;j--) { if (fabs(1.0-p[i][j][P1])&lt;eps) continue; dp[i][j] = (db)(dp[i][j+1]*p[i][j][P2]+dp[i+1][j]*p[i][j][P3]+2)/(db)(1.0-p[i][j][P1]); } } printf(&quot;%.3f\n&quot;, dp[1][1]); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif while (scanf(&quot;%d%d&quot;, &amp;r, &amp;c)==2) solve(); return 0; }]]></content>
      <categories>
        <category>Hdu</category>
      </categories>
      <tags>
        <tag>概率DP</tag>
        <tag>Hdu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1715」「Usaco2006 Dec」Wormholes 虫洞 (SPFA找负环)]]></title>
    <url>%2Fbzoj1715%2F</url>
    <content type="text"><![CDATA[BZOJ 1715Luogu 2850from: USACO 2006 Dec Gold由题意就是判一个负环，用SPFA，据说DFS要快一点，不过这里还是BFS了。一个点进队超过$n$次就存在负环。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;stack&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long using namespace std; const int MAXN = 100 + 5; int n; char s[MAXN][MAXN]; void clear() { } void init() { clear(); for (int i=1;i&lt;=n;i++) scanf(&quot;%s&quot;, s[i]+1); } void solve() { int ans = 0; for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=n;j++) for (int x=i+1;x&lt;=n;x++) for (int y=1;y&lt;=j;y++) { int si = j - y, ti = x - i; int x3 = i + si, y3 = j + ti, x4 = x + si, y4 = y + ti; if (x3&lt;=0||x3&gt;n||x4&lt;=0||x4&gt;n||y3&lt;=0||y3&gt;n||y4&lt;=0||y4&gt;n) continue; if (s[i][j]==&#39;B&#39;||s[x][y]==&#39;B&#39;||s[x3][y3]==&#39;B&#39;||s[x4][y4]==&#39;B&#39;) continue; int tot = 0; if (s[i][j]==&#39;J&#39;) tot++; if (s[x][y]==&#39;J&#39;) tot++; if (s[x3][y3]==&#39;J&#39;) tot++; if (s[x4][y4]==&#39;J&#39;) tot++; if (tot&gt;=3) ans = max(ans, si*si+ti*ti); } printf(&quot;%d\n&quot;, ans); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif while (scanf(&quot;%d&quot;, &amp;n)==1&amp;&amp;n) init(), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>最短路</tag>
        <tag>USACO月赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj 3071(概率DP)]]></title>
    <url>%2Fpoj3071%2F</url>
    <content type="text"><![CDATA[poj 3071题意：有$2^n​$个队进行$n​$轮比赛，每轮比赛相邻(例如1-2, 3-4, 5-6)的两个队比赛一场，给出胜率矩阵，求出哪个队最大几率获胜。设$dp(i,j)$为第$i$轮比赛$j$赢的概率。$dp(i,j)=\sum dp(i-1, j) \times dp(i-1, k) \times p(j, k)$ (全概率公式)其中$k$是和$j$相邻的队。通过分析队编号的二进制(从0开始),可以发现(j&gt;&gt;(i-1))^1)==(k&gt;&gt;(i-1)的时候$k$和$j$相邻，具体可以自己推一推。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 10, MAXNF = 200; int n, len; db p[MAXNF][MAXNF], dp[MAXN][MAXNF]; void clean() { ms(dp, 0); } void solve() { clean(); len = (1&lt;&lt;n); for (int i=0;i&lt;len;i++) for (int j=0;j&lt;len;j++) scanf(&quot;%lf&quot;, &amp;p[i][j]); for (int i=0;i&lt;len;i++) dp[0][i] = 1.0; for (int i=1;i&lt;=n;i++) { for (int j=0;j&lt;len;j++) { for (int k=0;k&lt;len;k++) { if (((j&gt;&gt;(i-1))^1)==(k&gt;&gt;(i-1))) { dp[i][j] += dp[i-1][j] * dp[i-1][k] * p[j][k]; } } } } db ans = 0.0; int k = 0; for (int i=0;i&lt;len;i++) { if (dp[n][i]&gt;ans) ans = dp[n][i], k = i; } printf(&quot;%d\n&quot;, k+1); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif while (scanf(&quot;%d&quot;, &amp;n)==1&amp;&amp;n!=-1) solve(); return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>概率DP</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AHSOFNU NOIP模拟题-3 T4/BZOJ 3339(离线+线段树)]]></title>
    <url>%2FAHSOFNU-NOIP%E6%A8%A1%E6%8B%9F-3-t4%2F</url>
    <content type="text"><![CDATA[此题在线做很麻烦，而且这题也不强制在线，不会修改$A$的值，那就离线吧。先求出$[1, i]$的$mex$值，然后求出$nxt$值，即下一个为该数值的下标，没有就是$0$，可以很容易$O(n)$推出来然后考虑从$A[1]$开始删数，即考虑$A[i]$对后面的$mex$值的影响可以发现，删去$A[i]$后，$i$到$nxt[i]-1$都会受影响，并且这个范围内$mex$大于$A[i]$的都要等于$A[i]$，这里的修改可以线段树完成，有点麻烦。那么对查询区间按左端点排序，然后依次删数，发现一个区间的$mex$值就是线段树上单点查询右端点的值。(实际上线段树上单点查询$i$表示为删了几个数$+1$到$i$之间的$mex$值) 注意此题卡输入，一定要输入优化，以后做题要测一测极限数据，看看大概时间，如果输入数据很大的话，也要考虑输入优化。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define FN2 &quot;mex&quot; using namespace std; const int MAXN = 200000 + 5, INF = 1000000000; struct inv { int no, l, r; bool operator &lt; (const inv &amp;b) const { return l &lt; b.l; } }qj[MAXN]; int n, q, A[MAXN], mex[MAXN], mk[MAXN], nxt[MAXN], ans[MAXN]; #define M ((l+r)&gt;&gt;1) #define lc (o&lt;&lt;1) #define rc (o&lt;&lt;1|1) int lazy[MAXN*4]; int read() { int x=0;char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();} return x; } void pushdown(int o, int l, int r) { if (lazy[o]!=INF) { if (l!=r) lazy[lc] = min(lazy[lc], lazy[o]); if (l!=r) lazy[rc] = min(lazy[rc], lazy[o]); } } void build(int o, int l, int r) { if (l==r) lazy[o] = mex[l]; else lazy[o] = INF, build(lc, l, M), build(rc, M+1, r); } void update(int o, int l, int r, int x, int y, int w) { pushdown(o, l, r); if (x&lt;=l&amp;&amp;r&lt;=y) { lazy[o] = min(lazy[o], w); return ; } if (x&lt;=M) update(lc, l, M, x, y, w); if (M&lt;y) update(rc, M+1, r, x, y, w); } int query(int o, int l, int r, int p) { pushdown(o, l, r); if (l==r) { return lazy[o]; } if (p&lt;=M) return query(lc, l, M, p); else if (M&lt;p) return query(rc, M+1, r, p); } void clean() { ms(mk, false), ms(nxt, 0); } void solve() { clean(); int k = 0; for (int i=1;i&lt;=n;i++) { A[i] = read(); mk[A[i]] = true; if (mk[k]) { while (mk[k]) k++; } mex[i] = k; } ms(mk, false); for (int i=n;i&gt;0;i--) { nxt[i] = mk[A[i]]; mk[A[i]] = i; } build(1,1,n); for (int i=1;i&lt;=q;i++) qj[i].l = read(), qj[i].r = read(), qj[i].no = i; sort(qj+1, qj+1+q), k = 1; for (int i=1;i&lt;=q;i++) { while (k!=qj[i].l) { if (nxt[k]==0) update(1,1,n,k,n,A[k]); else update(1,1,n,k,nxt[k]-1,A[k]); k++; } ans[qj[i].no] = query(1,1,n,qj[i].r); } for (int i=1;i&lt;=q;i++) printf(&quot;%d\n&quot;, ans[i]); } int main() { freopen(FN2&quot;.in&quot;, &quot;r&quot;, stdin); freopen(FN2&quot;.out&quot;, &quot;w&quot;, stdout); scanf(&quot;%d%d&quot;, &amp;n, &amp;q), solve(); fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>模拟题/训练题</category>
      </categories>
      <tags>
        <tag>模拟题/训练题</tag>
        <tag>Bzoj</tag>
        <tag>离线</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[概率\概率DP 学习笔记]]></title>
    <url>%2Fsz%E6%A6%82%E7%8E%87DP%2F</url>
    <content type="text"><![CDATA[模板及讲解数学期望随机变量$X$的数学期望$E(X)$就是所有可能值按照概率加权的和。$$E(X)=\sum_{i=1}^nx_ip_i$$ 数学期望计算线性性质$$E(aX+bY)=aE(X)+bE(Y)$$$$E(XY)=E(X)+E(Y)$$ 概率部分公式($P(A|B)$表示$B$事件发生的条件下，事件$A$发生的概率。)($P(AB)=P(A \cap B)$表示$A、B$同时发生的概率。) 1、若$A、B$不相交，则$P(A \cup B) = P(A) + P(B)$若$A、B$为事件，则$P(A \cup B) = P(A) + P(B) - P(AB)$(广义加法公式) 2、若$A_1, A_2, …, A_3$互不相交，则$P(A_1+A_2+…+A_n)=P(A_1) + P(A_2) +…P(A_n)$(加法原理) 3、$A \in B$时$P(B-A)=P(B)-P(A)$(容斥原理) 4、$P(AB)=0$时$P(AB) = P(A)(B)$(乘法原理) 全概率公式$$P(A)=P(A|B_1) \times P(B_1) + P(A|B_2) \times P(B_2) + … + P(A|B_n) \times P(B_n)$$ 常见题型1、DP求期望(倒推, dp状态表示为从当前点到终态的期望)Q: 求到达某目标(终态)的期望值。解: 倒推, $dp[i]$为从$i$点到终态的期望。例题:poj 20962、DP求概率1(顺推, 第i层j前进的概率)Q: 求到达某目标(终态)的概率。解: 顺推, $dp[i][j]$为在$i$层$j$前进的概率。例题:poj 30713、DP求概率2(xx状态存在概率)Q: 求到达某目标(终态)的概率。解: 设$dp(i,j,k)$为状态为$(i,j,k)$的存在概率。例题:Codeforces 540D4、直接求期望Q: 每个概率有一个权，求期望权。解: 直接利用期望定义求解。例题:AHSOFNU NOIP模拟-11 t35、记忆化搜索求期望解: 从要求的状态向已知状态记忆化搜索。例题:zoj 36406、最优策略分步取$min$Q: 在最有策略下，xxx的最小期望解: 分步取$min$。例题: NOIP2016 Day2 T1, bzoj 1076]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>概率DP</tag>
        <tag>算法笔记</tag>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj 2096(概率期望DP)]]></title>
    <url>%2Fpoj2096%2F</url>
    <content type="text"><![CDATA[poj 2096设$dp(i, j)$为已经发现了$i$类bug，$j$个系统中发现了bug时要到达目标的天数期望。明显$dp(n, s)=0$，因为已经到达了目标，所以这题要倒推，期望DP一般都要倒推来做，因为已知终态。那么$dp(i,j)$可以由$4$个状态转移：$dp(i+1,j+1)$, 这个bug不在已经找到的类型中，也不在已经找到bug的系统中，概率为$(1-\frac{i}{n})(1-\frac{j}{s})=\frac{(n-i)(s-j)}{ns}$(通分处理一下，这样减少除法，减小精度误差)$dp(i+1,j)$, 这个bug不在已经找到的类型中，但在已经找到bug的系统中，概率为$(1-\frac{i}{n})\frac{j}{s}=\frac{(n-i)j}{ns}$$dp(i,j+1)​$, 这个bug在已经找到的类型中，但不在已经找到bug的系统中，概率为$\frac{i}{n}(1-\frac{j}{s})=\frac{i(s-j)}{ns}​$$dp(i,j)$, 这个bug不在已经找到的类型中，也不在已经找到bug的系统中，概率为$\frac{ij}{ns}$然后根据期望运算的线性性质，得到转移方程：$dp(i,j)=dp(i+1,j+1) \times \frac{(n-i)(s-j)}{ns} + dp(i+1,j) \times \frac{(n-i)j}{ns}$$+ dp(i,j+1) \times \frac{i(s-j)}{ns} + dp(i,j) \times \frac{i(s-j)}{ns}+1$其中$+1$是本次转移，就是从其他四个状态转移转移到本状态的花费。把右边的$dp(i,j)$移到左边，有$dp(i,j)=\frac{dp(i+1,j+1) \times \frac{(n-i)(s-j)}{ns} + dp(i+1,j) \times \frac{(n-i)j}{ns} + dp(i,j+1) \times \frac{i(s-j)}{ns} +1}{1-\frac{ij}{ns}}$然后发现有分母下都有$ns$，那么上下乘$ns$，得$dp(i,j)=\frac{dp(i+1,j+1) \times (n-i)(s-j) + dp(i+1,j) \times (n-i)j + dp(i,j+1) \times i(s-j) +ns}{ns-ij}$经过转换，除法只有一个了，大大减小精度误差，接着倒推求解就行了，答案是$dp(0,0)$ #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 1000 + 5; int n, s; db dp[MAXN][MAXN]; void clean() { ms(dp, 0); } void solve() { clean(); for (int i=n;i&gt;=0;i--) { for (int j=s;j&gt;=0;j--) { if (i==n &amp;&amp; j==s) continue; dp[i][j] = (db)(n*s + dp[i+1][j+1]*(n-i)*(s-j) + dp[i+1][j]*(n-i)*j + dp[i][j+1]*i*(s-j))/(db)(n*s - i*j); } } printf(&quot;%.4f&quot;, dp[0][0]); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif while (scanf(&quot;%d%d&quot;, &amp;n, &amp;s)==2) solve(); return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>概率DP</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj 2441(状压DP)]]></title>
    <url>%2Fpoj2441%2F</url>
    <content type="text"><![CDATA[poj 2441 用二进制来表示每个牛棚进棚情况。设$dp(i, S)$为第$i$只奶牛$S$状态的总方案数。则状态转移方程为$$dp(i, S) += dp(i-1, S-j)$$其中$j$在$S$中且$j$被$i$奶牛喜欢。本来不想压滚动数组，但是会MLE，无奈只能压了，注意$S$就要倒过来求值了 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long using namespace std; const int MAXN = 20 + 2; int n, m, dp[1&lt;&lt;20], fav[MAXN][MAXN]; bool check(int x) { int ans = 0; while (x) { ans++; x&amp;=(x-1); } return ans == n; } void clean() { ms(fav, -1), ms(dp, 0), dp[0] = 1; } void solve() { clean(); for (int i=1;i&lt;=n;i++) { int p; scanf(&quot;%d&quot;, &amp;p); for (int j=1;j&lt;=p;j++) scanf(&quot;%d&quot;, &amp;fav[i][j]); } for (int hi=1;hi&lt;=n;hi++) { for (int S=(1&lt;&lt;m);S&gt;0;S--) { for (int orz=1;fav[hi][orz]!=-1;orz++) { int i = fav[hi][orz]; if (S&amp;(1&lt;&lt;(i-1))) { dp[S] += dp[S^(1&lt;&lt;(i-1))]; } } } } int ans = 0; for (int S=1;S&lt;(1&lt;&lt;m);S++) { if (check(S)) { ans += dp[S]; } } printf(&quot;%d\n&quot;, ans); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif while (scanf(&quot;%d%d&quot;, &amp;n, &amp;m)==2) solve(); return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>状压DP</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zoj 3471(状压DP)]]></title>
    <url>%2Fzoj3471%2F</url>
    <content type="text"><![CDATA[zoj 3471比较基础的状压，看题目数据才$n&lt;=10$，果断状压。用十位二进制来存储分子的存在情况，$1$为存在，$0$为不存在设$dp(S)$为状态为$S$的最优值。$$dp(S) = max(dp(S+j)+map(i, j))$$注意因为是从$1$多向$1$少来转移，所以要倒推。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long using namespace std; const int MAXN = 10 + 2; int n, ma[MAXN][MAXN], dp[1&lt;&lt;MAXN]; void clean() {} void solve() { clean(); for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=n;j++) scanf(&quot;%d&quot;, &amp;ma[i][j]); ms(dp, 0); for (int S=(1&lt;&lt;n)-1;S&gt;0;S--) {//倒推，因为是从1多向1少来转移 for (int i=1;i&lt;=n;i++) { if (S&amp;(1&lt;&lt;(i-1))) { for (int j=1;j&lt;=n;j++) { if (i!=j&amp;&amp;!(S&amp;(1&lt;&lt;(j-1)))) { dp[S] = max(dp[S], dp[S^(1&lt;&lt;(j-1))]+ma[i][j]); } } } } } int ans = 0; for (int i=1;i&lt;=n;i++) { ans = max(ans, dp[1&lt;&lt;(i-1)]); } printf(&quot;%d\n&quot;, ans); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif while (scanf(&quot;%d&quot;, &amp;n)==1&amp;&amp;n) solve(); return 0; }]]></content>
      <categories>
        <category>zoj</category>
      </categories>
      <tags>
        <tag>状压DP</tag>
        <tag>zoj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOI 2017-07-11集训 T2(状压DP)]]></title>
    <url>%2FBZOI%202017-07-11%E9%9B%86%E8%AE%AD-t2%2F</url>
    <content type="text"><![CDATA[类似于poj1185，但是这里的影响范围是它曼哈顿距离为$2$的格子，也就是说处理状态变得复杂了很多。设$dp(i, st(j), st(k))$为第$i$行用状态$k$，第$i-1$行用状态$j$的最优值。那么转移方程即为：$$dp(i, st(j), st(k)) = max(dp(i, st(t), st(j)) + num(k))$$怎么处理状态？先处理每行可行方案，1、不能有三个连续的摆放 2、不能有两个摆放之间距离为$2$按位DP的时候，$i$上面一行对$i$行的影响只有两个方格，具体是哪个画图就知道。$i$上面第二行对$i$行的影响只有一个方格，同样具体是哪个画图就知道。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define FN2 &quot;soldier&quot; using namespace std; const int MAXN = 100 + 5; int n, m, num[200 + 5], cur[MAXN], st[200 + 5], dp[MAXN][200 + 5][200 + 5], top; int js(int x) { int ret = 0; while (x) { ret++; x&amp;=(x-1); } return ret; } int check(int x) { int tot = 0, tot2 = 0; while (x) { if (x&amp;1) { if (tot2==1&amp;&amp;tot!=-1) return false; else if (tot2&gt;=1) tot = 0; tot2 = 0, tot++; if (tot&gt;=3) return false; } else { tot2++; if (tot==0) tot = -1; } x&gt;&gt;=1; } if (tot&gt;=3) return false; return true; } int check2(int up, int down) { int i = 0; while (up) { if (up&amp;1) { if (i-1&gt;=0&amp;&amp;(down&gt;&gt;(i-1))&amp;1) return false; if (i+1&lt;m&amp;&amp;(down&gt;&gt;(i+1))&amp;1) return false; } up&gt;&gt;=1, i++; } return true; } bool fit(int s1, int h) {return (s1&amp;cur[h]) ? false : true;} void clean() { top = 1, ms(dp, -1), st[top] = 0; } void solve() { clean(); for (int i=1;i&lt;(1&lt;&lt;m);i++) if (check(i)) st[++top] = i, num[top] = js(i); for (int i=1;i&lt;=n;i++) { cur[i] = 0; for (int j=1;j&lt;=m;j++) { int x; scanf(&quot;%d&quot;, &amp;x); if (!x) cur[i] += (1&lt;&lt;(j-1)); } } for (int i=1;i&lt;=top;i++) { if (fit(st[i], 1)) dp[1][i][1] = num[i]; } for (int hi=2;hi&lt;=n;hi++) { for (int i=1;i&lt;=top;i++) { if (fit(st[i], hi)) { for (int j=1;j&lt;=top;j++) { if (check2(st[j], st[i])&amp;&amp;fit(st[j], hi-1)) { for (int k=1;k&lt;=top;k++) { if (st[k]&amp;st[i]) continue; if (dp[hi-1][j][k]==-1) continue; if (check2(st[k], st[j])&amp;&amp;fit(st[k], hi-2)) dp[hi][i][j] = max(dp[hi][i][j], dp[hi-1][j][k] + num[i]); } } } } } } int ans = 0; for (int hi=1;hi&lt;=n;hi++) { for (int i=1;i&lt;=top;i++) { for (int j=1;j&lt;=top;j++) { ans = max(ans, dp[hi][i][j]); } } } printf(&quot;%d\n&quot;, ans); } int main() { freopen(FN2&quot;.in&quot;, &quot;r&quot;, stdin); freopen(FN2&quot;.out&quot;, &quot;w&quot;, stdout); while (scanf(&quot;%d%d&quot;, &amp;n, &amp;m)==2&amp;&amp;n&amp;&amp;m) solve(); fclose(stdin); fclose(stdout); return 0; } Soldier1sProblem Description 郑厂长不是正厂长 也不是副厂长 他根本就不是厂长 事实上 他是带兵打仗的团长 一天，郑厂长带着他的军队来到了一个n*m的平原准备布阵。 根据以往的战斗经验，每个士兵可以攻击到并且只能攻击到与之曼哈顿距离为2的位置以及士兵本身所在的位置。当然，一个士兵不能站在另外一个士兵所能攻击到的位置，同时因为地形的原因平原上也不是每一个位置都可以安排士兵。 现在，已知n,m 以及平原阵地的具体地形，请你帮助郑厂长计算该阵地,最多能安排多少个士兵。 Input输入包含多组测试数据；每组数据的第一行包含2个整数n和m (n &lt;= 100, m &lt;= 10 )，之间用空格隔开；接下来的n行，每行m个数，表示n*m的矩形阵地，其中1表示该位置可以安排士兵，0表示该地形不允许安排士兵。 Output请为每组数据计算并输出最多能安排的士兵数量，每组数据输出一行。 Sample Input6 60 0 0 0 0 00 0 0 0 0 00 0 1 1 0 00 0 0 0 0 00 0 0 0 0 00 0 0 0 0 0 Sample Output2]]></content>
      <categories>
        <category>模拟题/训练题</category>
      </categories>
      <tags>
        <tag>模拟题/训练题</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOI 2017-07-11集训 T1(贪心+堆)]]></title>
    <url>%2FBZOI%202017-07-11%E9%9B%86%E8%AE%AD-t1%2F</url>
    <content type="text"><![CDATA[我们可以将兔子血量从小到大排序，然后对于每一个兔子，我们把能射死他的箭插入一个以价格为关键字的小根堆中，然后每次在堆中找一个最小值贡献给$ans$，对于下一个兔子，由于前面的兔子血量大于后面的兔子，所以能射死前面的兔子的箭肯定能射死这只兔子，所以不需要清空堆，直接继续插入即可，注意如果没有箭可以射死兔子说明无解. #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define FN2 &quot;hare&quot; const int MAXN = 100000 + 5; using namespace std; struct row { int d, p; bool operator &lt; (const row &amp;a) const { return p &gt; a.p; } }ai[MAXN]; int bi[MAXN], n, m; bool cmp1(const row &amp;a, const row &amp;b) { return a.d &gt; b.d; } bool cmp2(int a, int b) { return a &gt; b; } void clean() {} void solve() { clean(); priority_queue&lt;row&gt; pq; bool flag = false; for (int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;, &amp;bi[i]); for (int i=1;i&lt;=m;i++) scanf(&quot;%d&quot;, &amp;ai[i].d); for (int i=1;i&lt;=m;i++) scanf(&quot;%d&quot;, &amp;ai[i].p); sort(bi+1, bi+1+n, cmp2); sort(ai+1, ai+1+m, cmp1); int j = 1; LL ans = 0; for (int i=1;i&lt;=n;i++) { while (ai[j].d&gt;=bi[i]&amp;&amp;j&lt;=m) pq.push(ai[j++]); if (pq.empty()) {flag = true; break;} row p = pq.top(); pq.pop(); ans += p.p; } if (flag) printf(&quot;No\n&quot;); else printf(&quot;%I64d\n&quot;, ans); } int main() { freopen(FN2&quot;.in&quot;, &quot;r&quot;, stdin); freopen(FN2&quot;.out&quot;, &quot;w&quot;, stdout); while (scanf(&quot;%d%d&quot;, &amp;n, &amp;m)==2) solve(); fclose(stdin); fclose(stdout); return 0; } Hare1sProblem Description 湫湫减肥 越减越肥！ 最近，减肥失败的湫湫为发泄心中郁闷，在玩一个消灭免子的游戏。 游戏规则很简单，用箭杀死免子即可。 箭是一种消耗品，已知有M种不同类型的箭可以选择，并且每种箭都会对兔子造成伤害，对应的伤害值分别为Di（1 &lt;= i &lt;= M），每种箭需要一定的QQ币购买。 假设每种箭只能使用一次，每只免子也只能被射一次，请计算要消灭地图上的所有兔子最少需要的QQ币。 Input输入数据有多组，每组数据有四行；第一行有两个整数N，M（1 &lt;= N, M &lt;= 100000），分别表示兔子的个数和箭的种类；第二行有N个正整数，分别表示兔子的血量Bi（1 &lt;= i &lt;= N）；第三行有M个正整数，表示每把箭所能造成的伤害值Di（1 &lt;= i &lt;= M）；第四行有M个正整数，表示每把箭需要花费的QQ币Pi（1 &lt;= i &lt;= M）。 特别说明：1、当箭的伤害值大于等于兔子的血量时，就能将兔子杀死；2、血量Bi，箭的伤害值Di，箭的价格Pi，均小于等于100000。 Output如果不能杀死所有兔子，请输出”No”，否则，请输出最少的QQ币数，每组输出一行。 Sample Input3 31 2 32 3 41 2 33 41 2 31 2 3 41 2 3 1 Sample Output64]]></content>
      <categories>
        <category>模拟题/训练题</category>
      </categories>
      <tags>
        <tag>模拟题/训练题</tag>
        <tag>堆</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩阵/快速幂 学习笔记]]></title>
    <url>%2Fsz%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%2F</url>
    <content type="text"><![CDATA[模板及讲解矩阵单位矩阵：$$\begin{pmatrix} 1 &amp; 0 &amp; 0 \\\ 0 &amp; 1 &amp; 0 \\\ 0 &amp; 0 &amp; 1\end{pmatrix}$$空矩阵：$$\begin{pmatrix} 0 &amp; 0 &amp; 0 \\\ 0 &amp; 0 &amp; 0 \\\ 0 &amp; 0 &amp; 0\end{pmatrix}$$ 矩阵加法对应位置加起来即可，矩阵加法的数初始化为空矩阵。 矩阵乘法定义第一个矩阵的第$i$行的每个元素乘以第二个矩阵第$j$列的每个数的积的和就是新矩阵第$i$行$j$列的数，矩阵乘法的数初始化为单位矩阵，单位矩阵乘以任意一个矩阵是不会改变值的。 写成式子，$A$大小$a \times b$，$B$大小$b \times c$，那么$C$大小为$a \times c$，则 $$C[i,j]=\sum_{k=1}^b A[i,k]B[k,j]$$ 如果$A$列数不等于$B$, 则矩阵乘法无意义 存储矩阵的时候最好用结构体，因为结构体可以直接被函数返回，而且能够较为整体化 matrix mul(matrix ai, matrix bi) {//矩阵乘法 matrix ret; ret.init2(2, 2); for (int i = 0; i &lt; ai.x; i++) { for (int j = 0; j &lt; bi.y; j++) { for (int k = 0; k &lt; ai.y; k++) { ret.ma[i][j] = (ret.ma[i][j] % MO + (ai.ma[i][k] % MO) * (bi.ma[k][j] % MO)) % MO; } } } return ret; } 结合律矩阵乘法具有结合律。即$(AB)C=A(BC)$ 证明：$A$大小$a \times b$，$B$大小$b \times c$，$C$大小$c \times d$，则 $$((AB)C) [i,j]$$$$=\sum_{l=1}^d(\sum_{k=1}^b A[i, k]B[k,l])C[l,j]$$$$=\sum_{l=1}^d\sum_{k=1}^b A[i, k]B[k,l]C[l,j]$$$$=\sum_{k=1}^b A[i, k] (\sum_{l=1}^dB[k,l]C[l,j])$$$$=(A(BC)) [i,j]$$ 结合律使得矩阵可以使用快速幂。 快速幂二进制int fastpow(int a,int b) { //快速幂 int ans = 1, bs = a; while(b!=0){ if(b &amp; 1) ans *= bs; bs *= bs; b &gt;&gt;= 1; } return ans; } 十进制思路与二进制的一样，就是例如$3^{4056}=(3^{1})^{6} \times (3^{10})^{5} \times (3^{100})^{0} \times (3^{1000})^{4}$ 用来应付数据有形如$a^{100000}$的题目 矩阵快速幂把普通的快速幂中的乘法换为矩阵乘法即可。 应用矩阵乘法求解递推构造矩阵使得$$\begin{pmatrix} F_{n} \ F_{n-1} … F_{n-k+1}\end{pmatrix} \times \begin{pmatrix} … \\\ … \\\ …\end{pmatrix}=\begin{pmatrix} F_{n + 1} \ F_{n} … F_{n-k+2}\end{pmatrix}$$ 其中第一个是初始矩阵，第二个矩阵为状态矩阵 这个乘法意思是$F_n = F_{n-1} + F_{n-3} + F_{n-k}$，即构造矩阵的时候可以在矩阵第一行设置$0$来消掉某个$F_i$ 转移矩阵构造方法：若状态矩阵中的第 $x$ 个数对下个单位时间状态矩阵的第 $y$ 个数产生影响，则吧转移矩阵的第 $x$ 行第 $y$ 列赋值为适当的系数 矩阵快速幂可以优化倍增DP。倍增DP(Bzoj 2165)：ST表、LCA的pre数组求法都是这种思路，在数据大时需要矩阵快速幂的优化。 矩阵乘法求解图论问题1、图中求$u$走$k$步(可重复走)到$v$的路径条数 图中DP：设$dp(i,x)$为走了$i$步在$x$点位置，则转移$dp(i,x)=\sum dp(i-1, y)$，其中$(x,y) \in E$那么这个式子显然符合矩阵乘法(矩阵则为邻接矩阵)，快速幂即可。我们也可以尝试定义$dp(k,i,j)$为$i$到$j$经过$k$个点(走$k$步)的路径条数。则$$dp(k,i,j)=\sum dp(k-1,i,k) \cdot dp(k-1,k,j)$$压掉第一维，则$dp(i,j)=\sum dp(i,k) \cdot dp(k,j)$，发现是 Floyd 的式子我们观察一个图的邻接矩阵，发现它自乘就模拟了上面 DP 的过程则 Floyd 一个只有1边权的矩阵相当于是矩阵乘法。所以一个图的邻接矩阵的$k$次方表示一点走$k$步到另一点路径条数。矩阵快速幂解决。 2、带权图中求$u$走$k$步(可重复走)到$v$的最短路长度 Bzoj 1706 图中DP：设$dp(i,x)$为走了$i$步在$x$点位置，则转移$dp(i,x)=min( dp(i-1, y)+w(y, x))$，其中$(x,y) \in E$这里不是求方案就不能直接矩阵优化，我们尝试 Floyd 思想。我们定义$dp(k,i,j)$为$i$到$j$经过$k$个点(走$k$步)的最短路。则$$dp(k,i,j)=min(dp(k-1,i,k)+dp(k-1,k,j))$$压掉第一维，则$dp(i,j)=min(dp(i,k)+dp(k,j))$我们发现和上面式子很像，那么我们可以试图修改一下矩阵乘法定义如下 $$C[i,j]=min(A[i,k]+B[k,i])$$ 易用前面方法推导结合律。则可以用矩阵快速幂加速。 其实这也体现出 Floyd 的倍增思想。相当于对一个图做几次 Floyd 就是走了几步。矩阵快速幂就是倍增的过程。这题在图上DP思想实际上就是分层图思想，每一步对应一张新图。与 NOIP2017Day1T3 有点像 总而言之，图上DP一般有两种思路。一种是DP 想出来以后用矩阵优化。一种是Floyd 中间点思想。后者可以运用在最优化和计数问题，前者一般只能用于计数问题。视情况选择合适的算法，充分结合图论知识。 矩阵幂前缀和欲求$M$的幂前缀和$M+M^2+M^3+…+M^k$，构造矩阵$$\begin{pmatrix} M &amp; I \\ 0 &amp; M \\end{pmatrix}$$ 对这个矩阵快速幂即可。 常见题型1、构造矩阵优化递推Q：求递推式$F_{n} = F_{n-1} + F_{n-3}$。解：构造矩阵使用矩阵快速幂快速求解递推问题。例题：AHSOFNU NOIP模拟题-2 T22、构造矩阵优化方案DPQ：求递推式$F_{i,j} = F_{i-1,k}$。解：构造矩阵使用矩阵快速幂快速求解方案DP问题。例题：AHSOFNU NOIP模拟题-3 T33、倍增 FLoyd4、优化倍增 DP]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>矩阵</tag>
        <tag>快速幂</tag>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj 3070(矩阵快速幂)]]></title>
    <url>%2Fpoj3070%2F</url>
    <content type="text"><![CDATA[poj 3070 求Fibonacci数列，但是这里直接递推肯定炸。我们根据$$F_{n} = F_{n-1} +F_{n-2}$$构造矩阵$$\begin{pmatrix} 1 &amp; 1 \\\ 1 &amp; 0\end{pmatrix}\times\begin{pmatrix} F_{n-1} \\\ F_{n-2}\end{pmatrix}=\begin{pmatrix} F_{n} \\\ F_{n-1}\end{pmatrix}$$矩阵快速幂即可。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long using namespace std; const int MAXN = 4, MO = 10000; int n; struct matrix { int x, y, ma[MAXN][MAXN]; void init(int x, int y) {this-&gt;x = x, this-&gt;y = y; for (int i=0;i&lt;MAXN;i++) for (int j=0;j&lt;MAXN;j++) ma[i][j] = (i==j);}//初始化为单位矩阵 void init2(int x, int y) {this-&gt;x = x, this-&gt;y = y; for (int i=0;i&lt;MAXN;i++) for (int j=0;j&lt;MAXN;j++) ma[i][j] = 0;}//初始化为空矩阵 }a; matrix mul(matrix ai, matrix bi) {//矩阵乘法 matrix ret; ret.init2(2, 2); for (int i=0;i&lt;ai.x;i++) { for (int j=0;j&lt;bi.y;j++) { for (int k=0;k&lt;ai.y;k++) { ret.ma[i][j] = (ret.ma[i][j]%MO + (ai.ma[i][k]%MO) * (bi.ma[k][j]%MO))%MO; } } } return ret; } matrix poww(matrix ai, int x) {//快速幂 matrix s, ret; s = ai, ret.init(2, 2); while (x) { if (x&amp;1) ret = mul(ret, s); s = mul(s, s); x&gt;&gt;=1; } return ret; } void clean() {} void solve() { clean(); if (n==0) {printf(&quot;0\n&quot;); return ;} if (n==1||n==2) {printf(&quot;1\n&quot;); return ;} a.init(2,2), a.ma[0][0] = 1, a.ma[0][1] = 1, a.ma[1][0] = 1, a.ma[1][1] = 0;//矩阵初始化 matrix b = poww(a, n-1); printf(&quot;%d\n&quot;, b.ma[0][0]); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif while (scanf(&quot;%d&quot;, &amp;n)==1&amp;&amp;n!=-1) solve(); return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>矩阵</tag>
        <tag>快速幂</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj 2411(状压DP)]]></title>
    <url>%2Fpoj2411%2F</url>
    <content type="text"><![CDATA[poj 2411设$dp(i, j)$为第$i$行用$j$(状态)的方案总数，注意这里$j$不是编号就是状态！然后先把行可行的方案标记，然后按行DP要注意，横着的砖是11，竖着的砖是竖着的01，所以($h[i] $或$h[i-1]$)必须全是$1$，不然就会有空隙，然后最重要的是要注意($h[i]$与$h[i-1]$)一定是可行方案，否则会出现“半个砖横向填充”的情况。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define FN2 &quot;poj2411&quot; using namespace std; const int MAXN = 11 + 2; int h, w, st[1&lt;&lt;MAXN]; LL dp[MAXN][1&lt;&lt;MAXN];//dp[i][j] 为第i行用j(状态)的方案总数 bool check(int x) { int tot = 0; while (x) { if (x&amp;1) tot++; else { if ((tot&amp;1)==1) return false; tot = 0; } x&gt;&gt;=1; } if ((tot&amp;1)==1) return false; return true; } bool check2(int s1, int s2) { return ((s1|s2)==(1&lt;&lt;w)-1) &amp;&amp; (st[s1&amp;s2]); //s1|s2必须是满的，不然有空隙 //s1&amp;s2必须是可行方案，否则会有横着摆的砖是奇数 } void clean() { ms(st, false), ms(dp, 0); } void solve() { clean(); if (w&gt;h) swap(h, w); for (int i=0;i&lt;(1&lt;&lt;w);i++) if (check(i)) st[i] = true; for (int i=0;i&lt;(1&lt;&lt;w);i++) { if (st[i]) dp[1][i] = 1; } for (int hi=2;hi&lt;=h;hi++) { for (int i=0;i&lt;(1&lt;&lt;w);i++) { for (int j=0;j&lt;(1&lt;&lt;w);j++) { if (dp[hi-1][j]==0) continue; if (check2(i, j)) { dp[hi][i] += dp[hi-1][j]; } } } } printf(&quot;%lld\n&quot;, dp[h][(1&lt;&lt;w)-1]); } int main() { #ifndef ONLINE_JUDGE freopen(FN2&quot;.in&quot;, &quot;r&quot;, stdin); freopen(FN2&quot;.out&quot;, &quot;w&quot;, stdout); #endif while (scanf(&quot;%d%d&quot;, &amp;h, &amp;w)==2&amp;&amp;h&amp;&amp;w) solve(); fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>状压DP</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AHSOFNU NOIP模拟题-1 T2(DP+乘法原理)]]></title>
    <url>%2FAHSOFNU-NOIP%E6%A8%A1%E6%8B%9F-1-t2%2F</url>
    <content type="text"><![CDATA[对于$1-n$等类似的排列计数问题，以动态规划和组合数学2种大方向为基本解决方向。我们从小到大插入数字，因此我们现在插的这个数比现在所有在序列里的数都要大。这样一来就不需要记录是哪些数字插入了(而只要记录插入到了第几个数字)，同时不需要记录每个数字的具体位置，也不需要记录数字的相对位置，而只需记录相对关系的数目(对本题而言就是有几个“&lt;”)我们设$dp(i, j)$表示前$i$个数字构成的数列中，恰有$j$个”&lt;”号的方案数(“&gt;”号就有$i-j-1$个)考虑插入数的位置：1、插入在两个数关系为”&lt;”之间：显然这样插入会增加一个“&gt;”，那么有$j+1$个位置可以插，那么有状态转移方程$dp(i, j) += dp(i-1, j) * (j+1)$2、插入在两个数关系为”&gt;”之间：显然这样插入会增加一个“&lt;”，那么有$(i-j+1)-1$个位置可以插，那么有状态转移方程$dp(i, j) += dp(i-1, j-1) * (i-j)$综上所述，$dp(i, j) = dp(i-1, j) * (j+1) + dp(i-1, j-1) * (i-j)$ #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define FN2 &quot;num&quot; using namespace std; const int MAXN = 1000 + 5, MO = 2012; int n, k, dp[MAXN][MAXN]; void clean() { } void solve() { clean(); scanf(&quot;%d%d&quot;, &amp;n, &amp;k); dp[1][0] = 1; for (int i=2;i&lt;=n;i++) { dp[i][0] = 1; for (int j=1;j&lt;n;j++) { dp[i][j] = (dp[i][j]%MO + (dp[i-1][j]*(j+1))%MO + (dp[i-1][j-1]*(i-j)%MO))%MO; } } printf(&quot;%d\n&quot;, dp[n][k]%MO); } int main() { freopen(FN2&quot;.in&quot;, &quot;r&quot;, stdin);freopen(FN2&quot;.out&quot;, &quot;w&quot;, stdout); solve(); fclose(stdin), fclose(stdout); return 0; } Problem 2 不等数列【题目描述】将1到n任意排列，然后在排列的每两个数之间根据他们的大小关系插入“&gt;”和“&lt;”。问在所有排列中，有多少个排列恰好有k个“&lt;”。答案对2012取模。 【输入格式】第一行2个整数n,k。 【输出格式】一个整数表示答案。 【样例输入】5 2【样例输出】66【数据范围】对于30%的数据：n &lt;= 10对于100%的数据：k &lt; n &lt;= 1000，]]></content>
      <categories>
        <category>模拟题/训练题</category>
      </categories>
      <tags>
        <tag>模拟题/训练题</tag>
        <tag>计数DP</tag>
        <tag>计数原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AHSOFNU NOIP模拟题-1 T3(DP/贪心)]]></title>
    <url>%2FAHSOFNU-NOIP%E6%A8%A1%E6%8B%9F-1-t3%2F</url>
    <content type="text"><![CDATA[本题的一大瓶颈就是当前钻头能力。所以我们尝试不要存储钻头能力。钻头能力对之后的状态只会贡献一个数值(就好像初始钻头能力为$w$，实际上你可以按$1$来做，最后再把$ans$乘上$w$)，假设从第$i$个星球开始时钻头能力为$1$，因为正着会有后效性，所以我们设$f(i)$为$[i, n]$的最优数值(即上述$ans$)很容易就能写出一个状态转移方程(资源型)：$$f(i) = max(f(i+1), f(i+1) * (1-0.01k) + a[i])$$维护型类似。观察方程，发现实际上就是取下$[i+1, n]$的最值而已，所以这题实际上就成了贪心 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define FN2 &quot;exploit&quot; using namespace std; const int MAXN = 100000 + 5; int n, tp[MAXN], x[MAXN]; double k, c, w; void clean() { } void solve() { clean(); scanf(&quot;%d%lf%lf%lf&quot;, &amp;n, &amp;k, &amp;c, &amp;w); k = 1-k*0.01, c = 1+c*0.01; for (int i=1;i&lt;=n;i++) scanf(&quot;%d%d&quot;, &amp;tp[i], &amp;x[i]); double ans = 0; for (int i=n;i&gt;0;i--) { if (tp[i]==1) ans=max(ans,ans*k+x[i]); else ans=max(ans,ans*c-x[i]); } printf(&quot;%.2lf\n&quot;,ans*w); } int main() { freopen(FN2&quot;.in&quot;, &quot;r&quot;, stdin);freopen(FN2&quot;.out&quot;, &quot;w&quot;, stdout); solve(); fclose(stdin), fclose(stdout); return 0; } Problem 3 经营与开发【题目描述】4X概念体系，是指在PC战略游戏中一种相当普及和成熟的系统概念，得名自4个同样以“EX”为开头的英语单词。eXplore（探索）eXpand（拓张与发展）eXploit（经营与开发）eXterminate（征服）——维基百科 今次我们着重考虑exploit部分，并将其模型简化：你驾驶着一台带有钻头（初始能力值w）的飞船，按既定路线依次飞过n个星球。 星球笼统的分为2类：资源型和维修型。（p为钻头当前能力值）1.资源型：含矿物质量a[i]，若选择开采，则得到a[i]*p的金钱，之后钻头损耗k%，即p=p*(1-0.01k)2.维修型：维护费用b[i]，若选择维修，则支付b[i]*p的金钱，之后钻头修复c%，即p=p*(1+0.01c)注：维修后钻头的能力值可以超过初始值（你可以认为是翻修+升级） 请作为舰长的你仔细抉择以最大化收入。 【输入格式】第一行4个整数n,k,c,w。以下n行，每行2个整数type,x。type为1则代表其为资源型星球，x为其矿物质含量a[i]；type为2则代表其为维修型星球，x为其维护费用b[i]； 【输出格式】一个实数（保留2位小数），表示最大的收入。 【样例输入】5 50 50 101 101 202 102 201 30【样例输出】375.00【数据范围】对于30%的数据 n&lt;=100另有20%的数据 n&lt;=1000；k=100对于100%的数据 n&lt;=100000; 0&lt;=k,c,w,a[i],b[i]&lt;=100；保证答案不超过10^9]]></content>
      <categories>
        <category>模拟题/训练题</category>
      </categories>
      <tags>
        <tag>模拟题/训练题</tag>
        <tag>贪心</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj 3311(状压DP+最短路)]]></title>
    <url>%2Fpoj3311%2F</url>
    <content type="text"><![CDATA[poj 3311经典TSP问题，之前做的时候被虐，现在来做就是一道水题。设$dp(S, i)$为状态$i$最后访问到$j$城市的最优解，那么有状态转移方程$$dp(S, i) = min(dp(S-i, j), dis(j, i))$$其中$j$是已经访问过的城市(即在$S$中)，$dis$是两点最短路。边界是$dp(S, i) = dis(0, i)$，当且仅当即只访问了点$i$答案是$min(dp(E)(i) + dis(i, 0))$，其中$E$为$n$位$1$的二进制数(即全部访问)注意图不是对称的，所以$dis(i, j)$是有序的，从$j$到$i$必须是$dis(j, i)$而不是$dis(i, j)$ #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long using namespace std; const int MAXN = 10 + 5; int n, dis[MAXN][MAXN], dp[1&lt;&lt;MAXN][MAXN]; //dp[st[i]][j] 设 状态i最后访问到j城市的最优解 void clean() { ms(dis, 63), ms(dp, 63); } void solve() { clean(); for (int i=0;i&lt;=n;i++) for (int j=0;j&lt;=n;j++) scanf(&quot;%d&quot;, &amp;dis[i][j]); for (int k=0;k&lt;=n;k++) for (int i=0;i&lt;=n;i++) for (int j=0;j&lt;=n;j++) if (k!=i&amp;&amp;k!=j&amp;&amp;i!=j) dis[i][j] = min(dis[i][j], dis[i][k]+dis[k][j]);//floyd for (int S=1;S&lt;(1&lt;&lt;n);S++) {//枚举每个状态 for (int i=1;i&lt;=n;i++) {//枚举每个点 if (S&amp;(1&lt;&lt;(i-1))) {//这个点在S中(已被访问) if (S==(1&lt;&lt;(i-1))) {//如果S只访问了i dp[S][i] = dis[0][i];//DP边界 } else { for (int j=1;j&lt;=n;j++) if (i!=j) {//找每个访问过的点j且这个点不是i if (S&amp;(1&lt;&lt;(j-1))) { dp[S][i] = min(dp[S][i], dp[S^(1&lt;&lt;(i-1))][j] + dis[j][i]); //图不对称所以必须是dis[j][i]而不是dis[i][j] //找中间点更新值，类似floyd } } } } } } int ans = 1000000000; for (int i=1;i&lt;=n;i++) ans = min(ans, dp[(1&lt;&lt;n)-1][i] + dis[i][0]); printf(&quot;%d\n&quot;, ans); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif while (scanf(&quot;%d&quot;, &amp;n)==1&amp;&amp;n) solve(); return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>状压DP</tag>
        <tag>最短路</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj 1185(状压DP)]]></title>
    <url>%2Fpoj1185%2F</url>
    <content type="text"><![CDATA[poj 1185 本题很像这题，唯一不同的是一个物品会影响周围两个方格，那么我们设$dp(i, st(j), st(k))$为第$i$行用状态$k$，第$i-1$行用状态$j$的最优值。那么转移方程即为：$$dp(i, st(j), st(k)) = max(dp(i, st(t), st(j)) + num(k))$$其中$t$是与$k$不冲突的所有状态。初始化要初始化$num[i]$(st[i]中的$1$的个数)，我们可以用x&amp;(x-1)来快速消掉$x$最后的$1$，算出$num$。判断是否冲突可以用i&amp;(i&lt;&lt;1), i&amp; (i&lt;&lt;2)来判断，可以视为一个平移的过程，仔细思考可以发现。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long using namespace std; const int MAXN = 100 + 5, MAXM = 10 + 2; int n, m, top, st[100], cur[MAXN], dp[MAXN][100][100], num[MAXN]; char map[MAXN][MAXM]; void querynum(int i) { int t = st[i]; while (t) { num[i]++; t&amp;=(t-1); } } bool fit(int j, int h) {return (st[j]&amp;cur[h]) ? false : true;} void clean() { top = 0, ms(cur, 0), ms(dp, -1), ms(num, 0); } void solve() { clean(); for (int i=0;i&lt;(1&lt;&lt;m);i++) { if ( (i&amp; (i&lt;&lt;1) ) || (i&amp; (i&lt;&lt;2) ) ) continue; else st[++top] = i; } for (int i=1;i&lt;=n;i++) scanf(&quot;%s&quot;, map[i]+1); for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++) { if (map[i][j]==&#39;H&#39;) cur[i] += (1&lt;&lt;(j-1)); } for (int i=1;i&lt;=top;i++) { querynum(i); if (fit(i, 1)) dp[1][1][i] = num[i]; } for (int hi=2;hi&lt;=n;hi++) { for (int i=1;i&lt;=top;i++) { if (fit(i, hi)) { for (int j=1;j&lt;=top;j++) { if (st[i]&amp;st[j]) continue; for (int k=1;k&lt;=top;k++) { if (st[i]&amp;st[k]) continue; if (dp[hi-1][k][j]==-1) continue; dp[hi][j][i] = max(dp[hi][j][i], dp[hi-1][k][j] + num[i]); } } } } } int ans = 0; for (int hi=1;hi&lt;=n;hi++) { for (int i=1;i&lt;=top;i++) { for (int j=1;j&lt;=top;j++) { ans = max(ans, dp[hi][i][j]); } } } printf(&quot;%d\n&quot;, ans); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif while (scanf(&quot;%d%d&quot;, &amp;n, &amp;m)==2) solve(); return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>状压DP</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[状压DP/位运算 学习笔记]]></title>
    <url>%2Fsz%E7%8A%B6%E5%8E%8BDP%E4%BD%8D%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[模板及讲解状态压缩动态规划就是用于某种时候DP的状态难以表示时，使用二进制进行存储状态的一种动态规划。通常会用位运算进行操作： 位运算1、对$x$取反：~x2、$x+1(x为偶数)$：x|13、$2^x$：1&lt;&lt;x4、$2^{-x}$：1&gt;&gt;x5、$x的对应值$(例如$0$对$1$，$2$对$3$，$8$对$9$)：x^16、构造0~n-1位二进制数全部为1：(1&lt;&lt;n)-17、构造形如10,100,100000即[0, k-1]全部为0，[k,k]为1，这样的二进制数：1&lt;&lt;(k-1) 状压DP常用欲想用状压dp，先在dp方程中加上一维状态S再进行思考有哪些需要知道。 有一些状压 (DP) 可以根据最高位来转移，即低位数+最高位=高位数 1、将a的第k位修改为1：a |= 1&lt;&lt;k;2、将a的第k位修改为0：a &amp;= ~(1&lt;&lt;k);3、取第k位：a &gt;&gt; k &amp; 1;4、判定序列里有没有连续出现的1：a&amp;(a&gt;&gt;1)或a&amp;(a&lt;&lt;1)5、枚举子集：i = (i - 1) &amp; S6、取最后一个1：i &amp;= (i - 1)7、x的二进制表达式中最低位的1所对应的值：lowbit(x) = x &amp; (-x) 三(多)进制状压Loj 10172 我们相当于把一个整数当做三进制数来看，也就是说$(25)_{10}={221}_3$，我们就维护这个$221$。我们开一个数组sjc[状态][位]=位上的值 (0, 1, 2)，用来找一个状态每一个位上是什么这个数组可以用十进制转三进制的方法求得，具体看代码。然后注意本题要特判$k=1，k=n$，并且只有一行的情况。 异或性质1、$a \oplus a=0$2、$a \oplus b \oplus c=a \oplus (b \oplus c)$ (右结合律)3、$a \oplus 0 = a $ 异或题：(核心：按位贪心)1、两个之间的异或值：Trie树 (最大异或和，CF 888G，十二省联考异或粽子)2、多个之间的异或值：线性基 (Bzoj 4568) 常见题型]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>状压DP</tag>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj 3254(状压DP)]]></title>
    <url>%2Fpoj3254%2F</url>
    <content type="text"><![CDATA[poj 3254状态压缩基础题。题意是有一个矩阵，数为0的地方可以放牛，且牛不可以上下左右相邻，求摆放方案数。DP解答，我们每行DP，但是这里状态比较复杂，这里要用到状压DP设$dp(i, st[j])$为第$i$行使用状态$j$的方案数。状态转移方程：$$dp(i, st[j]) = \sum dp(i-1, st[k])$$其中$k$是满足$k$在$i-1$行时与$j$在$i$行时不相邻的状态。代码中运用了多处位运算技巧。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long using namespace std; const int MAXN = 12 + 2; int m, n; int cur[MAXN], st[1&lt;&lt;MAXN], top, dp[MAXN][1&lt;&lt;MAXN];//输入状态,可行状态,可行状态个数,dp[i][st[j]]为第i行使用状态j的总方案.其中cur中1为不可放置, st中1为放置点 bool fit(int j, int h) {return (st[j]&amp;cur[h]) ? false : true;} void clean() { top = 0, ms(cur, 0), ms(dp, 0); } void solve() { clean(); for (int i=0;i&lt;(1&lt;&lt;n);i++) {//处理可行状态(无相邻) if (i&amp;(i&gt;&gt;1)) continue; else st[++top] = i; } for (int i=1;i&lt;=m;i++) for (int j=1;j&lt;=n;j++) {//处理输入 int x; scanf(&quot;%d&quot;, &amp;x); if (!x) cur[i] += (1&lt;&lt;(j-1)); } for (int i=1;i&lt;=top;i++) if (fit(i, 1)) dp[1][i] = 1;//初始化DP for (int hi=2;hi&lt;=m;hi++) {//DP for (int j=1;j&lt;=top;j++) { if (!fit(j, hi)) continue; for (int k=1;k&lt;=top;k++) { if (!fit(k, hi-1)) continue; if (st[j]&amp;st[k]) continue; dp[hi][j] = (dp[hi][j] + dp[hi-1][k])%100000000; } } } int ans = 0; for (int i=1;i&lt;=top;i++) ans = (ans+dp[m][i])%100000000; printf(&quot;%d\n&quot;, ans); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif while (scanf(&quot;%d%d&quot;, &amp;m, &amp;n)==2) solve(); return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>状压DP</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2012 Day1 T2(贪心+高精度)]]></title>
    <url>%2FNOIP2012tgD1T2%2F</url>
    <content type="text"><![CDATA[以后贪心排序多考虑考虑cmp函数的写法….本题可以把大臣排序(不要排序国王，国王始终在第一位)，然后最后一个大臣的钱就是最多的(显然)关键是排序的cmp怎么写我们按照$a[i] * b[i]$排序。证明：对于最后一个大臣，它所得的钱为$W=sum / a / b$，即$W=sum / (a * b)$, 那么使$(a * b)$尽可能大，那么$W$就尽可能小。 严谨证明见算法进阶指南，采用的是临项交换的方法。 (题目数字大，要高精度，但这里没打高精度了。。) #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long using namespace std; const int MAXN = 1000 + 10; struct data { int l, r; bool operator &lt; (const data &amp;b) const { return l * r &lt; b.l * b.r; } }h[MAXN]; int n; void clean() { } void init() { clean(); n++; scanf(&quot;%d%d&quot;, &amp;h[1].l, &amp;h[1].r); for (int i=2;i&lt;=n;i++) scanf(&quot;%d%d&quot;, &amp;h[i].l, &amp;h[i].r); sort(h+2, h+1+n); } void solve() { LL ans = 1; for (int i=1;i&lt;n;i++) ans *= h[i].l; ans /= h[n].r; printf(&quot;%lld\n&quot;, ans); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif while (scanf(&quot;%d&quot;, &amp;n)==1) init(), solve(); return 0; }]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>NOIP</tag>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2013 Day1 T3(最大生成树+树链剖分/最大生成树+倍增)]]></title>
    <url>%2FNOIP2013tgD1T3%2F</url>
    <content type="text"><![CDATA[一看题目就想树剖，但是这里是图，怎么办？用最小生成树。我们只需要用最大的那几条边来连接这些点成为一棵树，其他的边是没有用的。求完最大树以后，再树链剖分或者倍增思想，这里没有做倍增只做了树剖，注意树剖的时候边权转点权，边权放到深度深的那个点上，然后处理每一个路径$(u,v)$，对于$LCA(u,v)$是不用加的！刚开始正解和暴力全部写挂这里直接10分。改了之后发现暴力还比正解快500ms。。下面给出树剖代码和暴力代码，以及数据生成器，有用的可以拿去。树剖： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long using namespace std; const int MAXN = 10000 + 5, MAXM = 50000 + 5, INF = 1000000000; struct data1 { int u, v, wi; bool operator &lt; (const data1 &amp;x) const { return wi &gt; x.wi; } }e1[MAXM];//原图 struct data2 { int v, wi; }e2[MAXM*2];//最大树 int n, m, Q, en, f[MAXN];//最大树边数，并查集 int dwi[MAXN], dep[MAXN], fa[MAXN], top[MAXN], p[MAXN], siz[MAXN], son[MAXN], pre;//树剖 int minv[MAXN*4];//线段树 vector&lt;int&gt; G[MAXN];//最大树 #define lc (o&lt;&lt;1) #define rc (o&lt;&lt;1|1) #define M ((l+r)&gt;&gt;1) void pushup(int o) {//线段树 minv[o] = min(minv[lc], minv[rc]); } void update(int o, int l, int r, int p, int v) {//线段树 if (l==r) { minv[o] = v; return ; } if (p&lt;=M) update(lc, l, M, p, v); else if (M&lt;p) update(rc, M+1, r, p, v); pushup(o); } int query(int o, int l, int r, int x, int y) {//线段树 int ret = INF; if (x&lt;=l&amp;&amp;r&lt;=y) { return minv[o]; } if (x&lt;=M) ret = min(ret, query(lc, l, M, x, y)); if (M&lt;y) ret = min(ret, query(rc, M+1, r, x, y)); return ret; } int find(int x) {return x==f[x] ? x : f[x] = find(f[x]);}//并查集find void dfs1(int u, int pa) {//树剖 dep[u] = dep[pa] + 1, fa[u] = pa, siz[u] = 1; for (int i=0;i&lt;G[u].size();i++) { data2 d2 = e2[G[u][i]]; int v = d2.v, wi = d2.wi; if (v!=pa) { dfs1(v, u); dwi[v] = wi; siz[u] += siz[v]; if (son[u]==-1||siz[v]&gt;siz[son[u]]) son[u] = v; } } } void dfs2(int u, int cha) {//树剖 top[u] = cha, p[u] = ++pre; if (son[u]!=-1) { dfs2(son[u], cha); for (int i=0;i&lt;G[u].size();i++) { data2 d2 = e2[G[u][i]]; int v = d2.v; if (v!=fa[u]&amp;&amp;v!=son[u]) { dfs2(v, v); } } } } int findMax(int u, int v) {//树剖 int ret = INF, f1 = top[u], f2 = top[v]; while (f1!=f2) { if (dep[f1]&lt;dep[f2]) swap(f1, f2), swap(u, v); ret = min(ret, query(1,1,n,p[f1],p[u])); u = fa[f1]; f1 = top[u]; } if (dep[u]&lt;dep[v]) swap(u, v); return min(ret, query(1,1,n,p[v]+1,p[u])); } void MST() {//Kruskal sort(e1+1, e1+1+m); for (int i=1;i&lt;=m;i++) { int a1 = find(e1[i].u), b1 = find(e1[i].v); if (a1==b1) continue; f[a1] = b1; en++, e2[en].v = e1[i].v, e2[en].wi = e1[i].wi, G[e1[i].u].push_back(en); en++, e2[en].v = e1[i].u, e2[en].wi = e1[i].wi, G[e1[i].v].push_back(en); } } void clean() { pre = en = 0; for (int i=0;i&lt;=n;i++) { dep[i] = fa[i] = top[i] = p[i] = siz[i] = 0; son[i] = -1; f[i] = i; G[i].clear(); } for (int i=0;i&lt;=4*n;i++) minv[i] = INF; } void init() { clean(); for (int i=1;i&lt;=m;i++) { scanf(&quot;%d%d%d&quot;, &amp;e1[i].u, &amp;e1[i].v, &amp;e1[i].wi); } } void solve() { MST(); for (int i=1;i&lt;=n;i++) if (!dep[i]) dfs1(i, 0); for (int i=1;i&lt;=n;i++) if (!p[i]) dfs2(i, i); for (int i=1;i&lt;=n;i++) if (fa[i]!=0) update(1,1,n,p[i],dwi[i]); scanf(&quot;%d&quot;, &amp;Q); for (int i=1;i&lt;=Q;i++) { int u, v; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); int a1 = find(u), b1 = find(v); if (a1!=b1) {printf(&quot;-1\n&quot;); continue;} printf(&quot;%d\n&quot;, findMax(u, v)); } } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif while (scanf(&quot;%d%d&quot;, &amp;n, &amp;m)==2) init(), solve(); return 0; } 暴力：(跑得比树剖还快) #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long using namespace std; const int MAXN = 10000 + 5, MAXM = 50000 + 5, INF = 1000000000; struct data1 { int u, v, wi; bool operator &lt; (const data1 &amp;x) const { return wi &gt; x.wi; } }e1[MAXM];//原图 struct data2 { int v, wi; }e2[MAXM*2];//最大树 vector&lt;int&gt; G[MAXN];//最大树 int dwi[MAXN], en, n, m, dep[MAXN], fa[MAXN], f[MAXN]; void dfs(int u, int pa) { dep[u] = dep[pa] + 1, fa[u] = pa; for (int i=0;i&lt;G[u].size();i++) { data2 d2 = e2[G[u][i]]; int v = d2.v; if (v!=fa[u]) { dfs(v, u); dwi[v] = d2.wi; } } } int find(int x) {return x==f[x] ? x : f[x] = find(f[x]);}//并查集find void MST() {//Kruskal sort(e1+1, e1+1+m); for (int i=1;i&lt;=m;i++) { int a1 = find(e1[i].u), b1 = find(e1[i].v); if (a1==b1) continue; f[a1] = b1; en++, e2[en].v = e1[i].v, e2[en].wi = e1[i].wi, G[e1[i].u].push_back(en); en++, e2[en].v = e1[i].u, e2[en].wi = e1[i].wi, G[e1[i].v].push_back(en); } } int findMax(int u, int v) { int ret = INF; if (dep[u]&lt;dep[v]) swap(u, v); while (dep[u]&gt;dep[v]) ret = min(ret, dwi[u]), u = fa[u]; if (u==v) return ret; while (u!=v) ret = min(ret, min(dwi[v], dwi[u])), u = fa[u], v = fa[v]; return ret; } void clean() { en = 0; for (int i=0;i&lt;=n;i++) { dep[i] = fa[i] = 0; f[i] = i; G[i].clear(); } } void init() { clean(); for (int i=1;i&lt;=m;i++) { scanf(&quot;%d%d%d&quot;, &amp;e1[i].u, &amp;e1[i].v, &amp;e1[i].wi); } } void solve() { MST(); for (int i=1;i&lt;=n;i++) if (!dep[i]) dfs(i, 0); int Q; scanf(&quot;%d&quot;, &amp;Q); for (int i=1;i&lt;=Q;i++) { int u, v; scanf(&quot;%d%d&quot;, &amp;u ,&amp;v); int a1 = find(u), b1 = find(v); if (a1!=b1) {printf(&quot;-1\n&quot;); continue;} printf(&quot;%d\n&quot;, findMax(u, v)); } } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;2.out&quot;, &quot;w&quot;, stdout); #endif while (scanf(&quot;%d%d&quot;, &amp;n, &amp;m)==2) init(), solve(); return 0; } 数据生成器： #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;windows.h&gt; #include&lt;winbase.h&gt; #include&lt;set&gt; using namespace std; int n = 3, m = 5, w = 5, q = 3; int main() { freopen(&quot;1.in&quot;, &quot;w&quot;, stdout); srand(GetTickCount()); printf(&quot;%d %d\n&quot;, n, m); for (int i=1;i&lt;=m;i++) { int a = rand()%n+1; int b = rand()%n+1; while (a==b) b = rand()%n+1; printf(&quot;%d %d %d\n&quot;, a, b, rand()%w); } printf(&quot;%d\n&quot;, q); for (int i=1;i&lt;=q;i++) { int a = rand()%n+1; int b = rand()%n+1; while (a==b) b = rand()%n+1; printf(&quot;%d %d\n&quot;, a, b); } return 0; }]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>生成树</tag>
        <tag>倍增</tag>
        <tag>NOIP</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2015 Day2 T3(树上差分序列+LCA)]]></title>
    <url>%2FNOIP2015tgD2T3%2F</url>
    <content type="text"><![CDATA[这题求最大值最小，显然二分。我们二分本题的答案，如何处理虫洞的情况？因为只能改造一个虫洞，那么这个虫洞一定是在某些“不改造虫洞会超过二分答案的路径”上，也就是这些路径的交。那么我们先把每条路径的时间长求出来，怎么求？树上的路径，用LCA即可，时间复杂度$O(mlogn)$求出来以后，我们每次二分，都一一检查每个路径的时间，如果大于二分答案，就在树上将这一个路径覆盖，那么问题来了，这里怎么覆盖？直接暴力？$O(mn)$的时间复杂度无法接受。这里方法一是树剖后线段树维护，但是这样的代码量直线上升。我们可以考虑差分序列。在线性的数据结构上的差分序列我们已经很熟悉了，$f[a]+1$, $f[b+1]-1$，那么在树上怎么办？很简单，我们让$f[u]+1, f[v]+1, f[LCA(u, v)]-2$，这样做以后在树上的前缀和$\sum_{k\in son(i)}{f[k]}$就表示该点为到其父亲的这条边被经过的次数，之后再找出所有路径的交，判定一下删除的情况就行了，这个地方边权一定要转化为点权。修改在深度深的那个节点上，否则会出现节点未更新完就判断导致错误，代码中有提示。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long using namespace std; const int MAXN = 300000 + 5, logs = 21, INF = 1000000000; int n, m, en, dep[MAXN], fa[MAXN], pre[MAXN][logs+1], dis[MAXN], pu[MAXN], pv[MAXN], pc[MAXN], f[MAXN], lca[MAXN], dwi[MAXN]; vector&lt;int&gt; G[MAXN]; struct edge{int v, wi;}e[MAXN*2]; void ins(int u, int v, int wi) { en++, e[en].v = v, e[en].wi = wi, G[u].push_back(en); } void clean() { en = 0; for (int i=0;i&lt;=n;i++) { G[i].clear(); lca[i] = pc[i] = dep[i] = fa[i] = dis[i] = 0; for (int j=0;j&lt;=logs;j++) pre[i][j] = 0; } } void init() { clean(); for (int i=1;i&lt;n;i++) { int ai, bi, ti; scanf(&quot;%d%d%d&quot;, &amp;ai, &amp;bi, &amp;ti); ins(ai, bi, ti), ins(bi, ai, ti); } for (int i=1;i&lt;=m;i++) { scanf(&quot;%d%d&quot;, &amp;pu[i], &amp;pv[i]); } } void dfs1(int u, int pa) { dep[u] = dep[pa]+1, fa[u] = pa, pre[u][0] = pa; for (int i=1;i&lt;=logs;i++) pre[u][i] = pre[pre[u][i-1]][i-1]; for (int i=0;i&lt;G[u].size();i++) { edge ed = e[G[u][i]]; int v = ed.v, wi = ed.wi; if (v!=pa) { dis[v] = dis[u] + wi; dwi[v] = wi; dfs1(v, u); } } } int LCA(int a, int b) { if (dep[a]&lt;dep[b]) swap(a, b); for (int i=logs;i&gt;=0;i--) if (dep[pre[a][i]]&gt;=dep[b]) a = pre[a][i]; if (a==b) return a; for (int i=logs;i&gt;=0;i--) if (pre[a][i]!=pre[b][i]) a = pre[a][i], b = pre[b][i]; return pre[a][0]; } int max1, max2, tot; void dfs2(int u, int pa) { for (int i=0;i&lt;G[u].size();i++) { edge ed = e[G[u][i]]; int v = ed.v, wi = ed.wi; if (v!=pa) { dfs2(v, u); f[u] += f[v]; } } if (f[u]==tot) max2 = max(max2, dwi[u]); } bool check(int x) { ms(f, 0), tot = max1 = max2 = 0; for (int i=1;i&lt;=m;i++) { if (pc[i]&gt;x) { max1 = max(max1, pc[i]); tot++; f[lca[i]]-=2; f[pu[i]]++, f[pv[i]]++; } } dfs2(1, 0); return x&gt;=max1-max2; } void solve() { dfs1(1, 0); int l = 0, r = 300000*1000, ans = INF; for (int i=1;i&lt;=m;i++) { pc[i] = dis[pu[i]]+dis[pv[i]]-2*dis[lca[i] = LCA(pu[i], pv[i])]; } r++; while (l&lt;r) { int mid = (l+r)&gt;&gt;1; if (check(mid)) { ans = mid; r = mid; } else l = mid + 1; } printf(&quot;%d\n&quot;, ans); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif while (scanf(&quot;%d%d&quot;, &amp;n, &amp;m)==2) init(), solve(); return 0; }]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
        <tag>倍增</tag>
        <tag>差分序列</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2015 Day2 T2(字符串DP)]]></title>
    <url>%2FNOIP2015tgD2T2%2F</url>
    <content type="text"><![CDATA[这题真的是。。不想说了，刚开始不敢加第三维，然后看题解发现第一维可以压掉。。然后如果我们设$f[i,j,k]$为$A$匹配到$i$, $B$匹配到$j$, 已经分了$k$个部分的方案总数，在转移的时候发现不能判断某一个字符取了还是没取，那么加一维, $f[i, j, k, 0]$表示不取，$f[i, j, k, 0]$表示取。那么分别转移：$$f[i,j,k,0]=f[i-1,j,k,1]+f[i-1,j,k,0]$$$$f[i,j,k,1] = f[i-1,j-1,k,1] + f[i-1,j-1,k-1,1] + f[i-1,j-1,k-1,0]$$在$A[i]==B[j]$时，才能更新$f[i,j,k,1]$初始化时$f[i,1,1,0] = s​$, $s​$为前$i​$个字符能匹配$B[1]​$多少次，那么每次枚举，都$f[i,1,1,0]=s​$, 如果当前为能够匹配，则$f[i,1,1,1] = 1，s+=1​$最后答案是$f[n,m,k,0]+f[n,m,k,1]$注意本题要取模，并且要计算空间复杂度不然会爆炸 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long using namespace std; const int MAXN = 1000 + 5, MAXM = 200 + 5, MO = 1000000007; int n, m, k; char a[MAXN], b[MAXM]; LL f[MAXM][MAXM][2], g[MAXM][MAXM][2]; void clean() { ms(f, 0), ms(g, 0); } void init() { clean(); scanf(&quot;%s%s&quot;, a+1, b+1); } void solve() { int s = 0; for (int i=1;i&lt;=n;i++) { //init f[1][1][0] = s; if (a[i]==b[1]) f[1][1][1] = 1, s++; //start for (int j=2;j&lt;=m;j++) for (int kk=1;kk&lt;=k;kk++) { f[j][kk][0] = (g[j][kk][1]+g[j][kk][0])%MO; if (a[i]==b[j]) f[j][kk][1] = (g[j-1][kk][1]+g[j-1][kk-1][1]+g[j-1][kk-1][0])%MO; } //clean for (int j=1;j&lt;=m;j++) for (int kk=1;kk&lt;=k;kk++) { g[j][kk][0] = f[j][kk][0], f[j][kk][0] = 0; g[j][kk][1] = f[j][kk][1], f[j][kk][1] = 0; } } printf(&quot;%lld\n&quot;, (g[m][k][0]+g[m][k][1])%MO); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif while (scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k)==3) init(), solve(); return 0; }]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>计数DP</tag>
        <tag>字符串DP</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2014 Day1 T3(背包DP)]]></title>
    <url>%2FNOIP2014tgD1T3%2F</url>
    <content type="text"><![CDATA[题目是一个无限背包+01背包，但是要先做无限背包，再做01背包。如果先做01背包，那么在做无限背包的时候会出现多次下降的情况。根据题目，很容易想出设$f[i][j]$为在$x=i, h=j$时的最小点击次数，那么有下列方程(无限背包部分, 即上升部分)$$f[i][j] = min(f[i][j], f[i-1][j-kx]+1)$$很明显，这样的做法TLE。我们回想无限背包的式子，$f[v] = max(f[v], f[v-w[i]]+c[i])$对吧？应该大部分人都记得这个“滚动后的式子”，而原式都不记得了，原式为设$f[i][v]$为前$i$个物品装进$v$容量的最大利益。则状态转移方程为$$f[i][v] = max(f[i-1][v], f[i][v-w[i]]+c[i])$$这个方程是”继承$f[i-1]$的值“或者”在$f[i]$中已经计算过的值再用来转移(即实现了多重)”，我们的原方程是不是也可以这样呢？答案是肯定的。原方程可化为$$f[i][j] = min(f[i][j-x]+1, f[i][j-x]+1)$$这样就不会超时了，处理之后的01背包，直接在多重处理完后扫一遍，$f[i][j] = min(f[i][j], f[i-1][j+y])$就能算出来了。注意此题要因为上升高度大于$m$则为$m$，需要进行特殊判定，并且每个是管道的状态也要转移，因为这个对多重做出了贡献，在处理完之后再进行覆盖最大值即可，否则这里会丢掉25分。直接沦为暴力选手 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) using namespace std; const int MAXN = 10000 + 5, MAXM = 1000 + 5, INF = 1000000000; int n, m, k, f[MAXN][MAXM], d[MAXN], u[MAXN], l[MAXN], h[MAXN]; void clean() { for (int i=0;i&lt;=n;i++) { l[i] = -1; h[i] = m + 1; f[i][0] = INF + 1; for (int j=1;j&lt;=m;j++) { if (i==0) f[i][j] = 0; else f[i][j] = INF; } } } void init() { clean(); for (int i=1;i&lt;=n;i++) { scanf(&quot;%d%d&quot;, &amp;u[i], &amp;d[i]); } for (int i=1;i&lt;=k;i++) { int p, x, y; scanf(&quot;%d%d%d&quot;, &amp;p, &amp;x, &amp;y); l[p] = x, h[p] = y; } } void solve() { int zz = 0, ans = INF; for (int i=1;i&lt;=n;i++) { for (int j=1;j&lt;=m;j++) { if (j-u[i]&gt;0) { f[i][j] = min(f[i][j], f[i][j-u[i]]+1); f[i][j] = min(f[i][j], f[i-1][j-u[i]]+1); } if (j==m) { for (int o=0;o&lt;u[i];o++) { f[i][j] = min(f[i][j], f[i][m-o]+1); f[i][j] = min(f[i][j], f[i-1][m-o]+1); } } } for (int j=1;j&lt;=m;j++) { if (j+d[i]&lt;=m) f[i][j] = min(f[i][j], f[i-1][j+d[i]]); } for (int j=1;j&lt;=l[i];j++) f[i][j] = INF; for (int j=h[i];j&lt;=m;j++) f[i][j] = INF; } for (int i=1;i&lt;=n;i++) { int ap = INF, flag = 0; for (int j=1;j&lt;=m;j++) { if (f[i][j]&lt;INF) flag = 1; ap = min(ap, f[i][j]); } if (!flag) {printf(&quot;0\n%d\n&quot;, zz); return ;} else ans = ap; if (l[i]!=-1) zz++; } printf(&quot;1\n%d\n&quot;, ans); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif while (scanf(&quot;%d%d%d&quot;, &amp;n ,&amp;m, &amp;k)==3) init(), solve(); return 0; } 2018.10.2，注意检查 DP 转移的完全性 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;stack&gt; #include&lt;set&gt; #include&lt;queue&gt; #include&lt;climits&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; namespace flyinthesky { const int MAXN = 10000 + 5, MAXM = 1000 + 5, INF = 1000000000; struct data {int l, h;} pp[MAXN]; int n, m, k, dp[MAXN][MAXM], x[MAXN], y[MAXN], vis[MAXN][MAXN]; void clean() { for (int i = 0; i &lt;= n; i++) for (int j = 0; j &lt;= m; j++) dp[i][j] = INF, vis[i][j] = 0; for (int i = 0; i &lt;= n; i++) pp[i] = (data){0, m + 1}; } int solve() { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k); clean(); for (int i = 0; i &lt; n; i++) scanf(&quot;%d%d&quot;, &amp;x[i], &amp;y[i]); for (int pos, i = 1; i &lt;= k; i++) { scanf(&quot;%d&quot;, &amp;pos); scanf(&quot;%d%d&quot;, &amp;pp[pos].l, &amp;pp[pos].h); for (int j = 0; j &lt;= pp[pos].l; j++) vis[pos][j] = 1; for (int j = pp[pos].h; j &lt;= m; j++) vis[pos][j] = 1; } for (int i = 1; i &lt;= m; i++) dp[0][i] = 0; for (int i = 1; i &lt;= n; i++) { for (int j = x[i - 1]; j &lt;= m; j++) { dp[i][j] = min(dp[i][j], dp[i][j - x[i - 1]] + 1); if (!vis[i - 1][j - x[i - 1]]) dp[i][j] = min(dp[i][j], dp[i - 1][j - x[i - 1]] + 1); // printf(&quot;i=%d, j=%d, dp=%d\n&quot;, i, j, dp[i][j]); } for (int j = m; j &gt;= max(m - x[i - 1], 1); j--) { dp[i][m] = min(dp[i][m], dp[i][j] + 1);//不要忘了 if (!vis[i - 1][j]) dp[i][m] = min(dp[i][m], dp[i - 1][j] + 1); } for (int j = 1; j + y[i - 1] &lt;= m; j++) if (!vis[i - 1][j + y[i - 1]]) dp[i][j] = min(dp[i][j], dp[i - 1][j + y[i - 1]]); } /*for (int j = m; j &gt;= 0; j--) for (int i = 0; i &lt;= n; i++) printf(&quot;%d%c&quot;, vis[i][j], i == n ? &#39;\n&#39; : &#39; &#39;); puts(&quot;&quot;); for (int j = m; j &gt;= 0; j--) for (int i = 0; i &lt;= n; i++) printf(&quot;%c%c&quot;, dp[i][j] == INF ? &#39;u&#39; : dp[i][j] + &#39;0&#39;, i == n ? &#39;\n&#39; : &#39; &#39;);*/ int tot = 0; for (int i = 1; i &lt;= n; i++) { int st = pp[i].l + 1, ed = pp[i].h - 1; if (!(st == 1 &amp;&amp; ed == m)) ++tot; int fl = 0; for (int j = st; j &lt;= ed; j++) if (dp[i][j] != INF) {fl = 1; break;} if (fl) continue; return printf(&quot;0\n%d\n&quot;, tot - 1); } int ans = INF; for (int j = 1; j &lt;= m; j++) ans = min(ans, dp[n][j]); printf(&quot;1\n%d\n&quot;, ans); return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>NOIP</tag>
        <tag>背包DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bzoj 3400(单调栈)]]></title>
    <url>%2Fbzoj3400%2F</url>
    <content type="text"><![CDATA[BZOJ 3400Luogu 2947from: USACO 2009 Mar Sliver(USACO刷题第19题) 维护一个从顶到底单调递减的单调栈然后就可以求解了。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) using namespace std; const int MAXN = 100000 + 5; int n, ans[MAXN], hi[MAXN], st[MAXN], top; void clean() { top = 0; ms(st, 0); } void init() { clean(); for (int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;, &amp;hi[i]); } void solve() { for (int i=n;i&gt;=1;i--) { while (top&amp;&amp;hi[i]&gt;=hi[st[top]]) top--; ans[i] = st[top]; st[++top] = i; } for (int i=1;i&lt;=n;i++) printf(&quot;%d\n&quot;, ans[i]); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif while (scanf(&quot;%d&quot;, &amp;n)==1) init(), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>USACO月赛</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1612」「Usaco2008 Jan」Cow Contest奶牛的比赛 (最短路)]]></title>
    <url>%2Fbzoj1612%2F</url>
    <content type="text"><![CDATA[BZOJ 1612Luogu 2419from: USACO 2008 Jan Sliver(USACO刷题第16题) 根据题目的胜负关系可以想到要建图建图，然后关键是怎么才能判断出某个点是否可以确定名次如果一个点和它连通的点的个数为$n-1$，那么这个点一定可以确定名次，正确性显然数据小，用Floyd传递闭包判连通即可求一个点和它连通的点的个数 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) using namespace std; const int MAXN = 100 + 5; int n, m, G[MAXN][MAXN], ans[MAXN]; void clean() { ms(G, 0), ms(ans, 0); } void init() { clean(); for (int i=1;i&lt;=m;i++) { int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); G[a][b] = 1; } } void solve() { for (int k=1;k&lt;=n;k++) for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=n;j++) if (i!=j&amp;&amp;i!=k&amp;&amp;j!=k) G[i][j] = (G[i][j]||(G[i][k]&amp;&amp;G[k][j])); for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=n;j++) if (G[i][j]) ans[i]++, ans[j]++; int tot = 0; for (int i=1;i&lt;=n;i++) if (ans[i]&gt;=n-1) tot++; printf(&quot;%d\n&quot;, tot); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif while (scanf(&quot;%d%d&quot;, &amp;n, &amp;m)==2) init(), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>最短路</tag>
        <tag>USACO月赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1614」「Usaco2007 Jan」Telephone Lines架设电话线 (二分+最短路)]]></title>
    <url>%2Fbzoj1614%2F</url>
    <content type="text"><![CDATA[BZOJ 1614Luogu 1948from: USACO 2008 Jan Sliver(USACO刷题第18题) 如果去掉一条路径上的边，肯定要优先删掉大的边，所以我们可以二分整条路径上的第$k+1$大的边，把比他小边的设为0，大的设为1然后最后的$dis[n]$就是如果第$k+1$大的边为当前二分$mid$值，所需要免费的边数，即可判断可行性。注意：无向图的边数组要开多两倍！！！牢记！！！ #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) using namespace std; const int MAXN = 1000 + 5, MAXM = 10000 + 5, INF = 1000000000; struct edge{int v, wi;}e[MAXM*2]; //无向边要*2！ int en, n, m, k; vector&lt;int&gt; G[MAXN]; void ins(int u, int v, int wi) { en++, e[en].v = v, e[en].wi = wi, G[u].push_back(en); en++, e[en].v = u, e[en].wi = wi, G[v].push_back(en); } void clean() { for (int i=0;i&lt;=n;i++) G[i].clear(); en = 0; } void init() { clean(); for (int i=1;i&lt;=m;i++) { int ai, bi, li; scanf(&quot;%d%d%d&quot;, &amp;ai, &amp;bi, &amp;li); ins(ai, bi, li); } } int dis[MAXN], vi[MAXN]; bool check(int x) { queue&lt;int&gt; q; for (int i=1;i&lt;=n;i++) dis[i] = INF, vi[i] = false; dis[1] = 0, q.push(1), vi[1] = true; while (!q.empty()) { int u = q.front(); q.pop(); vi[u] = false; for (int i=0;i&lt;G[u].size();i++) { edge p = e[G[u][i]]; int v = p.v, w = p.wi; if (dis[v]&gt;dis[u]+(p.wi&gt;x)) { dis[v] = dis[u]+(p.wi&gt;x); if (!vi[v]) q.push(v), vi[v] = true; } } } return dis[n]&lt;=k; } void solve() { int ans = -1, l = 0, r = 1000005; while (l&lt;r) { int mid = (l+r)&gt;&gt;1; if (check(mid)) { ans = mid; r = mid; } else l = mid + 1; } printf(&quot;%d\n&quot;, ans); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif while (scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k)==3) init(), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>最短路</tag>
        <tag>二分</tag>
        <tag>USACO月赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1610」「Usaco2008 Feb」Line连线游戏 (计算几何+排序去重)]]></title>
    <url>%2Fbzoj1610%2F</url>
    <content type="text"><![CDATA[BZOJ 1610Luogu 2665from: USACO 2008 Feb Sliver(USACO刷题第17题) 刚开始想到搜索每个点然后求斜率…然后并不行看题解以后直接全部求出来排序去重就可以了… 求斜率公式：$$k = \frac{y_1-y_2}{x_1-x_2}$$推导过程：设两个点为$(x_1, y_1),(x_2, y_2)$，它们之间连线的解析式为$y=kx+b$将两点坐标带入解析式，得$y_1=kx_1+b, y_2=kx_2+b$$y_1- y_2$，得$ y_1-y_2=kx_1-kx_2$$k(x_1-x_2) = y_1-y_2$即$k = \frac{y_1-y_2}{x_1-x_2}$ 注意，比较两个浮点数的大小为$fabs(a-b)&lt;eps$即相等, $eps$为最小误差值 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) using namespace std; const int MAXN = 200 + 5; const double INF = 1000000000.0, eps = 1e-8; int n, px[MAXN], py[MAXN], tot; double xl[MAXN*MAXN]; void clean() { tot = 0; xl[0] = INF; } void init() { clean(); for (int i=1;i&lt;=n;i++) scanf(&quot;%d%d&quot;, &amp;px[i], &amp;py[i]); } void solve() { for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=n;j++) if (i!=j) { if (px[i]==px[j]) xl[++tot] = INF; else xl[++tot] = (double)(py[i]-py[j])/(double)(px[i]-px[j]); } sort(xl+1, xl+1+tot); int ans = 0; for (int i=1;i&lt;=tot;i++) if (fabs(xl[i]-xl[i-1])&gt;eps) ans++; printf(&quot;%d\n&quot;, ans); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif while (scanf(&quot;%d&quot;, &amp;n)==1) init(), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>USACO月赛</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1638」「Usaco2007 Mar」Cow Traffic 奶牛交通 (树形DP+乘法原理)]]></title>
    <url>%2Fbzoj1638%2F</url>
    <content type="text"><![CDATA[BZOJ 1638Luogu 2883from: USACO 2007 Mar Sliver(USACO刷题第14题) 一开始只能想到暴力做法，看了题解才知道怎么做首先，对于一条边$(a,b)$, 设入度为0的节点为$w$, $path(x, y)$为$x -&gt; y$的路径条数根据乘法原理，经过该边次数为$$path(w, a) * path(b, n)$$这样我们可以分别求出$path(w, a), path(b, n)$，$path(w, a)$即$g$使用反图$RG$用DP求解，$path(b, n)$即$f$使用原图$G$用DP求解 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) using namespace std; const int MAXN = 5000 + 5, MAXM = 50000 + 5; vector&lt;int&gt; G[MAXN], RG[MAXN]; int n, m, a[MAXM], b[MAXM], f[MAXN], g[MAXN]; void dfs1(int u) { if (!G[u].size()) {f[u] = 1; return ;} for (int i=0;i&lt;G[u].size();i++) { int v = G[u][i]; if (!f[v]) dfs1(v); f[u] += f[v]; } } void dfs2(int u) { if (!RG[u].size()) {g[u] = 1; return ;} for (int i=0;i&lt;RG[u].size();i++) { int v = RG[u][i]; if (!g[v]) dfs2(v); g[u] += g[v]; } } void clean() { for (int i=0;i&lt;=n;i++) G[i].clear(), RG[i].clear(), f[i] = g[i] = 0; } void init() { clean(); for (int i=1;i&lt;=m;i++) { scanf(&quot;%d%d&quot;, &amp;a[i], &amp;b[i]); G[a[i]].push_back(b[i]), RG[b[i]].push_back(a[i]); } } void solve() { for (int i=1;i&lt;=n;i++) if (!f[i]) dfs1(i); dfs2(n); int ans = 0; for (int i=1;i&lt;=m;i++) ans = max(ans, g[a[i]]*f[b[i]]); printf(&quot;%d\n&quot;, ans); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif while (scanf(&quot;%d%d&quot;, &amp;n, &amp;m)==2) init(), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>计数DP</tag>
        <tag>计数原理</tag>
        <tag>Bzoj</tag>
        <tag>树形DP</tag>
        <tag>USACO月赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1641」「Usaco2007 Nov」Cow Hurdles 奶牛跨栏 (最短路)]]></title>
    <url>%2Fbzoj1641%2F</url>
    <content type="text"><![CDATA[BZOJ 1641Luogu 2888from: USACO 2007 Nov Sliver(USACO刷题第15题) 最大值最小，第一反应二分。但是这题把样例化画出来以后发现可以用最短路跑，改一下松弛为$$G[i][j] = min(G[i][j], max(G[i][k], G[k][j]))$$数据小Floyd水过。注意邻接矩阵重边问题！ #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) using namespace std; const int MAXN = 300 + 5, INF = 1000000000; int n, m, t, G[MAXN][MAXN]; void clean() { for (int i=0;i&lt;=n;i++) for (int j=0;j&lt;=n;j++) G[i][j] = INF; } void init() { clean(); for (int i=1;i&lt;=m;i++) { int si, ei, hi; scanf(&quot;%d%d%d&quot;, &amp;si, &amp;ei, &amp;hi); G[si][ei] = min(G[si][ei], hi);//重边 } } void solve() { for (int k=1;k&lt;=n;k++) for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=n;j++) if (i!=j&amp;&amp;i!=k&amp;&amp;j!=k&amp;&amp;G[i][k]!=INF&amp;&amp;G[k][j]!=INF) G[i][j] = min(G[i][j], max(G[i][k], G[k][j])); for (int i=1;i&lt;=t;i++) { int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); if (G[a][b]!=INF) printf(&quot;%d\n&quot;, G[a][b]); else printf(&quot;-1\n&quot;); } } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif while (scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;t)==3) init(), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>最短路</tag>
        <tag>USACO月赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1635」「Usaco2007 Jan」Tallest Cow 最高的牛 (差分序列)]]></title>
    <url>%2Fbzoj1635%2F</url>
    <content type="text"><![CDATA[BZOJ 1635Luogu 2879from: USACO 2007 Jan Sliver(USACO刷题第12题) 之前看完题目想到差分约束，然后是个区间不知道怎么搞。。看完题解是差分序列。。差分序列和差分约束并不是毫无关系啊。。差分约束运用于两个元素，差分序列运用于区间。。 本题对于每个约束$a,b$，如果$a&gt;b$，显然，交换不会影响结果我们设$f[i]$为差分序列，然后对于每个约束$a,b$，我们使$f[a+1]–, f[b]++$，这样可以保证$a,b$之间的元素严格小于$a,b$之后前缀和加上最高高度即可。前缀和一定不会大于$0$，因为每次操作都是在左边$-1$，右边$+1$本题可能会有重复的约束，要排序以后去重(考试的时候一定要注意这种问题) #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;stack&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long using namespace std; const int MAXN = 10000 + 5; struct data { int l, r; bool operator &lt; (const data &amp;b) const { if (l==b.l) return r &lt; b.r; return l &lt; b.l; } }d[MAXN]; int f[MAXN], n, m, q; void clear() { ms(f, 0); } void init() { clear(); for (int i=1;i&lt;=q;i++) { scanf(&quot;%d%d&quot;, &amp;d[i].l, &amp;d[i].r); if (d[i].l&gt;d[i].r) swap(d[i].l, d[i].r); } } void solve() { for (int i=1;i&lt;=q;i++) { if (i!=1&amp;&amp;d[i].l==d[i-1].l&amp;&amp;d[i].r==d[i-1].r) continue; f[d[i].l+1]--, f[d[i].r]++; } for (int i=1;i&lt;=n;i++) f[i] += f[i-1]; for (int i=1;i&lt;=n;i++) printf(&quot;%d\n&quot;, f[i]+m); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif while (scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;m, &amp;q)==4) init(), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>前缀和</tag>
        <tag>差分序列</tag>
        <tag>USACO月赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1633」「Usaco2007 Feb」The Cow Lexicon 牛的词典(字符串DP)]]></title>
    <url>%2Fbzoj1633%2F</url>
    <content type="text"><![CDATA[BZOJ 1633Luogu 2875from: USACO 2007 Jan Sliver(USACO刷题第13题) 刚开始根本没想到DP，什么kmp，AC自动机，后缀数组都想了。。看了题解才知道解决字符串的几大武器：(字符串DP，字符串Hash，KMP，AC自动机，后缀家族……) 本题设$f[i]$为给定串前$i$个字符进行处理后最少删除的字符数。刚开始想了个超时的方法。。然后发现其实直接写就行了。。还是太弱方程：$$f[i] = min(f[i], f[k]+cnt)$$其中$k$满足$[k,i]$之间能够被字典中的词匹配(可以删字符)，$cnt$为为此删除的字符数初始化$f[i] = i$ #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;stack&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long using namespace std; const int MAXW = 600 + 5, MAXL = 300 + 5; char dic[MAXW][MAXL], s[MAXL]; int n, L, f[MAXL]; void clear() {} void init() { clear(); scanf(&quot;%s&quot;, s+1); for (int i=1;i&lt;=n;i++) scanf(&quot;%s&quot;, dic[i]+1); } void solve() { for (int i=1;i&lt;=L;i++) { f[i] = i; for (int j=1;j&lt;=n;j++) { int len = strlen(dic[j]+1); int k, cnt = 0; for (k=i;k&gt;0;k--) { if (dic[j][len]==s[k]) len--; else cnt++; if (len==0) break; } if (len==0) f[i] = min(f[i], f[k-1]+cnt); } } printf(&quot;%d\n&quot;, f[L]); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif while (scanf(&quot;%d%d&quot;, &amp;n ,&amp;L)==2) init(), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>字符串DP</tag>
        <tag>USACO月赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1634」「Usaco2007 Jan」Protecting the Flowers 护花(贪心)]]></title>
    <url>%2Fbzoj1634%2F</url>
    <content type="text"><![CDATA[BZOJ 1634Luogu 2878from: USACO 2007 Jan Sliver(USACO刷题第11题) 刚开始naive的认为比较函数是第一关键字$d$第二关键字$t$，狂炸的我.. 对于两头牛$a, b$，他们的先后顺序不影响其他牛吃花的个数那么考虑$a$在$b$前面，那么吃的花为$2*d[b]*t[a]$$b$在$a$前面，那么吃的花为$2*d[a]*t[b]$要使$a$在前面吃的花最少，必须满足$d[b]*t[a] &lt; d[a]*t[b]$那么放进快排比较函数里就行了，之后贪心 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;stack&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long using namespace std; const int MAXN = 100000 + 5; struct data { int di, ti; bool operator &lt; (const data &amp;b) const { return ti*b.di &lt; b.ti*di; } }c[MAXN]; int n; LL sum, tot; void clear() { tot = sum = 0; } void init() { clear(); for (int i=1;i&lt;=n;i++) { scanf(&quot;%d%d&quot;, &amp;c[i].ti, &amp;c[i].di); sum += c[i].di; } sort(c+1, c+1+n); } void solve() { for (int i=1;i&lt;=n;i++) { sum -= c[i].di; tot += sum*c[i].ti*2; } printf(&quot;%lld\n&quot;, tot); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif while (scanf(&quot;%d&quot;, &amp;n)==1) init(), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>Bzoj</tag>
        <tag>USACO月赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1649」「Usaco2006 Dec」Cow Roller Coaster (背包DP)]]></title>
    <url>%2Fbzoj1649%2F</url>
    <content type="text"><![CDATA[BZOJ 1649Luogu 2854from: USACO 2006 Dec Sliver(USACO刷题第10题) 显然是二维费用01背包。但是直接做会超时，而且还有连接的限制。根据题意可以知道只有在$wi[i]+xi[i]=j$才需要考虑转移那么我们设$f[i][j]$为铺到$i$,成本为$j$的最大有趣值那么有下列转移方程$$f[xi[i]+wi[i]][j] = max(f[xi[i]+wi[i]][j], f[xi[i]][j-ci[i]]+fi[i])$$同时，这样使用会有后效性，我们将数组按照$xi$排序，接下来按照这个顺序的f[xi[i]]一定是更新完毕的状态，使得无后效性注意，方程初始化全部为$-INF$，除了$f[0][0]=0$，因为从$f[0][0]$转移的状态才是可行的，否则可能会有轨道不连接的问题 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;stack&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long using namespace std; const int MAXN = 10000 + 5, MAXL = 1000 + 5; struct data { int xi, wi, fi, ci; bool operator &lt; (const data &amp;b) const { return xi &lt; b.xi; } }di[MAXN]; int L, n, B; LL f[MAXL][MAXL];//设f[i][j]为铺到i,成本为j void clear() { ms(f, -127); f[0][0] = 0; } void init() { clear(); for (int i=1;i&lt;=n;i++) { scanf(&quot;%d%d%d%d&quot;, &amp;di[i].xi, &amp;di[i].wi, &amp;di[i].fi, &amp;di[i].ci); } sort(di+1, di+1+n); } void solve() { LL ans = 0; for (int i=1;i&lt;=n;i++) { for (int j=B;j&gt;=di[i].ci;j--) { f[di[i].xi+di[i].wi][j] = max(f[di[i].xi+di[i].wi][j], f[di[i].xi][j-di[i].ci]+di[i].fi); ans = max(ans, f[L][j]); } } if (ans&gt;0) printf(&quot;%lld\n&quot;, ans); else printf(&quot;-1\n&quot;); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif while (scanf(&quot;%d%d%d&quot;, &amp;L, &amp;n, &amp;B)==3) init(), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>背包DP</tag>
        <tag>USACO月赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1648」「Usaco2006 Dec」Cow Picnic 奶牛野餐 (DFS)]]></title>
    <url>%2Fbzoj1648%2F</url>
    <content type="text"><![CDATA[BZOJ 1648Luogu 2853from: USACO 2006 Dec Sliver(USACO刷题第8题) 记录一下每个牧场的奶牛个数，之后如果一个牧场有牛就dfs遍历，把遍历到的点的$tot[i]$都加上这个奶牛数，然后最后统计每个牧场如果$tot[i]=k$那么就是一个答案。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;stack&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long using namespace std; const int MAXN = 1000 + 5; vector&lt;int&gt; G[MAXN]; int cs[MAXN], vi[MAXN], tot[MAXN], k, n, m; void dfs(int u, int s) { tot[u] += s; for (int i=0;i&lt;G[u].size();i++) { int v = G[u][i]; if (!vi[v]) { vi[v] = true; dfs(v, s); } } } void clear() { ms(tot, 0); ms(cs, 0); } void init() { clear(); for (int i=1;i&lt;=k;i++) { int ki; scanf(&quot;%d&quot;, &amp;ki); cs[ki]++; } for (int i=1;i&lt;=m;i++) { int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); G[a].push_back(b); } } void solve() { for (int i=1;i&lt;=n;i++) { if (cs[i]) { ms(vi, 0), vi[i] = true; dfs(i, cs[i]); } } int ans = 0; for (int i=1;i&lt;=n;i++) if (tot[i]==k) ans++; printf(&quot;%d\n&quot;, ans); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif while (scanf(&quot;%d%d%d&quot;, &amp;k, &amp;n, &amp;m)==3&amp;&amp;k&amp;&amp;n&amp;&amp;m) init(), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>DFS</tag>
        <tag>USACO月赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1650」「Usaco2006 Dec」River Hopscotch 跳石子 (二分+贪心)]]></title>
    <url>%2Fbzoj1650%2F</url>
    <content type="text"><![CDATA[BZOJ 1650Luogu 2855from: USACO 2006 Dec Sliver(USACO刷题第9题) 最小值最大，显然二分。二分最小值最大距离，然后贪心处理。这里我们在头尾各增加一个石头，贪心时先从第一个石头开始记为$l$，然后往后扫描，当前扫描的石头记为$r$，如果$st[r]-st[l]&lt;mid$的话，说明$l, r$中间的石头就算都移走都不能满足最小值最大为$mid$，所以我们一直往后找，找到一个$st[r]-st[l]&gt;=mid$时停下来，移掉中间的所有石头数$r-l-1$，之后和$m$比较即可。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;stack&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long using namespace std; const int MAXN = 50000 + 5; int L, n, m, st[MAXN]; int check(int x) { int tot = 0, l = 0, r = 1; while (l&lt;n) { while (r&lt;n&amp;&amp;st[r]-st[l]&lt;x) r++; tot += r - l - 1; l = r; } return tot&lt;=m; } void clear() {} void init() { clear(); for (int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;, &amp;st[i]); sort(st+1, st+1+n); st[0] = 0, st[++n] = L; } void solve() { int ans = 0, l = 0, r = L + 1; while (l&lt;r) { int mid = (l+r)&gt;&gt;1; if (check(mid)) { ans = mid; l = mid + 1; } else r = mid; } printf(&quot;%d\n&quot;, ans); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif while (scanf(&quot;%d%d%d&quot;, &amp;L, &amp;n, &amp;m)==3) init(), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>Bzoj</tag>
        <tag>二分</tag>
        <tag>USACO月赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1661」「Usaco2006 Nov」Big Square 巨大正方形 (枚举)]]></title>
    <url>%2Fbzoj1661%2F</url>
    <content type="text"><![CDATA[BZOJ 1661Luogu 2867from: USACO 2006 Nov Sliver(USACO刷题第7题) 枚举两个点，第二个点要在第一个点的右下，那么这样我们就可以根据一个公式来求另外两个点了。之后四个点求出来后判断四个点是否都可行，然后记录这四个点中J的数量，如果$&gt;=3$，则这个正方形就是可行的，更新答案即可。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;stack&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long using namespace std; const int MAXN = 100 + 5; int n; char s[MAXN][MAXN]; void clear() { } void init() { clear(); for (int i=1;i&lt;=n;i++) scanf(&quot;%s&quot;, s[i]+1); } void solve() { int ans = 0; for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=n;j++) for (int x=i+1;x&lt;=n;x++) for (int y=1;y&lt;=j;y++) { int si = j - y, ti = x - i; int x3 = i + si, y3 = j + ti, x4 = x + si, y4 = y + ti; if (x3&lt;=0||x3&gt;n||x4&lt;=0||x4&gt;n||y3&lt;=0||y3&gt;n||y4&lt;=0||y4&gt;n) continue; if (s[i][j]==&#39;B&#39;||s[x][y]==&#39;B&#39;||s[x3][y3]==&#39;B&#39;||s[x4][y4]==&#39;B&#39;) continue; int tot = 0; if (s[i][j]==&#39;J&#39;) tot++; if (s[x][y]==&#39;J&#39;) tot++; if (s[x3][y3]==&#39;J&#39;) tot++; if (s[x4][y4]==&#39;J&#39;) tot++; if (tot&gt;=3) ans = max(ans, si*si+ti*ti); } printf(&quot;%d\n&quot;, ans); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif while (scanf(&quot;%d&quot;, &amp;n)==1&amp;&amp;n) init(), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>枚举</tag>
        <tag>USACO月赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1660」「Usaco2006 Nov」Bad Hair Day 乱发节 (单调栈)]]></title>
    <url>%2Fbzoj1660%2F</url>
    <content type="text"><![CDATA[BZOJ 1660Luogu 2866from: USACO 2006 Nov Sliver(USACO刷题第6题) 单调栈，对于每个数，他后面所有比他小的数(中间不能有大于他的数)都会对答案做出贡献。那么我们可以用单调栈来维护这个”后面所有比他小的数(中间不能有大于他的数)” #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long using namespace std; const int MAXN = 80000 + 5; int n, hi[MAXN], top, stk[MAXN]; void clear() { top = 0; } void init() { clear(); for (int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;, &amp;hi[i]); } void solve() { LL ans = 0; for (int i=1;i&lt;=n;i++) { if (hi[i]&lt;stk[top]) { ans += top; } else { while (top&amp;&amp;hi[i]&gt;=stk[top]) top--; ans += top; } stk[++top] = hi[i]; } printf(&quot;%lld\n&quot;, ans); } int main() { while (scanf(&quot;%d&quot;, &amp;n)==1&amp;&amp;n) init(), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>USACO月赛</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1651」「Usaco2006 Feb」Stall Reservations 专用牛棚(差分序列)]]></title>
    <url>%2Fbzoj1651%2F</url>
    <content type="text"><![CDATA[BZOJ 1651Luogu 2859from: USACO 2006 Feb Sliver(USACO刷题第4题) 首先需要发现的是，覆盖次数最多的点就是答案然后可以用线段树求解了但是这里要介绍一个很有用的东西，差分序列差分序列$f$记录$a[i]-a[i-1]$的值，$a$为原序列那么根据定义可以发现差分序列的前缀和就是原序列的数那么输入$a,b$, 我们让$f[a]+1, f[b+1]-1$就可以构造出差分序列这样可以实现$O(1)$区间修改，$O(n)$单点查询(这里可以用数据结构维护，但是本题不需要) #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;stack&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long using namespace std; const int MAXV = 1000000 + 5; int n, f[MAXV]; void clear() { ms(f, 0); } void init() { clear(); for (int i=1;i&lt;=n;i++) { int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); f[a]++, f[b+1]--; } } void solve() { int sum = 0, ans = 0; for (int i=1;i&lt;=1000001;i++) { sum += f[i]; ans = max(ans, sum); } printf(&quot;%d\n&quot;, ans); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif while (scanf(&quot;%d&quot;, &amp;n)==1&amp;&amp;n) init(), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>前缀和</tag>
        <tag>差分序列</tag>
        <tag>USACO月赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1652」「Usaco2006 Feb」Treats for the Cows (区间DP)]]></title>
    <url>%2Fbzoj1652%2F</url>
    <content type="text"><![CDATA[BZOJ 1652Luogu 2858from: USACO 2006 Feb Sliver(USACO刷题第5题) 显然DP。设$f[i][j]$为左取$i$个，右取$j$个的最大值初值：$$f[x][0] = \sum_{i=1}^{x}vi[i]*i$$$$f[0][x] = \sum_{i=n}^{x}vi[i]*(i-n+1)$$方程：$$f[i][j] = max(f[i-1][j]+(i+j)*vi[i], f[i][j-1]+(i+j)*vi[n-j+1])$$ #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;stack&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long using namespace std; const int MAXN = 2000 + 5; int f[MAXN][MAXN], n, vi[MAXN]; void clear() { } void init() { clear(); for (int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;, &amp;vi[i]); } void solve() { int tot = 0; f[0][0] = 0; for (int i=1;i&lt;=n;i++) { tot += vi[i]*i; f[i][0] = tot; } tot = 0; for (int i=n;i&gt;=1;i--) { tot += vi[i]*(n-i+1); f[0][n-i+1] = tot; } for (int i=1;i&lt;=n;i++) { for (int j=1;j&lt;=n;j++) { f[i][j] = max(f[i-1][j]+(i+j)*vi[i], f[i][j-1]+(i+j)*vi[n-j+1]); } } int ans = 0; for (int i=0;i&lt;=n;i++) { ans = max(f[i][n-i], ans); } printf(&quot;%d\n&quot;, ans); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif while (scanf(&quot;%d&quot;, &amp;n)==1&amp;&amp;n) init(), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>区间DP</tag>
        <tag>USACO月赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1654」「Usaco2006 Jan」The Cow Prom 奶牛舞会 (Tarjan找强连通分量)]]></title>
    <url>%2Fbzoj1654%2F</url>
    <content type="text"><![CDATA[BZOJ 1654Luogu 2863from: USACO 2006 Jan Sliver(USACO刷题第2题) tarjan找强连通分量，最后输出强连通分量保含节点个数$&gt;=2$的强连通分量个数即可，几乎是模板题 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;stack&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) using namespace std; const int MAXN = 10000 + 5; int n, m; vector&lt;int&gt; G[MAXN]; stack&lt;int&gt; s; int scc_num, scc_siz[MAXN], dn[MAXN], low[MAXN], vi[MAXN], tb; void tarjan(int u) { low[u] = dn[u] = ++tb; s.push(u), vi[u] = -1; for (int i=0;i&lt;G[u].size();i++) { int v = G[u][i]; if (vi[v]==0) { tarjan(v); low[u] = min(low[u], low[v]); } else if (vi[v]==-1) low[u] = min(low[u], dn[v]); } if (low[u]==dn[u]) { int e; scc_num++; do { e = s.top(); s.pop(); vi[e] = 1; scc_siz[scc_num]++; }while (e!=u); } } void clear() { tb = scc_num = 0; for (int i=1;i&lt;=n;i++) { G[i].clear(); vi[i] = dn[i] = low[i] = scc_siz[i] = 0; } } void init() { clear(); for (int i=1;i&lt;=m;i++) { int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); G[a].push_back(b); } } void solve() { int ans = 0; for (int i=1;i&lt;=n;i++) if (!dn[i]) tarjan(i); for (int i=1;i&lt;=scc_num;i++) if (scc_siz[i]&gt;=2) ans++; printf(&quot;%d\n&quot;, ans); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif while (scanf(&quot;%d%d&quot;, &amp;n ,&amp;m)==2&amp;&amp;n&amp;&amp;m) init(), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>Tarjan</tag>
        <tag>USACO月赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1655」「Usaco2006 Jan」 Dollar Dayz 奶牛商店 (背包DP+高精度)]]></title>
    <url>%2Fbzoj1655%2F</url>
    <content type="text"><![CDATA[BZOJ 1655poj 3181from: USACO 2006 Jan Sliver(USACO刷题第3题) 很容易看出本题是个无限背包方案数的dp，但是本题数据大会爆long long，那就可以把dp数组拆分为两个数组，类似于高精度压位地做 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;stack&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long using namespace std; const int MAXN = 1000 + 5; const LL MOD = 1000000000000000000; int k, n; LL a[MAXN], b[MAXN]; void clear() { ms(a, 0), ms(b, 0); } void init() { clear(); b[0] = 1; } void solve() { for (int i=1;i&lt;=k;i++) { for (int j=i;j&lt;=n;j++) { a[j] = a[j] + a[j-i] + (b[j] + b[j-i]) / MOD; b[j] = (b[j] + b[j-i]) % MOD; } } if (a[n]==0) printf(&quot;%lld\n&quot;, b[n]); else printf(&quot;%lld%018lld\n&quot;, a[n], b[n]); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif while (scanf(&quot;%d%d&quot;, &amp;n, &amp;k)==2&amp;&amp;n&amp;&amp;k) init(), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>高精度</tag>
        <tag>背包DP</tag>
        <tag>USACO月赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1656」「Usaco2006 Jan」 The Grove 树木 (BFS)]]></title>
    <url>%2Fbzoj1656%2F</url>
    <content type="text"><![CDATA[bzoj 1656luogu 2864from: USACO 2006 Jan Sliver(USACO刷题第1题) 一道BFS。之前没看题解没什么思路搜索，看了题解后发现可以随便找一棵树然后垂直于坐标轴作一条射线，该线内的方块不可到达(相当于障碍物)。BFS记录到达每个点的最短步数，之后再在这条射线上进行合并局部解，得到最后的最优解。 本题咋一看就是一个BFS，但是他要求绕着树林走，那么画一条射线来分解问题，把原问题分解为各走一半的最优解，最后再进行合并，得到全走完的最优解 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) using namespace std; const int MAXN = 50 + 5; const int dx[8] = {1,0,-1,0,1,-1,1,-1}; const int dy[8] = {0,1,0,-1,1,-1,-1,1}; struct node{int step, x, y;}; int r, c, s, t, woodx, woody, vi[MAXN][MAXN]; char m[MAXN][MAXN]; void bfs() { queue&lt;node&gt; q; vi[s][t] = 0; q.push((node){0,s,t}); while (!q.empty()) { node p = q.front(); q.pop(); for (int i=0;i&lt;8;i++) { int tx = p.x + dx[i], ty = p.y + dy[i]; if (tx&gt;0&amp;&amp;ty&gt;0&amp;&amp;tx&lt;=r&amp;&amp;ty&lt;=c) { if (m[tx][ty]==&#39;.&#39;&amp;&amp;vi[tx][ty]==-1) { vi[tx][ty] = p.step + 1; q.push((node){p.step + 1,tx,ty}); } } } } } void clear() { for (int i=1;i&lt;=r;i++) for (int j=1;j&lt;=c;j++) vi[i][j] = -1; woodx = woody = 0; } void init() { clear(); for (int i=1;i&lt;=r;i++) { for (int j=1;j&lt;=c;j++) { char ch; while (ch!=&#39;.&#39;&amp;&amp;ch!=&#39;X&#39;&amp;&amp;ch!=&#39;*&#39;) ch = getchar(); m[i][j] = ch; if (ch==&#39;*&#39;) s = i, t = j; if (!woodx&amp;&amp;ch==&#39;X&#39;) woodx = i, woody = j; ch = getchar(); } } for (int j=1;j&lt;woody;j++) m[woodx][j] = &#39;^&#39;; } void solve() { bfs(); int ans = 1000000000; for (int j=1;j&lt;woody;j++) { if (j-1&gt;0&amp;&amp;vi[woodx-1][j-1]!=-1&amp;&amp;vi[woodx+1][j+1]!=-1) ans = min(ans, vi[woodx-1][j-1]+vi[woodx+1][j+1]);//1 6 if (vi[woodx-1][j]!=-1 &amp;&amp;vi[woodx+1][j]!=-1) ans = min(ans, vi[woodx-1][j]+ vi[woodx+1][j]);//2 5 if (j-1&gt;0&amp;&amp;vi[woodx-1][j+1]!=-1&amp;&amp;vi[woodx+1][j-1]!=-1) ans = min(ans, vi[woodx-1][j+1]+vi[woodx+1][j-1]);//3 4 if (vi[woodx-1][j]!=-1 &amp;&amp;vi[woodx+1][j+1]!=-1) ans = min(ans, vi[woodx-1][j]+ vi[woodx+1][j+1]);//2 6 if (vi[woodx-1][j+1]!=-1&amp;&amp;vi[woodx+1][j]!=-1) ans = min(ans, vi[woodx-1][j+1]+vi[woodx+1][j]);//3 5 } printf(&quot;%d\n&quot;, ans+2); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif while (scanf(&quot;%d%d&quot;, &amp;r, &amp;c)==2&amp;&amp;r&amp;&amp;c) init(), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>BFS</tag>
        <tag>USACO月赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj 3264(ST表)]]></title>
    <url>%2Fpoj3264%2F</url>
    <content type="text"><![CDATA[poj 3264 ST表模板题。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) using namespace std; const int MAXN = 50000 + 5; int n, q; int h[MAXN], fmaxi[MAXN][25], fmini[MAXN][25]; //h为原数组，fmaxi[i][j]为从i开始长度为2^j的区间最小值 void initRMQ() { for (int i=1;i&lt;=n;i++) fmaxi[i][0] = fmini[i][0] = h[i];//初始值为原数组 for (int j=1;(1&lt;&lt;j)&lt;=n;j++) {//j必定在外层 for (int i=1;i+(1&lt;&lt;j)-1&lt;=n;i++) { fmaxi[i][j] = max(fmaxi[i][j-1], fmaxi[i+(1&lt;&lt;(j-1))][j-1]); fmini[i][j] = min(fmini[i][j-1], fmini[i+(1&lt;&lt;(j-1))][j-1]);//DP } } } int RMQMax(int x, int y) { int k = (int)(log(y-x+1.0)/log(2.0)); return max(fmaxi[x][k], fmaxi[y-(1&lt;&lt;k)+1][k]); } int RMQMin(int x, int y) { int k = (int)(log(y-x+1.0)/log(2.0)); return min(fmini[x][k], fmini[y-(1&lt;&lt;k)+1][k]); } void clear() {} void init() { clear(); for (int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;, &amp;h[i]); initRMQ(); } void solve() { for (int i=1;i&lt;=q;i++) { int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); printf(&quot;%d\n&quot;, RMQMax(a, b) - RMQMin(a, b)); } } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif while (scanf(&quot;%d%d&quot;, &amp;n, &amp;q)==2&amp;&amp;n&amp;&amp;q) init(), solve(); return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>poj</tag>
        <tag>ST表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj 2752(KMP)]]></title>
    <url>%2Fpoj2752%2F</url>
    <content type="text"><![CDATA[poj 27521、注意f数组的意思就是前缀和后缀最长公共部分长度，灵话运用解题 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; using namespace std; #define ms(i,j) memset(i, j, sizeof i); const int MAXN = 400000 + 5; char s[MAXN]; int f[MAXN], n, ans[MAXN], tot; void init() { n = strlen(s); } void solve() { f[0] = f[1] = 0; for (int i=1;i&lt;n;i++) { int j = f[i]; while (j &amp;&amp; s[i]!=s[j]) j = f[j]; f[i+1] = (s[i]==s[j]) ? (j+1) : (0); } int i = n; tot = 0; while (i) { int xh = i - f[i]; ans[++tot] = i; i = f[i]; } bool flag = false; for (int i=tot;i&gt;0;i--) { if (flag) printf(&quot; &quot;); printf(&quot;%d&quot;, ans[i]); flag = true; } printf(&quot;\n&quot;); } int main() { while (scanf(&quot;%s&quot;, s)==1) { init(); solve(); } return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>KMP</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj 2749(二分+2-SAT)]]></title>
    <url>%2Fpoj2749%2F</url>
    <content type="text"><![CDATA[poj 27491、加边视情况加2、2-SAT里面的c在solve里面千万不要再int c #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; #define ll long long #define db double #define ms(i,j) memset(i,j) #define INF 100000000 #define llINF 1LL&lt;&lt;60 using namespace std; const int MAXN = (50000 + 5) * 2, LEFT = 0, RIGHT = 1; struct TwoSAT { vector&lt;int&gt; G[MAXN*2]; int mark[MAXN*2]; int S[MAXN*2]; int n, c; void init(int n) { this-&gt;n = n; for (int i=0;i&lt;=n*2;i++) { mark[i] = false; G[i].clear(); } } void addE(int x, int xv, int y, int yv) { x = x*2 + xv; y = y*2 + yv; G[x^1].push_back(y); G[y^1].push_back(x); } int dfs(int x) { if (mark[x^1]) return false; if (mark[x]) return true; mark[x] = true; S[c++] = x; for (int i=0;i&lt;G[x].size();i++) { if (!dfs(G[x][i])) return false; } return true; } bool solve() { for (int i = 0;i &lt; n;i += 2) if (!mark[i]&amp;&amp;!mark[i+1]) { c = 0; if (!dfs(i)) { for (int j = 0; j &lt; c; j++) mark[S[j]] = false; c = 0; if (!dfs(i+1)) return false; } } return true; } }ts; int n, A, B, sx1, sy1, sx2, sy2, xi[MAXN], yi[MAXN], hate[MAXN][2], fri[MAXN][2], d1[MAXN], d2[MAXN],di; int dis(int x1, int y1, int x2, int y2) { return abs(x1-x2)+abs(y1-y2); } int judge(int mid) { ts.init(n); for (int i=0;i&lt;n;i++) for (int j=i+1;j&lt;n;j++) { int x = i, y = j; if (d1[i]+d1[j]&gt;mid) ts.addE(x, 1, y, 1); if (d2[i]+d2[j]&gt;mid) ts.addE(x, 0, y, 0); if (d1[i]+di+d2[j]&gt;mid) ts.addE(x, 1, y, 0); if (d2[i]+di+d1[j]&gt;mid) ts.addE(x, 0, y, 1); } for (int i=0;i&lt;A;i++) { int x = hate[i][LEFT] - 1, y = hate[i][RIGHT] - 1; ts.addE(x, 0, y, 0); ts.addE(x, 1, y, 1); } for (int i=0;i&lt;B;i++) { int x = fri[i][LEFT] - 1, y = fri[i][RIGHT] - 1; ts.addE(x, 0, y, 1); ts.addE(y, 0, x, 1); } return ts.solve(); } int init() { scanf(&quot;%d%d%d%d&quot;, &amp;sx1, &amp;sy1, &amp;sx2, &amp;sy2); for (int i=0;i&lt;n;i++) { scanf(&quot;%d%d&quot;, &amp;xi[i], &amp;yi[i]); } for (int i=0;i&lt;A;i++) { scanf(&quot;%d%d&quot;, &amp;hate[i][LEFT], &amp;hate[i][RIGHT]); } for (int i=0;i&lt;B;i++) { scanf(&quot;%d%d&quot;, &amp;fri[i][LEFT], &amp;fri[i][RIGHT]); } } int solve() { di = dis(sx1, sy1, sx2, sy2); for (int i=0;i&lt;n;i++) { d1[i] = dis(xi[i], yi[i], sx1, sy1); d2[i] = dis(xi[i], yi[i], sx2, sy2); } int l = 0, r = 8000000, ans = 10000000; while (l &lt; r) { int mid = (l + r) / 2; if (judge(mid)) { ans = mid; r = mid; } else l = mid+1; } if (ans!=10000000) { printf(&quot;%d\n&quot;, ans); } else printf(&quot;%d\n&quot;, -1); } int main() { while (scanf(&quot;%d%d%d&quot;, &amp;n, &amp;A, &amp;B)==3) { init(); solve(); } return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>2-SAT</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj 2528(线段树)]]></title>
    <url>%2Fpoj2528%2F</url>
    <content type="text"><![CDATA[poj 2528线段树离散化区间后区间染色，注意离散化问题 #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;vector&gt; #define ms(i,j) memset(i,j, sizeof i); using namespace std; const int MAXN = 10000 + 5; const int LEFT = 0, RIGHT = 1; struct poi { int a, from, f; //a为坐标，from为该点来源，f为是否左右结点 bool operator &lt;(const poi &amp;b) const { return a&lt;b.a; } }p[MAXN*2]; struct ls { int ch[2];//离散化后的线段 }seg[MAXN]; int n; #define lc o*2 #define rc o*2+1 #define M (l+r)/2 struct st { int col[MAXN*4*4];//为-1则无颜色 void pushdown(int o) { if (col[o]!=-1) { col[lc] = col[rc] = col[o]; col[o] = -1; } } void build(int o, int l ,int r) { col[o] = -1; if (l==r) return ; build(lc, l, M); build(rc, M+1, r); } void update(int o, int l, int r, int x, int y, int c) { if (x&lt;=l&amp;&amp;r&lt;=y) { col[o] = c; return ; } pushdown(o); if (x&lt;=M) update(lc, l, M, x, y, c); if (M&lt;y) update(rc, M+1, r, x, y, c); } bool used[MAXN*2*4]; int query(int o, int l, int r, int x, int y) { if (col[o]!=-1) { if (!used[col[o]]) { used[col[o]] = true; return 1; }else { return 0; } } int ans = 0; if (x&lt;=M) ans += query(lc, l, M, x, y); if (M&lt;y) ans += query(rc, M+1, r, x, y); return ans; } }tree; int main() { int kase; scanf(&quot;%d&quot;, &amp;kase); while (kase--) { scanf(&quot;%d&quot;, &amp;n); for (int i=0;i&lt;n;i++) { int x,y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); p[i*2].a = x, p[i*2].from = i, p[i*2].f = LEFT; p[i*2+1].a = y, p[i*2+1].from = i, p[i*2+1].f = RIGHT; } sort(p, p+n*2); //处理第一个 int last = p[0].a; int now = 1; seg[p[0].from].ch[p[0].f] = now; for (int i=1;i&lt;2*n;i++) { if (p[i].a!=p[i-1].a)now++; if (p[i].a-last&gt;1) now++; //离散化要在相距大于1的两个数之间加一个数！ seg[p[i].from].ch[p[i].f] = now; last = p[i].a; } tree.build(1,1,now); for (int i=0;i&lt;n;i++) tree.update(1,1,now,seg[i].ch[0], seg[i].ch[1], i); ms(tree.used, false); printf(&quot;%d\n&quot;, tree.query(1,1,now,1,now)); } return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj 3261(二分+后缀数组)]]></title>
    <url>%2Fpoj3261%2F</url>
    <content type="text"><![CDATA[poj 3261 还是一样的，这题是整形数字，也可以转为字符串算法做，用后缀数组，二分以后分组判定就可以了 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #define ms(i, j) memset(i, j, sizeof i) #define FN2 &quot;poj3261&quot; using namespace std; const int MAXN = 20000 + 5; int maxi, m, n, k, a[MAXN], tp[MAXN], SA[MAXN], rk[MAXN], height[MAXN], tax[MAXN]; bool cmp(int *f, int i, int k) {return f[SA[i]]==f[SA[i-1]]&amp;&amp;f[SA[i]+k]==f[SA[i-1]+k];} void build() { for (int i=0;i&lt;m;i++) tax[i] = 0; for (int i=0;i&lt;n;i++) tax[rk[i]=a[i]]++; for (int i=1;i&lt;m;i++) tax[i] += tax[i-1]; for (int i=n-1;i&gt;=0;i--) SA[--tax[rk[i]]] = i; int p; for (int k=1;k&lt;=n;k*=2) { p = 0; for (int i=n-k;i&lt;n;i++) tp[p++] = i; for (int i=0;i&lt;n;i++) if (SA[i]&gt;=k) tp[p++] = SA[i] - k; for (int i=0;i&lt;m;i++) tax[i] = 0; for (int i=0;i&lt;n;i++) tax[rk[tp[i]]]++; for (int i=1;i&lt;m;i++) tax[i] += tax[i-1]; for (int i=n-1;i&gt;=0;i--) SA[--tax[rk[tp[i]]]] = tp[i]; swap(rk, tp), p = 0, rk[SA[0]] = 0; for (int i=1;i&lt;n;i++) rk[SA[i]] = cmp(tp, i, k) ? p : ++p; if (++p&gt;=n) break; m = p; } } void getH() { int k = 0; for (int i=0;i&lt;n;i++) { if (k) k--; int j = SA[rk[i]-1]; while (a[i+k]==a[j+k]) k++; height[rk[i]] = k; } } void init() { maxi = 0; for (int i=0;i&lt;n;i++) scanf(&quot;%d&quot;, &amp;a[i]), maxi = max(maxi, ++a[i]);//原串可能有0，所以+1，注意 n++, a[n-1] = 0, m = maxi + 1; } int used[MAXN]; bool check(int x) { int tot = 0; ms(used, false); for (int i=2;i&lt;n;i++) { if (height[i]&lt;x) { ms(used, false); tot = 0; continue; } if (!used[SA[i-1]]) used[SA[i-1]] = true, ++tot; if (!used[SA[i]]) used[SA[i]] = true, ++tot; if (tot&gt;=k) return true; } return false; } void solve() { build(), getH(); int l = 1, r = n + 1, ans = 0; while (l&lt;r) { int mid = (l+r)/2; if (check(mid)) { ans = mid; l = mid + 1; } else r = mid; } printf(&quot;%d\n&quot;, ans); } int main() { #ifndef ONLINE_JUDGE freopen(FN2&quot;.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout); #endif while(scanf(&quot;%d%d&quot;, &amp;n, &amp;k)==2) init(), solve(); return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>后缀数组</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj 1743(二分+后缀数组)]]></title>
    <url>%2Fpoj1743%2F</url>
    <content type="text"><![CDATA[poj 1743 注意用$height$分组如果最后一组最后一个元素在序列末，那么要进行处理！最方便是直接$&lt;=n$，还要注意的是不能重复，而且是$mini+x&lt;maxi$不能是$mini+x&lt;=maxi$ 本题求的是长度最少为5的重复子串，并且重复子串可以加上或者减去一个数。我们将数字处理一下取差值，然后直接做，之后再结果$+1$即可 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) using namespace std; const int MAXN = 20000 + 5; int n, m, a[MAXN], SA[MAXN], tp[MAXN], rk[MAXN], tax[MAXN], height[MAXN]; bool cmp(int *f, int i, int k) {return f[SA[i]]==f[SA[i-1]]&amp;&amp;f[SA[i]+k]==f[SA[i-1]+k];} void build_SA() { for (int i=0;i&lt;m;i++) tax[i] = 0; for (int i=0;i&lt;n;i++) tax[rk[i]=a[i]]++; for (int i=1;i&lt;m;i++) tax[i] += tax[i-1]; for (int i=n-1;i&gt;=0;i--) SA[--tax[rk[i]]] = i; int p; for (int k=1;k&lt;=n;k*=2) { p = 0; for (int i=n-k;i&lt;n;i++) tp[p++] = i; for (int i=0;i&lt;n;i++) if (SA[i]&gt;=k) tp[p++] = SA[i] - k; for (int i=0;i&lt;m;i++) tax[i] = 0; for (int i=0;i&lt;n;i++) tax[rk[tp[i]]]++; for (int i=1;i&lt;m;i++) tax[i] += tax[i-1]; for (int i=n-1;i&gt;=0;i--) SA[--tax[rk[tp[i]]]] = tp[i]; swap(tp, rk), p = 0, rk[SA[0]] = 0; for (int i=1;i&lt;n;i++) rk[SA[i]] = cmp(tp, i, k) ? p : ++p; if (++p&gt;=n) break; m = p; } int k = 0; for (int i=0;i&lt;n;i++) { if (k) k--; int j = SA[rk[i]-1]; while (a[i+k]==a[j+k]) k++; height[rk[i]] = k; } } bool check(int x) { int maxi , mini; maxi = mini = SA[1]; for (int i=2;i&lt;=n;i++) { if (height[i]&gt;=x) { maxi = max(maxi, SA[i]); mini = min(mini, SA[i]); } else { if (mini+x&lt;maxi) return true; maxi = mini = SA[i]; } } return false; } void clear() {} void init() { clear(); a[n] = 0; for (int i=0;i&lt;n;i++) { scanf(&quot;%d&quot;, &amp;a[i]); a[i-1] = a[i] - a[i-1] + 100; } a[n-1] = a[n] - a[n-1] + 100; n++, m = 300; } void solve() { build_SA(); int l = 1, r = n, ans = 0; while (l&lt;r) { int mid = (l+r)&gt;&gt;1; if (check(mid)) { ans = mid; l = mid + 1; } else r = mid; } if (ans&lt;4) ans = 0; else ans++; printf(&quot;%d\n&quot;, ans); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif while (scanf(&quot;%d&quot;, &amp;n)==1&amp;&amp;n) init(), solve(); return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>后缀数组</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj 1523(割顶)]]></title>
    <url>%2Fpoj1523%2F</url>
    <content type="text"><![CDATA[poj 1523直接模板即可。注意不一定是连通图。-1的时候注意是不是unsigned int，G[u].size()是unsigned int，切记切记 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i ,j) memset(i, j, sizeof i) #define rd(a) scanf(&quot;%d&quot;, &amp;a) #define rd2(a, b) scanf(&quot;%d%d&quot;, &amp;a, &amp;b) #define rd3(a, b, c) scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c) #define fo(i, j, k) for (i=(j);i&lt;=(k);i++) #define fd(i, k, j) for (i=(k);i&gt;=(j);i--) #define fe(i, u) for (i=head[u];i!=-1;i=e[i].next) #define FN2 &quot;poj1523&quot; using namespace std; const int MAXN = 1000 + 5; int n, kase = 0, low[MAXN], dn[MAXN], block[MAXN], tb; vector&lt;int&gt; G[MAXN]; void tarjan(int u, int fa) { int i, child = 0; dn[u] = low[u] = ++tb; for(i=0;i&lt;G[u].size();i++) { int v = G[u][i]; if (!dn[v]) { child++; tarjan(v, u); low[u] = min(low[u], low[v]); if (low[v]&gt;=dn[u]) block[u]++; } else if (v!=fa&amp;&amp;dn[v]&lt;dn[u]) low[u] = min(low[u], dn[v]); } if (fa&lt;0&amp;&amp;child==1) block[u] = 0; } void init() { int u, v, i; n = tb = 0; fo (i, 1, MAXN-5) G[i].clear(), low[i] = dn[i] = block[i] = 0; while (rd(u)&amp;&amp;u) { rd(v); n = max(n, max(u,v)); G[u].push_back(v), G[v].push_back(u); } if (n==0) exit(0); fo (i, 1, n) block[i] = 1; block[1] = 0; } void solve() { int i, flag = false; tarjan(1, -1); if (kase) printf(&quot;\n&quot;); printf(&quot;Network #%d\n&quot;, ++kase); fo (i, 1, n) if (block[i]&gt;1) { printf(&quot; SPF node %d leaves %d subnets\n&quot;, i, block[i]); flag = true; } if (!flag) printf(&quot; No SPF nodes\n&quot;); } int main() { #ifndef ONLINE_JUDGE freopen(FN2&quot;.in&quot;, &quot;r&quot;, stdin);freopen(FN2&quot;.out&quot;, &quot;w&quot;, stdout); #endif while (1) init(), solve(); return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>Tarjan</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj 3207(2-SAT)]]></title>
    <url>%2Fpoj3207%2F</url>
    <content type="text"><![CDATA[poj 32071、注意加边2、判两条线段是否重叠的方法 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; #define ll long long #define db double #define ms(i,j) memset(i,j) #define INF 100000000 #define llINF 1LL&lt;&lt;60 using namespace std; const int MAXM = 500 + 5; struct TwoSAT { int mark[MAXM*2]; int S[MAXM*2]; vector&lt;int&gt; G[MAXM*2]; int n, c; void init(int n) { this-&gt;n = n; for (int i=0;i&lt;=2*n;i++) { G[i].clear(); mark[i] = false; } } void addE(int x, int xv, int y, int yv) { x = x * 2 + xv; y = y * 2 + yv; G[x^1].push_back(y); G[y^1].push_back(x); } bool dfs(int x) { if (mark[x^1]) return false; if (mark[x]) return true; mark[x] = true; S[++c] = x; for (int i=0;i&lt;G[x].size();i++) { if (!dfs(G[x][i])) return false; } return true; } bool solve() { for (int i=0;i&lt;2*n;i+=2) if (!mark[i]&amp;&amp;!mark[i+1]) { c = 0; if (!dfs(i)) { while (c&gt;0) mark[S[c--]] = false; if (!dfs(i+1)) return false; } } return true; } }ts; struct linkz { int a, b; }lk[MAXM]; int n, m; int init() { for (int i=1;i&lt;=m;i++) { scanf(&quot;%d%d&quot;, &amp;lk[i].a, &amp;lk[i].b); if (lk[i].a&gt;lk[i].b) { int t = lk[i].a; lk[i].a = lk[i].b, lk[i].b = t; } } ts.init(n); for (int i=1;i&lt;=m;i++) for (int j=i+1;j&lt;=m;j++) { int &amp;x1 = lk[i].a, &amp;y1 = lk[i].b, &amp;x2 = lk[j].a, &amp;y2 = lk[j].b; if ( (x1&lt;=x2 &amp;&amp; y1&lt;=y2 &amp;&amp; x2&lt;=y1) || (x1&gt;=x2 &amp;&amp; y1&gt;=y2 &amp;&amp; y2&gt;=x1) ) { ts.addE(i-1, 0, j-1, 0); ts.addE(i-1, 1, j-1, 1); } } } int solve() { if (ts.solve()) { printf(&quot;panda is telling the truth...\n&quot;); } else printf(&quot;the evil panda is lying again\n&quot;); } int main() { while (scanf(&quot;%d%d&quot;, &amp;n, &amp;m)==2) { init(); solve(); } return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>2-SAT</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj 1201(差分约束)]]></title>
    <url>%2Fpoj1201%2F</url>
    <content type="text"><![CDATA[poj 1201差分约束。设$dis[i]$为$[1,i]$包含在$Z$集合内数的个数由题意得，$dis[b]-dis[a-1]\ge c$，由隐含条件每个数只出现一次或不出现，得$0 \le dis[i]-dis[i-1] \le 1$整理后得，$$dis[b]-dis[a-1]\ge c \\dis[i]-dis[i-1]\ge 0 \\dis[i-1]-dis[i]\ge -1$$然后按照差分约束系统用SPFA求最长路即可。 #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ms(i,j) memset(i,j, sizeof i); using namespace std; const int MAXN = 50000 + 5; struct edge { int u, v, c; }E[MAXN*3*2]; vector&lt;int&gt; G[MAXN*2]; int e_num; int n; int minr = 100000000, maxr = -minr; void addE(int u, int v, int c) { e_num++; E[e_num].u = u; E[e_num].v = v; E[e_num].c = c; G[u].push_back(e_num); } int dis[MAXN*2]; int vi[MAXN*2]; void spfa() { ms(dis, -(127/3)); ms(vi, false); queue&lt;int&gt; q; q.push(minr); dis[minr] = 0; while (!q.empty()) { int r = q.front(); q.pop(); vi[r] = false; for (int i=0;i&lt;G[r].size();i++) { edge ed = E[G[r][i]]; if (dis[ed.v]&lt;dis[r]+ed.c) { dis[ed.v] = dis[r] + ed.c; if (!vi[ed.v]) { vi[ed.v] = true; q.push(ed.v); } } } } } int main() { while (scanf(&quot;%d&quot;, &amp;n)==1) { e_num = 0; for (int i=1;i&lt;=n;i++) { int ai,bi,ci; scanf(&quot;%d%d%d&quot;, &amp;ai, &amp;bi, &amp;ci); //dis[bi]-dis[ai-1]&gt;=ci addE(ai-1, bi, ci); minr = min(minr, ai-1); maxr = max(maxr, bi); } for (int i=minr+1;i&lt;=maxr;i++) { //0&lt;=dis[i]-dis[i-1]&lt;=1 //dis[i]-dis[i-1]&gt;=0 addE(i-1, i, 0); //dis[i]-dis[i-1]&lt;=1 //dis[i-1]-dis[i]&gt;=-1 addE(i, i-1, -1); } spfa(); printf(&quot;%d\n&quot;, dis[maxr]); } return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj 2723(二分+2-SAT)]]></title>
    <url>%2Fpoj2723%2F</url>
    <content type="text"><![CDATA[poj 2723二分枚举m，然后建2-SAT图即可。 #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;vector&gt; #define ms(i,j) memset(i,j, sizeof i); using namespace std; const int MAXM = 2100, MAXN = 1100; struct pa { int x, y; }keis[MAXN], locs[MAXM]; int n,m; struct twoSAT { vector&lt;int&gt; G[MAXN*4]; int mark[MAXN*4]; int c; int S[MAXN*4]; void init() { for (int i=0;i&lt;4*n;i++) { G[i].clear(); mark[i] = false; } } void addE(int x, int y, int xv, int yv) { x = x*2+xv; y = y*2+yv; G[x^1].push_back(y); G[y^1].push_back(x); } void built(int to) { init(); for (int i=0;i&lt;n;i++) { addE(keis[i].x, keis[i].y, 0, 0); } for (int i=0;i&lt;to;i++) { addE(locs[i].x, locs[i].y, 1, 1); } } bool dfs(int x) { if (mark[x^1]) return false; if (mark[x]) return true; mark[x] = true; S[++c] = x; for (int i=0;i&lt;G[x].size();i++) if(!dfs(G[x][i])) return false; return true; } bool solve() { for (int i=0;i&lt;n*2;i++) if (!mark[i*2] &amp;&amp; !mark[i*2+1]) { c = 0; if (!dfs(i*2)) { while (c&gt;0) mark[S[c--]] = false; if (!dfs(i*2+1)) return false; } } return true; } }ts; int main() { while (scanf(&quot;%d%d&quot;, &amp;n,&amp;m)==2&amp;&amp;(n||m)) { for (int i=0;i&lt;n;i++) { scanf(&quot;%d%d&quot;, &amp;keis[i].x, &amp;keis[i].y); } for (int i=0;i&lt;m;i++) { scanf(&quot;%d%d&quot;, &amp;locs[i].x, &amp;locs[i].y); } int l = 0, r = m, mid; while (l&lt;r) { mid = (l+r)/2+1; ts.built(mid); bool ans = ts.solve(); if (ans) l = mid; else r = mid-1; } printf(&quot;%d\n&quot;, l); } return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>2-SAT</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj 2478(欧拉函数)]]></title>
    <url>%2Fpoj2478%2F</url>
    <content type="text"><![CDATA[poj 2478筛选法求欧拉函数 每个询问答案是$$\sum_{i=1}^n\varphi(i)$$ #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #define ms(i,j) memset(i,j, sizeof i); using namespace std; #define ll long long ll phi[1000000+5]; void phitable(ll n) { for (int i=2;i&lt;=n;i++) phi[i] = 0; phi[1] = 1; for (int i=2;i&lt;=n;i++) if (!phi[i]) for (int j=i;j&lt;=n;j+=i) { if (!phi[j]) phi[j] = j; phi[j] = phi[j]/i*(i-1); } } int main() { phitable(1000000); int n; while (scanf(&quot;%d&quot;, &amp;n)==1 &amp;&amp; n) { ll tot = 0; for (int i=2;i&lt;=n;i++) tot += phi[i]; printf(&quot;%lld\n&quot;, tot); } return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>欧拉函数</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj 1226(二分+后缀数组)]]></title>
    <url>%2Fpoj1226%2F</url>
    <content type="text"><![CDATA[poj 1226 几本上与这题一样，只不过这里还要把读入的字符串的翻转后的字符串也要连上 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define FN2 &quot;poj1226&quot; using namespace std; const int MAXN = 100 + 10; char s[MAXN]; int mini, t, n, m, a[2*MAXN*MAXN], belong[2*MAXN*MAXN], SA[2*MAXN*MAXN], rk[2*MAXN*MAXN], tp[2*MAXN*MAXN], tax[2*MAXN*MAXN], height[2*MAXN*MAXN]; bool cmp(int *f, int i, int k) {return f[SA[i]]==f[SA[i-1]]&amp;&amp;f[SA[i]+k]==f[SA[i-1]+k];} void build() { for (int i=0;i&lt;m;i++) tax[i] = 0; for (int i=0;i&lt;n;i++) tax[rk[i]=a[i]]++; for (int i=1;i&lt;m;i++) tax[i] += tax[i-1]; for (int i=n-1;i&gt;=0;i--) SA[--tax[rk[i]]] = i; int p; for (int k=1;k&lt;=n;k*=2) { p = 0; for (int i=n-k;i&lt;n;i++) tp[p++] = i; for (int i=0;i&lt;n;i++) if (SA[i]&gt;=k) tp[p++] = SA[i] - k; for (int i=0;i&lt;m;i++) tax[i] = 0; for (int i=0;i&lt;n;i++) tax[rk[tp[i]]]++; for (int i=1;i&lt;m;i++) tax[i] += tax[i-1]; for (int i=n-1;i&gt;=0;i--) SA[--tax[rk[tp[i]]]] = tp[i]; swap(rk, tp), p = 0, rk[SA[0]] = 0; for (int i=1;i&lt;n;i++) rk[SA[i]] = cmp(tp, i, k) ? p : ++p; if (++p&gt;=n) break; m = p; } } void getH() { int k = 0; for (int i=0;i&lt;n;i++) { if (k) k--; int j = SA[rk[i]-1]; while (a[i+k]==a[j+k]) k++; height[rk[i]] = k; } } void init() { n = 0, m = 200, mini = 200000000; scanf(&quot;%d&quot;, &amp;t); for (int i=0;i&lt;t;i++) { scanf(&quot;%s&quot;, s); int l1 = strlen(s); mini = min(l1, mini); for (int j=0;j&lt;l1;j++) { belong[n] = i; a[n++] = s[j]; } a[n++] = m++; for (int j=l1-1;j&gt;=0;j--) { belong[n] = i; a[n++] = s[j]; } a[n++] = m++; } a[n-1] = 0; m += 5; } int used[MAXN]; bool check(int x) { int tot = 0; ms(used, 0); for (int i=2;i&lt;n;i++) { if (height[i]&lt;x) { ms(used, 0); tot = 0; continue; } if (!used[belong[SA[i-1]]]) used[belong[SA[i-1]]] = true, ++tot; if (!used[belong[SA[i]]]) used[belong[SA[i]]] = true, ++tot; if (tot&gt;=t) return true; } return false; } void solve() { build(), getH(); int l = 1, r = mini + 1, ans = 0; while (l&lt;r) { int mid = (l+r)/2; if (check(mid)) { ans = mid; l = mid + 1; } else r = mid; } printf(&quot;%d\n&quot;, ans); } int main() { #ifndef ONLINE_JUDGE freopen(FN2&quot;.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout); #endif int kase; scanf(&quot;%d&quot;, &amp;kase); while(kase--) init(), solve(); return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>后缀数组</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj 3581(后缀数组)]]></title>
    <url>%2Fpoj3581%2F</url>
    <content type="text"><![CDATA[poj 3581 因为第一个数比后面的大，所以将原串翻转后找出排第$i$位的后缀输出，符合$SA[i]&gt;=2$的最小$i$(后缀数组中的排列是字典序) 之后将之前已经处理的数据删掉，然后题目变为将剩下的数据分为两份翻转后字典序最小，那么我们设$S$为这个序列，$S_1, S_2, …, S_k, S_{k+1},…S_n$，其中$k$是分割点，处理后变为$S_k, S_{k-1}, …, S_1, S_n, S_{n-1},…,S_{k+1}$，我们发现这个序列是$S_n, S_{n-1}, …, S_1, S_n, S_{n-1},…,S_{1}$的子串，那么我们将翻转后的数列复制一份放在后面，然后找出排第$i$位的后缀输出，符合$SA[i]&gt;=1, SA[i]∈第一部分$的最小$i$输出。(后缀数组中的排列是字典序，设法构造一个串，使得欲求串的字典序能够求出) 输出剩余的数据，即可完成 ```c++#include#include#include#include#includeusing namespace std;#define ms(i, j) memeset(i, j, sizeof i) const int MAXN = 200000 + 5; int N, n, m, a[MAXN*2], SA[MAXN*2], tp[MAXN*2], tax[MAXN*2], rk[MAXN*2], pos[MAXN*2];int siz, inp[MAXN], ls[MAXN], sub_a[MAXN]; bool cmp(int *f, int i, int k) {return f[SA[i]]==f[SA[i-1]]&amp;&amp;f[SA[i]+k]==f[SA[i-1]+k];}void build_SA() { for (int i=0;i=0;i–) SA[–tax[rk[i]]] = i; int p; for (int k=1;k&lt;=n;k*=2) { p = 0; for (int i=n-k;i=k) tp[p++] = SA[i] - k; for (int i=0;i=0;i–) SA[–tax[rk[tp[i]]]] = tp[i]; swap(tp, rk), p = 0, rk[SA[0]] = 0; for (int i=1;i=n) break; m = p; }}void clear() {}void init() { //初始化 clear(); //输入 for (int i=0;i=0;i–) { pos[n] = i; a[n++] = ls[i]; } a[n++] = 0; build_SA(); for (int i=1;i=2) { las = pos[SA[i]]; for (int j=las;j&gt;=0;j–) printf(“%d\n”, inp[j]); break; } } //sec n = 0, m = siz + 1; int mid = 0, las2 = 0; for (int i=N-1;i&gt;las;i–) { pos[n] = i; a[n++] = ls[i]; } mid = n; for (int i=N-1;i&gt;las;i–) { pos[n] = i; a[n++] = ls[i]; } a[n++] = 0; build_SA(); for (int i=1;i]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>后缀数组</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj 2763(LCA+树状数组/树链剖分+线段树)]]></title>
    <url>%2Fpoj2763%2F</url>
    <content type="text"><![CDATA[poj 2763 LCA+树状数组/线段树。 首先本题大致一看就是一个LCA，但是本题有操作更改某边的权，这样会使得原本的far数组变化，不难发现，更改边权后影响该边下面所有点的答案。此时可以在LCA的DFS预处理时求出DFS序列(即时间戳)，找到每个点管辖的范围，修改边权相当于修改该边连接的两个点深度深的那个点所管辖的范围，此时修改可以用暴力，但是由于far数组与LCA本身查询无关，我们可以用数据结构进行维护far数组，树状数组/线段树都可以 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define FN2 &quot;poj2763&quot; using namespace std; const int MAXN = 100000 + 5, logs = 17; int n, q, s, wi[MAXN], deep[MAXN], pre[MAXN][logs+1], far[MAXN], ll[MAXN], rr[MAXN], cnt, a[MAXN], b[MAXN], Sc[MAXN]; vector&lt;int&gt; G[MAXN]; //bit int lowbit(int x) { return x&amp;(-x); } void update(int x, int v) { for (int i=x;i&lt;=n;i+=lowbit(i)) { far[i] += v; } } int dist(int x) { int ret = 0; for (int i=x;i&gt;0;i-=lowbit(i)) { ret += far[i]; } return ret; } //lca void dfs(int x, int p) { ll[x] = ++cnt; Sc[x] = cnt; pre[x][0] = p; deep[x] = deep[p] + 1; for (int i=1;i&lt;=logs;i++) pre[x][i] = pre[pre[x][i-1]][i-1]; for (int i=0;i&lt;G[x].size();i++) { int u = G[x][i]; if (u!=p) { dfs(u, x); } } rr[x] = cnt; } int lca(int x, int y) { if (deep[x]&gt;deep[y]) swap(x, y); int del = deep[y] - deep[x]; for (int i=logs;i&gt;=0;i--) if ((del&gt;&gt;i) &amp;1) y = pre[y][i]; if (x==y) return x; for (int i=logs;i&gt;=0;i--) if (pre[x][i]!=pre[y][i]) x = pre[x][i], y = pre[y][i]; return pre[x][0]; } //pro void init() { cnt = 0; for (int i=1;i&lt;=n;i++) { G[i].clear(), deep[i] = far[i] = ll[i] = rr[i] = 0; for (int j=0;j&lt;=logs;j++) pre[i][j] = 0; } for (int i=1;i&lt;n;i++) { scanf(&quot;%d%d%d&quot;, &amp;a[i], &amp;b[i], &amp;wi[i]); G[a[i]].push_back(b[i]); G[b[i]].push_back(a[i]); } } void solve() { dfs(1, 0); int db4; for (int i=1;i&lt;n;i++) { int x = a[i], y = b[i]; if (deep[x]&gt;deep[y]) swap(x, y); update(ll[y], wi[i]); update(rr[y]+1, -wi[i]); } for (int i=1;i&lt;=q;i++) { int opr; scanf(&quot;%d&quot;, &amp;opr); if (opr==0) { int u; scanf(&quot;%d&quot;, &amp;u); printf(&quot;%d\n&quot;, dist(Sc[s])+dist(Sc[u])-2*dist(Sc[lca(s, u)]));//一定要找s,u在DFS序列中的位置 s = u; } else { int x, w; scanf(&quot;%d%d&quot;, &amp;x, &amp;w); int y = (deep[a[x]]&gt;deep[b[x]]) ? a[x] : b[x]; update(ll[y], w-wi[x]); update(rr[y]+1, wi[x]-w); wi[x] += w-wi[x];//边权点权分清楚 } } } int main() { #ifndef ONLINE_JUDGE freopen(FN2&quot;.in&quot;,&quot;r&quot;,stdin); freopen(FN2&quot;.out&quot;,&quot;w&quot;,stdout); #endif while (scanf(&quot;%d%d%d&quot;, &amp;n, &amp;q, &amp;s)==3) { init(); solve(); } return 0; } 树链剖分+线段树也可以。(此题卡vector，这迫使我试了一次链式前向星) #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #define fo(i, j, k) for (i=(j);i&lt;=(k);i++) #define fd(i, k, j) for (i=(k);i&gt;=(j);i--) #define rd(a) scanf(&quot;%d&quot;, &amp;a) #define rd2(a, b) scanf(&quot;%d%d&quot;, &amp;a, &amp;b) #define rd3(a, b, c) scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c) #define ms(i, j) memset(i, j, sizeof i) #define FN2 &quot;poj2763&quot; using namespace std; const int MAXN = 100001 + 5; struct data{int to, next;}e[MAXN*2]; int head[MAXN],cnt; int n, q, s, ai[MAXN], bi[MAXN], wi[MAXN]; int dep[MAXN], fa[MAXN], son[MAXN], siz[MAXN], p[MAXN], top[MAXN], pre; void ins(int u, int v) {cnt++, e[cnt].to = v, e[cnt].next = head[u],head[u] = cnt;} void dfs1(int u, int p) { int i; dep[u] = dep[p] + 1, fa[u] = p, siz[u] = 1; for (i=head[u];i!=-1;i=e[i].next) { int v = e[i].to; if (v!=p) { dfs1(v, u); siz[u] += siz[v]; if (son[u]==-1||siz[son[u]]&lt;siz[v]) son[u] = v; } } } void dfs2(int u, int chain) { int i; top[u] = chain, p[u] = ++pre; if (son[u]!=-1) { dfs2(son[u], chain); for (i=head[u];i!=-1;i=e[i].next) { int v = e[i].to; if (v!=fa[u]&amp;&amp;v!=son[u]) dfs2(v, v); } } } int sumv[MAXN*4]; void pushup(int o) { int lc = o*2, rc = o*2+1; sumv[o] = sumv[lc] + sumv[rc]; } void update(int o, int l, int r, int x, int y, int v) { int lc = o*2, rc = o*2+1, M = (l+r)/2; if (x&lt;=l&amp;&amp;r&lt;=y) { sumv[o] = v; return ; } if (x&lt;=M) update(lc, l, M, x, y, v); if (M&lt;y) update(rc, M+1, r, x, y, v); pushup(o); } int query(int o, int l, int r, int x, int y) { int lc = o*2, rc = o*2+1, M = (l+r)/2, ret = 0; if (x&lt;=l&amp;&amp;r&lt;=y) { return sumv[o]; } if (x&lt;=M) ret += query(lc, l, M, x, y); if (M&lt;y) ret += query(rc, M+1, r, x, y); return ret; } int findSUM(int u, int v) { int f1 = top[u], f2 = top[v], ret = 0; while (f1!=f2) { if (dep[f1]&lt;dep[f2]) swap(f1, f2), swap(u, v); ret += query(1,1,n,p[f1],p[u]); u = fa[f1]; f1 = top[u]; } if (dep[u]&lt;dep[v]) swap(u, v); return ret + query(1,1,n,p[v]+1,p[u]); } void init() { int i; pre = 0; fo (i, 1, n) dep[i] = fa[i] = siz[i] = p[i] = top[i] = 0, son[i] = -1, head[i] = e[i].next = -1; fo (i, 1, n*4) sumv[i] = 0; fo (i, 1, n-1) { rd3(ai[i], bi[i], wi[i]); ins(ai[i], bi[i]), ins(bi[i], ai[i]); } dfs1(1, 0), dfs2(1, 1); fo (i, 1, n-1) { int a1 = ai[i], b1 = bi[i]; if (dep[a1]&gt;dep[b1]) update(1, 1, n, p[a1], p[a1], wi[i]); if (dep[a1]&lt;dep[b1]) update(1, 1, n, p[b1], p[b1], wi[i]); } } void solve() { int i; fo (i, 1, q) { int opt; rd(opt); if (opt==0) { int u; rd(u); printf(&quot;%d\n&quot;, findSUM(u, s)); s = u; } else { int u, w; rd2(u, w); int a1 = ai[u], b1 = bi[u]; if (dep[a1]&gt;dep[b1]) update(1, 1, n, p[a1], p[a1], w); if (dep[a1]&lt;dep[b1]) update(1, 1, n, p[b1], p[b1], w); } } } int main() { #ifndef ONLINE_JUDGE freopen(FN2&quot;.in&quot;,&quot;r&quot;,stdin);freopen(FN2&quot;.out&quot;,&quot;w&quot;,stdout); #endif while (rd3(n, q, s)==3) init(), solve(); return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>树状数组</tag>
        <tag>倍增</tag>
        <tag>树链剖分</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj 1006(中国剩余定理)]]></title>
    <url>%2Fpoj1006%2F</url>
    <content type="text"><![CDATA[poj 1006裸的中国剩余定理，注意一下负数的情况即可 #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #define ms(i,j) memset(i,j, sizeof i); #define ll long long using namespace std; int p, e, i, d; int a[4],m[4]; void e_gcd(int a, int b, int &amp;x, int &amp;y) { if (b==0) { x=1; y=0; return ; } e_gcd(b,a%b,x,y); int t = x; x = y; y = t-y*a/b; } int crt(int n) { int ans = 0; int M = 1; for (int i=1;i&lt;=n;i++) M*=m[i]; for (int i=1;i&lt;=n;i++) { int Mi = M/m[i]; int x,y; e_gcd(Mi, m[i], x, y); ans = (ans + Mi*a[i]*x)%M; } return (ans+M)%M; } int main() { int kase = 0; m[1] = 23;m[2] = 28;m[3] = 33; while (scanf(&quot;%d%d%d%d&quot;, &amp;p, &amp;e, &amp;i, &amp;d)==4) { if(p == -1 &amp;&amp; e == -1 &amp;&amp; i == -1 &amp;&amp; d == -1) break; a[1] = p; a[2] = e; a[3] = i; int ans = crt(3); ans -= d; if (ans&lt;=0) ans += 21252; printf(&quot;Case %d: the next triple peak occurs in %d days.\n&quot;, ++kase, ans); } return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>中国剩余定理</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj 3648(2-SAT)]]></title>
    <url>%2Fpoj3648%2F</url>
    <content type="text"><![CDATA[poj 36481、注意2-SAT的定义(例如此题定义坐不坐新郎这边比坐不坐新娘这边更好解题)2、取了和题目不同定义时，记得反一下 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; using namespace std; #define ms(i,j) memset(i, j, sizeof i); const int MAXN = 200 + 5; struct TwoSAT { vector&lt;int&gt; G[MAXN*2]; int S[MAXN*2]; bool mark[MAXN*2]; int n, c; void init(int n) { this-&gt;n = n; for (int i=0;i&lt;=2*n;i++) { G[i].clear(); mark[i] = false; } } void ins(int u, int v) { G[u].push_back(v); } int dfs(int x) { if (mark[x^1]) return false; if (mark[x]) return true; mark[x] = true; S[++c] = x; for (int i=0;i&lt;G[x].size();i++) { if (!dfs(G[x][i])) return false; } return true; } int solve() { for (int i=0;i&lt;2*n;i+=2) if (!mark[i]&amp;&amp;!mark[i+1]) { c = 0; if (!dfs(i)) { while (c&gt;0) mark[S[c--]] = false; if (!dfs(i+1)) return false; } } return true; } }ts; int n, m; void init()//2*x is h, 2*x+1 is w { ts.init(n); ts.ins(1, 0);//the groom must be in the line for (int i=1;i&lt;=m;i++) { int a,b; char as, bs; scanf(&quot;%d%c%d%c&quot;, &amp;a, &amp;as, &amp;b, &amp;bs); if (as==&#39;h&#39;&amp;&amp;bs==&#39;w&#39;) { ts.ins(2*a, 2*b);//ha-&gt;hb ts.ins(2*b+1, 2*a+1);//wb-&gt;wa } if (as==&#39;w&#39;&amp;&amp;bs==&#39;h&#39;) { ts.ins(2*b, 2*a);//hb-&gt;ha ts.ins(2*a+1, 2*b+1);//wa-&gt;wb } if (as==&#39;h&#39;&amp;&amp;bs==&#39;h&#39;) { ts.ins(2*a, 2*b+1);//ha-&gt;wb ts.ins(2*b, 2*a+1);//hb-&gt;wa } if (as==&#39;w&#39;&amp;&amp;bs==&#39;w&#39;) { ts.ins(2*a+1, 2*b);//wa-&gt;hb ts.ins(2*b+1, 2*a);//wb-&gt;ha } } } void solve() { bool flag = false; if (ts.solve()) { for (int i=1;i&lt;ts.n;i++) { if (ts.mark[i*2]) { if (flag) printf(&quot; &quot;); printf(&quot;%dw&quot;, i), flag = true; } if (ts.mark[i*2+1]) { if (flag) printf(&quot; &quot;); printf(&quot;%dh&quot;, i), flag = true; } } printf(&quot;\n&quot;); } else printf(&quot;bad luck\n&quot;); } int main() { while (scanf(&quot;%d%d&quot;, &amp;n, &amp;m)==2&amp;&amp;n&amp;&amp;m) { init(); solve(); } return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>2-SAT</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj 3678(2-SAT)]]></title>
    <url>%2Fpoj3678%2F</url>
    <content type="text"><![CDATA[poj 3678 1、加边a-&gt;b 代表选了a的话b也得选例如 x-&gt;x` 表示选了x就必须选x` ，所以这个值必为x2、最好2*a表示True，2*a+1表示FLASE #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; using namespace std; #define ms(i,j) memset(i, j, sizeof i); const int MAXN = 1000 + 5; struct TwoSAT { vector&lt;int&gt; G[MAXN*2]; int mark[MAXN*2]; int S[MAXN*2]; int n,c; void init(int n) { this-&gt;n = n; for (int i=0;i&lt;=2*n;i++) { mark[i] = false; G[i].clear(); } } void ins(int u, int v) { G[u].push_back(v); } int dfs(int x) { if (mark[x^1]) return false; if (mark[x]) return true; mark[x] = true; S[++c] = x; for (int i=0;i&lt;G[x].size();i++) { if (!dfs(G[x][i])) return false; } return true; } int solve() { for (int i=0;i&lt;2*n;i+=2) if (!mark[i]&amp;&amp;!mark[i+1]) { c = 0; if (!dfs(i)) { while (c&gt;0) mark[S[c--]] = false; if (!dfs(i+1)) return false; } } return true; } }ts; int n,m; void init()//x*2 is TRUE, x*2+1 is FALSE { ts.init(n); for (int i=1;i&lt;=m;i++) { int a,b,c,op = -1; char s[5]; scanf(&quot;%d%d%d%s&quot;, &amp;a, &amp;b, &amp;c, s); //op = 0 is OR, op = 1 is AND if (s[0]==&#39;A&#39;) op = 1; else if (s[0]==&#39;O&#39;) op = 0; if (op==1)//AND { if (c)//1 { ts.ins(a*2+1, a*2); ts.ins(b*2+1, b*2); } else//0 { ts.ins(b*2, a*2+1); ts.ins(a*2, b*2+1); } } else if (op==0) //OR { if (c)//1 { ts.ins(b*2+1, a*2); ts.ins(a*2+1, b*2); } else//0 { ts.ins(a*2, a*2+1); ts.ins(b*2, b*2+1); } } else if (op==-1) { if (c)//1 { ts.ins(a*2, b*2+1); ts.ins(a*2+1, b*2); ts.ins(b*2, a*2+1); ts.ins(b*2+1, a*2); } else//0 { ts.ins(a*2, b*2); ts.ins(a*2+1, b*2+1); ts.ins(b*2, a*2); ts.ins(b*2+1, a*2+1); } } } } void solve() { if (ts.solve()) printf(&quot;YES\n&quot;); else printf(&quot;NO\n&quot;); } int main() { while (scanf(&quot;%d%d&quot;, &amp;n, &amp;m)==2) { init(); solve(); } return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>2-SAT</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj 3237(树链剖分+线段树)]]></title>
    <url>%2Fpoj3237%2F</url>
    <content type="text"><![CDATA[poj 3237 树剖+线段树。刚开始想用记录该区域被NEGATE了几次，结果发现不可行，翻别人博客发现了原来维护最大值$maxv$和最小值$minv$，NEGATE就是$maxv=-minv, minv=maxv$, 正确性显然。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #define fo(i, j, k) for (i=(j);i&lt;=(k);i++) #define fd(i, k, j) for (i=(k);i&gt;=(j);i--) #define fe(i, u) for (i=head[u];i!=-1;i=e[i].next) #define rd(a) scanf(&quot;%d&quot;, &amp;a) #define rd2(a, b) scanf(&quot;%d%d&quot;, &amp;a, &amp;b) #define rd3(a, b, c) scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c) #define ms(i, j) memset(i, j, sizeof i) #define FN2 &quot;poj3237&quot; using namespace std; const int MAXN = 10000 + 5, INF = 200000000; struct data{int to, next;}e[MAXN*2]; int n, wi[MAXN], ai[MAXN], bi[MAXN], head[MAXN], cnt; int p[MAXN], top[MAXN], son[MAXN], dep[MAXN], fa[MAXN], siz[MAXN]; int pre; void dfs1(int u, int pa) { int i; dep[u] = dep[pa] + 1, fa[u] = pa, siz[u] = 1; fe (i, u) { int v = e[i].to; if (v!=pa) { dfs1(v, u); siz[u] += siz[v]; if (son[u]==-1||siz[son[u]]&lt;siz[v]) son[u] = v; } } } void dfs2(int u, int chain) { int i; p[u] = ++pre, top[u] = chain; if (son[u]!=-1) { dfs2(son[u], chain); fe (i, u) { int v = e[i].to; if (v!=fa[u]&amp;&amp;v!=son[u]) dfs2(v, v); } } } #define lc (o&lt;&lt;1) #define rc (o&lt;&lt;1|1) #define M ((l+r)&gt;&gt;1) int maxv[MAXN*4], minv[MAXN*4], lazy[MAXN*4]; void proc(int &amp;a, int &amp;b) {int t = a; a = -b, b = -t;} void pushup(int o) { maxv[o] = max(maxv[lc], maxv[rc]); minv[o] = min(minv[lc], minv[rc]); } void pushdown(int o, int l, int r) { if (l==r) return ; if (lazy[o]) { lazy[lc] ^= 1, lazy[rc] ^= 1; proc(maxv[lc], minv[lc]), proc(maxv[rc], minv[rc]); lazy[o] = 0; } } void update(int o, int l, int r, int p, int v) { pushdown(o, l, r); if (l==r) { maxv[o] = minv[o] = v; return ; } if (p&lt;=M) update(lc,l,M,p,v); else if (M&lt;p) update(rc,M+1,r,p,v); pushup(o); } void ngt(int o, int l, int r, int x, int y) { pushdown(o, l, r); if (x&lt;=l&amp;&amp;r&lt;=y) { proc(maxv[o], minv[o]); lazy[o] = 1; return ; } if (x&lt;=M) ngt(lc,l,M,x,y); if (M&lt;y) ngt(rc,M+1,r,x,y); pushup(o); } int query(int o, int l, int r, int x, int y) { pushdown(o, l, r); int ret = -INF; if (x&lt;=l&amp;&amp;r&lt;=y) return maxv[o]; if (x&lt;=M) ret=max(ret,query(lc,l,M,x,y)); if (M&lt;y) ret=max(ret,query(rc,M+1,r,x,y)); return ret; } void tongt(int u, int v) { int f1 = top[u], f2 = top[v]; while (f1!=f2) { if (dep[f1]&lt;dep[f2]) swap(f1, f2), swap(u, v); ngt(1,1,n,p[f1], p[u]); u = fa[f1], f1 = top[u]; } if (dep[u]&lt;dep[v]) swap(u, v); ngt(1,1,n,p[v]+1, p[u]); } int toget(int u, int v) { int f1 = top[u], f2 = top[v], ret = -INF; while (f1!=f2) { if (dep[f1]&lt;dep[f2]) swap(f1, f2), swap(u, v); ret = max(ret, query(1,1,n,p[f1], p[u])); u = fa[f1], f1 = top[u]; } if (dep[u]&lt;dep[v]) swap(u, v); return max(ret, query(1,1,n,p[v]+1, p[u])); } void ins(int u, int v) { cnt++; e[cnt].to = v, e[cnt].next = head[u], head[u] = cnt; cnt++; e[cnt].to = u, e[cnt].next = head[v], head[v] = cnt; } void init() { int i; rd(n); cnt = pre = 0; fo (i, 1, n) head[i] = -1, p[i] = 0, top[i] = 0, son[i] = -1, dep[i] = 0, fa[i] = 0, siz[i] = 0; fo (i, 1, n*2) e[i].to = 0, e[i].next = -1; fo (i, 1, n*4) maxv[i] = -INF, minv[i] = INF, lazy[i] = 0; fo (i, 1, n-1) { rd3(ai[i], bi[i], wi[i]); ins(ai[i],bi[i]); } } void solve() { int i; dfs1(1, 0), dfs2(1, 1); fo (i, 1, n-1) { int a1 = ai[i], b1 = bi[i]; if (dep[a1]&gt;dep[b1]) update(1,1,n, p[a1], wi[i]); if (dep[a1]&lt;dep[b1]) update(1,1,n, p[b1], wi[i]); } char ch[10]; while (1) { scanf(&quot;%s&quot;, ch); if (ch[0]==&#39;D&#39;) break; if (ch[0]==&#39;C&#39;) { int x, v; rd2(x, v); int a1 = ai[x], b1 = bi[x]; if (dep[a1]&gt;dep[b1]) update(1,1,n, p[a1], v); if (dep[a1]&lt;dep[b1]) update(1,1,n, p[b1], v); } if (ch[0]==&#39;N&#39;) { int u, v; rd2(u, v); tongt(u, v); } if (ch[0]==&#39;Q&#39;) { int u, v; rd2(u, v); printf(&quot;%d\n&quot;, toget(u, v)); } } } int main() { #ifndef ONLINE_JUDGE freopen(FN2&quot;.in&quot;,&quot;r&quot;,stdin);freopen(FN2&quot;.out&quot;,&quot;w&quot;,stdout); #endif int t; rd(t); while (t--) init(), solve(); return 0; } 一个很弱的数据： input: 1 12 1 2 6 2 3 7 3 4 1 3 5 -4 5 6 -3 1 7 2 7 8 3 7 9 6 7 10 7 9 11 -1 11 12 4 QUERY 6 12 CHANGE 2 10 QUERY 6 12 NEGATE 5 2 QUERY 6 12 CHANGE 4 10 QUERY 6 12 NEGATE 8 10 QUERY 6 12 DONE output: 7 10 6 10 10]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj 3683(2-SAT)]]></title>
    <url>%2Fpoj3683%2F</url>
    <content type="text"><![CDATA[poj 36831、区间重合的判定2、想要输出数最少两位可以用”%.2d”输出例如数是8，但想输出08，就可以用，如果是14，则还是输出14 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; using namespace std; #define ms(i,j) memset(i, j, sizeof i); const int MAXN = 1000 + 5; struct inv { int l, r, time; }in[MAXN]; struct TwoSAT { vector&lt;int&gt; G[MAXN*2]; int S[MAXN*2]; bool mark[MAXN*2]; int n, c; void init(int n) { this-&gt;n = n; for (int i=0;i&lt;=n*2;i++) { G[i].clear(); mark[i] = false; } } void ins(int u, int v) { G[u].push_back(v); } int dfs(int x) { if (mark[x^1]) return false; if (mark[x]) return true; mark[x] = true; S[++c] = x; for (int i=0;i&lt;G[x].size();i++) { if (!dfs(G[x][i])) return false; } return true; } int solve() { for (int i=0;i&lt;2*n;i+=2) if (!mark[i]&amp;&amp;!mark[i+1]) { c = 0; if (!dfs(i)) { while (c&gt;0) mark[S[c--]] = false; if (!dfs(i+1)) return false; } } return true; } }ts; int n; int fight(int x1, int y1, int x2, int y2) { if (x2&gt;=x1&amp;&amp;x2&lt;y1) return true; if (y2&lt;=y1&amp;&amp;x1&lt;y2) return true; return false; } void init() { for (int i=0;i&lt;n;i++) { int h1, h2, m1, m2; scanf(&quot;%d:%d %d:%d %d&quot;, &amp;h1, &amp;m1, &amp;h2, &amp;m2, &amp;in[i].time); in[i].l = h1*60+m1; in[i].r = h2*60+m2; } } void solve()//2*x is left, 2*x+1 is right(~) { ts.init(n); for (int i=0;i&lt;n;i++) for (int j=0;j&lt;n;j++) if (i!=j) { int &amp;x1 = in[i].l, &amp;y1 = in[i].r, &amp;x2 = in[j].l, &amp;y2 = in[j].r, &amp;t1 = in[i].time, &amp;t2 = in[j].time; if (fight(x1, x1+t1, x2, x2+t2))//l l { ts.ins(2*i, 2*j+1); ts.ins(2*j, 2*i+1); } if (fight(x1, x1+t1, y2-t2, y2))//l r { ts.ins(2*i, 2*j); ts.ins(2*j+1, 2*i+1); } if (fight(y1-t1, y1, y2-t2, y2))//r r { ts.ins(2*i+1, 2*j); ts.ins(2*j+1, 2*i); } if (fight(y1-t1, y1, x2, x2+t2))//r l { ts.ins(2*j, 2*i); ts.ins(2*i+1, 2*j+1); } } if (ts.solve()) { printf(&quot;YES\n&quot;); for (int i=0;i&lt;n;i++) { if (ts.mark[i*2])//l { int tot = in[i].l + in[i].time; int h1 = in[i].l / 60, m1 = in[i].l % 60; int h2 = tot / 60, m2 = tot % 60; printf(&quot;%.2d:%.2d %.2d:%.2d\n&quot;, h1, m1, h2, m2); } if (ts.mark[i*2+1])//r { int tot = in[i].r - in[i].time; int h1 = in[i].r / 60, m1 = in[i].r % 60; int h2 = tot / 60, m2 = tot % 60; printf(&quot;%.2d:%.2d %.2d:%.2d\n&quot;, h2, m2, h1, m1); } } } else printf(&quot;NO\n&quot;); } int main() { while (scanf(&quot;%d&quot;, &amp;n)==1) { init(); solve(); } return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>2-SAT</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj 2406(KMP)]]></title>
    <url>%2Fpoj2406%2F</url>
    <content type="text"><![CDATA[poj 2406可以知道，在一个字符串里的最短周期是$ms=n-f[n]​$, 其中$f​$是kmp中的失配函数。如果$ms|n$, 那么输出$n/ms$, 否则输出$1$. #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #define ms(i,j) memset(i,j, sizeof i); using namespace std; const int MAXN = 1000000 + 5; int n; char s[MAXN]; int f[MAXN]; int main() { while (scanf(&quot;%s&quot;, s)&amp;&amp;(s[0]!=&#39;.&#39;)) { n = strlen(s); f[0] = f[1] = 0; for (int i=1;i&lt;n;i++) { int j = f[i]; while (j &amp;&amp; s[i]!=s[j]) j = f[j]; f[i+1] = (s[i]==s[j]) ? (j+1) : (0); } int ans = n-f[n]; if (n%ans==0) ans = n/ans; else ans = 1; printf(&quot;%d\n&quot;, ans); } return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>KMP</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj 3728(LCA)]]></title>
    <url>%2Fpoj3728%2F</url>
    <content type="text"><![CDATA[poj 3728 维护6个数组 pre[i][j] i的第2^j个祖先 deep[i] i的深度 up[i][j] i到i的第2^j个祖先的最优解 down[i][j] i的第2^j个祖先到i的最优解 dmax[i][j] i到i的第2^j个祖先路径上的最大值 dmin[i][j] i到i的第2^j个祖先路径上的最小值然后可以通过倍增维护以上数组，期中包含一些dp思想，此题非常好，作为一个LCA的跳板 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cstdlib&gt; #define ms(i, j) memset(i, j, sizeof i) #define FN2 &quot;poj3728&quot; using namespace std; const int ZINF2 = 100000000, MAXN = 50000 + 5, logs = 16; int n, wi[MAXN], pre[MAXN][logs+1], deep[MAXN], up[MAXN][logs+1], down[MAXN][logs+1], dmax[MAXN][logs+1], dmin[MAXN][logs+1]; /*维护6个数组 pre[i][j] i的第2^j个祖先 deep[i] i的深度 up[i][j] i到i的第2^j个祖先的最优解 down[i][j] i的第2^j个祖先到i的最优解 dmax[i][j] i到i的第2^j个祖先路径上的最大值 dmin[i][j] i到i的第2^j个祖先路径上的最小值 */ vector&lt;int&gt; G[MAXN]; void dfs(int x, int p) { pre[x][0] = p; deep[x] = deep[p] + 1; dmax[x][0] = max(wi[x], wi[p]); dmin[x][0] = min(wi[x], wi[p]); up[x][0] = max(0, wi[p]-wi[x]); down[x][0] = max(0, wi[x]-wi[p]); for (int i=1;i&lt;=logs;i++) { int pa = pre[x][i-1]; pre[x][i] = pre[pa][i-1]; dmax[x][i] = max(dmax[pa][i-1], dmax[x][i-1]); dmin[x][i] = min(dmin[pa][i-1], dmin[x][i-1]); up[x][i] = max(up[pa][i-1], up[x][i-1]);//合并 up[x][i] = max(up[x][i], dmax[pa][i-1]-dmin[x][i-1]); down[x][i] = max(down[pa][i-1], down[x][i-1]);//合并 down[x][i] = max(down[x][i], dmax[x][i-1]-dmin[pa][i-1]); } for (int i=0;i&lt;G[x].size();i++) { int v = G[x][i]; if (p!=v) { dfs(v, x); } } } int lca(int a, int b) { if (deep[a]&gt;deep[b]) swap(a, b); for (int i=logs;i&gt;=0;i--) if (deep[pre[b][i]]&gt;=deep[a]) b = pre[b][i]; if (a==b) return a; for (int i=logs;i&gt;=0;i--) if (pre[a][i]!=pre[b][i]) a = pre[a][i], b = pre[b][i]; return pre[a][0]; } void climb(int x, int y, bool UP, int &amp;ans, int &amp;temp) { temp = wi[x]; int del = deep[x] - deep[y]; for (int i=logs;i&gt;=0;i--) { if ((del&gt;&gt;i) &amp; 1) { if (UP) { ans = max(ans, dmax[x][i] - temp);//有可能不在up里 temp = min(temp, dmin[x][i]); ans = max(ans, up[x][i]); } else { ans = max(ans, temp - dmin[x][i]); temp = max(temp, dmax[x][i]); ans = max(ans, down[x][i]); } x = pre[x][i]; } } } void init() { for (int i=1;i&lt;=n;i++) { deep[i] = 0; for (int j=0;j&lt;=logs;j++) pre[i][j] = 0; scanf(&quot;%d&quot;, &amp;wi[i]); } for (int i=1;i&lt;n;i++) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); G[x].push_back(y), G[y].push_back(x); } } void solve() { dfs(1, 0); int q; scanf(&quot;%d&quot; ,&amp;q); for (int i=1;i&lt;=q;i++) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); int px, py, ans = 0, lc = lca(x, y); climb(x, lc, 1, ans, px); climb(y, lc, 0, ans, py); printf(&quot;%d\n&quot;, max(ans, py - px)); } } int main() { #ifndef ONLINE_JUDGE freopen(FN2&quot;.in&quot;,&quot;r&quot;,stdin); freopen(FN2&quot;.out&quot;,&quot;w&quot;,stdout); #endif while (scanf(&quot;%d&quot;, &amp;n)==1) { init(); solve(); } return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>倍增</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj 2407(欧拉函数)]]></title>
    <url>%2Fpoj2407%2F</url>
    <content type="text"><![CDATA[poj 2407简单的求$\varphi(n)$，复习了一下模板 #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #define ms(i,j) memset(i,j, sizeof i); using namespace std; int phi(int n) { int m = sqrt(n+0.5); int ans = n; for (int i=2;i&lt;=m;i++) if (n%i==0) { ans = ans/i*(i-1); while (n%i==0) n /= i; } if (n&gt;1) ans = ans/n*(n-1); return ans; } int main() { int n; while (scanf(&quot;%d&quot;, &amp;n)==1 &amp;&amp; n) { printf(&quot;%d\n&quot;, phi(n)); } return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>欧拉函数</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj 2299(权值线段树)]]></title>
    <url>%2Fpoj2299%2F</url>
    <content type="text"><![CDATA[poj 2299注意开long long权值线段树就是线段树每个节点存每个权值出现的次数，本题求逆序对应该算一个比较简单的权值线段树，注意离散化 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; using namespace std; #define ms(i, j) memeset(i, j, sizeof i) #define LL long long const int MAXN = 500000 + 5; int n; int a[MAXN], sa[MAXN], siz; int sumv[MAXN * 4]; #define M ((l+r)&gt;&gt;1) #define lc o*2 #define rc o*2+1 void pushup(int o) { sumv[o] = sumv[lc] + sumv[rc]; } void update(int o, int l, int r, int p) { if (l==r) { sumv[o]++; return ; } if (p&lt;=M) update(lc,l,M,p); else if (M&lt;p) update(rc,M+1,r,p); pushup(o); } int query(int o, int l, int r, int x, int y) { int ret = 0; if (x&lt;=l&amp;&amp;r&lt;=y) { return sumv[o]; } if (x&lt;=M) ret += query(lc, l, M, x, y); if (M&lt;y) ret += query(rc, M+1, r, x, y); return ret; } void clear() { for (int i=0;i&lt;=n*4;i++) { sumv[i] = 0; } } void init() { clear(); for (int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;, &amp;a[i]), sa[i] = a[i]; sort(sa+1, sa+1+n), siz = unique(sa+1, sa+1+n) - sa; for (int i=1;i&lt;=n;i++) { a[i] = lower_bound(sa+1, sa+siz, a[i]) - sa; } } void solve() { LL ans = 0; for (int i=1;i&lt;=n;i++) { ans += query(1,1,n,a[i],n); update(1,1,n,a[i]); } printf(&quot;%lld\n&quot;, ans); } int main() { while (scanf(&quot;%d&quot;, &amp;n)==1&amp;&amp;n) init(), solve(); return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>权值线段树</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj 2342(树形DP)]]></title>
    <url>%2Fpoj2342%2F</url>
    <content type="text"><![CDATA[poj 2342树形DP基础题，具体看注释。设状态$f[i][0]$为$i$不来，$f[i][1]$为$i$要来$f[r][1] += f[i][0]$ r要来，i为r的下属$f[r][0] += max(f[i][0], f[i][1])$ /不来，i为r的下属 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cstdlib&gt; #define ms(i,j) memset(i, j, sizeof(i)); using namespace std; const int maxn = 6005; int f[maxn][2]; bool visit[maxn]; int father[maxn]; int n; void dfs(int r) { visit[r] = true; for (int i=1;i&lt;=n;i++) { if (!visit[i]&amp;&amp;father[i]==r)//没有访问过的点并且i是r的下属 { dfs(i);//向叶子结点DFS，在叶子节点DP f[r][1] += f[i][0]; f[r][0] += max(f[i][0], f[i][1]); } } } int main() { while (scanf(&quot;%d&quot;, &amp;n)==1) { ms(f,0); ms(visit, false); ms(father, 0); for (int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;, &amp;f[i][1]); int root = 0;//找最大权利的监督者(树根) int l,k; while (scanf(&quot;%d%d&quot;, &amp;l, &amp;k)==2&amp;&amp;(l||k)) { father[l] = k;//k监督l if (root==l) { root = k; } } dfs(root); printf(&quot;%d\n&quot;, max(f[root][0], f[root][1])); } return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>树形DP</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj 2296(二分+2-SAT)]]></title>
    <url>%2Fpoj2296%2F</url>
    <content type="text"><![CDATA[poj 2296教训：1、注意复杂情况的分类讨论2、$a&lt;x&lt;b$这样的不要写错了 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; using namespace std; #define ms(i,j) memset(i, j, sizeof i); const int MAXM = 1000 + 5; struct TwoSAT { vector&lt;int&gt; G[MAXM*2]; int S[MAXM*2]; bool mark[MAXM*2]; int n, c; void init(int n) { this-&gt;n = n; for (int i=0;i&lt;=2*n;i++) { G[i].clear(); mark[i] = false; } } void ins(int u, int v) { G[u].push_back(v); } int dfs(int x) { if (mark[x^1]) return false; if (mark[x]) return true; mark[x] = true; S[++c] = x; for (int i=0;i&lt;G[x].size();i++) { if (!dfs(G[x][i])) return false; } return true; } int solve() { for (int i=0;i&lt;2*n;i+=2) if (!mark[i]&amp;&amp;!mark[i+1]) { c = 0; if (!dfs(i)) { while (c&gt;0) mark[S[c--]] = false; if (!dfs(i+1)) return false; } } return true; } }ts; int m, xi[MAXM], yi[MAXM]; int abss(int x) {return (x&lt;0) ? (-x) : (x);} void init() { scanf(&quot;%d&quot;, &amp;m); for (int i=0;i&lt;m;i++) { scanf(&quot;%d%d&quot;, &amp;xi[i], &amp;yi[i]); } } void solve() { int l = 0, r = 80000, ans = 0; while (l &lt; r) { int mid = (l+r)/2; ts.init(m); for (int i=0;i&lt;m;i++) for (int j=i+1;j&lt;m;j++) { int ax = abss(xi[i]-xi[j]); int ay = abss(yi[i]-yi[j]); if (ax&lt;mid)//2*i is up, 2*i+1 is down { if (ay&lt;mid) { if (yi[i]==yi[j])//特判差值为0的情况 { ts.ins(2*i+1, 2*j); ts.ins(2*j+1, 2*i); ts.ins(2*i, 2*j+1); ts.ins(2*j, 2*i+1); } else if (yi[i]&gt;yi[j])//A是上面的点，B是下面的点 { ts.ins(2*i+1, 2*i); ts.ins(2*j, 2*j+1); } else//B是上面的点，A是下面的点 { ts.ins(2*j+1, 2*j); ts.ins(2*i, 2*i+1); } } else if (ay&lt;2*mid) { if (yi[i]&gt;yi[j])//A是上面的点，B是下面的点 { ts.ins(2*i+1, 2*j+1); ts.ins(2*j, 2*i); } else//B是上面的点，A是下面的点 { ts.ins(2*j+1, 2*i+1); ts.ins(2*i, 2*j); } } } } if (ts.solve()) { ans = mid; l = mid+1; }else r = mid; } printf(&quot;%d\n&quot;, ans); } int main() { int t; scanf(&quot;%d&quot;, &amp;t); while (t--) { init(); solve(); } return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>2-SAT</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj 2186/Bzoj 1051(Tarjan强连通分量)]]></title>
    <url>%2Fpoj2186%2F</url>
    <content type="text"><![CDATA[poj 2186Bzoj 1051这题求所有满足被所有点能够到达的节点，那么我们可以进行缩点，缩点之后得到一个有向DAG图，统计新图的出度，如果有一个强连通分量的出度是=0的，那么输出这个强连通分量的大小，如果有多个，输出0 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;stack&gt; #define ms(i ,j) memset(i, j, sizeof i) #define rd2(a, b) scanf(&quot;%d%d&quot;, &amp;a, &amp;b) #define rd3(a, b, c) scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c) #define FN2 &quot;poj2186&quot; using namespace std; const int MAXN = 10000 + 5; int n,m; vector&lt;int&gt; G[MAXN]; int cnt, scc_size[MAXN], scc_out[MAXN], scc_belong[MAXN]; int tb, dn[MAXN], low[MAXN], ex[MAXN]; stack&lt;int&gt; s; void tarjan(int u) { dn[u] = low[u] = ++tb; ex[u] = -1; s.push(u); for (int i=0;i&lt;G[u].size();i++) { int v = G[u][i]; if (ex[v]==0) { tarjan(v); low[u] = min(low[u], low[v]); } else if (ex[v]==-1) { low[u] = min(low[u], dn[v]); } } if (dn[u]==low[u]) { cnt++; int e; do { e = s.top(); s.pop(); scc_belong[e] = cnt; scc_size[cnt]++; ex[e] = 1; }while (e!=u); } } void rebuild() { for (int x=1;x&lt;=n;x++) { for (int i=0;i&lt;G[x].size();i++) { int v = G[x][i]; if (scc_belong[x]!=scc_belong[v]) { scc_out[scc_belong[x]]++; break; } } } } void init() { for (int i=1;i&lt;=m;i++) { int a,b; rd2(a, b); G[a].push_back(b); } cnt = tb = 0; ms(ex, 0); ms(scc_size, 0); ms(scc_out, 0); } void solve() { for (int i=1;i&lt;=n;i++) if (!dn[i]) tarjan(i); rebuild(); int tot = 0, ans = 0; for (int i=1;i&lt;=cnt;i++) if (scc_out[i]==0) { tot++; ans = scc_size[i]; if (tot&gt;=2) { ans = 0; break; } } printf(&quot;%d\n&quot;, ans); } int main() { while (rd2(n,m)==2) { init(); solve(); } fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>Tarjan</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj 1995(快速幂)]]></title>
    <url>%2Fpoj1995%2F</url>
    <content type="text"><![CDATA[poj 1995 根据题目公式$$(A_1^{B_1}+A_2^{B_2}+ … +A_h^{B_h})\mod M$$快速幂即可 #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #define ms(i,j) memset(i,j, sizeof i); using namespace std; #define ll long long int h; ll m; ll ans; ll poww(ll a, ll b) { ll ans = 1, base = a%m; while (b!=0) { if (b&amp;1!=0) { ans = (ans*base)%m; } base = (base*base)%m; b&gt;&gt;=1; } return ans; } int main() { int kase; scanf(&quot;%d&quot;, &amp;kase); while (kase--) { scanf(&quot;%lld%d&quot;, &amp;m, &amp;h); ans = 0; for (int i=1;i&lt;=h;i++) { ll a,b; scanf(&quot;%lld%lld&quot;, &amp;a, &amp;b); ans = (ans+poww(a,b))%m; } printf(&quot;%d\n&quot;, ans%m); } return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>快速幂</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bzoj 3531(树链剖分+动态开点线段树)]]></title>
    <url>%2Fbzoj3531%2F</url>
    <content type="text"><![CDATA[BZOJ 3531 树剖以后每个宗教建立一棵线段树，节点太多用传统方法开数组肯定不行，这里进行改进，使用了动态开点线段树，即需要这个点再开这个点。 知识点：1、树剖后的编号注意2、动态开点没有开到的点赋值不要赋-1而是赋值0，否则要很多细节处理 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define ll long long using namespace std; const int MAXN = 1e5 + 5, MAXTN = 10000000 + 5; vector&lt;int&gt; G[MAXN]; int n, q, wi[MAXN], ci[MAXN]; int top[MAXN], fa[MAXN], son[MAXN], siz[MAXN], p[MAXN], dep[MAXN], pre; int lt[MAXTN], rt[MAXTN], root[MAXN], nd; ll sumv[MAXTN], maxv[MAXTN]; //树剖部分 void dfs1(int u, int pa) { dep[u] = dep[pa] + 1, fa[u] = pa, siz[u] = 1; for (int i=0;i&lt;G[u].size();i++) { int v = G[u][i]; if (v!=pa) { dfs1(v, u); siz[u] += siz[v]; if (son[u]==-1||siz[v]&gt;siz[son[u]]) son[u] = v; } } } void dfs2(int u, int chain) { p[u] = ++pre, top[u] = chain; if (son[u]!=-1) { dfs2(son[u], chain); for (int i=0;i&lt;G[u].size();i++) { int v = G[u][i]; if (v!=fa[u]&amp;&amp;v!=son[u]) { dfs2(v, v); } } } } //线段树部分 #define M ((l+r)&gt;&gt;1) void pushup(int o) { sumv[o] = sumv[lt[o]] + sumv[rt[o]]; maxv[o] = max(maxv[lt[o]], maxv[rt[o]]); } void update(int o, int l, int r, int p, ll w) { if (l==r) { sumv[o] = maxv[o] = w; return ; } if (p&lt;=M) { if (!lt[o]) lt[o] = ++nd; update(lt[o], l, M, p, w); } else if (M&lt;p) { if (!rt[o]) rt[o] = ++nd; update(rt[o], M+1, r, p, w); } pushup(o); } ll queryMax(int o, int l, int r, int x, int y) { ll ret = 0; if (x&lt;=l&amp;&amp;r&lt;=y) { return maxv[o]; } if (x&lt;=M) { if (lt[o]) ret = max(ret, queryMax(lt[o], l, M, x, y)); } if (M&lt;y) { if (rt[o]) ret = max(ret, queryMax(rt[o], M+1, r, x, y)); } return ret; } ll querySum(int o, int l, int r, int x, int y) { ll ret = 0; if (x&lt;=l&amp;&amp;r&lt;=y) { return sumv[o]; } if (x&lt;=M) { if (lt[o]) ret += querySum(lt[o], l, M, x, y); } if (M&lt;y) { if (rt[o]) ret += querySum(rt[o], M+1, r, x, y); } return ret; } //树剖找值 ll findMax(int u, int v, int rt) { ll ret = 0;int f1 = top[u], f2 = top[v]; while (f1!=f2) { if (dep[f1]&lt;dep[f2]) swap(f1, f2), swap(u, v); ret = max(ret, queryMax(rt, 1, n, p[f1], p[u])); u = fa[f1]; f1 = top[u]; } if (dep[u]&lt;dep[v]) swap(u, v); return max(ret, queryMax(rt, 1, n, p[v], p[u])); } ll findSum(int u, int v, int rt) { ll ret = 0;int f1 = top[u], f2 = top[v]; while (f1!=f2) { if (dep[f1]&lt;dep[f2]) swap(f1, f2), swap(u, v); ret += querySum(rt, 1, n, p[f1], p[u]); u = fa[f1]; f1 = top[u]; } if (dep[u]&lt;dep[v]) swap(u, v); return ret + querySum(rt, 1, n, p[v], p[u]); } //主程序 void clear() { pre = nd = 0; ms(sumv, 0), ms(maxv, 0), ms(lt, 0), ms(rt, 0), ms(root, 0); for (int i=0;i&lt;=n;i++) { G[i].clear(); top[i] = fa[i] = siz[i] = p[i] = dep[i] = 0; son[i] = -1; } } void init() { clear(); for (int i=1;i&lt;=n;i++) scanf(&quot;%d%d&quot;, &amp;wi[i], &amp;ci[i]); for (int i=1;i&lt;n;i++) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); G[x].push_back(y), G[y].push_back(x); } } void solve() { dfs1(1, 0), dfs2(1, 1); for (int i=1;i&lt;=n;i++) { if (!root[ci[i]]) root[ci[i]] = ++nd; update(root[ci[i]], 1, n, p[i], wi[i]); } char ch[10]; for (int i=1;i&lt;=q;i++) { scanf(&quot;%s&quot;, ch); if (ch[0]==&#39;C&#39;) { if (ch[1]==&#39;C&#39;) {//CC int x, c; scanf(&quot;%d%d&quot;, &amp;x, &amp;c); update(root[ci[x]], 1, n, p[x], 0); ci[x] = c; update(root[c], 1, n, p[x], wi[x]); } else {//CW int x, w; scanf(&quot;%d%d&quot;, &amp;x, &amp;w); wi[x] = w; update(root[ci[x]], 1, n, p[x], w); } } else if (ch[0]==&#39;Q&#39;) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); if (ch[1]==&#39;S&#39;) {//QS printf(&quot;%lld\n&quot;, findSum(x,y,root[ci[x]])); } else {//QM printf(&quot;%lld\n&quot;, findMax(x,y,root[ci[x]])); } } } } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif while (scanf(&quot;%d%d&quot;, &amp;n, &amp;q)==2) init(), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>树链剖分</tag>
        <tag>动态开点线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj 3623(后缀数组)]]></title>
    <url>%2Fpoj3623%2F</url>
    <content type="text"><![CDATA[poj 2774 poj 3623字符串翻转后的和原串后的数组进行求后缀数组，然后之后两个指针$i，j$选择两端$rk$值最小的输出，注意格式 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define ll long long using namespace std; const int MAXN = 30000 * 2 + 5; int N, n, m, a[MAXN]; int SA[MAXN], rk[MAXN], tp[MAXN], tax[MAXN]; bool cmp(int *f, int i, int k) {return f[SA[i]]==f[SA[i-1]]&amp;&amp;f[SA[i]+k]==f[SA[i-1]+k];} void build() { for (int i=0;i&lt;m;i++) tax[i] = 0; for (int i=0;i&lt;n;i++) tax[rk[i]=a[i]]++; for (int i=1;i&lt;m;i++) tax[i] += tax[i-1]; for (int i=n-1;i&gt;=0;i--) SA[--tax[rk[i]]] = i; int p; for (int k=1;k&lt;=n;k*=2) { p = 0; for (int i=n-k;i&lt;n;i++) tp[p++] = i; for (int i=0;i&lt;n;i++) if (SA[i]&gt;=k) tp[p++] = SA[i] - k; for (int i=0;i&lt;m;i++) tax[i] = 0; for (int i=0;i&lt;n;i++) tax[rk[tp[i]]]++; for (int i=1;i&lt;m;i++) tax[i] += tax[i-1]; for (int i=n-1;i&gt;=0;i--) SA[--tax[rk[tp[i]]]] = tp[i]; swap(tp, rk), p = 0, rk[SA[0]] = 0; for (int i=1;i&lt;n;i++) rk[SA[i]] = cmp(tp, i, k) ? p : ++p; if (++p&gt;=n) break; m = p; } } void init() { char ch[10]; n = N; for (int i=0;i&lt;N;i++) { scanf(&quot;%s&quot;, ch); a[i] = ch[0]; } a[n++] = &#39;$&#39;; for (int i=N-1;i&gt;=0;i--) { a[n++] = a[i]; } a[n++] = 0; m = 128; } void solve() { build(); int i = 0, j = N+1, tot = 0; do { if (rk[i]&lt;rk[j]) putchar(a[i]), i++, tot++; else putchar(a[j]), j++, tot++; if (tot%80==0) printf(&quot;\n&quot;); } while (tot&lt;N); printf(&quot;\n&quot;); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif while (scanf(&quot;%d&quot;, &amp;N)==1&amp;&amp;N) init(), solve(); return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>后缀数组</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spoj 694(后缀数组)]]></title>
    <url>%2Fspoj694%2F</url>
    <content type="text"><![CDATA[spoj 694 给出一个字符串，求字符串中不相同的子串个数。 我们可以知道，字符串中的每个子串都是某个后缀的前缀，于是题目转化为求不相同的后缀的前缀问题。对于每一个$SA[k]$开始的后缀，将会增加$n-SA[k]+1$个后缀，而其中$height[k]$个是和前面的字符串的前缀是相同的。所以答案就是所有$n-SA[k]+1-height[k]$的总和 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #define ms(i, j) memset(i, j, sizeof i) #define FN2 &quot;spoj694&quot; using namespace std; const int MAXN = 1000 + 5; char s[MAXN]; int n, m, a[MAXN], tp[MAXN], rk[MAXN], SA[MAXN], tax[MAXN], height[MAXN]; bool cmp(int *f, int i, int k) {return f[SA[i]]==f[SA[i-1]]&amp;&amp;f[SA[i]+k]==f[SA[i-1]+k];} void build() { for (int i=0;i&lt;m;i++) tax[i] = 0; for (int i=0;i&lt;n;i++) tax[rk[i]=a[i]]++; for (int i=1;i&lt;m;i++) tax[i] += tax[i-1]; for (int i=n-1;i&gt;=0;i--) SA[--tax[rk[i]]] = i; int p; for (int k=1;k&lt;=n;k*=2) { p = 0; for (int i=n-k;i&lt;n;i++) tp[p++] = i; for (int i=0;i&lt;n;i++) if (SA[i]&gt;=k) tp[p++] = SA[i]-k; for (int i=0;i&lt;m;i++) tax[i] = 0; for (int i=0;i&lt;n;i++) tax[rk[tp[i]]]++; for (int i=1;i&lt;m;i++) tax[i] += tax[i-1]; for (int i=n-1;i&gt;=0;i--) SA[--tax[rk[tp[i]]]] = tp[i]; swap(rk, tp), p = 0, rk[SA[0]] = 0; for (int i=1;i&lt;n;i++) rk[SA[i]] = cmp(tp, i, k) ? p : ++p; if (++p&gt;=n) break; m = p; } } void getH() { int k = 0; for (int i=0;i&lt;n;i++) { if (k) k--; int j = SA[rk[i]-1]; while (a[i+k]==a[j+k]) k++; height[rk[i]] = k; } } void init() { scanf(&quot;%s&quot;, s); n = strlen(s) + 1; for (int i=0;i&lt;n-1;i++) a[i] = s[i]; m = 128, a[n-1] = 0; } void solve() { build(), getH(); int ans = 0; for (int i=1;i&lt;n;i++) { ans += (n-1) - SA[i] - height[i]; } printf(&quot;%d\n&quot;, ans); } int main() { #ifndef ONLINE_JUDGE freopen(FN2&quot;.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout); #endif int kase; scanf(&quot;%d&quot;, &amp;kase); while(kase--) init(), solve(); return 0; }]]></content>
      <categories>
        <category>spoj</category>
      </categories>
      <tags>
        <tag>后缀数组</tag>
        <tag>spoj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj 3294(二分+后缀数组)]]></title>
    <url>%2Fpoj3294%2F</url>
    <content type="text"><![CDATA[poj 3294 和这题差不多，二分后后缀数组$height$判断，此题要输出所有的解，用个数组存下每个解在$a$中的起始位置即可。不同的是，此题判断时一定要找到一个$height[i]&lt;x$或者循环完毕$height$才能更新解，这样才能防止重复解出现。(ps: $vi$数组不要开大了，否则memset时容易TLE) #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define FN2 &quot;poj3296&quot; using namespace std; const int MAXN = 105 * 1005 + 5; char s[MAXN]; int ans,ba,bf[MAXN],mini,t,n,m,a[MAXN],tp[MAXN],SA[MAXN],rk[MAXN],tax[MAXN],height[MAXN],belong[MAXN]; bool cmp(int *f, int i, int k) {return f[SA[i]]==f[SA[i-1]]&amp;&amp;f[SA[i]+k]==f[SA[i-1]+k];} void build() { for (int i=0;i&lt;m;i++) tax[i] = 0; for (int i=0;i&lt;n;i++) tax[rk[i]=a[i]]++; for (int i=1;i&lt;m;i++) tax[i] += tax[i-1]; for (int i=n-1;i&gt;=0;i--) SA[--tax[rk[i]]] = i; int p; for (int k=1;k&lt;=n;k*=2) { p = 0; for (int i=n-k;i&lt;n;i++) tp[p++] = i; for (int i=0;i&lt;n;i++) if (SA[i]&gt;=k) tp[p++] = SA[i] - k; for (int i=0;i&lt;m;i++) tax[i] = 0; for (int i=0;i&lt;n;i++) tax[rk[tp[i]]]++; for (int i=1;i&lt;m;i++) tax[i] += tax[i-1]; for (int i=n-1;i&gt;=0;i--) SA[--tax[rk[tp[i]]]] = tp[i]; swap(rk, tp), p = 0, rk[SA[0]] = 0; for (int i=1;i&lt;n;i++) rk[SA[i]] = cmp(tp, i, k) ? p : ++p; if (++p&gt;=n) break; m = p; } } void getH() { int k = 0; for (int i=0;i&lt;n;i++) { if (k) k--; int j = SA[rk[i]-1]; while (a[i+k]==a[j+k]) k++; height[rk[i]] = k; } } void init() { n = 0, m = 200, mini = 200000000; for (int i=0;i&lt;t;i++) { scanf(&quot;%s&quot;, s); int l = strlen(s); mini = min(mini, l); for (int j=0;j&lt;l;j++) belong[n] = i, a[n++] = s[j]; belong[n] = 104; a[n++] = m++; } a[n-1] = 0, m+=5; } int vi[100 + 5]; bool check(int x) { int tot = 0, flag = false; ms(vi, false); for (int i=2;i&lt;n;i++) { if (height[i]&lt;x) { if (tot&gt;t/2) { flag = true; if (x&gt;ba) { ans = 0; ba = x; bf[ans] = SA[i-1]; ans++; } else if (x==ba) { bf[ans] = SA[i-1]; ans++; } } ms(vi, false); tot = 0; continue; } if (!vi[belong[SA[i]]]) vi[belong[SA[i]]] = true, ++tot; if (!vi[belong[SA[i-1]]]) vi[belong[SA[i-1]]] = true, ++tot; } if (tot&gt;t/2) { if (x&gt;ba) { ans = 0; ba = x; bf[ans] = SA[n-1]; ans++; } else if (x==ba) { bf[ans] = SA[n-1]; ans++; } return true; } return flag; } void solve() { build(), getH(); int l = 1, r = mini + 1; ba = 0, ms(bf, 0), ans = 0; while (l&lt;r) { int mid = (l+r)/2; if (check(mid)) { l = mid + 1; } else r = mid; } if (!ans) printf(&quot;?\n&quot;); else { for (int i=0;i&lt;ans;i++) { for (int j=bf[i];j&lt;bf[i]+ba;j++) { printf(&quot;%c&quot;, a[j]); } printf(&quot;\n&quot;); } } printf(&quot;\n&quot;); } int main() { #ifndef ONLINE_JUDGE freopen(FN2&quot;.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout); #endif while(scanf(&quot;%d&quot;, &amp;t)==1&amp;&amp;t) init(), solve(); return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>后缀数组</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hdu 2328(二分+后缀数组)]]></title>
    <url>%2Fhdu2328%2F</url>
    <content type="text"><![CDATA[hdu 2328 给出n个字符串，输出他们的最长公共子串，无解输出”IDENTITY LOST” 用不同的符号连接每个字符串，然后二分公共子串的长度，在$height$数组中看有没有连续$n$个$height$大于公共子串的长度，如果有，那么更新答案。(此题暴力比SA快，而且poj上用SA一直TLE，Hdu上1840ms就过了) #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define FN2 &quot;poj3450&quot; using namespace std; const int MAXN = 200 + 5, MAXT = 4000 + 5; char s[MAXT][MAXN]; int t, n, m, ans[MAXN], ll, mini; int a[MAXT*MAXN+200], SA[MAXT*MAXN+200], rk[MAXT*MAXN+200], tp[MAXT*MAXN+200], tax[MAXT*MAXN+200], height[MAXT*MAXN+200], belong[MAXT*MAXN+200]; bool cmp(int *f, int i, int k) {return f[SA[i]]==f[SA[i-1]]&amp;&amp;f[SA[i]+k]==f[SA[i-1]+k];} void build() { for (int i=0;i&lt;m;i++) tax[i] = 0; for (int i=0;i&lt;n;i++) tax[rk[i]=a[i]]++; for (int i=1;i&lt;m;i++) tax[i] += tax[i-1]; for (int i=n-1;i&gt;=0;i--) SA[--tax[rk[i]]] = i; int p; for (int k=1;k&lt;=n;k*=2) { p = 0; for (int i=n-k;i&lt;n;i++) tp[p++] = i; for (int i=0;i&lt;n;i++) if (SA[i]&gt;=k) tp[p++] = SA[i] - k; for (int i=0;i&lt;m;i++) tax[i] = 0; for (int i=0;i&lt;n;i++) tax[rk[tp[i]]]++; for (int i=1;i&lt;m;i++) tax[i] += tax[i-1]; for (int i=n-1;i&gt;=0;i--) SA[--tax[rk[tp[i]]]] = tp[i]; swap(rk, tp), p = 0, rk[SA[0]] = 0; for (int i=1;i&lt;n;i++) rk[SA[i]] = cmp(tp, i, k) ? p : ++p; if (++p&gt;=n) break; m = p; } } void getH() { int k = 0; for (int i=0;i&lt;n;i++) { if (k) k--; int j = SA[rk[i]-1]; while (a[i+k]==a[j+k]) k++; height[rk[i]] = k; } } void init() { n = 0; int orz = 200; mini = 200000000; for (int i=0;i&lt;t;i++) { scanf(&quot;%s&quot;, s[i]); int l = strlen(s[i]); mini = min(mini, l);//取mini优化二分次数 for (int j=0;j&lt;l;j++) belong[n] = i, a[n++] = s[i][j]; a[n] = orz; a[n++] = orz++; } a[n-1] = 0; m = orz + 5; } int used[MAXT]; bool check(int x) { int tot = 0; ms(used, false); for (int i=2;i&lt;n;i++) { if (height[i]&lt;x) { tot = 0; ms(used, false); continue; } if (!used[belong[SA[i-1]]]) used[belong[SA[i-1]]] = true, ++tot; if (!used[belong[SA[i]]]) used[belong[SA[i]]] = true, ++tot; if (tot&gt;=t) { int k = 0; for (int j=SA[i-1];j&lt;SA[i-1]+height[i-1];j++) ans[k++] = a[j]; return true; } } return false; } void solve() { build(), getH(); int l = 0, r = mini+1; ll = 0;//左闭右开，要+1！ /* for (int i=0;i&lt;n;i++) { for (int j=SA[i];j&lt;n;j++) printf(&quot;%4d &quot;, a[j]); putchar(&#39;\n&#39;); } return ;*/ while (l&lt;r) { int mid = (l+r)/2; if (check(mid)) { ll = mid; l = mid + 1; } else r = mid; } if (ll==0) printf(&quot;IDENTITY LOST\n&quot;); else { for (int i=0;i&lt;ll;i++) printf(&quot;%c&quot;, ans[i]); printf(&quot;\n&quot;); } } int main() { #ifndef ONLINE_JUDGE freopen(FN2&quot;.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout); #endif while(scanf(&quot;%d&quot;, &amp;t)==1&amp;t) init(), solve(); return 0; } 附上比SA快的暴力(可以对拍) #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define FN2 &quot;poj3450&quot; using namespace std; const int MAXN = 200 + 5, MAXT = 4000 + 5; char s[MAXT][MAXN], ch[MAXN]; int t, n; void init() { for (int i=0;i&lt;t;i++) { scanf(&quot;%s&quot;, s[i]); } n = strlen(s[0]); } void solve() { int ans = 0; char fi[MAXN]; for (int bg=0;bg&lt;n;bg++) { for (int end=bg;end&lt;n;end++) { int k = 0; int siz = end - bg + 1; if (siz&lt;ans) continue; for (int i=0;i&lt;n;i++) ch[i] = 0; for (int i=bg;i&lt;=end;i++) ch[k++] = s[0][i]; bool flag = false; for (int i=1;i&lt;t;i++) if (!strstr(s[i], ch)) {flag = true; break;} if (!flag) { if (siz==ans&amp;&amp;strcmp(ch, fi)&gt;=0) continue; memcpy(fi, ch, sizeof ch), ans = siz; } } } if (ans==0) printf(&quot;IDENTITY LOST\n&quot;); else printf(&quot;%s\n&quot;, fi); } int main() { #ifndef ONLINE_JUDGE freopen(FN2&quot;.in&quot;,&quot;r&quot;,stdin);freopen(&quot;2.out&quot;,&quot;w&quot;,stdout); #endif while(scanf(&quot;%d&quot;, &amp;t)==1&amp;&amp;t) init(), solve(); return 0; }]]></content>
      <categories>
        <category>Hdu</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>后缀数组</tag>
        <tag>Hdu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj 2774(后缀数组)]]></title>
    <url>%2Fpoj2774%2F</url>
    <content type="text"><![CDATA[poj 2774 给出两个字符串，求这两个字符串的公共子串。 我们可以连接两个字符串，中间插入$\$$，然后构造后缀数组，用$height$数组解决。 以abbbc和bbc为例。因为后缀数组是字典序排的，所以排名最近的两个后缀拥有的最大公共前缀一定比不相邻的长。所以，由图可知，只要后缀$i$的位置在串1的范围，后缀$i-1$在串2的范围(反过来亦可)，那么就可以用$height[i]$更新$ans$的答案 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define FN2 &quot;poj2774&quot; using namespace std; const int MAXN = 100000 + 5; char s1[MAXN], s2[MAXN]; int l1, l2, n, m, a[MAXN*2+100], SA[MAXN*2+100], rk[MAXN*2+100], tp[MAXN*2+100], height[MAXN*2+100], tax[MAXN*2+100]; bool cmp(int *f, int i, int k) {return f[SA[i]]==f[SA[i-1]]&amp;&amp;f[SA[i]+k]==f[SA[i-1]+k];} void build() { for (int i=0;i&lt;m;i++) tax[i] = 0; for (int i=0;i&lt;n;i++) tax[rk[i]=a[i]]++; for (int i=1;i&lt;m;i++) tax[i] += tax[i-1]; for (int i=n-1;i&gt;=0;i--) SA[--tax[rk[i]]] = i; int p; for (int k=1;k&lt;=n;k*=2) { p = 0; for (int i=n-k;i&lt;n;i++) tp[p++] = i; for (int i=0;i&lt;n;i++) if (SA[i]&gt;=k) tp[p++] = SA[i] - k; for (int i=0;i&lt;m;i++) tax[i] = 0; for (int i=0;i&lt;n;i++) tax[rk[tp[i]]]++; for (int i=1;i&lt;m;i++) tax[i] += tax[i-1]; for (int i=n-1;i&gt;=0;i--) SA[--tax[rk[tp[i]]]] = tp[i]; swap(rk, tp), rk[SA[0]] = 0, p = 0; for (int i=1;i&lt;n;i++) rk[SA[i]] = cmp(tp, i, k) ? p : ++p; if (++p&gt;=n) break; m = p; } } void getH() { int k = 0; for (int i=0;i&lt;n;i++) { if (k) k--; int j = SA[rk[i]-1]; while (a[i+k]==a[j+k]) k++; height[rk[i]] = k; } } void init() { scanf(&quot;%s&quot;, s2); l1 = strlen(s1), l2 = strlen(s2); n = l1 + l2 + 2, m = 128; for (int i=0;i&lt;l1;i++) a[i] = s1[i]; a[l1] = &#39;$&#39;, a[n-1] = 0; for (int i=0;i&lt;l2;i++) a[l1+1+i] = s2[i]; } void solve() { build(), getH(); int ans = 0; for (int i=2;i&lt;n;i++) if (height[i]&gt;ans) { if ((0&lt;=SA[i]&amp;&amp;SA[i]&lt;l1&amp;&amp;SA[i-1]&gt;l1) || (0&lt;=SA[i-1]&amp;&amp;SA[i-1]&lt;l1&amp;&amp;SA[i]&gt;l1)) ans = height[i]; //i在第一个字符串内，i-1在第二个字符串内 //或者i-1在第一个字符串内，i在第二个字符串内 } printf(&quot;%d\n&quot;, ans); } int main() { #ifndef ONLINE_JUDGE freopen(FN2&quot;.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout); #endif while(scanf(&quot;%s&quot;, s1)==1) init(), solve(); return 0; }]]></content>
      <categories>
        <category>poj</category>
      </categories>
      <tags>
        <tag>后缀数组</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bzoj 4196(树链剖分)]]></title>
    <url>%2Fbzoj4196%2F</url>
    <content type="text"><![CDATA[BZOJ 4196 树链剖分支持修改查找子树和到根的路径权值和即可解决，注意pushdown放前面注意lc，rc会爆的情况 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #define fo(i, j, k) for (i=(j);i&lt;=(k);i++) #define fd(i, k, j) for (i=(k);i&gt;=(j);i--) #define fe(i, u) for (i=head[u];i!=-1;i=e[i].next) #define rd(a) scanf(&quot;%d&quot;, &amp;a) #define rd2(a, b) scanf(&quot;%d%d&quot;, &amp;a, &amp;b) #define rd3(a, b, c) scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c) #define ms(i, j) memset(i, j, sizeof i) #define FN2 &quot;bzoj4196&quot; using namespace std; const int MAXN = 100000 + 500; int n, head[MAXN], cnt; int p[MAXN], dep[MAXN], fa[MAXN], top[MAXN], son[MAXN], siz[MAXN], pre, ll[MAXN], rr[MAXN]; struct data{int to, next;}e[MAXN*2]; void dfs1(int u, int pa) { int i; dep[u] = dep[pa] + 1, fa[u] = pa, siz[u] = 1; fe (i, u) { int v = e[i].to; if (v!=pa) { dfs1(v, u); siz[u] += siz[v]; if (son[u]==-1||siz[son[u]]&lt;siz[v]) son[u] = v; } } } void dfs2(int u, int chain) { int i; p[u] = ++pre, top[u] = chain, ll[u] = pre; if (son[u]!=-1) { dfs2(son[u], chain); fe (i, u) { int v = e[i].to; if (v!=fa[u]&amp;&amp;v!=son[u]) dfs2(v, v); } } rr[u] = pre; } int sumv[MAXN*4], lazy[MAXN*4]; #define lc (o&lt;&lt;1) #define rc (o&lt;&lt;1|1) #define M ((l+r)&gt;&gt;1) void pushup(int o) { sumv[o] = sumv[lc] + sumv[rc]; } void pushdown(int o, int len) { if (len==1) return ; if (lazy[o]!=-1) { lazy[lc] = lazy[rc] = lazy[o]; sumv[lc] = lazy[o] * (len-len/2); sumv[rc] = lazy[o] * (len/2); lazy[o] = -1; } } void update(int o, int l, int r, int x, int y, int v) { pushdown(o, r-l+1); if (x&lt;=l&amp;&amp;r&lt;=y) { lazy[o] = v; sumv[o] = v * (r-l+1); return ; } if (x&lt;=M) update(lc,l,M,x,y,v); if (M&lt;y) update(rc,M+1,r,x,y,v); pushup(o); } int query(int o, int l, int r, int x, int y) { pushdown(o, r-l+1); int ret = 0; if (x&lt;=l&amp;&amp;r&lt;=y) { return sumv[o]; } if (x&lt;=M) ret += query(lc,l,M,x,y); if (M&lt;y) ret += query(rc,M+1,r,x,y); return ret; } int findRoute(int u, int v) { int f1 = top[u], f2 = top[v], ret = 0, tot = 0; while (f1!=f2) { if (dep[f1]&lt;dep[f2]) swap(f1, f2), swap(u, v); ret += query(1,1,n,p[f1],p[u]); tot += p[u] - p[f1] + 1; u = fa[f1]; f1 = top[u]; } if (dep[u]&lt;dep[v]) swap(u, v); ret += query(1,1,n,p[v],p[u]); tot += p[u] - p[v] + 1; return tot - ret; } int changeRoute(int u, int v, int c) { int f1 = top[u], f2 = top[v]; while (f1!=f2) { if (dep[f1]&lt;dep[f2]) swap(f1, f2), swap(u, v); update(1,1,n,p[f1],p[u],c); u = fa[f1]; f1 = top[u]; } if (dep[u]&lt;dep[v]) swap(u, v); update(1,1,n,p[v],p[u],c); } int findSub(int u) { int ret = query(1,1,n,ll[u],rr[u]); return ret; } int changeSub(int u, int c) { update(1,1,n,ll[u],rr[u],c); } void ins(int u, int v) { ++cnt; e[cnt].to = v, e[cnt].next = head[u], head[u] = cnt; ++cnt; e[cnt].to = u, e[cnt].next = head[v], head[v] = cnt; } void init() { int i; pre = cnt = 0; fo (i, 1, n) head[i] = -1, p[i] = 0, dep[i] = 0, fa[i] = 0, top[i] = 0, son[i] = -1, siz[i] = 0, ll[i] = rr[i] = 0; fo (i, 1, 2*n) e[i].to = 0, e[i].next = -1; fo (i, 1, 4*n) sumv[i] = 0, lazy[i] = -1; fo (i, 1, n-1) { int a; rd(a); ins(a+1, i+1); } } void solve() { int i; dfs1(1, 0), dfs2(1, 1); int q, x; rd(q); char ch[20]; fo (i, 1, q) { scanf(&quot;%s&quot;, ch); if (ch[0]==&#39;i&#39;) { rd(x); printf(&quot;%d\n&quot;, findRoute(x+1, 1)); changeRoute(x+1,1,1); } else { rd(x); printf(&quot;%d\n&quot;, findSub(x+1)); changeSub(x+1,0); } } } int main() { #ifndef ONLINE_JUDGE freopen(FN2&quot;.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout); #endif while (rd(n)==1) init(), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bzoj 4034(树链剖分)]]></title>
    <url>%2Fbzoj4034%2F</url>
    <content type="text"><![CDATA[BZOJ 4034 树剖后线段树维护。此题要修改子树的权，根据树剖性质子树是连续的一段，运用时间戳思想即可。 注意开long long，第一次没开就WA了(痛不欲生) #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #define fo(i, j, k) for (i=(j);i&lt;=(k);i++) #define fd(i, k, j) for (i=(k);i&gt;=(j);i--) #define fe(i, u) for (i=head[u];i!=-1;i=e[i].next) #define rd(a) scanf(&quot;%d&quot;, &amp;a) #define rd2(a, b) scanf(&quot;%d%d&quot;, &amp;a, &amp;b) #define rd3(a, b, c) scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c) #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define FN2 &quot;bzoj4034&quot; using namespace std; const int MAXN = 100000 + 5; int n, m, head[MAXN], wi[MAXN], cnt; struct data{int to, next;}e[MAXN*2]; int p[MAXN], top[MAXN], son[MAXN], siz[MAXN], fa[MAXN], dep[MAXN], pre, ll[MAXN], rr[MAXN]; void dfs1(int u, int pa) { int i; fa[u] = pa, dep[u] = dep[pa] + 1, siz[u] = 1; fe (i, u) { int v = e[i].to; if (v!=pa) { dfs1(v, u); siz[u] += siz[v]; if (son[u]==-1||siz[son[u]]&lt;siz[v]) son[u] = v; } } } void dfs2(int u, int chain) { int i; p[u] = ++pre, top[u] = chain, ll[u] = pre; if (son[u]!=-1) { dfs2(son[u], chain); fe (i, u) { int v = e[i].to; if (v!=fa[u]&amp;&amp;v!=son[u]) dfs2(v, v); } } rr[u] = pre; } LL sumv[MAXN*4], addv[MAXN*4]; #define lc (o&lt;&lt;1) #define rc (o&lt;&lt;1|1) #define M ((l+r)&gt;&gt;1) void pushup(LL o) { sumv[o] = sumv[lc] + sumv[rc]; } void pushdown(int o,int len) { if (addv[o]) { addv[lc] += addv[o], addv[rc] += addv[o]; sumv[lc] += addv[o] * (len-len/2), sumv[rc] += addv[o] * (len/2); addv[o] = 0; } } void update(int o, int l, int r, int x, int y, LL v) { if (x&lt;=l&amp;&amp;r&lt;=y) { addv[o] += v; sumv[o] += (r-l+1) * v; return ; } pushdown(o, r-l+1); if (x&lt;=M) update(lc,l,M,x,y,v); if (M&lt;y) update(rc,M+1,r,x,y,v); pushup(o); } LL query(int o, int l, int r, int x, int y) { LL ret = 0; if (x&lt;=l&amp;&amp;r&lt;=y) { return sumv[o]; } pushdown(o, r-l+1); if (x&lt;=M) ret += query(lc,l,M,x,y); if (M&lt;y) ret += query(rc,M+1,r,x,y); return ret; } LL findSUM(int u, int v) { int f1 = top[u], f2 = top[v]; LL ret = 0; while (f1!=f2) { if (dep[f1]&lt;dep[f2]) swap(f1, f2), swap(u, v); ret += query(1,1,n,p[f1],p[u]); u = fa[f1], f1 = top[u]; } if (dep[u]&lt;dep[v]) swap(u, v); return ret+query(1,1,n,p[v],p[u]); } void ins(int u, int v) { cnt++, e[cnt].to = v, e[cnt].next = head[u], head[u] = cnt; cnt++, e[cnt].to = u, e[cnt].next = head[v], head[v] = cnt; } void init() { int i; cnt = pre = 0; fo (i, 1, n) rd(wi[i]); fo (i, 1, n) head[i] = -1, p[i] = 0, top[i] = 0, son[i] = -1, siz[i] = 0, fa[i] = 0, dep[i] = 0, ll[i] = rr[i] = 0; fo (i, 1, n*2) e[i].to = 0, e[i].next = -1; fo (i, 1, n*4) sumv[i] = addv[i] = 0; fo (i, 1, n-1) { int u, v; rd2(u, v); ins(u, v); } } void solve() { int i; dfs1(1, 0), dfs2(1, 1); fo (i, 1, n) update(1,1,n,p[i],p[i],wi[i]); fo (i, 1, m) { int opt, x, a; rd(opt); if (opt==1) { rd2(x, a); update(1,1,n,p[x],p[x],a); } else if (opt==2) { rd2(x, a); update(1,1,n,ll[x],rr[x],a); } else if (opt==3) { rd(x); printf(&quot;%lld\n&quot;, findSUM(x, 1)); } } } int main() { #ifndef ONLINE_JUDGE freopen(FN2&quot;.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout); #endif while (rd2(n, m)==2) init(), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bzoj 2763(分层图最短路)]]></title>
    <url>%2Fbzoj2763%2F</url>
    <content type="text"><![CDATA[BZOJ 2763 分层图最短路 注意：priority_queue默认排序序列是从大到小的，所以重载小于符号时要a&gt;b以后权值一律写w，不要用v或c！ #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define fo(i, j, k) for (i=(j);i&lt;=(k);i++) #define fd(i, k, j) for (i=(k);i&gt;=(j);i--) #define fg(i, u) for (i=0;i&lt;G[u].size();i++) #define fe(i, u) for (i=head[u];i!=-1;i=e[i].next) #define rd(a) scanf(&quot;%d&quot;, &amp;a) #define rd2(a, b) scanf(&quot;%d%d&quot;, &amp;a, &amp;b) #define rd3(a, b, c) scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c) #define ms(i, j) memset(i, j, sizeof i) #define FN2 &quot;bzoj2763&quot; using namespace std; const int MAXN = 1200100, INF = 0x3f3f3f3f; struct edge{int v, c;}e[MAXN&lt;&lt;2]; struct data { int u, c; bool operator &lt; (data const &amp;b) const { return c&gt;b.c; } }; int n, m, k, en, dis[MAXN], s, t, vi[MAXN]; vector&lt;int&gt; G[MAXN]; void ins(int u, int v, int c) { en++, e[en].v = v, e[en].c = c, G[u].push_back(en); } void pre() { int i; en = 0; fo (i, 0, n*(k+2)) G[i].clear(), dis[i] = INF, vi[i] = false; } void init() { int i,j; pre(); rd2(s, t); fo (i, 1, m) { int a, b, c; rd3(a, b, c); fo (j, 0, k) { ins(a+j*n, b+j*n, c), ins(b+j*n, a+j*n, c); if (j!=k) ins(a+j*n, b+(j+1)*n, 0), ins(b+j*n, a+(j+1)*n, 0); } } } void solve() { int i, ans = INF; priority_queue&lt;data&gt; q; dis[s] = 0, q.push((data){s, dis[s]}); while (!q.empty()) { data p = q.top(); q.pop(); int u = p.u; if (vi[u]) continue; vi[u] = true; for (i=0;i&lt;G[u].size();i++) { int v = e[G[u][i]].v; if (dis[v]&gt;dis[u]+e[G[u][i]].c) { dis[v] = dis[u]+e[G[u][i]].c;//用dis[u]，因为有重边 q.push((data){v, dis[v]}); } } } fo (i, 0, k) { ans = min(ans, dis[t+i*n]); } printf(&quot;%d\n&quot;, ans); } int main() { #ifndef ONLINE_JUDGE freopen(FN2&quot;.in&quot;,&quot;r&quot;,stdin);freopen(&quot;1.out&quot;,&quot;w&quot;,stdout); #endif while (rd3(n,m,k)==3) init(), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OI中的常用数据生成]]></title>
    <url>%2FszOI%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%94%9F%E6%88%90%2F</url>
    <content type="text"><![CDATA[一、随机生成一个小于等于$n$的数 int RAND(int n) { srand((int)time(0)); return rand()%n+1; } 二、随机生成排列 int t[MAXN]; int mp(int n) { int i; srand((int)time(0)); for(int i = 1; i &lt;= n; ++i) t[i] = i; random_shuffle(t + 1, t + 1 + n);//STL的打乱数组函数 } 三、随机生成树1、以1为根的树 int mt1(int n) { int i; srand((int)time(0)); for (int i = 2; i &lt;= n; ++i) printf(&quot;%d %d\n&quot;, i, RAND(i - 1)); } 2、以任意结点为根的树 int mt2(int n) { int i; srand((int)time(0)); mp(n); for (int i = 2; i &lt;= n; ++i) printf(&quot;%d %d\n&quot;, t[i], t[RAND(i - 1)]); } 四、随机生成图1、连通图先构造一棵树，再随意加边2、普通图随便加边就可以了3、无重边用set记录二元组4、无自环起点终点不一致即可5、DAG随机一个排列作为拓扑序，然后随机从前面的点加边到后面6、无大环套小环每个点至多一个出度]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1036」「ZJOI2008」树的统计Count (树链剖分)]]></title>
    <url>%2Fbzoj1036%2F</url>
    <content type="text"><![CDATA[bzoj 1036 树剖+线段树。 第一个树剖题，终于AC #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define fo(i, j, k) for (i=(j);i&lt;=(k);i++) #define fd(i, k, j) for (i=(k);i&gt;=(j);i--) #define rd(a) scanf(&quot;%d&quot;, &amp;a) #define rd2(a, b) scanf(&quot;%d%d&quot;, &amp;a, &amp;b) #define rd3(a, b, c) scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c) #define ms(i, j) memset(i, j, sizeof i) #define FN2 &quot;bzoj1036&quot; using namespace std; const int MAXN = 30000 + 5; int dep[MAXN], son[MAXN], fa[MAXN], siz[MAXN]; //深度，重儿子，父亲，子树大小 int p[MAXN], top[MAXN], pre; //在线段树中的位置，所在重链顶部，线段树当前标号 int n, wi[MAXN]; vector&lt;int&gt; G[MAXN]; void dfs1(int u, int f)//第一次dfs记录值 { int i; dep[u] = dep[f] + 1, fa[u] = f, siz[u] = 1; fo (i, 0, G[u].size()-1) { int v = G[u][i]; if (v!=f) { dfs1(v, u); siz[u] += siz[v]; if (son[u]==-1||siz[son[u]]&lt;siz[v]) son[u] = v; } } } void dfs2(int u, int chain) {//第二次dfs连重儿子成重链 int i; p[u] = ++pre, top[u] = chain; if (son[u]!=-1) { dfs2(son[u], chain); fo (i, 0, G[u].size()-1) { int v = G[u][i]; if (v!=son[u]&amp;&amp;v!=fa[u]) dfs2(v, v); } } } int maxv[MAXN*4], sumv[MAXN*4]; void pushup(int o) { int lc = o*2, rc = o*2+1; maxv[o] = max(maxv[lc], maxv[rc]); sumv[o] = sumv[lc] + sumv[rc]; } void update(int o, int l, int r, int p, int v) { int lc = o*2, rc = o*2+1, M = (l+r)/2; if (l==r) { sumv[o] = maxv[o] = v; return ; } if (p&lt;=M) update(lc, l, M, p, v); else if (M&lt;p) update(rc, M+1, r, p, v); pushup(o); } int getMax(int o, int l, int r, int x, int y) { int lc = o*2, rc = o*2+1, M = (l+r)/2, ret = -200000000; if (x&lt;=l&amp;&amp;r&lt;=y) { return maxv[o]; } if (x&lt;=M) ret = max(ret, getMax(lc, l, M, x, y)); if (M&lt;y) ret = max(ret, getMax(rc, M+1, r, x, y)); return ret; } int getSum(int o, int l, int r, int x, int y) { int lc = o*2, rc = o*2+1, M = (l+r)/2, ret = 0; if (x&lt;=l&amp;&amp;r&lt;=y) { return sumv[o]; } if (x&lt;=M) ret += getSum(lc, l, M, x, y); if (M&lt;y) ret += getSum(rc, M+1, r, x, y); return ret; } int findMax(int u, int v) { int f1 = top[u], f2 = top[v]; int ret = -200000000; while (f1!=f2) { if (dep[f1]&lt;dep[f2]) swap(f1, f2), swap(u, v); ret = max(ret, getMax(1, 1, n, p[f1], p[u])); u = fa[f1], f1 = top[u]; } if (dep[u]&lt;dep[v]) swap(u, v); return max(ret, getMax(1, 1, n, p[v], p[u])); } int findSum(int u, int v) { int f1 = top[u], f2 = top[v]; int ret = 0; while (f1!=f2) { if (dep[f1]&lt;dep[f2]) swap(f1, f2), swap(u, v); ret += getSum(1, 1, n, p[f1], p[u]); u = fa[f1], f1 = top[u]; } if (dep[u]&lt;dep[v]) swap(u, v); return ret+getSum(1, 1, n, p[v], p[u]); } void init() { int i; pre = 0; fo (i, 1, n) dep[i] = fa[i] = siz[i] = p[i] = top[i] = 0, son[i] = -1, G[i].clear(); fo (i, 1, n*4) maxv[i] = -200000000, sumv[i] = 0; fo (i, 1, n-1) { int a, b; rd2(a, b); G[a].push_back(b), G[b].push_back(a); } } void solve() { int q, i; dfs1(1, 0); dfs2(1, 1); fo (i, 1, n) rd(wi[i]), update(1, 1, n, p[i], wi[i]); rd(q); fo (i, 1, q) { char ch[10]; scanf(&quot;%s&quot;, ch); if (ch[0]==&#39;C&#39;) { int u, t; rd2(u, t), update(1, 1, n, p[u], t); } else if (ch[1]==&#39;M&#39;) { int u, v; rd2(u, v), printf(&quot;%d\n&quot;, findMax(u, v)); } else if (ch[1]==&#39;S&#39;) { int u, v; rd2(u, v), printf(&quot;%d\n&quot;, findSum(u, v)); } } } int main() { #ifndef ONLINE_JUDGE freopen(FN2&quot;.in&quot;,&quot;r&quot;,stdin);freopen(FN2&quot;.out&quot;,&quot;w&quot;,stdout); #endif while (rd(n)==1) init(), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hdu 3666(差分约束)]]></title>
    <url>%2Fhdu3666%2F</url>
    <content type="text"><![CDATA[hdu 3666 由题意可知, $$L &lt;= C(i,j) * a_i/b_j &lt;= U$$可以都除以$C(i,j)$, 得 $$L/C(i,j) &lt;= a_i/b_j &lt;= U/C(i,j)$$此时都是除法，不满足差分约束 看两个性质$log(a/b) = log(a) - log(b)$$log(a*b) = log(a) + log(b)$ 那么原式可以变为$$log(L/C(i,j)) &lt;= log(a_i/b_j) &lt;= log(U/C(i,j))$$$$log(L) - log(C(i,j)) &lt;= log(a_i) - log(b_j) &lt;= log(U) - log(C(i,j))$$将$a_i, b_j$看做是一个元素，就可以建立差分约束系统求解是否存在 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define FN2 &quot;hdu3666&quot; using namespace std; const int MAXN = 400 * 400 + 5; struct edge { int v; double w; }ed[MAXN*2]; int en; vector&lt;int&gt; G[MAXN]; struct sdc { double dis[MAXN]; int cir[MAXN], vi[MAXN]; int n; void init(int n) { en = 0; this-&gt;n = n; for (int i=1;i&lt;=n;i++) G[i].clear(); } void addedge(int x, int y, double c) // a - b &lt;= c { en++, ed[en].v = x, ed[en].w = c, G[y].push_back(en); } int solve() { queue&lt;int&gt; q; for (int i=1;i&lt;=n;i++) dis[i] = 0, cir[i] = 1, vi[i] = true, q.push(i); while (!q.empty()) { int p = q.front(); q.pop(); vi[p] = false; for (int i=0;i&lt;G[p].size();i++) { int v = ed[G[p][i]].v; double w = ed[G[p][i]].w; if (dis[v]&gt;dis[p]+w) { dis[v] = dis[p] + w; if (!vi[v]) { vi[v] = true; cir[v]++; if (cir[v]&gt;4) return false;//坑，&gt;4只是卡的，&gt;n会无限TLE TAT q.push(v); } } } } return true; } }sd; int n, m; double L, U, l_L, l_U; void init() { sd.init(n*n); l_L = log(L), l_U = log(U); for (int i=1;i&lt;=n;i++) { for (int j=1;j&lt;=m;j++) { double c, l_c; scanf(&quot;%lf&quot;, &amp;c), l_c = log(c); // a 1~n, b n+1~2n sd.addedge(i, j+n, l_U-l_c); sd.addedge(j+n, i, l_c-l_L); } } } void solve() { if (sd.solve()) printf(&quot;YES\n&quot;); else printf(&quot;NO\n&quot;); } int main() { #ifndef ONLINE_JUDGE freopen(FN2&quot;.in&quot;,&quot;r&quot;,stdin); freopen(FN2&quot;.out&quot;,&quot;w&quot;,stdout); #endif while (scanf(&quot;%d%d%lf%lf&quot;, &amp;n, &amp;m, &amp;L, &amp;U)==4) { init(); solve(); } return 0; }]]></content>
      <categories>
        <category>Hdu</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
        <tag>Hdu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hdu 3440(差分约束)]]></title>
    <url>%2Fhdu3440%2F</url>
    <content type="text"><![CDATA[hdu 3440 差分约束，由于求最大差，故建立$a-b&lt;=c$的不等式，跑最短路h数组排序后，依次连接两个相邻的数，注意绝对值的问题 ps: INF要开0x7fffffff #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define FN2 &quot;hdu3440&quot; using namespace std; const int MAXN = 1000 + 5, ZINF2 = 0x7fffffff; struct edge { int u, v, c; }e[MAXN*MAXN]; struct house { int no, hi; bool operator &lt; (const house b) const { return hi &lt; b.hi; } }h[MAXN]; struct sdc { vector&lt;int&gt; G[MAXN]; int dis[MAXN], cir[MAXN], vi[MAXN], n, en; void init(int n) { en = 0; this-&gt;n = n; for (int i=0;i&lt;=n;i++) G[i].clear(), dis[i] = ZINF2, cir[i] = vi[i] = 0; } void addedge(int a, int b, int c)//a-b&lt;=c { en++; e[en].u = b, e[en].v = a, e[en].c = c; G[b].push_back(en); } int solve(int from, int to) { queue&lt;int&gt; q; cir[from] = 1, vi[from] = true, dis[from] = 0, q.push(from); while(!q.empty()) { int p = q.front(); q.pop(); vi[p] = false; for (int i=0;i&lt;G[p].size();i++) { int v = e[G[p][i]].v, w = e[G[p][i]].c; if (dis[p]+w&lt;dis[v]) { dis[v] = dis[p]+e[G[p][i]].c; if (!vi[v]) { vi[v] = true; cir[v]++; if (cir[v]&gt;n) return -1; q.push(v); } } } } return dis[to]; } }sd; int n, d, kase = 0; void init() { scanf(&quot;%d%d&quot;, &amp;n, &amp;d); sd.init(n); for (int i=1;i&lt;=n;i++) { scanf(&quot;%d&quot;, &amp;h[i].hi); h[i].no = i; } sort(h+1, h+1+n); } void solve() { for (int i=1;i&lt;n;i++) { sd.addedge(i, i+1, -1); int u = min(h[i].no, h[i+1].no); int v = max(h[i].no, h[i+1].no); sd.addedge(v, u, d); } int u = min(h[1].no, h[n].no), v = max(h[1].no, h[n].no); printf(&quot;Case %d: %d\n&quot;, ++kase, sd.solve(u, v)); } int main() { #ifndef ONLINE_JUDGE freopen(FN2&quot;.in&quot;,&quot;r&quot;,stdin); freopen(FN2&quot;.out&quot;,&quot;w&quot;,stdout); #endif int t; scanf(&quot;%d&quot;, &amp;t); while (t--) { init(); solve(); } return 0; }]]></content>
      <categories>
        <category>Hdu</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
        <tag>Hdu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GDOI 2017 总结]]></title>
    <url>%2FzzGDOI2017%2F</url>
    <content type="text"><![CDATA[$Day0$坐了4个小时的车才到酒店，酒店真是高端。。然后去了东华吃晚餐，这都是素菜。。？晚上浪浪浪$Day1$直到闹钟叫才醒。。真是睡得够死。。酒店早餐西式自助真不错。。7点半到东华，学校真大找半天路。。然后进去机房无力吐槽。。真是挤。。挺不舒服的 开考了，解压密码HaveANice51。。t1，怎么这么难，跳。(结果是题目读错了，裸kmp)t2，3000字题面，还有完整版5000字题面，真是丧心病狂。。mex定义和题目所求真是够乱。。然后刚开始理解成求子树最小值了。。后来发现错了改了。。结果之后有个同学求子树最小值得了60、。。真是。。t3，好像很难，但是貌似dp能有20分，没打真是可惜t4，???day1考完真是感觉差，觉得要爆0了。。之后发现t1还骗到10分？真是奇怪。。day1 10分滚粗 $Day2$t1，吸取第一天教训，一定要做出来，打了个bfs，出来的时候听到各位dalao说暴力以后最短路？？WTF？t2，样例感觉很奇怪？然后样例没过的程序交了上去。t3，暴力可行，打了个暴力完事。t4，WTF期望？跳。 期望得分100+0+5+0.下午出成绩，果然105，t1没炸，太好了，出题人不是说太暴力的算法会被卡么。。我的bfs根本没优化过。。 $Day3$太弱了Day3去旅行 $Day4$参加了颁奖仪式，得了个Cu。 总结：第一次看题要仔细仔细再仔细，不要因此误判难度，要知道题目不是一下子就能看出或者模板题，要仔细思考自己学过的知识拿部分分，再烦的题目暴力也要打，哪怕认为没什么分，不要看见题目有一点难就放弃，要认真思考，不要自己的理解过了样例就认为完全正确，同时题目要结合样例理解。其实应该每一道题目都要仔细看，不管题目复不复杂，都看一遍，就算不做，下午听题解也会好一些，不要在一题上花费太多时间，哪怕快做出来了，除非此时已无其他事可做。gdoi系列比赛最好多花时间在第一题，因为一般会比较简单。]]></content>
      <categories>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>杂文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hdu 2825(AC自动机+状压DP)]]></title>
    <url>%2Fhdu2825%2F</url>
    <content type="text"><![CDATA[hdu 2825题意：给出$m$个模式串，求至少包含$k$个模式串长为$n$的主串个数。用模式串建立AC自动机，设$dp(i,j,S)$为主串前$i$个字符，在AC自动机上$j$点，当前存在模式串状态的方案数。$$dp(i,v,S|val_v)=dp(i-1,j,S)$$因为有用的只有两层，所以其中可以运用滚动数组节省空间 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MO = 20090717, MAXN = 10 * 10 + 5; int n, m, k, sz = 10 * 10; char s[15]; int ch[MAXN][35], val[MAXN], f[MAXN], dp[2][MAXN][(1 &lt;&lt; 10) + 100]; void insert(char *s, int ith) { int now = 0, len = strlen(s); for (int i = 0; i &lt; len; i++) { int c = s[i] - &#39;a&#39;; if (!ch[now][c]) ch[now][c] = ++sz; now = ch[now][c]; if (i == len - 1) val[now] += (1 &lt;&lt; (ith - 1)); } } void getFail() { queue&lt;int&gt; q; f[0] = 0; for (int c = 0; c &lt; 26; c++) { int v = ch[0][c]; if (v) q.push(v), f[v] = 0; } while (!q.empty()) { int u = q.front(); q.pop(); for (int c = 0; c &lt; 26; c++) { int v = ch[u][c]; if (!v) {ch[u][c] = ch[f[u]][c]; continue;} q.push(v); int j = f[u]; while (j &amp;&amp; !ch[j][c]) j = f[j]; f[v] = ch[j][c]; val[v] |= val[f[v]];//注意传递 } } } void cal() { dp[0][0][0] = 1; int x = 1;//滚动数组当前位置 for (int i = 1; i &lt;= n; i++) { for (int j = 0; j &lt;= sz; j++) for (int S = 0; S &lt; (1 &lt;&lt; m); S++) dp[x][j][S] = 0; for (int j = 0; j &lt;= sz; j++) { for (int S = 0; S &lt; (1 &lt;&lt; m); S++) { if (!dp[x ^ 1][j][S]) continue; for (int c = 0; c &lt; 26; c++) { int v = ch[j][c]; dp[x][v][S | val[v]] = (dp[x][v][S | val[v]] + dp[x ^ 1][j][S]) % MO;//方程不要写错了 } } } x ^= 1; } } void clean() { for (int i = 0; i &lt;= sz; i++) { for (int j = 0; j &lt; 28; j++) ch[i][j] = 0; for (int j = 0; j &lt; 1030; j++) dp[1][i][j] = dp[0][i][j] = 0; val[i] = f[i] = 0; } sz = 0; } bool check(int x) { int ret = 0, tmp = x; do { ret += tmp &amp; 1; tmp &gt;&gt;= 1; } while (tmp != 0); return ret &gt;= k; } void solve() { clean(); for (int i = 1; i &lt;= m; i++) { scanf(&quot;%s&quot;, s); insert(s, i); } getFail(), cal(); int taki = 0; for (int j = 0; j &lt;= sz; j++) { for (int S = 0; S &lt; (1 &lt;&lt; m); S++) { if (check(S)) taki = (taki + dp[n % 2][j][S]) % MO; } } printf(&quot;%d\n&quot;, taki); } int main() { while (scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k) == 3 &amp;&amp; (n || m || k)) solve(); return 0; }]]></content>
      <categories>
        <category>Hdu</category>
      </categories>
      <tags>
        <tag>状压DP</tag>
        <tag>AC自动机</tag>
        <tag>Hdu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hdu 1531(差分约束)]]></title>
    <url>%2Fhdu1531%2F</url>
    <content type="text"><![CDATA[Hdu 1531题目很烦，慢慢体会。1、SPFA的写法2、SPFA判负环搞清楚有几个点3、最短(长)路中的dis[i]表示 a[i]-a[0]的最大(小)值 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;queue&gt; using namespace std; #define ms(i,j) memset(i, j, sizeof i); const int MAXN = 100 + 5; struct edge { int u, v, c; }e[MAXN*MAXN]; int en; struct sysdc { int dis[MAXN]; int vi[MAXN]; int cir[MAXN]; vector&lt;int&gt; G[MAXN]; int n; void init(int n) { this-&gt;n = n; for (int i=0;i&lt;=n;i++) { G[i].clear(); } } int addedge(int a, int b, int c)//添加a-b&gt;=c { en++; e[en].u = b; e[en].v = a; e[en].c = c; G[b].push_back(en); } int solve() { queue&lt;int&gt; q; for (int i=0;i&lt;=n;i++) { vi[i] = false; cir[i] = 1; dis[i] = 0; q.push(i); } while (!q.empty()) { int p = q.front(); q.pop(); vi[p] = false; for (int i=0;i&lt;G[p].size();i++) { edge ed = e[G[p][i]]; if (dis[p]+ed.c&gt;dis[ed.v]) { dis[ed.v] = dis[p]+ed.c; if (!vi[ed.v]) { vi[ed.v] = true; cir[ed.v]++; if (cir[ed.v]&gt;n+1) return false; q.push(ed.v); } } } } return true; } }sdc; int n, m; void init() { en = 0; sdc.init(n); for (int i=1;i&lt;=m;i++) { int si, ni, ki; char oi, sb; scanf(&quot;%d %d %c%c %d&quot;, &amp;si, &amp;ni, &amp;oi, &amp;sb, &amp;ki); if (oi==&#39;g&#39;)//&gt; { sdc.addedge(si-1, si+ni, ki+1); } else sdc.addedge(si+ni, si-1, -ki+1);//&lt; } } void solve() { if (sdc.solve()) { printf(&quot;lamentable kingdom\n&quot;); } else printf(&quot;successful conspiracy\n&quot;); } int main() { while (scanf(&quot;%d%d&quot;, &amp;n, &amp;m)==2&amp;&amp;n&amp;&amp;m) { init(); solve(); } return 0; }]]></content>
      <categories>
        <category>Hdu</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
        <tag>Hdu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hdu 3336(KMP+DP)]]></title>
    <url>%2Fhdu3336%2F</url>
    <content type="text"><![CDATA[hdu 3336如果$next[j] = i$, 那么说明$[0, i-1]$与$[j-i, j-1]$部分相同并且$i,j$之间没有更多的前缀设$dp[i]$为前$i$个字符中前缀出现次数$dp[i] = dp[next[i]]+1 $ #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; using namespace std; #define ms(i,j) memset(i, j, sizeof i); const int MAXN = 200000 + 5; char s[MAXN]; int f[MAXN], dp[MAXN], n; void init() { scanf(&quot;%d&quot;, &amp;n); scanf(&quot;%s&quot;, s); } void solve() { f[0] = f[1] = 0; for (int i=1;i&lt;n;i++) { int j = f[i]; while (j &amp;&amp; s[i]!=s[j]) j = f[j]; f[i+1] = (s[i]==s[j]) ? (j+1) : (0); } ms(dp, 0); int ans = 0; for (int i=1;i&lt;=n;i++) { dp[i] = dp[f[i]] + 1; ans = (ans+dp[i]) % 10007; } printf(&quot;%d\n&quot;, ans); } int main() { int t; scanf(&quot;%d&quot;, &amp;t); while (t--) { init(); solve(); } return 0; }]]></content>
      <categories>
        <category>Hdu</category>
      </categories>
      <tags>
        <tag>计数DP</tag>
        <tag>KMP</tag>
        <tag>Hdu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hdu 2594(KMP)]]></title>
    <url>%2Fhdu2594%2F</url>
    <content type="text"><![CDATA[Hdu传送门连接s1,s2, kmp求前缀和后缀(给了两个字符串，有时可以连接解题 ) #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; using namespace std; #define ms(i,j) memset(i, j, sizeof i); const int MAXN = 50000 + 5; char s1[MAXN*3], s2[MAXN]; int n1, n2, n, f[MAXN*3]; void init() { n1 = strlen(s1), n2 = strlen(s2); n = n1 + n2; for (int i=n1;i&lt;n;i++) { s1[i] = s2[i-n1]; } } void solve() { f[0] = f[1] = 0; for (int i=1;i&lt;n;i++) { int j = f[i]; while (j &amp;&amp; s1[i]!=s1[j]) j = f[j]; f[i+1] = (s1[i]==s1[j]) ? (j+1) : (0); } int i = n; while (f[i]) { if (f[i]&lt;=min(n1,n2)) { for (int j=0;j&lt;f[i];j++) putchar(s1[j]); printf(&quot; %d\n&quot;, f[i]); return ; } i = f[i]; } printf(&quot;%d\n&quot;, 0); } int main() { while (scanf(&quot;%s%s&quot;, s1, s2)==2) { init(); solve(); } return 0; }]]></content>
      <categories>
        <category>Hdu</category>
      </categories>
      <tags>
        <tag>KMP</tag>
        <tag>Hdu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hdu 3622(二分+2-SAT)]]></title>
    <url>%2Fhdu3622%2F</url>
    <content type="text"><![CDATA[Hdu 3622二分后2-SAT判断1、2-SAT加边视情况加2、浮点数二分查找的写法3、浮点数的eps最好开多一点，防卡精度 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; #define ll long long #define db double #define ms(i,j) memset(i,j) #define INF 100000000 #define llINF 1LL&lt;&lt;60 using namespace std; const int MAXN = (100 + 5) * 2; struct TwoSat { int mark[MAXN*2]; int S[MAXN*2]; vector&lt;int&gt; G[MAXN*2]; int n, c; int init(int ni) { n = ni; for (int i=0;i&lt;=n*2;i++) { mark[i] = false; G[i].clear(); } } int dfs(int u) { if (mark[u^1]) return false; if (mark[u]) return true; mark[u] = true; S[++c] = u; for (int i=0;i&lt;G[u].size();i++) { if (!dfs(G[u][i])) return false; } return true; } int solve() { for (int i=0;i&lt;n*2;i+=2) if (!mark[i]&amp;&amp;!mark[i+1]) { c = 0; if (!dfs(i)) { while (c&gt;0) mark[S[c--]] = false; if (!dfs(i+1)) return false; } } return true; } }ts; int n; int xi[MAXN], yi[MAXN]; db dis(int x, int y) { return sqrt(1.0*(xi[x]-xi[y])*(xi[x]-xi[y]) + (yi[x]-yi[y])*(yi[x]-yi[y])); } int init() { for (int i=0;i&lt;n;i++) { scanf(&quot;%d%d%d%d&quot;, &amp;xi[i], &amp;yi[i], &amp;xi[i+n], &amp;yi[i+n]); } } int solve() { db l = 0.0, r = 40000.0; db ans = 0; for (int i=0;i&lt;100;i++) { db mid = (l+r)/2.0; ts.init(n); for (int i=0;i&lt;n;i++) for (int j=i+1;j&lt;n;j++) { int x = i*2, y = j*2; if (dis(i,j)+0.0000001&lt;mid*2) { ts.G[x].push_back(y^1); ts.G[y].push_back(x^1); } if (dis(i,j+n)+0.0000001&lt;mid*2) { ts.G[x].push_back(y); ts.G[y^1].push_back(x^1); } if (dis(i+n,j)+0.0000001&lt;mid*2) { ts.G[x^1].push_back(y^1); ts.G[y].push_back(x); } if (dis(i+n,j+n)+0.0000001&lt;mid*2) { ts.G[x^1].push_back(y); ts.G[y^1].push_back(x); } } if (ts.solve()) { ans = l = mid; } else r = mid; } printf(&quot;%.2f\n&quot;, ans); } int main() { while (scanf(&quot;%d&quot;, &amp;n)==1) { init(); solve(); } return 0; }]]></content>
      <categories>
        <category>Hdu</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>2-SAT</tag>
        <tag>Hdu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bzoj 3183(DFS)]]></title>
    <url>%2Fbzoj3183%2F</url>
    <content type="text"><![CDATA[bzoj 3183Luogu免权限地址裸搜索，根据生物学知识可得入度为0的结点是食物链开端，出度为0则是末端为防止超时使用了记忆化 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i,j) memset(i,j,sizeof i) using namespace std; const int MAXN = 100000 + 5; int n,m; vector&lt;int&gt; G[MAXN]; int outd[MAXN], ino[MAXN]; int f[MAXN]; int ans = 0; int dfs(int u) { int ret = 0; if (outd[u]==0) { f[u] = 1; return 1; } if (f[u]) return f[u]; for (int i=0;i&lt;G[u].size();i++) { ret += dfs(G[u][i]); } f[u] = ret; return ret; } int main() { scanf(&quot;%d%d&quot;, &amp;n ,&amp;m); ms(outd, 0); ms(ino, 0); for (int i=1;i&lt;=m;i++) { int ai, bi; scanf(&quot;%d%d&quot;, &amp;ai, &amp;bi); G[ai].push_back(bi); outd[ai]++; ino[bi]++; } ms(f, 0); for (int i=1;i&lt;=n;i++) if (ino[i]==0&amp;&amp;outd[i]!=0) { ans += dfs(i); } printf(&quot;%d\n&quot;, ans); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1619」「Usaco2008 Nov」Guarding the Farm 保卫牧场 (BFS)]]></title>
    <url>%2Fbzoj1619%2F</url>
    <content type="text"><![CDATA[bzoj 1619Luogu免权限地址从高的地方开始BFS灌水 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i,j) memset(i,j,sizeof i) using namespace std; const int MAXN = 700 + 5; struct po { int x, y, h; bool operator &lt; (const po &amp;b) const { return h &gt; b.h; } }p[MAXN*MAXN]; const int dx[8] = {1,0,-1,0,1,-1,1,-1}, dy[8] = {0,1,0,-1,1,-1,-1,1}; int map[MAXN][MAXN]; int vi[MAXN][MAXN]; int n,m; int cnt = 0; int ans = 0; int dfs(int x, int y) { for (int i=0;i&lt;8;i++) { int tx = x + dx[i], ty = y + dy[i]; if (tx&gt;0&amp;&amp;ty&gt;0&amp;&amp;tx&lt;=n&amp;&amp;ty&lt;=m) { if (!vi[tx][ty]) if (map[tx][ty]&lt;=map[x][y]) { vi[tx][ty] = true; dfs(tx, ty); } } } } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++) { scanf(&quot;%d&quot;, &amp;map[i][j]); p[++cnt].x = i; p[ cnt].y = j; p[ cnt].h = map[i][j]; } sort(p+1, p+1+cnt); ms(vi, false); for (int i=1;i&lt;=cnt;i++) if (!vi[p[i].x][p[i].y]) { vi[p[i].x][p[i].y] = true; dfs(p[i].x, p[i].y); ans++; } printf(&quot;%d\n&quot;, ans); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 3191」「JLOI2013」卡牌游戏 (概率DP)]]></title>
    <url>%2Fbzoj3191%2F</url>
    <content type="text"><![CDATA[bzoj 3191题意：见上。 根据题目，我们可以从终态入手。考虑什么状态下概率已定。(期望概率题入手套路)这里可以发现只有一个人时，必定他会胜利，所以我们可以按照「人数」划分阶段。那么可以设$dp(i,j)$为有$i$个人时，庄家开始数第$j$个人胜利的概率。(也可以设更加明显的三维状态)那么$dp(i-1)$可以转移到$dp(i)$从$i-1$到$i$, $i$下$j$的这个人是不动的。考虑$i$时淘汰一个人，即枚举$a[k]$使得$c=a[k] \mod i$，$c-1$是淘汰的人相对当前$i$庄家的位置。然后因为淘汰了一个人庄家就是这个人的下一个，那么考虑两种情况第一种，庄家跑不到$j$的后面，那么这时$dp(i,j)=\frac{dp(i-1,j-c)}m$，画图可知第二种，庄家会跑到$j$的后面，那么这时$dp(i,j)=\frac{dp(i-1,j+(i-c))}m$，画图可知 那么最后$dp(n)$即为答案。 知识点：1、从终态入手，来判断怎么划分DP状态 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;map&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { int n, m, a[55]; db dp[55][55]; void clean() { ms(dp, 0); } int solve() { clean(); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; ++i) cin &gt;&gt; a[i]; dp[1][1] = 1.0; for (int i = 2; i &lt;= n; ++i) { for (int j = 1; j &lt;= n; ++j) { for (int k = 1; k &lt;= m; ++k) { int c = a[k] % i; if (!c) c = i; if (c &lt; j) dp[i][j] += dp[i - 1][j - c] / m; else if (c &gt; j) dp[i][j] += dp[i - 1][j + (i - c)] / m; } } } for (int i = 1; i &lt;= n; ++i) { printf(&quot;%.2f%% &quot;, dp[n][i] * 100.0); } return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>概率DP</tag>
        <tag>Bzoj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bzoj 2429(最小瓶颈路)]]></title>
    <url>%2Fbzoj2429%2F</url>
    <content type="text"><![CDATA[BZOJ传送门最小瓶颈路，求一条路径，使得$u-&gt;v$路径上的最大边权最小。可以知道，最小瓶颈路必在最小生成树上，所以用最小生成树求解求出最小的最大边权后和每个猴子的距离比较即可(PS: 之前还用dfs跑。。结果发现直接比较即可。。) /* Date: 04-03-17 10:27 bzoj 2429 */ #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;vector&gt; #define ms(i,j) memset(i,j,sizeof i); using namespace std; const int MAXM = 500 + 5, MAXN = 1000 + 5; struct edge { int u; int v; double w; bool operator &lt; (const edge &amp;b) const { return w &lt; b.w; } }e[MAXN*MAXN]; int en = 0; void addE(int x, int y, double w) { en++; e[en].u = x; e[en].v = y; e[en].w = w; } int fa[MAXN]; int find(int x) {return (fa[x]==x) ? (x) : (fa[x] = find(fa[x]));} int m, n; int h[MAXM]; int x[MAXN], y[MAXN]; int main() { scanf(&quot;%d&quot;, &amp;m); for (int i=1;i&lt;=m;i++) { scanf(&quot;%d&quot;, &amp;h[i]); } scanf(&quot;%d&quot;, &amp;n); for (int i=1;i&lt;=n;i++) { scanf(&quot;%d%d&quot;, &amp;x[i], &amp;y[i]); fa[i] = i; } for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=n;j++) if (i!=j) { addE(i, j, sqrt( (x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]) ) ); } sort(e+1, e+1+en); int tot = 0; double maxe = 0; for (int i=1;i&lt;=en;i++) { int fx = find(e[i].u); int fy = find(e[i].v); if (fx==fy) continue; fa[fx] = fy; tot++; if (tot == n-1) {maxe = e[i].w; break;} } int ans = 0; for (int i=1;i&lt;=m;i++) { if (h[i]&gt;=maxe) ans++; } printf(&quot;%d\n&quot;, ans); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hdu 1512(可并堆)]]></title>
    <url>%2Fhdu1512%2F</url>
    <content type="text"><![CDATA[Hdu 1512左偏树模板题，细节一定要注意 #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #define ms(i,j) memset(i,j,sizeof i); using namespace std; const int MAXN = 100000 + 5; struct node { int l, r;//左偏树左、右孩子编号 int dis, key;//左偏树距离，键值 int f;//并查集father }lt[MAXN]; int n; int m; int find(int x) //并查集find { return (x==lt[x].f) ? (x) : (lt[x].f = find(lt[x].f)); } void build(int rt, int v)//使rt初始化为v值 { lt[rt].l = lt[rt].r = lt[rt].dis = 0; lt[rt].key = v; lt[rt].f = rt; if (rt==0) lt[rt].dis = -1; } int merge(int rtA, int rtB)//合并两棵树 { if (rtA==0) return rtB; if (rtB==0) return rtA; if (lt[rtA].key&lt;lt[rtB].key) swap(rtA, rtB);//大值左偏树要满足key(x)&lt;key(parents[x]) lt[rtA].r = merge(lt[rtA].r, rtB);//A的右子树和B合并 int &amp;l = lt[rtA].l, &amp;r = lt[rtA].r;//利用引用减少代码量，更加清晰 lt[l].f = lt[r].f = rtA; //更新并查集 if (lt[l].dis&lt;lt[r].dis) swap(l, r);//需要满足左偏性质dis(lc)&gt;=dis(rc) if (r==0) lt[rtA].dis = 0; else lt[rtA].dis = lt[r].dis+1;//算距离 return rtA; } int del(int rt)//删除rt节点 { int l = lt[rt].l; int r = lt[rt].r; lt[l].f = l; lt[r].f = r; lt[rt].l = lt[rt].r = lt[rt].dis = 0; return merge(l, r); } int main() { while (scanf(&quot;%d&quot;, &amp;n)==1) { for (int i=1;i&lt;=n;i++) { int x; scanf(&quot;%d&quot;, &amp;x); build(i, x); } build(0, 0); scanf(&quot;%d&quot;, &amp;m); for (int i=1;i&lt;=m;i++) { int x,y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); int x1 = find(x); int x2 = find(y);//找最强壮的 if (x1==x2) {printf(&quot;-1\n&quot;);continue;} lt[x1].key&gt;&gt;=1; lt[x2].key&gt;&gt;=1;//之后插入的值 int left = del(x1), right = del(x2); left = merge(left, x1), right = merge(right, x2); left = merge(left, right); printf(&quot;%d\n&quot;, lt[left].key); } } fclose(stdin);fclose(stdout); return 0; }]]></content>
      <categories>
        <category>Hdu</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>Hdu</tag>
        <tag>可并堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1452」「JSOI2009」Count (二维树状数组)]]></title>
    <url>%2Fbzoj1452%2F</url>
    <content type="text"><![CDATA[BZOJ 1452可以每一种颜色建一个二维树状数组，数据$O(n^2c)$的空间复杂度可以接受 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #define ms(i,j) memset(i, j, sizeof i); using namespace std; int n,m,Q; int a[300 + 5][300 + 5]; int lowbit(int x) { return x&amp;(-x); } struct bits { int a[300 + 5][300 + 5]; void init() { ms(a, 0); } void add(int x, int y, int c) { for (int i=x;i&lt;=n;i+=lowbit(i)) for (int j=y;j&lt;=n;j+=lowbit(j)) { a[i][j] += c; } } int sum(int x, int y) { int ret = 0; for (int i=x;i&gt;0;i-=lowbit(i)) for (int j=y;j&gt;0;j-=lowbit(j)) { ret += a[i][j]; } return ret; } int query(int x1, int y1, int x2, int y2) { return sum(x2, y2)+sum(x1-1, y1-1)-sum(x1-1, y2)-sum(x2, y1-1); } }b[100 + 5]; int main() { // freopen(&quot;bzoj1452.in&quot;, &quot;r&quot;, stdin); freopen(&quot;bzoj1452.out&quot;, &quot;w&quot;, stdout); for (int i=1;i&lt;=102;i++) b[i].init(); scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++) { scanf(&quot;%d&quot;, &amp;a[i][j]); b[a[i][j]].add(i,j,1); } scanf(&quot;%d&quot;, &amp;Q); for (int i=1;i&lt;=Q;i++) { int opt; scanf(&quot;%d&quot;, &amp;opt); if (opt==1) { int x, y, c; scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;c); b[a[x][y]].add(x,y,-1); b[a[x][y]=c].add(x,y,1); } else { int x1, x2, y1, y2, c; scanf(&quot;%d%d%d%d%d&quot;, &amp;x1, &amp;x2, &amp;y1, &amp;y2, &amp;c); printf(&quot;%d\n&quot;, b[c].query(x1,y1,x2,y2)); } } return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GDKOI 2017 总结]]></title>
    <url>%2FzzGDKOI2017%2F</url>
    <content type="text"><![CDATA[Day0 就随便复习了一下各种东西的模板Day1 t1:读题之后想到搜索，但是刚开始没想到怎么搜索，想到了图论，就构了一幅图，随便搞了一下发现空间会炸?就开了60%的空间，做其他题去了，这里浪费了1h+ t2:第一次粗读题时没想到思路，之后搞其他题目用的时间太多没空仔细看题，考完讲评据说是括号匹配? t3:看题输入数据只有两个，想暴力打表的，结果发现此题暴力挺难打，暴力始终没调试出来，浪费了0.5h+就做其他题去了 t4:看完题后想到设f[i][j]为左选i个，右选j个的最优值，但由于不会转移，改为贪心，设f[i]为左选i个的最优解，g[i]为右选i个的最优值，之后枚举一个k，则ans=max{f[i]+g[n-i]} day1成绩60+0+0+30，第一题就是一个搜索，想太复杂没拿全分数，以后每道题都先打一个暴力再去深究正解，可以保证分数，又可以用于对拍。第二题好像还比较简单?没留时间看似乎有些吃亏，以后时间要合理分配，不要在一道题上花太多时间。 Day2 t1:读题后想到打表?枚举每个点的坐标，勾股定理求边长，海伦公式求面积，但是似乎有些条件没判断好，总是会多算三角形，之后又发现好像有数学方法，推了一会儿没推出来，又在t1花了1.5h+ t2:没加条件前可以DP求最长上升子序列?加了以后不会了，输出每个字符串的长度了事 t3:一看就想打表，暴力很快就调试出来了，很激动，但是之后的事情太可怕——打表打了3h都没打出来，只能交了个500+的表 t4:题意特别迷..浪费了0.5h..调试不出就没搞了 day2爆零，第一题容斥原理和数学规律，还是不怎么会。第二题二分图匹配，没学过。第三题暴力能拿50?似乎题目用循环就可以做，我的dfs似乎复杂度很高。第四题链表辅助?还是不太会。以后要提高拿部分分的能力，提高打暴力的能力，提高时间分配的能力，还要多做题目。 GDKOI2017考的不是很好，没得到奖，希望能够从这次竞赛中，吸取教训，争取在今后的竞赛中获得好的成绩! 2017.2.25]]></content>
      <categories>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>杂文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1878」「SDOI2009」HH的项链 (莫队)]]></title>
    <url>%2Fbzoj1878%2F</url>
    <content type="text"><![CDATA[BZOJ 1878见此处讲解，莫队入门题 #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cmath&gt; using namespace std; #define ms(i, j) memset(i, j, sizeof i) #define ll long long const int MAXN = 1000000 + 5; int m, n, totblo, ai[MAXN], bl[MAXN]; struct query { int l, r, id, ans;//询问左边界，右边界，第几个询问，答案 }q[MAXN]; bool cmp1(const query &amp;a, const query &amp;b) {//莫队排序 if (bl[a.l] == bl[b.l]) return a.r &lt; b.r; return bl[a.l] &lt; bl[b.l]; } bool cmp2(const query &amp;a, const query &amp;b) { return a.id &lt; b.id; } int nl, nr, nans, tax[MAXN];//当前l位置，当前r位置，当前答案，桶 void clean() {nl = nr = nans = 0, ms(tax, 0);} void adjust(int x, int add) { if (tax[ai[x]] == 0 &amp;&amp; add == 1) nans++; tax[ai[x]] += add; if (tax[ai[x]] == 0 &amp;&amp; add == -1) nans--; /*一定要指明add 否则 对于询问区间1 3后询问5 8 会炸 */ } int solve() { clean(); totblo = sqrt(n); for (int i = 1; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;ai[i]); bl[i] = (i - 1) / totblo + 1; } scanf(&quot;%d&quot;, &amp;m); for (int i = 1; i &lt;= m; i++) { scanf(&quot;%d%d&quot;, &amp;q[i].l, &amp;q[i].r); q[i].id = i; } sort(q + 1, q + 1 + m, cmp1); nl = 1, nr = 0; for (int i = 1; i &lt;= m; i++) { while (nl &lt; q[i].l) adjust(nl , -1), nl++; while (nl &gt; q[i].l) adjust(nl - 1, +1), nl--; while (nr &lt; q[i].r) adjust(nr + 1, +1), nr++; while (nr &gt; q[i].r) adjust(nr , -1), nr--; q[i].ans = nans;//进行调整 } sort(q + 1, q + 1 + m, cmp2); for (int i = 1; i &lt;= m; i++) printf(&quot;%d\n&quot;, q[i].ans); return 0; } int main() { scanf(&quot;%d&quot;, &amp;n), solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bzoj 3445(最短路+枚举)]]></title>
    <url>%2Fbzoj3445%2F</url>
    <content type="text"><![CDATA[bzoj 3445Luogu免权限地址先对原图进行一次最短路，然后记录最短路上的边，然后枚举每一条边加倍，进行最短路，取每次最短路的答案减去原图最短路即可 #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;queue&gt; #define ms(i,j) memset(i,j, sizeof i); using namespace std; const int MAXN = 100 + 10, INF = 100000000; struct node { int dis, no; bool operator &lt; (const node &amp;b) const {return dis&gt;b.dis;} }; struct edge { int u,v; }E[5000+100]; int cnt = 0; int G[MAXN][MAXN]; int dis[MAXN]; int vi[MAXN]; int pre[MAXN]; int n,m; int ans = 0, oa; void fdij() { priority_queue&lt;node&gt; pq; for (int i=1;i&lt;=n;i++) dis[i] = INF, vi[i] = false, pre[i] = 0; dis[1] = 0; pq.push((node){0, 1}); while (!pq.empty()) { node p = pq.top(); pq.pop(); if (vi[p.no]) continue; vi[p.no] = true; for (int i=1;i&lt;=n;i++) if (G[i][p.no]!=INF) if (dis[p.no]+G[p.no][i]&lt;dis[i]) { dis[i] = dis[p.no]+G[p.no][i]; pre[i] = p.no; pq.push((node){dis[i], i}); } } oa = ans = dis[n]; } void dij() { priority_queue&lt;node&gt; pq; for (int i=1;i&lt;=n;i++) dis[i] = INF, vi[i] = false; dis[1] = 0; pq.push((node){0, 1}); while (!pq.empty()) { node p = pq.top(); pq.pop(); if (vi[p.no]) continue; vi[p.no] = true; for (int i=1;i&lt;=n;i++) if (G[i][p.no]!=INF) if (dis[p.no]+G[p.no][i]&lt;dis[i]) { dis[i] = dis[p.no]+G[p.no][i]; pq.push((node){dis[i], i}); } } ans = max(ans, dis[n]); } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=n;j++) G[i][j] = INF; for (int i=1;i&lt;=m;i++) { int x,y,z; scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z); G[x][y] = G[y][x] = z; } fdij(); int now = n; while (pre[now]!=0) { E[++cnt].u = now; E[ cnt].v = pre[now]; now = pre[now]; } for (int i=1;i&lt;=cnt;i++) { int x = E[i].u; int y = E[i].v; G[x][y] *= 2; G[y][x] *= 2; dij(); G[x][y] /= 2; G[y][x] /= 2; } printf(&quot;%d\n&quot;, ans-oa); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>最短路</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hdu 1828(线段树+扫描线)]]></title>
    <url>%2Fhdu1828%2F</url>
    <content type="text"><![CDATA[Hdu 1828线段树扫描线求周长并，看这篇好文学习：http://blog.csdn.net/tomorrowtodie/article/details/52048323 #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;vector&gt; #define ms(i,j) memset(i,j, sizeof i); using namespace std; const int MAXR = 10000 + 5; const int MAXN = 5000 + 5; const int Zinf = 100000; struct xian { int l, r, h; int f; bool operator&lt;(const xian &amp;b) const { return h&lt;b.h; } }a[MAXN*2]; int abss(int x) {return x&lt;0 ? -x : x;} int n; #define lc (o*2) #define rc (o*2+1) #define M ((l+r)&gt;&gt;1) struct st { int col[MAXR*4*4];//覆盖次数 int num[MAXR*4*4];//当前区间分离线段条数 int ls[MAXR*4*4], rs[MAXR*4*4];//左右结点是否被遮挡 int sum[MAXR*4*4];//计算时的有效区间长 void build(int o, int l ,int r) { col[o] = 0; num[o] = 0; ls[o] = rs[o] = 0; sum[o] = 0; if (l==r) return ; build(lc, l, M); build(rc, M+1, r); } void pushup(int o, int l, int r) { if (col[o]) { num[o] = 1; ls[o] = rs[o] = 1; sum[o] = r-l+1; } else if (l==r) { num[o] = 0; ls[o] = rs[o] = 0; sum[o] = 0; } else { ls[o] = ls[lc]; rs[o] = rs[rc]; sum[o] = sum[lc] + sum[rc]; num[o] = num[lc] + num[rc] - (rs[lc]&amp;&amp;ls[rc]); } } void update(int o, int l, int r, int x, int y, int c) { if (x&lt;=l&amp;&amp;r&lt;=y) { col[o] += c; pushup(o,l,r); return ; } if (x&lt;=M) update(lc, l, M, x, y, c); if (M&lt;y) update(rc, M+1, r, x, y, c); pushup(o,l,r); } }tree; int main() { while (scanf(&quot;%d&quot;, &amp;n)==1) { int minr = Zinf, maxr = -Zinf; for (int i=0;i&lt;n;i++) { int x1, y1, x2, y2; scanf(&quot;%d%d%d%d&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2); minr = min(minr, min(x1,x2)); maxr = max(maxr, max(x1,x2)); a[i*2].l = a[i*2+1].l = x1; a[i*2].r = a[i*2+1].r = x2; a[i*2].h = y1; a[i*2+1].h = y2; a[i*2].f = -1; a[i*2+1].f = 1; } sort(a, a+2*n);//数小，不用离散化。 tree.build(1, minr, maxr-1); int last = 0; int ans = 0; for (int i=0;i&lt;2*n;i++) { tree.update(1,minr,maxr-1,a[i].l, a[i].r-1, a[i].f); ans += abss(tree.sum[1]-last); ans += (a[i+1].h-a[i].h)*2*tree.num[1]; last = tree.sum[1]; } printf(&quot;%d\n&quot;,ans); } return 0; }]]></content>
      <categories>
        <category>Hdu</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>Hdu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bzoj 2427(Tarjan强连通分量+树形背包DP)]]></title>
    <url>%2Fbzoj2427%2F</url>
    <content type="text"><![CDATA[BZOJ传送门根据题目可以构造一幅图，可以得知这个图是一些森林和环，我们对图缩点，建立虚结点，使所有没有入度的强连通分量连接虚结点，再进行树上背包即可。(相关树形背包解法)17.8.13: 重写了一发 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;stack&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 100 + 5, MAXM = 500 + 5; int n, m, wi[MAXN], vi[MAXN]; vector&lt;int&gt; G[MAXN], RG[MAXN]; stack&lt;int&gt; s; int tb, low[MAXN], dn[MAXN], vis[MAXN], scc_size, scc_wi[MAXN], scc_vi[MAXN], scc_belong[MAXN], scc_ind[MAXN]; int dp[MAXN][MAXM]; void tarjan(int u) { low[u] = dn[u] = ++tb; vis[u] = -1 ,s.push(u); for (int i=0;i&lt;G[u].size();i++) { int v = G[u][i]; if (!vis[v]) tarjan(v), low[u] = min(low[u], low[v]); else if (vis[v] == -1) low[u] = min(low[u], dn[v]); } if (low[u] == dn[u]) { int e; scc_size++; do { e = s.top(); s.pop(); scc_wi[scc_size] += wi[e]; scc_vi[scc_size] += vi[e]; scc_belong[e] = scc_size; vis[e] = 1; } while (e != u); } } void dfs(int u) { for (int i=0;i&lt;RG[u].size();i++) { int v = RG[u][i]; dfs(v); for (int j=m-scc_wi[u];j&gt;=0;j--) { for (int k=0;k&lt;=j;k++) { dp[u][j] = max(dp[u][j], dp[u][j - k] + dp[v][k]); } } } for (int j=m;j&gt;=0;j--) { if (j &gt;= scc_wi[u]) dp[u][j] = dp[u][j - scc_wi[u]] + scc_vi[u]; else dp[u][j] = 0; } } void clean() { ms(scc_ind, 0), ms(dp, 0); wi[0] = vi[0] = tb = scc_size = 0; for (int i=0;i&lt;=n;i++) vis[i] = scc_belong[i] = scc_wi[i] = scc_vi[i] = 0, G[i].clear(), RG[i].clear(); } void solve() { clean(); for (int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;, &amp;wi[i]); for (int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;, &amp;vi[i]); for (int i=1;i&lt;=n;i++) { int x; scanf(&quot;%d&quot;, &amp;x); G[x].push_back(i); } for (int i=0;i&lt;=n;i++) if (!vis[i]) tarjan(i); for (int u=0;u&lt;=n;u++) { for (int i=0;i&lt;G[u].size();i++) { int v = G[u][i]; if (scc_belong[u] != scc_belong[v]) RG[scc_belong[u]].push_back(scc_belong[v]), scc_ind[scc_belong[v]]++; } } for (int i=1;i&lt;=scc_size;i++) if (scc_ind[i] == 0 &amp;&amp; i != scc_belong[0]) RG[scc_belong[0]].push_back(i);//不可以不加，即使在前面已经连上了0。如果一个图就是一个环，缩点之后0是无法到达这个点的，即di里没有0 dfs(scc_belong[0]); printf(&quot;%d\n&quot;, dp[scc_belong[0]][m]); } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif scanf(&quot;%d%d&quot;, &amp;n, &amp;m), solve(); return 0; } 旧： #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;vector&gt; #include&lt;stack&gt; #define ms(i,j) memset(i,j, sizeof i); using namespace std; const int MAXN = 100 + 5, MAXM = 500 + 5; int n,m; int wi[MAXN], vi[MAXN]; vector&lt;int&gt; G[MAXN]; int s_size = 0, s_no[MAXN], s_wi[MAXN], s_vi[MAXN], ino[MAXN]; vector&lt;int&gt; RG[MAXN]; stack&lt;int&gt; s; int ex[MAXN], sz = 0, dn[MAXN], low[MAXN]; void tarjan(int u) { dn[u] = low[u] = ++sz; ex[u] = -1; s.push(u); for (int i=0;i&lt;G[u].size();i++) { int v = G[u][i]; if (!ex[v]) { tarjan(v); low[u] = min(low[u], low[v]); } else if (ex[v]==-1) { low[u] = min(low[u], dn[v]); } } if (low[u]==dn[u]) { s_size++; int e; do { e = s.top(); s.pop(); s_no[e] = s_size; s_wi[s_size] += wi[e]; s_vi[s_size] += vi[e]; ex[e] = 1; } while(e!=u); } } void rebuild() { ms(ino,0); for (int u=0;u&lt;=n;u++) { for (int j=0;j&lt;G[u].size();j++) { int v = G[u][j]; if (s_no[v]!=s_no[u]) { RG[s_no[u]].push_back(s_no[v]); ino[s_no[v]]++; } } } for (int i=1;i&lt;=s_size;i++) if (!ino[i]&amp;&amp;s_no[0]!=i) RG[s_no[0]].push_back(i); } int f[MAXN][MAXM]; void dp(int u) { for (int i=0;i&lt;RG[u].size();i++) { int v = RG[u][i]; if (!ex[v]) { ex[v] = true; dp(v); for (int j=m-s_wi[u];j&gt;=0;j--) for (int k=0;k&lt;=j;k++) f[u][j] = max(f[u][j], f[u][j-k]+f[v][k]); } } for (int j=m;j&gt;=0;j--) { if (j&gt;=s_wi[u]) f[u][j] = f[u][j-s_wi[u]] + s_vi[u]; else f[u][j] = 0; } } int main() { scanf(&quot;%d%d&quot;, &amp;n,&amp;m); wi[0] = vi[0] = 0; for (int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;, &amp;wi[i]); for (int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;, &amp;vi[i]); for (int i=1;i&lt;=n;i++) { int di; scanf(&quot;%d&quot;, &amp;di); G[di].push_back(i); } ms(ex,0); ms(s_wi,0); ms(s_vi,0); for (int i=0;i&lt;=n;i++) if (!ex[i]) tarjan(i); rebuild(); ms(ex,0); ms(f,0); dp(s_no[0]); printf(&quot;%d\n&quot;, f[s_no[0]][m]); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>Tarjan</tag>
        <tag>树形DP</tag>
        <tag>背包DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bzoj 2330(差分约束)]]></title>
    <url>%2Fbzoj2330%2F</url>
    <content type="text"><![CDATA[BZOJ 2330差分约束。裸题不讲了。可以看我的差分约束学习笔记。注意这题直接把所有点加进来做，否则TLE，还要开long long #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;vector&gt; #include&lt;queue&gt; #define ms(i,j) memset(i,j, sizeof i); #define ll long long using namespace std; const int MAXN = 100000 + 5; ll n,k; struct edge { ll u,v,c; }E[MAXN*4]; ll e_num = 0; vector&lt;ll&gt; G[MAXN]; void addE(ll u, ll v, ll c) { e_num++; E[e_num].u = u; E[e_num].v = v; E[e_num].c = c; G[u].push_back(e_num); } ll dis[MAXN]; ll vi[MAXN]; ll cir[MAXN]; ll spfa() { queue&lt;ll&gt; q; for (ll i=1;i&lt;=n;i++) { dis[i] = 1; vi[i] = false; cir[i] = 1; q.push(i); } while (!q.empty()) { ll r = q.front(); q.pop(); for (ll i=0;i&lt;G[r].size();i++) { edge ed = E[G[r][i]]; vi[ed.v] = false; if (dis[ed.v]&lt;dis[r]+ed.c) { dis[ed.v] = dis[r]+ed.c; if (!vi[ed.v]) { cir[i]++; if (cir[i]&gt;n) { return false; } vi[ed.v] = true; q.push(ed.v); } } } } return true; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for (ll i=1;i&lt;=k;i++) { ll x,a,b; scanf(&quot;%lld%lld%lld&quot;, &amp;x, &amp;a, &amp;b); switch(x) { case 1: addE(a,b,0); addE(b,a,0); break; case 2: if (a==b) {printf(&quot;-1\n&quot;);return 0;} addE(a,b,1); break; case 3: addE(b,a,0); break; case 4: if (a==b) {printf(&quot;-1\n&quot;);return 0;} addE(b,a,1); break; case 5: addE(a,b,0); break; } } if(!spfa()) printf(&quot;-1\n&quot;); else { ll ans = 0; for (ll i=1;i&lt;=n;i++) { ans += dis[i]; } printf(&quot;%lld\n&quot;, ans); } return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1012」「JSOI2008」最大数maxnumber (线段树 / 树状数组)]]></title>
    <url>%2Fbzoj1012%2F</url>
    <content type="text"><![CDATA[BZOJ 1012树状数组解法：$c[i]$维护$[i-\operatorname{lowbit}(i)+1,i]$的最大值，$a[i]$为原数组 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;map&gt; #include&lt;string&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { LL m, D, x, cnt, lastans = 0; LL a[200000 + 5], c[200000 + 5]; // c[i]维护[i-lowbit(i)+1,i]的最大值，a[i]为原数组 char s[5]; LL lowbit(LL x) {return x &amp; (-x);} LL query(LL l, LL r) { LL ret = a[r]; while (l &lt;= r) { ret = max(ret, a[r]); for (--r; r - l &gt;= lowbit(r); r -= lowbit(r)) ret = max(ret, c[r]); } return ret; } void clean() { cnt = 0, ms(a, 0), ms(c, 0); } int solve() { clean(); cin &gt;&gt; m &gt;&gt; D; for (LL i = 1; i &lt;= m; ++i) { scanf(&quot;%s%lld&quot;, s, &amp;x); if (s[0] == &#39;A&#39;) { a[++cnt] = (x + lastans) % D; c[cnt] = max(a[cnt], query(cnt - lowbit(cnt) + 1, cnt)); } else { printf(&quot;%lld\n&quot;, lastans = query(cnt - x + 1, cnt)); } } return 0; } } int main() { flyinthesky::solve(); return 0; } 线段树解法：线段树维护区间最大值单点修改即可。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;stack&gt; #include&lt;set&gt; #include&lt;queue&gt; #include&lt;climits&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; #define lc (o &lt;&lt; 1) #define rc (o &lt;&lt; 1 | 1) #define M ((l + r) &gt;&gt; 1) namespace flyinthesky { const LL MAXN = 200000 + 5; LL now, n, d; LL maxv[MAXN * 4]; char s[4]; void pushup(LL o) {maxv[o] = max(maxv[lc], maxv[rc]);} void build(LL o, LL l, LL r) { maxv[o] = 0; if (l == r) return ; else build(lc, l, M), build(rc, M + 1, r); pushup(o); } LL query(LL o, LL l, LL r, LL x, LL y) { if (x &lt;= l &amp;&amp; r &lt;= y) return maxv[o]; LL ans = 0; if (x &lt;= M) ans = max(ans, query(lc, l, M, x, y)); if (M &lt; y) ans = max(ans, query(rc, M + 1, r, x, y)); return ans; } void update(LL o, LL l, LL r, LL p, LL v) { if (l == r) {maxv[o] = v; return ;} if (p &lt;= M) update(lc, l, M, p, v); else if (M &lt; p) update(rc, M + 1, r, p, v); pushup(o); } void clean() { now = 0; } int solve() { scanf(&quot;%lld%lld&quot;, &amp;n, &amp;d); clean(); build(1, 1, n); LL t = 0; for (LL x, i = 1; i &lt;= n; i++) { scanf(&quot;%s%lld&quot;, s, &amp;x); if (s[0] == &#39;A&#39;) update(1, 1, n, ++now, (x + t) % d); else printf(&quot;%lld\n&quot;, t = query(1, 1, n, now - x + 1, now)); } return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>线段树</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Hdu 1542」Atlantis (线段树 + 扫描线)]]></title>
    <url>%2Fhdu1542%2F</url>
    <content type="text"><![CDATA[Hdu 1542线段树离散化以后进行扫描线求面积并。 具体就是用一条平行于$y$轴的直线自左向右地扫过去，然后每次扫到一个整块长方形记录面积。记录方法是，一个矩形分成左右两个边，左边在线段树中增加，右边在线段树中减少。则当前线段树中的所有大于0的数的个数即为当前长方形的一边。另一边为当前边横坐标减去前一条边的横坐标。 需要离散化。 这里维护的线段树很特殊，只需要查询根节点的和，则在线段树直接维护离散前的数据长度，记录一下区间覆盖次数，大于0则有值，否则没有。注意线段树里面每个点维护的是第几段的覆盖次数。 http://www.cnblogs.com/scau20110726/archive/2013/03/21/2972808.html2018/12/25 重写 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;set&gt; #include&lt;queue&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; int kse = 0; namespace flyinthesky { const int MAXN = 500 + 5; struct data { int ymin, ymax, v; db x, fymin, fymax; bool operator &lt; (const data &amp;rhs) const {return x &lt; rhs.x;} } cz[1000]; int n, cnt, czcnt, minpos; db whw[1000], ans; #define lc (o &lt;&lt; 1) #define rc (o &lt;&lt; 1 | 1) #define M ((l + r) &gt;&gt; 1) db sumv[MAXN * 4]; int lazy[MAXN * 4]; void pushup(int o, int l, int r) { if (lazy[o]) { sumv[o] = whw[r + 1] - whw[l]; } else sumv[o] = sumv[lc] + sumv[rc]; } void update(int o, int l, int r, int x, int y, int v) { if (x &lt;= l &amp;&amp; r &lt;= y) { lazy[o] += v; if (lazy[o] &gt; 0) sumv[o] = whw[r + 1] - whw[l]; else sumv[o] = sumv[lc] + sumv[rc]; return ; } if (x &lt;= M) update(lc, l, M, x, y, v); if (M &lt; y) update(rc, M + 1, r, x, y, v); pushup(o, l, r); } void clean() { ms(sumv, 0), ms(lazy, 0), ans = 0.0, czcnt = cnt = 0; } int solve() { clean(); for (int i = 1; i &lt;= n; ++i) { db x1, y1, x2, y2; scanf(&quot;%lf%lf%lf%lf&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2); cz[++czcnt] = (data){0, 0, 1, x1, y1, y2}; cz[++czcnt] = (data){0, 0, -1, x2, y1, y2}; whw[++cnt] = y1, whw[++cnt] = y2; } sort(whw + 1, whw + 1 + cnt), cnt = unique(whw + 1, whw + 1 + cnt) - whw - 1; for (int i = 1; i &lt;= czcnt; ++i) cz[i].ymin = lower_bound(whw + 1, whw + 1 + cnt, cz[i].fymin) - whw - 1, cz[i].ymax = lower_bound(whw + 1, whw + 1 + cnt, cz[i].fymax) - whw - 1; // for (int i = 1; i &lt;= czcnt; ++i) printf(&quot;cz %d: x=%.2lf, ymin=%.2lf, ymax=%.2lf, opt=%d\n&quot;, i, cz[i].x, cz[i].fymin, cz[i].fymax, cz[i].v); // for (int i = 1; i &lt;= czcnt; ++i) printf(&quot;cz %d: x=%.2lf, ymin=%d, ymax=%d, opt=%d\n&quot;, i, cz[i].x, cz[i].ymin, cz[i].ymax, cz[i].v); sort(cz + 1, cz + 1 + czcnt); cz[0] = (data){-1, -1, 0, 0, 0, 0}; for (int i = 1; i &lt;= czcnt; ++i) { ans += sumv[1] * (cz[i].x - cz[i - 1].x); if (cz[i].ymin + 1 &lt;= cz[i].ymax) update(1, 1, cnt, cz[i].ymin + 1, cz[i].ymax, cz[i].v); } printf(&quot;Test case #%d\nTotal explored area: %.2f\n\n&quot;, ++kse, ans); return 0; } } int main() { while (scanf(&quot;%d&quot;, &amp;flyinthesky::n) == 1 &amp;&amp; flyinthesky::n) flyinthesky::solve(); return 0; } #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;vector&gt; #define ms(i,j) memset(i,j, sizeof i); using namespace std; const int MAXN = 100 + 5; struct xian { int f; //up or down, up is -1, down is 1 double l, r;//the interval&#39;s end points double h;//height bool operator &lt; (const xian &amp;b) const { return h&lt;b.h; } }a[MAXN*2]; double hashs[MAXN*2];//the hashsed points int n; #define lc o*2 #define rc o*2+1 #define M (l+r)/2 struct st { int col[MAXN*4*4];//col[i]&gt;0 means this inerval was full marked double sum[MAXN*4*4];//available room void pushup(int o, int l, int r) { if (col[o]&gt;0) { sum[o] = hashs[r+1]-hashs[l]; } else if (l==r) sum[o] = 0; else { sum[o] = sum[lc] + sum[rc]; } } void update(int o, int l ,int r, int x, int y, int c) { if (x&lt;=l&amp;&amp;r&lt;=y) { col[o] += c; pushup(o,l,r); return ; } if (x&lt;=M) update(lc,l,M,x,y,c); if (M&lt;y) update(rc,M+1,r,x,y,c); pushup(o,l,r); } }tree; //binary-search the elements in hashs[] int find(int x, int y, double v) { int l = x, r = y, mid; while (l&lt;r) { mid = (l+r)/2; if (v&gt;hashs[mid]) { l = mid+1; } else r = mid; } return r; } int main() { int kase = 0; while (scanf(&quot;%d&quot;, &amp;n)==1&amp;&amp;n) { kase++; for (int i=0;i&lt;n;i++) { double x1, y1, x2, y2; scanf(&quot;%lf%lf%lf%lf&quot;, &amp;x1,&amp;y1,&amp;x2,&amp;y2); a[i*2].f = 1; a[i*2+1].f = -1; a[i*2].l = x1; a[i*2+1].l = x1; a[i*2].r = x2; a[i*2+1].r = x2; a[i*2].h = y1; a[i*2+1].h = y2;//add xian hashs[i*2] = x1; hashs[i*2+1] = x2;//add hashs } sort(hashs, hashs+2*n); sort(a, a+2*n); //sort to hashs //delete the repeated elements int m = 1; for (int i=1;i&lt;2*n;i++) if (hashs[i]!=hashs[i-1]) hashs[m++] = hashs[i]; //produce ms(tree.col, 0); double ans = 0; for (int i=0;i&lt;n*2;i++) { int l = find(0, m, a[i].l); int r = find(0, m, a[i].r)-1; /*int l = lower_bound(hashs, hashs+m, a[i].l)-hashs; int r = lower_bound(hashs, hashs+m, a[i].r)-hashs-1;*/ if (r&gt;=l) tree.update(1,0,m-2,l,r,a[i].f);//一定要r&gt;=l,这里原来错了 ans += (a[i+1].h-a[i].h)*tree.sum[1]; } printf(&quot;Test case #%d\nTotal explored area: %.2f\n\n&quot;, kase, ans); } return 0; }]]></content>
      <categories>
        <category>Hdu</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>Hdu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hdu 2087(KMP)]]></title>
    <url>%2Fhdu2087%2F</url>
    <content type="text"><![CDATA[Hdu 2087KMP即可。注意不可重叠，用一个$last$记录上一个不重复匹配成功的位置，之后如果匹配成功，记当前位置为$i$，如果$i-last&gt;模式串长度$，即匹配成功，更新$last$ #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #define ms(i,j) memset(i,j, sizeof i); using namespace std; char s1[1000 + 5], s2[1000 + 5]; int f[1000 + 5]; void getFail() { int len = strlen(s2); f[0] = f[1] = 0; for (int i=1;i&lt;len;i++) { int j = f[i]; while (j &amp;&amp; s2[i]!=s2[j]) j = f[j]; f[i+1] = (s2[i]==s2[j]) ? (j+1) : (0); } } int KMP() { int len = strlen(s1); int l2 = strlen(s2); int last = -1; int ret = 0; int j = 0; for (int i=0;i&lt;len;i++) { while (j &amp;&amp; s1[i]!=s2[j]) j = f[j]; if (s1[i]==s2[j]) j++; if (j==l2) { if (i-last&gt;=l2) { ret++; last = i; } } } return ret; } int main() { while (scanf(&quot;%s&quot;, s1)&amp;&amp;s1[0]!=&#39;#&#39;) { scanf(&quot;%s&quot;, s2); getFail(); printf(&quot;%d\n&quot;, KMP()); } return 0; }]]></content>
      <categories>
        <category>Hdu</category>
      </categories>
      <tags>
        <tag>KMP</tag>
        <tag>Hdu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hdu 2222(AC自动机)]]></title>
    <url>%2Fhdu2222%2F</url>
    <content type="text"><![CDATA[Hdu 2222AC自动机模板题，注意重复关键字的处理2017.11.18 重写 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; int n, sz = 500000, ch[500000 + 5][30], val[500000 + 5], tms[500000 + 5], lst[500000 + 5], f[500000 + 5], used[10000 + 5]; //n，节点时间戳，字典树数组，是否是单词, 单词出现个数，上一个单词位置(后缀链接)，失配函数，该单词是否记录过 char s[1000000 + 5]; int ans;//答案 void g(int u) {//统计 if (!used[val[u]] &amp;&amp; u) ans += tms[u], used[val[u]] = true, g(lst[u]); //如果没有记录过并且有单词(u!=0), 则加上数量继续向下递归处理 } void insert(char *s, int u, int ith, int a, int len) {//插入一个单词(递归更新，不建议) int c = s[a] - &#39;a&#39;; if (ch[u][c] == 0) ch[u][c] = ++sz;//新建节点 if (a == len - 1) val[ch[u][c]] = ith, tms[ch[u][c]]++; else insert(s, ch[u][c], ith, a + 1, len); //如果是最后一个要加是单词的标记，并且注意重复的单词 } void insert(char *s, int ith) {//插入一个单词(迭代更新，建议) int now = 0, len = strlen(s); for (int i = 0; i &lt; len; i++) { int c = s[i] - &#39;a&#39;; if (!ch[now][c]) ch[now][c] = ++sz;//新建节点 now = ch[now][c]; if (i == len - 1) val[now] = ith, tms[now]++; //如果是最后一个要加是单词的标记，并且注意重复的单词 } } void find(char *T) {//用字符串T当做文本串找模式串 int len = strlen(T), j = 0;//从0开始 for (int i = 0; i &lt; len; i++) { int c = T[i] - &#39;a&#39;; j = ch[j][c]; if (val[j]) g(j); else if (lst[j]) g(lst[j]);//如果当前位置有单词或者有上一个单词(不会多余, 例子1看代码末行)则处理 } } void getFail() {//得到失配函数 queue&lt;int&gt; q; f[0] = 0;//初始化开始点的失配函数为0 for (int c = 0; c &lt; 26; c++) {//初始化所以与0相连的点 int v = ch[0][c]; if (v) q.push(v), f[v] = 0, lst[v] = 0; } while (!q.empty()) {//bfs更新 int u = q.front(); q.pop(); for (int c = 0; c &lt; 26; c++) { int v = ch[u][c]; if (!v) {ch[u][c] = ch[f[u]][c]; continue;} //Trie上没有这条边 q.push(v); int j = f[u]; while (j &amp;&amp; !ch[j][c]) j = f[j];//沿着失配边走 f[v] = ch[j][c], lst[v] = (val[f[v]]) ? (f[v]) : (lst[f[v]]); //得到失配函数值，求出lst值 } } } void clean() {//清除 for (int i = 0; i &lt;= sz; i++) { for (int j = 0; j &lt; 26; j++) ch[i][j] = 0; f[i] = lst[i] = val[i] = tms[i] = 0; } for (int i = 0; i &lt;= n; i++) used[i] = false; sz = 0; } void solve() { scanf(&quot;%d&quot;, &amp;n); clean(); for (int i = 1; i &lt;= n; i++) { scanf(&quot;%s&quot;, s); //insert(s, 0, i, 0, strlen(s));//递归 insert(s, i);//迭代 } scanf(&quot;%s&quot;, s); getFail(), ans = 0, find(s); printf(&quot;%d\n&quot;, ans); } int main() { int T; scanf(&quot;%d&quot;, &amp;T); while (T--) solve(); return 0; } /* 例子1： 1 2 errd rr errd 如果不执行该语句，rr则不能被算入 */ 旧： #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;queue&gt; #define ms(i,j) memset(i,j, sizeof i); using namespace std; const int MAXN = 10000 + 5, _SIZE = 26; int n; struct acam { int sz;//结点编号 int res; int ch[MAXN*51][_SIZE];//Tire int last[MAXN*51];//后缀链接 int f[MAXN*51];//失配函数 int val[MAXN*51][2];//结点的权值 bool used[MAXN*51];//用过 void init()//初始化 { ms(val,0); ms(ch,0); ms(used,false); sz = 1; res = 0; } void insert(char *s, int v)//插入一个模板 { int u = 0; int len = strlen(s); for (int i=0;i&lt;len;i++) { int c = s[i] - &#39;a&#39;; if (ch[u][c]) { u = ch[u][c]; } else { ch[u][c] = ++sz; u = ch[u][c]; } if (i==len-1) { val[u][0] = v; val[u][1]++; } } } void g(int j)//递归更新cnt { if (j&amp;&amp;!used[val[j][0]]) { res+=val[j][1]; used[val[j][0]] = true; g(last[j]); } } void find(char *T)//在T中匹配 { int len = strlen(T); int j = 0; for (int i=0;i&lt;len;i++) { int c = T[i] - &#39;a&#39;; j = ch[j][c]; if (val[j][0]) g(j); else if (last[j]) g(last[j]); } } void getFail()//获得失配函数 { queue&lt;int&gt; q; f[0] = 0; for (int c=0;c&lt;_SIZE;c++)//初始化进队 { int u = ch[0][c]; if (u) { q.push(u); f[u] = 0; last[u] = 0; } } while (!q.empty()) { int r = q.front(); q.pop(); for (int c=0;c&lt;_SIZE;c++) { int u = ch[r][c]; if (!u) { ch[r][c] = ch[f[r]][c]; continue; } q.push(u); int j = f[r]; while (j&amp;&amp;!ch[j][c]) j = f[j]; f[u] = ch[j][c]; last[u] = (val[f[u]][0]) ? (f[u]) : (last[f[u]]); } } } }ac; char s[1000000 + 5]; int main() { int kase; scanf(&quot;%d&quot;, &amp;kase); while (kase--) { ac.init(); scanf(&quot;%d&quot;, &amp;n); for (int i=1;i&lt;=n;i++) { scanf(&quot;%s&quot;, s); ac.insert(s,i); } scanf(&quot;%s&quot;, s); ac.getFail(); ac.find(s); printf(&quot;%d\n&quot;, ac.res); } return 0; }]]></content>
      <categories>
        <category>Hdu</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
        <tag>Hdu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1823」「JSOI2010」满汉全席 (2-SAT)]]></title>
    <url>%2Fbzoj1823%2F</url>
    <content type="text"><![CDATA[BZOJ 1823经典2-SAT模型，注意输入Tarjan版本： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;stack&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; int tb, n, m, belongs[2 * 100 + 5], vis[2 * 100 + 5], scc_num, dfn[2 * 100 + 5], low[2 * 100 + 5]; vector&lt;int&gt; G[2 * 100 + 5];//2x-&gt;m 2x+1-&gt;h stack&lt;int&gt; s; void tarjan(int u) { dfn[u] = low[u] = ++tb, vis[u] = -1, s.push(u); for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i]; if (vis[v] == 0) { tarjan(v); low[u] = min(low[u], low[v]); } else if (vis[v] == -1) low[u] = min(low[u], dfn[v]); } if (low[u] == dfn[u]) { int e; scc_num++; do { e = s.top(); s.pop(); belongs[e] = scc_num; vis[e] = 1; } while (e != u); } } int getss() { char ans; while (true) { ans = getchar(); if (ans == &#39;m&#39;) return 0; if (ans == &#39;h&#39;) return 1; int ret = 0; while (ans &gt;= &#39;0&#39; &amp;&amp; ans &lt;= &#39;9&#39;) { ret = ret * 10 + ans - &#39;0&#39;; ans = getchar(); } if (ret &gt; 0) return ret; } } void clean() { tb = scc_num = 0; for (int i = 0; i &lt;= 2 * 100 + 1; i++) dfn[i] = low[i] = belongs[i] = vis[i] = 0, G[i].clear(); } void solve() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); clean(); char c1, c2; int a1, a2; for (int i = 1; i &lt;= m; i++) { c1 = getss(), a1 = getss(), c2 = getss(), a2 = getss(); int x = 2 * (a1 - 1) + (c1 == 1) , y = 2 * (a2 - 1) + (c2 == 1); G[x].push_back(y ^ 1), G[y].push_back(x ^ 1); } for (int i = 1; i &lt;= n * 2; i++) if (!vis[i]) tarjan(i); for (int i = 1; i &lt;= 2 * n; i += 2) { if (belongs[i] == belongs[i ^ 1]) { printf(&quot;BAD\n&quot;); return ; } } printf(&quot;GOOD\n&quot;); } int main() { int T; scanf(&quot;%d&quot;, &amp;T); while (T--) solve(); return 0; } #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;vector&gt; #define ms(i,j) memset(i,j, sizeof i); using namespace std; const int MAXN = 100 + 5; struct twoSAT { bool mark[MAXN*2]; vector&lt;int&gt; G[MAXN*2]; int n; int c, S[MAXN*2]; void init(int ni) { n = ni; for (int i=0;i&lt;2*n;i++) G[i].clear(); ms(mark, false); } bool dfs(int x) { if (mark[x^1]) return false; if (mark[x]) return true; mark[x] = true; S[++c] = x; for (int i=0;i&lt;G[x].size();i++) if (!dfs(G[x][i])) return false; return true; } void addE(int x, int y, int xv, int yv) { x = x * 2 + xv; y = y * 2 + yv; G[x^1].push_back(y); G[y^1].push_back(x);//2x for man, 2x+1 for han } bool solve() { for (int i=0;i&lt;2*n;i+=2) if (!mark[i] &amp;&amp; !mark[i+1]) { c = 0; if (!dfs(i)) { for (int j=1;j&lt;=c;j++) mark[S[j]] = false; c = 0; if (!dfs(i+1)) return false; } } return true; } }ts; int k; int n,m; int getss() { char ans; while (true) { ans = getchar(); if (ans==&#39;m&#39;) return 0; if (ans==&#39;h&#39;) return 1; int ret = 0; while (ans&gt;=&#39;0&#39;&amp;&amp;ans&lt;=&#39;9&#39;) { ret = ret*10+ans-&#39;0&#39;; ans = getchar(); } if (ret&gt;0) return ret; } } void inpu() { int v1 = getss(); int z1 = getss(); int v2 = getss(); int z2 = getss(); ts.addE(z1-1, z2-1, v1, v2); } int main() { scanf(&quot;%d&quot;, &amp;k); while (k--) { scanf(&quot;%d%d&quot;, &amp;n,&amp;m); ts.init(n); for (int i=0;i&lt;m;i++) { inpu(); } if (ts.solve()) { printf(&quot;GOOD\n&quot;); } else printf(&quot;BAD\n&quot;); } return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>2-SAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bzoj 2199(2-SAT)]]></title>
    <url>%2Fbzoj2199%2F</url>
    <content type="text"><![CDATA[BZOJ 2199luogu免权限地址2-SAT模板题，用2-SAT建图后，枚举每个议案能否通过 #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;vector&gt; #define ms(i,j) memset(i,j, sizeof i); using namespace std; const int MAXN = 1000 + 5; const char orz[10] = {&#39;Y&#39;, &#39;N&#39;, &#39;?&#39;}; int n,m; int ans[MAXN]; struct twoSAT//这里标号从0开始 { vector&lt;int&gt; G[MAXN*2];//邻接表 bool mark[MAXN*2];//每个点是否被标记 int n; int init(int ni)//初始化 { n = ni; for (int i=0;i&lt;2*n;i++) G[i].clear(); } int addEdge(int x, int y, int xv, int yv)//加一个条件 { x = x*2+xv; y = y*2+yv; G[x^1].push_back(y); G[y^1].push_back(x);//2i是假，2i+1是真 } int dfs(int x) { if (mark[x^1]) return false;//对应点被标记，不符合要求 if (mark[x]) return true;//已经被标记直接返回 mark[x] = true;//标记 for (int i=0;i&lt;G[x].size();i++)//继续标记 { if (!dfs(G[x][i])) return false; } return true; } int check(int x)//检查一个议案是否通过 { ms(mark, false); return dfs(x); } }ts; int main() { scanf(&quot;%d%d&quot;, &amp;n,&amp;m); ts.init(n); for (int i=0;i&lt;m;i++) { int bi,ci; char vbi,vci; scanf(&quot;%d %c %d %c&quot;, &amp;bi,&amp;vbi,&amp;ci,&amp;vci); int vvbi = false, vvci = false; if (vbi==&#39;Y&#39;) vvbi = true; if (vci==&#39;Y&#39;) vvci = true; ts.addEdge(bi-1,ci-1,vvbi,vvci); } for (int i=0;i&lt;n;i++) { int p = ts.check(i*2); int q = ts.check(i*2+1); if (!p&amp;&amp;!q) {printf(&quot;IMPOSSIBLE&quot;); return 0;} if (p&amp;&amp;q) ans[i] = 2; else if (!p) ans[i] = 0; else ans[i] = 1; } for (int i=0;i&lt;n;i++) putchar(orz[ans[i]]); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>2-SAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Bzoj 1593」「Usaco2008 Feb」Hotel 旅馆(线段树)]]></title>
    <url>%2Fbzoj1593%2F</url>
    <content type="text"><![CDATA[BZOJ 1593luogu免权限地址线段树记录4个信息：lm: 左端点开始最长连续空区间rm: 右端点开始最长连续空区间sum:整个区间最长连续空区间lazy:lazy标记 (-1:没有标记 0:空区间 1:满区间)具体请看代码 #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;vector&gt; #define ms(i,j) memset(i,j, sizeof i); using namespace std; #define lc o*2 #define rc o*2+1 #define M (l+r)/2 const int MAXN = 100000 + 5; int n,m; struct st//线段树 { int lm[MAXN*4], rm[MAXN*4], lazy[MAXN*4], sum[MAXN*4]; //lm: 左端点开始最长连续空区间 //rm: 右端点开始最长连续空区间 //sum:整个区间最长连续空区间 //lazy:lazy标记 (-1:没有标记 0:空区间 1:满区间) void build(int o, int l, int r) { lm[o] = rm[o] = sum[o] = r-l+1; lazy[o] = -1; if (l==r) return ; build(lc, l, M); build(rc, M+1, r); } //建树 void pushup(int o, int len) { lm[o] = lm[lc]; if (lm[lc]==len-len/2) lm[o] += lm[rc]; //如果左孩子全部为可用区间，那么加上右孩子的左端 rm[o] = rm[rc]; if (lm[rc]==len/2) rm[o] += rm[lc]; //如果右孩子全部为可用区间，那么加上左孩子的右端 sum[o] = max(max(sum[lc], sum[rc]), rm[lc]+lm[rc]); //左孩子最大的空区间、有孩子最大的空区间，和跨越左右孩子加在一起的空区间 } void pushdown(int o, int len) { if(lazy[o]!=-1) { if (lazy[o]==1) { sum[lc]=sum[rc]=lm[lc]=rm[lc]=lm[rc]=rm[rc]=0;//全部空 } else { sum[lc]=lm[lc]=rm[lc]=len - len/2; sum[rc]=lm[rc]=rm[rc]=len/2;//全部满 } lazy[lc]=lazy[rc]=lazy[o]; lazy[o] = -1;//传lazy } } void update(int o, int l, int r, int x, int y, int ty) { if(x&lt;=l&amp;&amp;r&lt;=y) { lazy[o] = ty; if (ty==1) sum[o]=lm[o]=rm[o]=0; else sum[o]=lm[o]=rm[o]=r-l+1; return ; } pushdown(o, r-l+1); if (x&lt;=M) update(lc,l,M,x,y,ty); if (M&lt;y) update(rc,M+1,r,x,y,ty); pushup(o,r-l+1); } int query(int o, int l, int r, int w) { if (l==r) return l; pushdown(o,r-l+1); if (sum[lc]&gt;=w) return query(lc,l,M,w); if (rm[lc]+lm[rc]&gt;=w) return M-rm[lc]+1; if (sum[rc]&gt;=w) return query(rc,M+1,r,w); } }tree; int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); tree.build(1,1,n); for (int i=1;i&lt;=m;i++) { int type; scanf(&quot;%d&quot;, &amp;type); if (type==1) { int x; scanf(&quot;%d&quot;, &amp;x); if (tree.sum[1]&lt;x) printf(&quot;0\n&quot;); else { int ans = tree.query(1,1,n,x); printf(&quot;%d\n&quot;, ans); tree.update(1,1,n,ans,ans+x-1,1); } } else { int x,y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); tree.update(1,1,n,x,x+y-1,0); } } return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bzoj 2060(树形DP)]]></title>
    <url>%2Fbzoj2060%2F</url>
    <content type="text"><![CDATA[(BZOJ 2060)[http://www.lydsy.com/JudgeOnline/problem.php?id=2060]luogu免权限地址设状态$f[i][0]$为$i$点不访问，$f[i][1]$为$i$点访问 $f[u][1] += f[v][0] $ u点要访问，(u,v)有连边$f[u][0] += max(f[v][0], f[v][1]) $ u点不访问，(u,v)有连边 #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;vector&gt; #define ms(i,j) memset(i,j, sizeof i); using namespace std; const int MAXN = 50000 + 5; int n; vector&lt;int&gt; G[MAXN]; int vi[MAXN]; int dp[MAXN][2];//0:不拜访i点 ，1:拜访i点 int dfs(int u) { dp[u][1] = 1; for (int i=0;i&lt;G[u].size();i++) { int v = G[u][i]; if(!vi[v]) { vi[v] = true; dfs(v); dp[u][0] += max(dp[v][0], dp[v][1]); dp[u][1] += dp[v][0]; } } } int main() { scanf(&quot;%d&quot;, &amp;n); for (int i=1;i&lt;n;i++) { int x,y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); G[x].push_back(y); G[y].push_back(x); } ms(vi,false);ms(dp,0);vi[1] = true;//不要忘了节点1的访问数组赋值 dfs(1); printf(&quot;%d\n&quot;, max(dp[1][0], dp[1][1])); return 0; }]]></content>
      <categories>
        <category>Bzoj</category>
      </categories>
      <tags>
        <tag>Bzoj</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语高级词汇合集]]></title>
    <url>%2Fwhk%E8%8B%B1%E8%AF%AD%E9%AB%98%E7%BA%A7%E8%AF%8D%E6%B1%87%2F</url>
    <content type="text"><![CDATA[like/love改be fond oflike/love = be fond of 例句1：I like the book. = I’ m fond of the book.例句2：I like to coding. = I’m fond of coding. be in改be located inbe in = be located in 例句：Guangdong is in China. = Guangdong is located in China. want改desire / be dying to dowant to do sth. = desire to do sth.want sth. = desire (for) sth. 例句1：I want to swim. = I desire to swim.例句2：I want some fish. = I desire (for) some fish. spend改devotesb. spend time/money (in) doing sth. = sb. devote time/money to doing sth.sb. spend time/money on sth. = sb. devote time/money to sth. 例句1：I spent two hours (in) coding. = I devoted two hours to coding.例句2：I spent two hours on the movie called Your Name. = I devoted two hours to the movie called Your Name. because of改due tobecause of = due to 例句：The sports meeting was put off because of the rain. = The sports meeting was put off due to the rain. as soon as改onon …(从句的动名词复合结构), (主句) = as soon as (从句), (主句) 例句：As soon as I look for my bag, he comes in. = On my looking for my bag, he comes in. be adj.改be of n.be adj. = be of n. 例句：The book is useful to me. = The book is of great use to me. have to do改can’ t but do/ can’ t help but dohave to do = can’ t but do/ can’ t help but do 例句1：I have to do my homework. = I can’t but do my homework.例句2：I have to do my homework. = I can’ t help but do my homework. usually改more often than notusually = more often than not(句首) 例句：I usually do my homework first. = More often than not, I do my homework. most of改the majority ofmost of = the majority of 例句：Most of the students are good. = The majority of the students are good. help改do sb. a favor to dohelp = do sb. a favor to do 例句：Can you help me? = Can you do me a favor? as a result改as a consequenceas a result = as a consequence 例句：As a result, it is a joke. = As a consequence, it is a joke. all kinds of / different kinds of改variousvariety-&gt;diversity with / be good at改 equipped with / blessed with / armed withbe good at 改 have a good command of sthfight for 改 struggle forbe worth doing 改 be worthwhile to dosee sb. do sth. 改 observe sb. do sth.take part in 改 get involved in / participate ina lot of 改 a variety of / a great deal of / a diversity oftraditional 改 conventional*have faith in sb.**for one thing, … , and for another thing*attract sb. 改 appeal to sb.focus on 改 concentrate ondecide to do 改 aim to do / with the intent of doing / with the aim ofsadly 改 to one’s sorrowspecial 改 in particularpoper 改 suitable / appropriate*be addicted to*in fact 改 as a matter of fact*deserve sb. …**some … ; others … ; still others …*control 改 regulate*put stress on sth. / stress that …**form the habit of doing*with the help of 改 with the assistance of*especially …**in terms of sth.*lead to 改 result in / result frompromise to do 改 commit to doingcontrol one’s excitment 改 contain one’s excitment*attached to email is …*credit … with = praise … for*It suddenly dawn on sb. / occur to sb.*try to do 改 Make all effort to do sth. = spare no effort to do sth.spend time doing 改 employ time doing*extend apology/gratitude/congratulations/invitation to sb.**With one’s eye fixed on sth.**vary in sth. from … to …*range from … to .. enough 改 adequate解释 改 illustrate*by means of*be different from 改 be distinct from*in the majority / in the minority*have nothing to do with 改 have no relevance to 有关：be relevant to*come into operation**hear sb. out*express 改 conveydevelop 改 cultivateordinary 改 averagebe rich in 改 be abundant inserious 改 severefinally 改 eventuallybe tried of 改 be fed up withduring 改 in the course ofadd up to 改 amount tobe coming soon 改 be approachingremember sth. 改 keep sth. in mindaffect 改 have an impact onrefuse to do 改 decline to douse 改 make use of*sth. occur to sb.*increase raise improve 改 promote*put forward suggestions*be good for 改 be beneficial toIt’s known that… 改 It’s universally acknowledged that …be different from 改 be in contradiction to/with*be occupied with sth.**in abundance / an abundance of**in vain**strike … into one’s heart**can’t resist doing sth.**owe sth. to sb. / owe it to sb that**Then came the adj. news that …**seize an opportunity**seize sb. by the arm*]]></content>
      <categories>
        <category>文化课</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[初中数学相似三角形(平面几何)做题笔记]]></title>
    <url>%2Fwhk%E6%95%B0%E5%AD%A6%E7%9B%B8%E4%BC%BC%E4%B8%89%E8%A7%92%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[平行相似如图1中的(1)，$AB∥CD$，则$△ABO∽△DCO$(“8”形)如图1中的(2)，$AB∥CD$，则$△OAB∽△OCD$(“A”形) 非平行的相似情况如图2中的(1), $∠A$为公共角，可证明另一角相等或夹边分别成比例即可相似(斜”A”形)如图2中的(2), $∠A$为公共角，可证明另一角相等或夹边分别成比例即可相似(斜”A”形)如图2中的(3), $∠AOB$与$∠COD$为对顶角，可证明另一角相等或夹边分别成比例即可相似(斜”8”形)如图2中的(4), $∠BAC$与$∠DAE$为旋转对应角，可证明另一角相等或夹边分别成比例即可相似(旋转形)如图2中的(5), $∠A$为公共角，可证明另一角相等或夹边分别成比例即可相似(飞机形)如图2中的(6), $∠D=∠C$, 则${AB}^2=AD \cdot BC$(飞机形)如图2中的(7), $∠CAB=∠BAD$, 则${AB}^2=AD \cdot AC$(旋转形) 构造平行线 如图3中的(1), $E$是$AC$中点，$B$是$DC$中点，求$\frac{AO}{OB}$ ​ 解：过$B$点作$BF∥AC$交$DE$与$F$，然后可得$△FOB∽△EOA$，根据中点相关知识可求证 如图3中的(2), $AE:EC=1:3$，$B$是$DC$中点，求$\frac{AO}{OB}$ ​ 解：过$B$点作$BF∥AC$交$DE$与$F$，然后可得$△FOB∽△EOA$，根据中点、比例相关知识可求证 如图3中的(3), $O$是$△ABC$的重心，求$\frac{AO}{OF}$ ​ 解：连接$DF$，可得$DF∥AC$，然后可得$△DOF∽△COA$，根据中点相关知识可求证 如图3中的(4), $D,E$是$BC$的三等分点，$F$是$AC$中点，求$BH:HG:GF$(此类问题大多数是某线段等于另两条线段长，然后再探究另两条线段的比例关系) ​ 解：连接$FE$，可得两个中位线(中点+三等分点=两个中位线，可以把三等分点分开看)。然后得到$△ACD∽△FCE，△BHD∽△BGE$，根据相关知识解答即可。(基本原则，作平行线交酱油线(与已知线段与结论线段无关的一条)，即可解决问题) 矩形折叠 如图4，$ABCD$是矩形，$BD$为对角线，将$B$对折到$D$，折痕为$EF$ 则$BO=OD，EO=FO，BF=ED，BE=DF，EF⊥BD$(四边形$EDFB$为菱形) 圆与射影定理如图5中的(1)，$BD$为$⊙O$的直径，$AD⊥BC$，则形成了射影图如图5中的(1)，$AD,BD$为$⊙O$的切线，交$⊙O$于$A,B$，连接$AB，OD$，则$AB⊥CD$,则形成了两个相同的射影图 一线三等角如图6中的(1)，$∠B=∠ACD=∠E$，则$△ABC∽△CDE$(外角知识可证明(基本图形))如图6中的(2)，$△ABC$为等腰三角形，$∠B=∠EDF$，则$△EBD∽△DCF$(外角知识可证明) 射影定理如图7中的(2)，$Rt△ABC$中$AD⊥BC$, 则有射影定理：$AD^2=BD \cdot DC$$AB^2=BC \cdot BD$$AC^2=BC \cdot DC$如图7中的(1)(3)，若$∠BAC=∠BDA$或者$∠B=∠DAC$，则也能构成一部分射影定理图 求最大值/最小值 设某边为$x$, 某边为$y$，求$x-y$的最大值 可以联系到求二次函数最大值，因为相似的比例式转化为乘积式可能产生$y=kx^2$例题：典中点P49 t5 求$XX+XX$最小。 可以联系到轴对称(核心是三角形两边之和大于第三边和两点之间线段最短)，作对称点即可做 圆中的相似问题在圆中给出直径(半径)长和另一边长，求某一边长。(给出圆中线段求另一线段)解：一般连接直径所对圆周角，然后算这条连边长，然后相似三角形建立关系求解例题：典中点P49 t1，典中点P49 t2，典中点P49 t6，典中点P50 t9 圆中边、角的转化边：(1)半径转化：设半径为$r$，找等量关系求出$r$。 例题：典中点P50 t11(2)矩形转化：构造矩形，用矩形对边相等转化边。 技巧：如果原题目中出现了1.垂直、2.垂径、3.切线，则可以考虑作垂直或者垂径。 例题：典中点P50 t8，典中点P50 t11角：(1)圆周角：同弧所对圆周角相等。 例题：典中点P49 t3，典中点P50 t10(2)弦切角等于所夹弧的圆周角 圆中解题技巧(1)垂径定理：作弦垂线、连弦中点，可构造中点或者垂直 例题：典中点P50 t11(2)作直径 圆中常见模型(1)弦切角等于所夹弧的圆周角(2)相交弦定理(3)相交弦定理推论(4)切割线定理(5)割线定理 相似三角形高的性质如图8(1)，已知$DE,BC$长以及梯形$BCED$，可以求出$S△BOC，S△DOE$的大小(相似三角形高的比例等于相似比，所以图中$\frac{HO}{OG}=\frac{DE}{BC}$，然后可以通过梯形面积和上底下底求梯形高，即可解决)，也可以求$S△DOB,S△OEC$, 并且这两个三角形面积是相等的(同底等高减$S△DOE$即可证明)如图8(3)，$D,E$是中点，则$\frac{S△DOE}{S△BOC}=\frac{1}{4}$$\frac{S△ADE}{S△ABC}=\frac{1}{4}$$\frac{S△ADE}{S_{四边形}BDEC}=\frac{1}{3}$$\frac{S△DOE}{S△ADE}=\frac{1}{3}$($DE$等底，$\frac{AI}{HO}=\frac13$)如图8(2)，$DE:BC=1:3$，则仍然有以上的规律，只是答案不同如图8(4)，$EFHG$为矩形，$AD$为$△ABC$的高，则可以利用相似解许多问题(比如$四边形EFHG$如何为正方形/$四边形EFHG$面积最大问题) 相似三角形与反比例函数如图9，$y=\frac kx$在第一象限，$Rt△ABO$中，$∠ABO=90°$，则可以得到$S△AOD=S_{梯形CEBA}$(根据反比例函数$k$的几何含义和面积差相关知识可得$S△COF=S_{四边形FEBD}$。)此问题可以运用相似三角形求面积比/线段比。 相似三角形解题步骤明确题目1、求证比例式相等/乘积式相等 1、直接得出(三点定型，此处可能定出一个不存在线段，但三点不共线，即可以构造三角形) 2、转化线段 3、求中间比、两次相似(乘积式可以等乘积带换(通常是一条边的平方)) 4、构造相似三角形2、求几个比例式的和(分母化为相同，转化线段) 1、通过相似三角形/转化线段使分母化为相同 2、找分子与分母的关系3、求比例式的值/乘积式的值 1、根据已知值顺藤摸瓜，找相似 三线合一、垂直平分线的性质连垂直平分线上的线段得到相等(有时是等边/等腰三角形，也能构造)如图10(1).例题：典中点P58 t5, 典中点P59 t11, 典中点P59 t12 有垂直/中点/角平分线，则有垂直平分线例题：典中点P64 t6 有等腰/等边三角形可以作斜边的高，构造高和角平分线例题：典中点P64 t6 等腰直角三角形底角为$45°$，作斜边的高形成两个等腰直角三角形例题：典中点P62 t5 角平分线的性质角平分线+平行线=等腰三角形(构造等腰1)如图11(1).这个公式还能反过来用，比如已知平行和等腰求角平分线，已知角平分线和等腰求平行等。这也是证明切线的常用定理。例题：典中点P61 t4 角平分线+角两边上的任意一个垂直(构造相等/全等)如图11(2).作另一个垂直，则这两条垂线长度相同，且形成两个全等三角形$△APO≌△BPO$ 角平分线+平分线上的任意一个垂直(构造等腰2/全等)如图11(3).作另一个垂直，则这两条垂线长度相同，且形成两个全等三角形$△APO≌△BPO$，且$△AOB$等腰 截取线段(构造全等)如图11(4).在$OB$上截取$OB=OA$，则形成两个全等三角形$△APO≌△BPO$ 双垂直+角平分线=等腰三角形(等腰)本题无一致的模型，但注意到只要有了两个垂直+角平分线，就能通过倒角得到等腰三角形。 三角函数的代换关系1、$cosA=sinB, cosB=sinA$2、$sin^2A+cos^2A=1, sin^2A+sin^2B=1$(构造完全平方式的诀窍)3、$sinA=cosA \cdot tanA$4、$tanA \cdot tanB=1$5、两个直角边关系$tan$6、一个直角边，一个斜边关系$sin，cos$ 三角函数解题方法(求三角函数)直接求转角 (1) 在圆中转到直径上 (2) 平行/垂直/等腰转角 (3) 相似转角 补角 基本方法是作垂直。 有6种基本方法，如图13. 面积面积法求高$h=\frac{S_{△}}{a}$ 底边比求面积$S_1:S_2=a_1:a_2$]]></content>
      <categories>
        <category>文化课</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[二分 学习笔记]]></title>
    <url>%2Fsz%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[以下程序对比了lower_bound和自写函数的比较，基本上能够保证正确 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;ctime&gt; using namespace std; #define ms(i,j) memset(i,j,sizeof i); const int MAXN = 1000; int n = 20; int a[MAXN]; int rightans; int cans; int bs(int begin, int end, int x) { int l = begin, r = end; int mid; while (l&lt;r)//如果是浮点数，换成for(int i=0;i&lt;100;i++) {即可 mid = (l+r)/2; if (x&gt;a[mid]) l = mid+1; else r = mid; } return r; } int main() { //freopen(&quot;.in&quot;, &quot;r&quot;, stdin); freopen(&quot;.out&quot;, &quot;w&quot;, stdout); srand((int)time(0)); for (;;) { for (int i=0;i&lt;n;i++) a[i] = rand()%100; sort(a, a+n); int f = rand()%100; rightans = lower_bound(a, a+n, f)-a; cans = bs(0, n, f); if (rightans!=cans) {printf(&quot;wrong\n&quot;); break;} else printf(&quot;right!\n&quot;); } //fclose(stdin); fclose(stdout); return 0; }]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树状数组 学习笔记]]></title>
    <url>%2Fsz%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[模板及讲解维护区间$[1, n]$的数据结构，可以用$[1, b]-[1, a]$来求$[a,b]$可以$add(a, x), add(b+1, -x)$实现区间修改单点查询(差分序列求前缀和优化到$logn$) 二维树状数组(容斥原理) 区间修改区间查询设原数组为$a_i$，原数组差分序列为$d_i$，$x$为查询区间$[1,x]$，则$$a_x=\sum_{i=1}^x d_i$$则$$\sum_{i=1}^x a_i= \sum_{i=1}^x \sum_{j=1}^i d_j =\sum_{i=1}^x(x-i+1)d_i$$那么$$\sum_{i=1}^x a_i=(x+1)\sum_{i=1}^x d_i-\sum_{i=1}^x d_i \times i$$这样我们维护两个树状数组，一个维护$d_i$，一个维护$d_i \times i$，每次查询修改对两个树状数组进行操作即可。(常数比线段树小) 单点修改区间最大值Bzoj 1012$c[i]$维护$[i-\operatorname{lowbit}(i)+1,i]$的最大值，$a[i]$为原数组 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;map&gt; #include&lt;string&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db long double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { LL m, D, x, cnt, lastans = 0; LL a[200000 + 5], c[200000 + 5]; // c[i]维护[i-lowbit(i)+1,i]的最大值，a[i]为原数组 char s[5]; LL lowbit(LL x) {return x &amp; (-x);} LL query(LL l, LL r) { LL ret = a[r]; while (l &lt;= r) { ret = max(ret, a[r]); for (--r; r - l &gt;= lowbit(r); r -= lowbit(r)) ret = max(ret, c[r]); } return ret; } void clean() { cnt = 0, ms(a, 0), ms(c, 0); } int solve() { clean(); cin &gt;&gt; m &gt;&gt; D; for (LL i = 1; i &lt;= m; ++i) { scanf(&quot;%s%lld&quot;, s, &amp;x); if (s[0] == &#39;A&#39;) { a[++cnt] = (x + lastans) % D; c[cnt] = max(a[cnt], query(cnt - lowbit(cnt) + 1, cnt)); } else { printf(&quot;%lld\n&quot;, lastans = query(cnt - x + 1, cnt)); } } return 0; } } int main() { flyinthesky::solve(); return 0; } 树状数组求$k$大 LL C[MAXN]; void update(LL x) {while (x &lt;= m) C[x]++, x += x &amp; (-x);} LL query(LL x) { LL p = 0; for (LL i = 20; ~i; --i) { if (p + (1 &lt;&lt; i) &lt;= m &amp;&amp; C[p + (1 &lt;&lt; i)] &lt;= x) x -= C[p + (1 &lt;&lt; i)], p += (1 &lt;&lt; i); } return p; } 常见题型1、单点修改区间查询/区间修改单点查询解：直接套用模板即可，见下面的相关代码2、开多棵树状数组解决问题Q：一个区间(矩阵)有多种颜色，每个点有一个权值，每次修改(查询)指定颜色上的权值解：对于每一种颜色(类型)都开一棵树状数组。例题：BZOJ 14523、二维树状数组Q：在矩阵上查询某个子矩阵的值。解：建二维树状数组，见模板讲解。例题：BZOJ 14524、求逆序对Q：求逆序对。解：类似权值线段树，每次使$[1, i] + 1$, 然后$i$对答案的贡献为$[1, i]$的值(即小于i的元素个数)例题：NOIP2013 D1T25、区间修改区间查询解：推公式，开两个树状数组求值，见模板讲解。例题：BZOJ 2017-07-20集训-t25、树状数组离线排序右端点解：离线，删点加点例题：spoj DQUERY 相关代码1 点修改，求x~y区间值 #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;queue&gt; #define ms(i,j) memset(i,j, sizeof i); using namespace std; int a[500005]; int n,m; int abss(int x){return x&gt;=0 ? x : -x;} int lowbit(int x) { return x&amp;(-x); } int getsum(int x)//求1~x的和 { int ret = 0; for (int i=x;i&gt;0;i-=lowbit(i)) { ret += a[i]; } return ret; } void addsum(int x, int y)//1~x加y { for (int i=x;i&lt;=n;i+=lowbit(i)) { a[i] += y; } } int main() { a[0] = 0; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i=1;i&lt;=n;i++) { int x; scanf(&quot;%d&quot;, &amp;x); addsum(i,x); } for (int i=1;i&lt;=m;i++) { int ty; scanf(&quot;%d&quot;, &amp;ty); if (ty==1) { int x,k; scanf(&quot;%d%d&quot;, &amp;x, &amp;k); addsum(x,k); } else { int x,y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); printf(&quot;%d\n&quot;, abss(getsum(y)-getsum(x-1))); } } return 0; } 2 区间修改，求某一点值(差分序列) #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; using namespace std; #define ms(i,j) memset(i,j,sizeof i); int n,m; const int maxn = 500005; int a[maxn];//a记录的是比i-lowbit(i)多的值 int lowbit(int x) { return x&amp;(-x); } int add(int x, int v) { for (int i=x;i&lt;=n;i+=lowbit(i)) { a[i] += v; } } int sub(int x) { int ret = 0; for (int i=x;i&gt;0;i-=lowbit(i)) { ret += a[i]; } return ret; } int main() { scanf(&quot;%d%d&quot;, &amp;n ,&amp;m); ms(a,0); for (int i=1;i&lt;=n;i++) { int x; scanf(&quot;%d&quot;, &amp;x); add(i,x); add(i+1,-x); } for (int i=1;i&lt;=m;i++) { int ty; scanf(&quot;%d&quot;, &amp;ty); if(ty==1) { int x,y,k; scanf(&quot;%d%d%d&quot;, &amp;x,&amp;y,&amp;k); add(x,k); add(y+1,-k); } else { int x; scanf(&quot;%d&quot;, &amp;x); printf(&quot;%d\n&quot;, sub(x)); } } system(&quot;pause&quot;); return 0; }]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[倍增LCA / DFS序 学习笔记]]></title>
    <url>%2FszLCA%2F</url>
    <content type="text"><![CDATA[模板及讲解倍增LCA倍增思想，维护$deep[i], pre[i][j]$为点$i$的深度和点$i$的$2^j$个祖先结点然后对于每一对$x, y$求$LCA(x, y)$，先把深的结点提上来和浅结点深度相同，如果此时$x, y$都相同，说明$x, y$在同侧，输出$x, y$任意一个即可，否则再一起提上来直到两点相等，输出$pre[x][0]$或者$pre[y][0]$ 跳的时候跳二进制，即设$del = deep[b] - deep[a] (deep[b] &gt;= deep[a])$如果 $del = 5$， 二进制为$101$那么从左往右扫描，第$i$位为$1$的就跳$2^i$个点$del = 5$时，跳$2^2$和$2^0$即可 DFS 序DFS序的一大重要性质即为连续的一段是一个子树，很多问题可以转化为此。 DFS 序经典问题给定一棵带点权树根为$1$。1、单点修改，子树查询 (直接维护) 直接用数据结构维护 DFS 序即可。 2、树链修改，单点查询 (贡献) 考虑将树链分割。若修改$(u,v)+1$则等价于修改$(1,u)+1, (1,v)+1, (1, LCA)-1, (1, fa(LCA)-1)$那么只用处理根到某个点的树链修改。修改即修改$dfn(u)+1, dfn(v)+1, dfn(LCA)-1, dfn(fa(LCA))-1$考虑一个查询一个点$y$，由贡献来看，只有$y$子树的点会对$(1,y)$产生贡献。所以直接查询$y$子树即可。 3、树链修改，子树查询 (贡献) 考虑将树链分割。若修改$(u,v)+1​$则等价于修改$(1,u)+1, (1,v)+1, (1, LCA)-1, (1, fa(LCA)-1)​$那么只用处理根到某个点的树链修改。修改即修改$dfn(u)+1, dfn(v)+1, dfn(LCA)-1, dfn(fa(LCA))-1$考虑一个查询一个子树$y$，由贡献来看，只有$y$子树的点会对$(1,y)$产生贡献。这里和上面不一样了，设$dep(x)$为$x$深度，$v(x)$为数据结构上$x$的权，则$\forall x \in \operatorname{subtree}(y)$，他的贡献为$(dep(x)-dep(y)) \times v(x)$转化，得$dep(x) \times v(x) - dep(y) \times v(x)$写成和的形式，则$\sum\limits_{x \in \operatorname{subtree}(y)} dep(x) \times v(x) - dep(y) \times v(x)$即$\sum\limits_{x \in \operatorname{subtree}(y)} dep(x) \times v(x) - dep(y) \sum\limits_{x \in \operatorname{subtree}(y)} v(x)$用数据结构维护$dep(x) \times v(x), v(x)$即可求解。 4、单点修改，树链查询 (差分序列) 考虑将树链分割。若查询$(u,v)$则等价于查询$(1,u)+ (1,v)-(1, LCA)-(1, fa(LCA)-1)$那么只用处理根到某个点的树链查询。对于修改$y$，维护差分序列，那就直接差分点$y$的子树即可，答案即为$\sum\limits_{i=1}^{dfn(y)} val(i)$。 5、子树修改，单点查询 (贡献+差分序列 / 直接维护) 对于询问$y$，只有修改$x$是$y$的祖先$x$才会贡献$y$。所以单点修改$x$，查询$(1,y)$的权和，转化为问题 $4$或直接用数据结构维护 DFS 序即可。 6、子树修改，子树查询 (直接维护) 直接用数据结构维护 DFS 序即可。 7、子树修改，树链查询 (贡献+差分序列) 和 $4$ 类似的问题。这里就是要处理一下深度，用类似 $2$ 的方法处理即可。例题：Bzoj 4034 总结：DFS序的问题主要有几种处理方法：1、直接维护 (维护原数组)2、贡献法3、维护差分序列 (询问前缀和)本质上还是要将询问变为询问子树(维护原数组)，询问前缀和(维护差分序列) 路径交 / 并问题路径并：Bzoj 3991，Loj 10132(多条路径并)路径交：CF 832D(两条路径交，并且有一个端点重合)，Hdu 6110(多条路径交) 判两条路径有没有交，只要一条链的$lca$在另一条链上就一定有交；取两条路径的交，把两条路径的端点两两求出四对$lca$，最深那两个就是路径交。 常见题型相关代码]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>倍增</tag>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树 学习笔记]]></title>
    <url>%2Fsz%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[模板及讲解什么时候要用线段树?1、统计量可合并2、修改量可合并3、通过修改量可直接修改统计量⼀句话: 满⾜区间加法即可使用线段树维护信息 常见题型1、线段树合并区间在区间维护若干个值。例题：BZOJ 15932、离散化解：运用二分查找进行离散化。1、全部顶点加入数组 2、排序去重 3、值相差大于1的中间插一个值(直接在末尾插$val[i-1]+1$, 再作sort即可)例题：Hdu 15423、动态开点线段树例题：BZOJ 35314、权值线段树例题：poj 22995、扫描线Q：给出n个矩形，求他们的面积并/周长并。例题：Hdu 1542，Hdu 18286、线段树合并(主席树) / 线段树分裂合并：Bzoj 1926, 主席树等分裂：Bzoj 45527、线段树优化连边例题：BZOJ 2143 相关代码区间修改，区间查询：Luogu 3372 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;stack&gt; #include&lt;set&gt; #include&lt;queue&gt; #include&lt;climits&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; #define lc (o &lt;&lt; 1) #define rc (o &lt;&lt; 1 | 1) #define M ((l + r) &gt;&gt; 1) namespace flyinthesky { const LL MAXN = 100000 + 5; LL n, m, a[MAXN]; LL sumv[MAXN * 4], addv[MAXN * 4]; void pushup(LL o) { sumv[o] = sumv[lc] + sumv[rc]; } void pushdown(LL o, LL len) { if (len == 1) return ; if (addv[o]) { addv[lc] += addv[o], addv[rc] += addv[o]; sumv[lc] += addv[o] * (len - (len / 2)), sumv[rc] += addv[o] * (len / 2); addv[o] = 0; } } void build(LL o, LL l, LL r) { if (l == r) {sumv[o] = a[l]; return ;} else build(lc, l, M), build(rc, M + 1, r); pushup(o); } void update(LL o, LL l, LL r, LL x, LL y, LL v) { pushdown(o, r - l + 1); if (x &lt;= l &amp;&amp; r &lt;= y) {addv[o] += v, sumv[o] += v * (r - l + 1); return ;} if (x &lt;= M) update(lc, l, M, x, y, v); if (M &lt; y) update(rc, M + 1, r, x, y, v); pushup(o); } LL query(LL o, LL l, LL r, LL x, LL y) { pushdown(o, r - l + 1); if (x &lt;= l &amp;&amp; r &lt;= y) return sumv[o]; LL ans = 0; if (x &lt;= M) ans += query(lc, l, M, x, y); if (M &lt; y) ans += query(rc, M + 1, r, x, y); return ans; } void clean() { } int solve() { scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m); clean(); for (LL i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;a[i]); build(1, 1, n); while (m--) { LL ty; scanf(&quot;%lld&quot;, &amp;ty); if (ty == 1) { LL x, y, k; scanf(&quot;%lld%lld%lld&quot;, &amp;x, &amp;y, &amp;k); update(1, 1, n, x, y, k); } else { LL x, y; scanf(&quot;%lld%lld&quot;, &amp;x, &amp;y); printf(&quot;%lld\n&quot;, query(1, 1, n, x, y)); } } return 0; } } int main() { flyinthesky::solve(); return 0; } 单点修改，区间查询：Bzoj 1012 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;stack&gt; #include&lt;set&gt; #include&lt;queue&gt; #include&lt;climits&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; #define lc (o &lt;&lt; 1) #define rc (o &lt;&lt; 1 | 1) #define M ((l + r) &gt;&gt; 1) namespace flyinthesky { const LL MAXN = 200000 + 5; LL now, n, d; LL maxv[MAXN * 4]; char s[4]; void pushup(LL o) {maxv[o] = max(maxv[lc], maxv[rc]);} void build(LL o, LL l, LL r) { maxv[o] = 0; if (l == r) return ; else build(lc, l, M), build(rc, M + 1, r); pushup(o); } LL query(LL o, LL l, LL r, LL x, LL y) { if (x &lt;= l &amp;&amp; r &lt;= y) return maxv[o]; LL ans = 0; if (x &lt;= M) ans = max(ans, query(lc, l, M, x, y)); if (M &lt; y) ans = max(ans, query(rc, M + 1, r, x, y)); return ans; } void update(LL o, LL l, LL r, LL p, LL v) { if (l == r) {maxv[o] = v; return ;} if (p &lt;= M) update(lc, l, M, p, v); else if (M &lt; p) update(rc, M + 1, r, p, v); pushup(o); } void clean() { now = 0; } int solve() { scanf(&quot;%lld%lld&quot;, &amp;n, &amp;d); clean(); build(1, 1, n); LL t = 0; for (LL x, i = 1; i &lt;= n; i++) { scanf(&quot;%s%lld&quot;, s, &amp;x); if (s[0] == &#39;A&#39;) update(1, 1, n, ++now, (x + t) % d); else printf(&quot;%lld\n&quot;, t = query(1, 1, n, now - x + 1, now)); } return 0; } } int main() { flyinthesky::solve(); return 0; }]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>权值线段树</tag>
        <tag>动态开点线段树</tag>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KMP 学习笔记]]></title>
    <url>%2FszKMP%2F</url>
    <content type="text"><![CDATA[模板及讲解常见题型 1、求最短循环节KMP中$n-f[n]$即为最短循环节。例题：poj 2406 2、求前缀和后缀最长公共部分$f[i]$即为前缀和后缀最长公共部分长度 (又称为 bother)。例题：poj 2752, BZOJ 3620, Noi2014动物园 3、Next 树就是$\text{Next}$指针连成的树。 相关代码 #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #define ms(i,j) memset(i,j, sizeof i); using namespace std; char s1[1000000 + 5], s2[1000 + 5]; int next[1000 + 5]; int n,m; void getNext()//获得失配函数 { next[0] = 0; next[1] = 0; for (int i=1;i&lt;m;i++) { int j = next[i]; while (j &amp;&amp; s2[i]!=s2[j]) j = next[j]; next[i+1] = ((s2[i]==s2[j]) ? (j+1) : (0)); } } void kmp()//在s1里找s2 { getNext(); int j = 0; for (int i=0;i&lt;n;i++) { while (j &amp;&amp; s1[i]!=s2[j]) j = next[j]; if (s1[i]==s2[j]) j++; if (j==m) printf(&quot;%d\n&quot;, i-m+1); } } int main() { scanf(&quot;%s%s&quot;, s1, s2); n = strlen(s1), m = strlen(s2); kmp(); return 0; } //KMP求字符串中的最短周期(循环节) #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #define ms(i,j) memset(i,j, sizeof i); using namespace std; const int MAXN = 1000000 + 5; int n; char s[MAXN]; int f[MAXN]; int main() { while (scanf(&quot;%s&quot;, s)&amp;&amp;(s[0]!=&#39;.&#39;)) { n = strlen(s); f[0] = f[1] = 0; for (int i=1;i&lt;n;i++) { int j = f[i]; while (j &amp;&amp; s[i]!=s[j]) j = f[j]; f[i+1] = (s[i]==s[j]) ? (j+1) : (0); } int ans = n-f[n]; if (n%ans==0) ans = n/ans; else ans = 1; printf(&quot;%d\n&quot;, ans); } return 0; }]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>KMP</tag>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2016 游记]]></title>
    <url>%2FzzNOIP2016%2F</url>
    <content type="text"><![CDATA[又是一年NOIP，去年PJ水到一个2=，今年本来想去水1=的。。 NOIP前三天停课集训，感觉作业补不完了。。 NOIP前一天中午就出发了，大概用了3个半钟到广州中大西苑一开始看外观觉得这宾馆似乎很不堪。。大厅那么小。。不过房间还不错吃饭的地方就在酒店附近的都城快餐，感觉东西都咬不动还挺贵。。晚上打了一晚上三国杀，据说三国杀可以锻炼搜索、贪心、动态规划、数论等等… 第二天早餐又在都城快餐，随便吃了点，然后回酒店整理然后又打了一次三国杀。。然后退完房坐地铁到六中吃午饭，居然又是都城快餐。。。吃完饭就进去六中休息等着考试了。 14点就进去考场了，然而今年的解压密码真tm神奇 用了10几分钟浏览题目，看第一题就是个水题，看见子任务和20个测试数据，还以为看错题了，结果就是个水题，几分钟搞定第二题，60%数据保证date1=date2，这不是送分么，noip怎么回事。同样水题，十几分钟打完，测了几个数据，都可以过 出考场和同学聊，本来以为自己考得很好(当时并不知道t4爆炸了)然后又到那个餐馆吃饭了，来广州两天都在一个地方吃饭。。晚上坐车10点半才到，然后回家看见luogu出民间数据了，就把代码重写交上去t1t2没问题，t3也拿到了打的70分，然后t4直接爆炸，当时我不能接受这个事实，这意味着我只能得到270+的分数，而这里是GD强省，丢了这宝贵的40分，与1=几乎无望了。 以后做题时，一定要认真审题，把做题当成考试，希望明年能够提高自我！]]></content>
      <categories>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>杂文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树链剖分 学习笔记]]></title>
    <url>%2Fsz%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%2F</url>
    <content type="text"><![CDATA[模板及讲解树链剖分解决树上的修改问题。将树剖成一条条链，再用线段树、树状数组等维护 相关代码#include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define fo(i, j, k) for (i=(j);i&lt;=(k);i++) #define fd(i, k, j) for (i=(k);i&gt;=(j);i--) #define rd(a) scanf(&quot;%d&quot;, &amp;a) #define rd2(a, b) scanf(&quot;%d%d&quot;, &amp;a, &amp;b) #define rd3(a, b, c) scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c) #define ms(i, j) memset(i, j, sizeof i) #define FN2 &quot;bzoj1036&quot; using namespace std; const int MAXN = 30000 + 5; int dep[MAXN], son[MAXN], fa[MAXN], siz[MAXN]; //深度，重儿子，父亲，子树大小 int p[MAXN], top[MAXN], pre; //在线段树中的位置，所在重链顶部，线段树当前标号 int n, wi[MAXN]; vector&lt;int&gt; G[MAXN]; void dfs1(int u, int f)//第一次dfs记录值 { int i; dep[u] = dep[f] + 1, fa[u] = f, siz[u] = 1; fo (i, 0, G[u].size()-1) { int v = G[u][i]; if (v!=f) { dfs1(v, u); siz[u] += siz[v]; if (son[u]==-1||siz[son[u]]&lt;siz[v]) son[u] = v; } } } void dfs2(int u, int chain) {//第二次dfs连重儿子成重链 int i; p[u] = ++pre, top[u] = chain; if (son[u]!=-1) { dfs2(son[u], chain); fo (i, 0, G[u].size()-1) { int v = G[u][i]; if (v!=son[u]&amp;&amp;v!=fa[u]) dfs2(v, v); } } } int maxv[MAXN*4], sumv[MAXN*4]; void pushup(int o) { int lc = o*2, rc = o*2+1; maxv[o] = max(maxv[lc], maxv[rc]); sumv[o] = sumv[lc] + sumv[rc]; } void update(int o, int l, int r, int p, int v) { int lc = o*2, rc = o*2+1, M = (l+r)/2; if (l==r) { sumv[o] = maxv[o] = v; return ; } if (p&lt;=M) update(lc, l, M, p, v); else if (M&lt;p) update(rc, M+1, r, p, v); pushup(o); } int getMax(int o, int l, int r, int x, int y) { int lc = o*2, rc = o*2+1, M = (l+r)/2, ret = -200000000; if (x&lt;=l&amp;&amp;r&lt;=y) { return maxv[o]; } if (x&lt;=M) ret = max(ret, getMax(lc, l, M, x, y)); if (M&lt;y) ret = max(ret, getMax(rc, M+1, r, x, y)); return ret; } int getSum(int o, int l, int r, int x, int y) { int lc = o*2, rc = o*2+1, M = (l+r)/2, ret = 0; if (x&lt;=l&amp;&amp;r&lt;=y) { return sumv[o]; } if (x&lt;=M) ret += getSum(lc, l, M, x, y); if (M&lt;y) ret += getSum(rc, M+1, r, x, y); return ret; } int findMax(int u, int v) { int f1 = top[u], f2 = top[v]; int ret = -200000000; while (f1!=f2) { if (dep[f1]&lt;dep[f2]) swap(f1, f2), swap(u, v); ret = max(ret, getMax(1, 1, n, p[f1], p[u])); u = fa[f1], f1 = top[u]; } if (dep[u]&lt;dep[v]) swap(u, v); return max(ret, getMax(1, 1, n, p[v], p[u])); } int findSum(int u, int v) { int f1 = top[u], f2 = top[v]; int ret = 0; while (f1!=f2) { if (dep[f1]&lt;dep[f2]) swap(f1, f2), swap(u, v); ret += getSum(1, 1, n, p[f1], p[u]); u = fa[f1], f1 = top[u]; } if (dep[u]&lt;dep[v]) swap(u, v); return ret+getSum(1, 1, n, p[v], p[u]); } void init() { int i; pre = 0; fo (i, 1, n) dep[i] = fa[i] = siz[i] = p[i] = top[i] = 0, son[i] = -1, G[i].clear(); fo (i, 1, n*4) maxv[i] = -200000000, sumv[i] = 0; fo (i, 1, n-1) { int a, b; rd2(a, b); G[a].push_back(b), G[b].push_back(a); } } void solve() { int q, i; dfs1(1, 0); dfs2(1, 1); fo (i, 1, n) rd(wi[i]), update(1, 1, n, p[i], wi[i]); rd(q); fo (i, 1, q) { char ch[10]; scanf(&quot;%s&quot;, ch); if (ch[0]==&#39;C&#39;) { int u, t; rd2(u, t), update(1, 1, n, p[u], t); } else if (ch[1]==&#39;M&#39;) { int u, v; rd2(u, v), printf(&quot;%d\n&quot;, findMax(u, v)); } else if (ch[1]==&#39;S&#39;) { int u, v; rd2(u, v), printf(&quot;%d\n&quot;, findSum(u, v)); } } } int main() { #ifndef ONLINE_JUDGE freopen(FN2&quot;.in&quot;,&quot;r&quot;,stdin);freopen(FN2&quot;.out&quot;,&quot;w&quot;,stdout); #endif while (rd(n)==1) init(), solve(); return 0; } 常见题型见 做题针对题目1、点权问题Q：修改某些点的权进行询问。解：直接树剖进行线段树/树状数组维护例题：bzoj10362、边权问题Q：修改某些边的权进行询问。解：树剖后维护点权，每个点的点权为这个点到他父亲之间边权，询问时删除lca的点权即可例题：poj27633、子树问题Q：修改结点u为根的子树的点权。解：由树剖的性质可得，树剖后结点u为根的子树在线段树上的区间是连续的一段，那么记录一个左端点和右端点即可(时间戳思想)例题：bzoj4034]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>树链剖分</tag>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双连通分量、割点和桥 学习笔记]]></title>
    <url>%2Fsz%E6%97%A0%E5%90%91%E5%9B%BE%E5%89%B2%E7%82%B9%E5%92%8C%E6%A1%A5%2F</url>
    <content type="text"><![CDATA[模板及讲解双连通分量一个子图中任意两个点之间有至少两条点不相同的路径，则这个子图就是点-双连通分量(无割点)一个子图中任意两个点之间有至少两条边不相同的路径，则这个子图就是边-双连通分量(无桥) 通俗来说，一个点-双连通分量中删除任意一个点都不会使原图变成多个连通块，一个边-双连通分量中删除任意一条边都不会使原图变成多个连通块 每个点-双连通分量就是一堆环套环，边-双连通分量一定是点-双连通分量 1 任意两个点-双连通分量至多有一个交点割顶2 桥不在任何边-双连通分量中 1 割点对应点-双连通分量，栈存的是边2 桥对应边-双连通分量，栈存的是点 相关代码求割点代码Luogu 3388 // 本代码不能处理重边问题，重边就记录父亲边的 ID，只有父亲边的 ID 不能更新 low #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;stack&gt; #define ms(i, j) memset(i, j, sizeof i) using namespace std; const int MAXN = 100000 + 5; int n, m; vector&lt;int&gt; G[MAXN]; int iscut[MAXN], low[MAXN], dn[MAXN], tb; void tarjan(int u, int fa) { low[u] = dn[u] = ++tb; int child = 0; for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i]; if (v == fa) continue; if (dn[v] == 0) { child++, tarjan(v, u); low[u] = min(low[u], low[v]); if (low[v] &gt;= dn[u]) iscut[u] = true;//u 是割点 } else if (dn[v] &lt; dn[u]) low[u] = min(low[u], dn[v]);//防重复更新 } if (fa &lt; 0 &amp;&amp; child == 1) iscut[u] = 0;//特判开始点 } void clean() { tb = 0; for (int i = 1; i &lt;= n; ++i) G[i].clear(), iscut[i] = low[i] = dn[i] = 0; } void solve() { clean(); for (int a, b, i = 1;i &lt;= m; ++i) scanf(&quot;%d%d&quot;, &amp;a, &amp;b), G[a].push_back(b), G[b].push_back(a); for (int i = 1;i &lt;= n; ++i) if (!dn[i]) tarjan(i, -1); int ans = 0; for (int i = 1; i &lt;= n; ++i) if (iscut[i]) ans++; printf(&quot;%d\n&quot;, ans); for (int i = 1; i &lt;= n; ++i) if (iscut[i]) printf(&quot;%d &quot;, i); } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m), solve(); return 0; } 求桥代码见 边-双连通分量缩点代码 中注释 边-双连通分量缩点代码方法与强连通分量 Tarjan 基本一致 CF 1000E #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;climits&gt; #include&lt;stack&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using std::cin; using std::cout; using std::endl; const int MAXN = 300000 + 5; struct edge {int v, nxt;} ed[MAXN * 2], ED2[MAXN * 2]; int n, m, en, EN2, hd[MAXN], HD2[MAXN]; int bcc_tot, bcc_belong[MAXN], sz, dfn[MAXN], low[MAXN]; std::stack&lt;int &gt; s; void ins(int x, int y) {ed[++en] = (edge){y, hd[x]}, hd[x] = en;} void INS2(int x, int y) {ED2[++EN2] = (edge){y, HD2[x]}, HD2[x] = EN2;} void tarjan(int u, int fa) {//边双连通缩点部分 dfn[u] = low[u] = ++sz, s.push(u); for (int i = hd[u]; i &gt; 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (e.v == fa) continue; if (!dfn[e.v]) tarjan(e.v, u), low[u] = std::min(low[u], low[e.v]); else low[u] = std::min(low[u], dfn[e.v]); } if (low[u] == dfn[u]) {//(u, fa(u))是桥, 栈存的是点 int e; bcc_tot++; do { e = s.top(); s.pop(); bcc_belong[e] = bcc_tot; } while (e != u); } } int dis[MAXN]; void dfs(int u, int fa) { dis[u] = dis[fa] + 1; for (int i = HD2[u]; i &gt; 0; i = ED2[i].nxt) { edge &amp;e = ED2[i]; if (e.v != fa) dfs(e.v, u); } } void clean() { en = EN2 = 0; ms(hd, 0), ms(HD2, 0); scc_tot = sz = 0, ms(dfn, 0); } int solve() { clean(); for (int x, y, i = 1; i &lt;= m; i++) scanf(&quot;%d%d&quot;, &amp;x, &amp;y), ins(x, y), ins(y, x); for (int i = 1; i &lt;= n; i++) if (!dfn[i]) tarjan(i, 0);//边双连通缩点部分 for (int u = 1; u &lt;= n; u++) { for (int i = hd[u]; i &gt; 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (bcc_belong[u] != bcc_belong[e.v]) INS2(bcc_belong[u], bcc_belong[e.v]); } } ms(dis, 0); dfs(1, 0); int S = 1; for (int i = 2; i &lt;= bcc_tot; i++) if (dis[i] &gt; dis[S]) S = i; dfs(S, 0); int T = 1; for (int i = 2; i &lt;= bcc_tot; i++) if (dis[i] &gt; dis[T]) T = i; printf(&quot;%d\n&quot;, dis[T] - 1); return 0; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m), solve(); return 0; } 点-双连通分量缩点代码CF 962F #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;stack&gt; #include&lt;set&gt; #include&lt;queue&gt; #include&lt;climits&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; const int MAXN = 100000 + 5; struct edge {int u, v, nxt;} ed[MAXN * 2]; int n, m, en, hd[MAXN]; int sz, dfn[MAXN], low[MAXN], bcc_tot, bcc_belong[MAXN], bcc_node_num[MAXN], bcc_edge_num[MAXN]; std::vector&lt;int &gt; bcc_edge[MAXN], ans;//每个 bcc 的边 std::stack&lt;int &gt; st; void ins(int x, int y) {ed[++en] = (edge){x, y, hd[x]}, hd[x] = en;} void tarjan(int u, int fa) { dfn[u] = low[u] = ++sz; for (int i = hd[u]; i &gt; 0; i = ed[i].nxt) { edge &amp;e = ed[i]; if (e.v == fa) continue; if (!dfn[e.v]) { st.push(i), tarjan(e.v, u), low[u] = std::min(low[u], low[e.v]); if (low[e.v] &gt;= dfn[u]) { bcc_edge[++bcc_tot].clear(); int whw; do { whw = st.top(), st.pop(); ++bcc_edge_num[bcc_tot], bcc_edge[bcc_tot].push_back(whw); if (bcc_belong[ed[whw].u] != bcc_tot) ++bcc_node_num[bcc_tot], bcc_belong[ed[whw].u] = bcc_tot; if (bcc_belong[ed[whw].v] != bcc_tot) ++bcc_node_num[bcc_tot], bcc_belong[ed[whw].v] = bcc_tot; } while (!(ed[whw].u == u &amp;&amp; ed[whw].v == e.v)); } } else if(dfn[e.v] &lt; dfn[u]) st.push(i), low[u] = std::min(low[u], dfn[e.v]);//防重复更新 } } void clean() { bcc_tot = sz = en = 0, ms(hd, -1), ms(bcc_node_num, 0), ms(bcc_edge_num, 0), ms(bcc_belong, 0); } int solve() { clean(); for (int u, v, i = 1; i &lt;= m; i++) scanf(&quot;%d%d&quot;, &amp;u, &amp;v), ins(u, v), ins(v, u); for (int i = 1; i &lt;= n; i++) if (!dfn[i]) tarjan(i, 0); for (int i = 1; i &lt;= bcc_tot; i++) { if (bcc_edge_num[i] == bcc_node_num[i] &amp;&amp; bcc_edge_num[i]) for (int j = 0; j &lt; (int)bcc_edge[i].size(); j++) ans.push_back(bcc_edge[i][j]); } std::sort(ans.begin(), ans.end()); printf(&quot;%d\n&quot;, (int)ans.size()); for (int i = 0; i &lt; (int)ans.size(); i++) printf(&quot;%d &quot;, (ans[i] + 1) / 2); return 0; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m), solve(); return 0; } 1、边-双连通分量缩点Q：模板题。解：模板题。例题：CF 1000E]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>双连通分量</tag>
        <tag>算法笔记</tag>
        <tag>割点</tag>
        <tag>桥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2-SAT 学习笔记]]></title>
    <url>%2Fsz2-SAT%2F</url>
    <content type="text"><![CDATA[模板及讲解 加边a-&gt;b 代表选了a的话b也得选例如 x-&gt;x` 表示选了x就必须选x` ，所以这个值必为x 有a, not a, a or b, a and b, a xor b四种基本运算，例如：1、A, B至少选一个：A&#39;-&gt;B, B&#39;-&gt;A (a or b)2、A, B必须同时选：A-&gt;B, B-&gt;A (a and b)3、A, B只能选一个：A-&gt;B&#39;, B-&gt;A&#39; (a xor b)4、A必选：A&#39;-&gt;A (a)5、A不能选：A-&gt;A&#39; (not a)6、A选或者B不选：A&#39;-&gt;B&#39;, B-&gt;A&#39; (a or not b) 2-SAT模板题：BZOJ 2199 #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;vector&gt; #define ms(i,j) memset(i,j, sizeof i); using namespace std; const int MAXN = 1000 + 5; const char orz[10] = {&#39;Y&#39;, &#39;N&#39;, &#39;?&#39;}; int n,m; int ans[MAXN]; struct twoSAT//这里标号从0开始 { vector&lt;int&gt; G[MAXN*2];//邻接表 bool mark[MAXN*2];//每个点是否被标记 int n; int init(int ni)//初始化 { n = ni; for (int i=0;i&lt;2*n;i++) G[i].clear(); } int addEdge(int x, int y, int xv, int yv)//加一个条件 { x = x*2+xv; y = y*2+yv; G[x^1].push_back(y); G[y^1].push_back(x);//2i是假，2i+1是真 } int dfs(int x) { if (mark[x^1]) return false;//对应点被标记，不符合要求 if (mark[x]) return true;//已经被标记直接返回 mark[x] = true;//标记 for (int i=0;i&lt;G[x].size();i++)//继续标记 { if (!dfs(G[x][i])) return false; } return true; } int check(int x)//检查一个议案是否通过 { ms(mark, false); return dfs(x); } }ts; int main() { scanf(&quot;%d%d&quot;, &amp;n,&amp;m); ts.init(n); for (int i=0;i&lt;m;i++) { int bi,ci; char vbi,vci; scanf(&quot;%d %c %d %c&quot;, &amp;bi,&amp;vbi,&amp;ci,&amp;vci); int vvbi = false, vvci = false; if (vbi==&#39;Y&#39;) vvbi = true; if (vci==&#39;Y&#39;) vvci = true; ts.addEdge(bi-1,ci-1,vvbi,vvci); } for (int i=0;i&lt;n;i++) { int p = ts.check(i*2); int q = ts.check(i*2+1); if (!p&amp;&amp;!q) {printf(&quot;IMPOSSIBLE&quot;); return 0;} if (p&amp;&amp;q) ans[i] = 2; else if (!p) ans[i] = 0; else ans[i] = 1; } for (int i=0;i&lt;n;i++) putchar(orz[ans[i]]); return 0; } Tarjan版本(Bzoj 1823)： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;stack&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double using namespace std; int tb, n, m, belongs[2 * 100 + 5], vis[2 * 100 + 5], scc_num, dfn[2 * 100 + 5], low[2 * 100 + 5]; vector&lt;int&gt; G[2 * 100 + 5];//2x-&gt;m 2x+1-&gt;h stack&lt;int&gt; s; void tarjan(int u) { dfn[u] = low[u] = ++tb, vis[u] = -1, s.push(u); for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i]; if (vis[v] == 0) { tarjan(v); low[u] = min(low[u], low[v]); } else if (vis[v] == -1) low[u] = min(low[u], dfn[v]); } if (low[u] == dfn[u]) { int e; scc_num++; do { e = s.top(); s.pop(); belongs[e] = scc_num; vis[e] = 1; } while (e != u); } } int getss() { char ans; while (true) { ans = getchar(); if (ans == &#39;m&#39;) return 0; if (ans == &#39;h&#39;) return 1; int ret = 0; while (ans &gt;= &#39;0&#39; &amp;&amp; ans &lt;= &#39;9&#39;) { ret = ret * 10 + ans - &#39;0&#39;; ans = getchar(); } if (ret &gt; 0) return ret; } } void clean() { tb = scc_num = 0; for (int i = 0; i &lt;= 2 * 100 + 1; i++) dfn[i] = low[i] = belongs[i] = vis[i] = 0, G[i].clear(); } void solve() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); clean(); char c1, c2; int a1, a2; for (int i = 1; i &lt;= m; i++) { c1 = getss(), a1 = getss(), c2 = getss(), a2 = getss(); int x = 2 * (a1 - 1) + (c1 == 1) , y = 2 * (a2 - 1) + (c2 == 1); G[x].push_back(y ^ 1), G[y].push_back(x ^ 1); } for (int i = 1; i &lt;= n * 2; i++) if (!vis[i]) tarjan(i); for (int i = 1; i &lt;= 2 * n; i += 2) { if (belongs[i] == belongs[i ^ 1]) { printf(&quot;BAD\n&quot;); return ; } } printf(&quot;GOOD\n&quot;); } int main() { int T; scanf(&quot;%d&quot;, &amp;T); while (T--) solve(); return 0; }]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>2-SAT</tag>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短路 学习笔记]]></title>
    <url>%2Fsz%E6%9C%80%E7%9F%AD%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[技巧性二分最短路 [GDOI2018Day2T1]最短路+枚举边/路径/点：[CF 544D]，[CF 954D]，最小环问题，[Bzoj 1880]拆点最短路 [AHSOFNU-NOIP模拟-2-t3] 分层图最短路[GDOI2016Day2T1]。 一般用来决策。 最短路图最短路树 [CF1005F]。 涉及多条最短路时。 DPDAG 图拓扑序 (任意图DP) 无后效性量[Luogu 1144], [NOIP2017Day1T3]， [Bzoj 1706] SPFA / Dij 松弛带环DP在不能贪心的时候不能用Dij，例如 Bzoj 3875，Luogu1875 ，这类题DP方程不同 可以贪心的：CF 938D 0-1 BFS解边权为 0，1 的图最短路用双端队列 deque 如果当前边权是 1 就放到队尾否则放到队首松弛最短路。不要开vis数组！用dis松弛即可。 例题：CF 821D. CF 1072D, Loj 2632 堆优化dijkstra #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;queue&gt; #define ms(i,j) memset(i,j, sizeof i); using namespace std; struct node//dijkstra结点 { int d; int u; bool operator&lt;(const node &amp;a) const//重载小于号，用于priority的比较 { return d&gt;a.d; } }; priority_queue&lt;node&gt; q; //堆 int dis[2505]; int vi[2505]; int t,c,ts,te; int G[2505][2505];//邻接矩阵储存 int dij() { q.push((node){dis[ts], ts});//入堆 while (!q.empty()) { node p = q.top(); q.pop(); if(vi[p.u]) continue;//已经标记过 vi[p.u] = true; for (int i=1;i&lt;=t;i++)//松弛 if(dis[p.u]+G[p.u][i]&lt;dis[i]) { dis[i] = dis[p.u]+G[p.u][i]; q.push((node){dis[i], i}); } } } int main() { scanf(&quot;%d%d%d%d&quot;, &amp;t,&amp;c,&amp;ts,&amp;te); ms(G,127);//初始化矩阵 ms(vi,false); ms(dis,127); dis[ts] = 0; for (int i=1;i&lt;=c;i++) { int rs,re,ci; scanf(&quot;%d%d%d&quot;, &amp;rs, &amp;re, &amp;ci); G[rs][re] = G[re][rs] = ci; } dij(); printf(&quot;%d\n&quot;, dis[te]); return 0; }]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[差分约束 学习笔记]]></title>
    <url>%2Fsz%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%2F</url>
    <content type="text"><![CDATA[模板及讲解差分约束是什么差分约束就是给出一些形如$x-y \ge c$的约束，问你是否有解，或求最大、最小解。该问题可以转化为图上最短路问题。 差分约束的几种形式求最大差建立形如 $A-B \le C$ 的不等式，在原图中添加边 $B-&gt;A$ 边权为 $C$对建好的图跑最短路，如果存在负环，无解（判断条件为某点被更新了$ n $次），$n $为图中点的数量 求最小差建立形如 $A-B \ge C$ 的不等式，在原图中添加边 $B-&gt;A$ 边权为 $C$对建好的图跑最长路，如果存在正环，无解（判断条件为某点被更新了$ n$ 次），$n$ 为图中点的数量 我们可以建立一个虚结点，然后让这个虚结点指向所有图中的结点，权值为0，从虚结点开始求最短路。(还可以先把所有点加入队列，之后dis全部初始化为0) 不等式标准化方法如果有一个不等式为$x-y&gt;c$, 则可变为$x-y \ge c+1$同理$x-y&lt;c$可变为$x-y \le c-1$如果是$x-y=c$,则变为两个式子$x-y\le c, x-y \ge c$ 负环无解，$dis=INF$为无限远，$dis[i]=min(a[i]-a[0])$ 常见题型：1、求最大差Q：有若干约束，求最大差解：见讲解例题：hdu 34402、求最小差Q：有若干约束，求最小差解：见讲解例题：poj 12013、求可行性Q：有若干约束，求可行性解：建立最小差/最大差无环/dis不等于INF即可例题：hdu 36664、不等式标准化Q：不等式为$x-y&gt;c$解：见讲解例题：BZOJ 2330]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拓扑排序 学习笔记]]></title>
    <url>%2Fsz%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[模板及讲解用queue来存入度为0的点，然后BFS即可 常见题型1、图中DPQ: 给你一张图，你要在上面DP解: 拓扑序保证无后效性，用拓扑序来DP转移例题: Codeforces 919D2、图中判环/无环Q: 给你一张图，判图中有环/无环解: 拓扑排序必须无环，如果没有拓扑某些点则有环例题: Codeforces 915D 相关代码hdu1285 #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;vector&gt; #include&lt;queue&gt; using namespace std; #define ms(i, j) memset(i, j, sizeof i) #define ll long long vector&lt;int&gt; G[505]; int n, m, ino[505], ino2[505], tot; bool topsort() { queue&lt;int&gt; q; for (int i = 1; i &lt;= n; i++) if (ino2[i] == 0) tot++, q.push(i); while (!q.empty()) { int u = q.front(); q.pop(); for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i]; ino2[v]--; if (ino2[v] == 0) tot++, q.push(v); if (ino2[v] &lt; 0) ino2[v] = 0; } } if (tot == n) return 1; else return 0; } void clean() { tot = 0, ms(ino, 0); } int solve() { clean(); for (int u, v, i = 1; i &lt;= m; i++) { scanf(&quot;%d%d&quot;, &amp;u, &amp;v); G[u].push_back(v), ino[v]++; } for (int i = 1; i &lt;= n; i++) { memcpy(ino2, ino, sizeof ino); if (!ino2[i]) continue; ino2[i]--, tot = 0; if (topsort()) return printf(&quot;YES\n&quot;), 0; } printf(&quot;NO\n&quot;); return 0; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m), solve(); return 0; }]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成树 学习笔记]]></title>
    <url>%2Fsz%E7%94%9F%E6%88%90%E6%A0%91%2F</url>
    <content type="text"><![CDATA[模板及讲解最小生成树：在一个图中选择$n-1$条边，使所有点连通且路径总权最小。常用算法是用并查集辅助求解的Kruskal最小瓶颈路：求一条路径，使得$u−&gt;v$路径上的最大边权最小。可以知道，最小瓶颈路必在最小生成树上，所以用最小生成树求解 最小生成树性质1切割性质2回路性质3相同边权数量相等4不同边权加入时互相独立5不产生环的同权值边可以替换边 Kruskal 重构树定义在做 Kruskal 的时候，我们将边权转点权，得到$2n-1$个点的树。 构造方法每次 Kruskal 时，如果当前边是需要的，那么我们建立一个新节点，节点权值为边权，然后从这个点向两边两个集合的并查集代表连边。 性质1、是一棵树，并且是一个二叉堆2、原最小生成树两点之间的边权最大值是重构树上两点$\text{LCA}$的权值3、重构树中代表原最小生成树中的点的节点全是叶子节点，其余节点都代表了一条边的边权。 例题1、Bzoj 3732 给你$N$个点的无向有边权图，图中有$M$条边，现在有$K$个询问，每个询问的格式是：A B，表示询问从$A$点走到$B$点的所有路径中，最长的边最小值是多少？ 最长的边最小值，我们考虑最小生成树。这题明显可以求出最小生成树，然后再在树上倍增 / 树剖求出最长的边。这里可以运用性质2，即原最小生成树两点之间的边权最大值是重构树上两点$\text{LCA}$的权值，那么我们构造出重构树，询问树上两点$\text{LCA}$的权值即为答案。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define LL long long #define db double #define fir first #define sec second #define mp make_pair using namespace std; namespace flyinthesky { const int MAXN = 30000 + 5, LOGS = 20; struct edge { int u, v, w; bool operator &lt; (const edge &amp;rhs) const {return w &lt; rhs.w;} } ed[30000 + 5]; int n, m, Q, val[MAXN], f[MAXN], idx; vector&lt;int &gt; G[MAXN]; int pre[MAXN][LOGS + 2], dep[MAXN]; void ins(int u, int v) {G[u].push_back(v);} int find(int x) {return x == f[x] ? x : f[x] = find(f[x]);} void dfs(int u, int fa) { pre[u][0] = fa, dep[u] = dep[fa] + 1; for (int i = 1; i &lt;= LOGS; ++i) pre[u][i] = pre[pre[u][i - 1]][i - 1]; for (int i = 0; i &lt; (int)G[u].size(); ++i) { int v = G[u][i]; if (v != fa) dfs(v, u); } } int LCA(int a, int b) { if (dep[a] &lt; dep[b]) swap(a, b); for (int i = LOGS; i &gt;= 0; --i) if (dep[pre[a][i]] &gt;= dep[b]) a = pre[a][i]; if (a == b) return a; for (int i = LOGS; i &gt;= 0; --i) if (pre[a][i] != pre[b][i]) a = pre[a][i], b = pre[b][i]; return pre[a][0]; } void clean() { ms(val, 0), ms(f, 0); ms(pre, 0), ms(dep, 0); } int solve() { clean(); cin &gt;&gt; n &gt;&gt; m &gt;&gt; Q; for (int i = 1; i &lt;= m; ++i) scanf(&quot;%d%d%d&quot;, &amp;ed[i].u, &amp;ed[i].v, &amp;ed[i].w); sort(ed + 1, ed + 1 + m), idx = n; // Kruskal int tot = 0; for (int i = 0; i &lt;= n * 2; ++i) f[i] = i; for (int i = 1; i &lt;= m; ++i) { int x = find(ed[i].u), y = find(ed[i].v); if (x != y) { ++idx; ins(idx, f[x]), ins(idx, f[y]); f[x] = f[y] = idx, val[idx] = ed[i].w; ++tot; if (tot &gt;= n - 1) break ; } } // LCA dfs(idx, 0); while (Q--) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); printf(&quot;%d\n&quot;, val[LCA(x, y)]); } return 0; } } int main() { flyinthesky::solve(); return 0; } 常见题型1、求一个图的最小/大生成树Q：给出一个图，求出这个图的最小/大生成树解：见讲解例题：BZOJ 24292、将一个图转为树Q：给出一个图，图中只有使图连通的最大/小的那几条边有用解：求最小/大生成树。例题：NOIP2013 D1 T33、求一条路径使得最大边最小Q：给出一个图，求一条路径使得$a-&gt;b$最大边最小(这种题的题面一般带有二分的标志：最大值最小)解：最小瓶颈路。最大边最小的路径在最小生成树上。例题：BZOJ 24294、最小生成树性质Q：BZOJ 1016解：BZOJ 1016例题：BZOJ 10165、最小生成树-倍增 (回路性质)Q：CF 609E解：CF 609E例题：CF 609E]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>生成树</tag>
        <tag>算法笔记</tag>
        <tag>Kruskal重构树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[强连通分量Tarjan 学习笔记]]></title>
    <url>%2Fsz%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8FTarjan%2F</url>
    <content type="text"><![CDATA[模板及讲解https://www.byvoid.com/blog/scc-tarjan/求出有向图中的强连通分量。 常见题型1、求强连通分量Q：求出强连通分量。解：直接写模板。例题：BZOJ 16542、缩点Q：求出强连通分量后缩点辅助其他算法。解：直接写模板后重新建图。例题：BZOJ 2427]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>Tarjan</tag>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ST表 学习笔记]]></title>
    <url>%2FszST%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[模板及讲解运用st表实现区间询问区间最大/最小，初始化时间复杂度$O(nlogn)$, 查询$O(1)$设$dp(i,j)$为从i开始长度为$2^j$的区间最小值，初始化合并结果即可，查询采用”两头补”方式模板题：poj 3264 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #define ms(i, j) memset(i, j, sizeof i) using namespace std; const int MAXN = 50000 + 5; int n, q; int h[MAXN], fmaxi[MAXN][25], fmini[MAXN][25]; //h为原数组，fmaxi[i][j]为从i开始长度为2^j的区间最小值 void initRMQ() { for (int i=1;i&lt;=n;i++) fmaxi[i][0] = fmini[i][0] = h[i];//初始值为原数组 for (int j=1;(1&lt;&lt;j)&lt;=n;j++) {//j必定在外层 for (int i=1;i+(1&lt;&lt;j)-1&lt;=n;i++) { fmaxi[i][j] = max(fmaxi[i][j-1], fmaxi[i+(1&lt;&lt;(j-1))][j-1]); fmini[i][j] = min(fmini[i][j-1], fmini[i+(1&lt;&lt;(j-1))][j-1]);//DP } } } int RMQMax(int x, int y) { int k = (int)(log(y-x+1.0)/log(2.0)); return max(fmaxi[x][k], fmaxi[y-(1&lt;&lt;k)+1][k]); } int RMQMin(int x, int y) { int k = (int)(log(y-x+1.0)/log(2.0)); return min(fmini[x][k], fmini[y-(1&lt;&lt;k)+1][k]); } void clear() {} void init() { clear(); for (int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;, &amp;h[i]); initRMQ(); } void solve() { for (int i=1;i&lt;=q;i++) { int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); printf(&quot;%d\n&quot;, RMQMax(a, b) - RMQMin(a, b)); } } int main() { #ifndef ONLINE_JUDGE freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); #endif while (scanf(&quot;%d%d&quot;, &amp;n, &amp;q)==2&amp;&amp;n&amp;&amp;q) init(), solve(); return 0; } 常见题型1、求区间最大/最小值Q：给出一个区间，询问某个子区间的最大/最小值。(没有修改操作)解：因为不用修改，所以用RMQ$O(1)$查询最优，常数也小。例题：poj 32642、求LCAQ：给出一棵树，求两个节点的LCA。解：例题：]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>ST表</tag>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前缀和与差分 学习笔记]]></title>
    <url>%2Fsz%E5%89%8D%E7%BC%80%E5%92%8C%2F</url>
    <content type="text"><![CDATA[模板及讲解差分序列差分序列$f$记录$a[i]-a[i-1]$的值，$a$为原序列那么根据定义可以发现差分序列的前缀和就是原序列的数那么输入$a,b$, 我们让$f[a]+1, f[b+1]-1$就可以构造出差分序列这样可以实现$O(1)$区间修改，$O(n)$单点查询(这里可以用数据结构维护) 差分序列性质： 1、差分序列前缀和$S_i$是原序列的数$A_i$2、原数组所有数等于 0 等价于 差分序列为 03、$f[a]+1, f[b+1]-1$等同于在原数组区间修改 1、修改区间操作BZOJ 1651 2、差分序列性质解题 积木大赛：区间减为0最小修改次数。 差分序列正负数配对消去(相当于$a[l]+1, a[r]-1$)，剩余正数与$a[0]$配对)原数组所有数等于 0 等价于 差分序列为 0 IncDec Sequence (Bzoj 3043)：区间 增/减 后所有数相等的最小修改次数，以及最后高度的可能情况。 原数组所有数等于 0 等价于 差分序列为 0 ，这里只要相同则对$a[1]$无要求差分序列正负数配对消去(相当于$a[l]+1, a[r]-1$)，剩余正数/负数与$a[1], a[n+1]$配对)求可能情况则可以认为剩余正数/负数可以与$a[1], a[n+1]$配对，则有$|正数-负数|$高度种情况 环形积木大赛： 找到一个最小值断环成链即可用上面的差分方法 3、差分与前缀和 (by ruanxingzhi 差分与前缀和) 差分降次，前缀和升次，对于前面加速其实就是将数组降次后，再升次得到原数组 区间$[l,r]$加一次函数(等差数列)： 将数组差分后，在$a[l]+=首项$，后面$a[l+1,r]+=d$，$a[r+1]-=首项+(r-l)d$显然这个可以用线段树维护。 区间$[l,r]$加二次函数： 考虑多阶差分。将二次函数差分后得到一次函数。一次函数差分后得到常值函数。然后用线段树维护即可。 找规律： 若觉得答案为关于$n$的多项式，那么可以取其前几项然后不断差分，如果发现$k$阶差分所有项都是同一常数，那么这个多项式就是$k$次的。 手动高斯消元找到$f(n)$，大概是用一阶差分来高斯消元 矩阵旋转$45^{\circ}$输入的时候按正常顺序输入，但存储时要存到$(i+j-1,n-i+j)$，这个公式退推一下就能出来 常见题型1、差分序列(一维前缀和)Q：区间修改单点查询。解：见解析例题：BZOJ 16512、树上差分序列(树上前缀和)Q：在树上修改某一条路径的值。解：我们让$f[u]+1, f[v]+1, f[LCA(u, v)]-2$，这样做以后在树上的前缀和$\sum_{k\in son(i)}{f[k]}$就是节点$i$的值例题：NOIP2015 D2 T33、差分序列约束区间Q：某区间必须小于某个值。解：对于每个约束$a,b$，我们使$f[a+1]–,f[b]++$，这样可以保证$a,b$之间的元素严格小于$a,b$例题：BZOJ 16354、二维前缀和Q：查询某个矩阵的子矩阵的和解：容斥原理，和二维树状数组的求法差不多例题：NOIP2016 D2 T15、旋转矩阵后前缀和维护Q：在一个矩阵中找出一个分值最大的斜矩阵解：把矩阵旋转$45^{\circ}$，然后就可以在水平求前缀和了例题：计蒜客NOIP模拟赛-1 Day1 T1]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后缀数组 学习笔记]]></title>
    <url>%2Fsz%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[模板及讲解性质1、字符串中的子串可以表示为后缀的前缀，即后缀的LCP。 模板、代码解决字符串的有力工具。直接上代码，注释讲解(此题为uoj #35)(注意：下标都是从0开始) #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define FN2 &quot;uoj35&quot; using namespace std; const int MAXN = 1000000 + 5; char ch[MAXN]; int a[MAXN], n, m; //ch为输入字符串，a为处理后的整数原串 int SA[MAXN], rk[MAXN], tp[MAXN], tax[MAXN], height[MAXN]; /* SA[i]: 排名第i的后缀的位置(下标是后缀排名) rk[i]: 第i个后缀的排名 tp[i]: 排名为i的第二关键字的第一关键字的位置 (下标是第二关键字排名) tax[i]:基数排序的桶 height[i]: 排名为i, i-1后缀的最长公共前缀 */ bool cmp(int *f, int i, int k) {return f[SA[i-1]]==f[SA[i]]&amp;&amp;f[SA[i-1]+k]==f[SA[i]+k];} //要判断两个字符串是否完全相等 void build() {//构造后缀数组 int i, p; for (int i=0;i&lt;m;i++) tax[i] = 0; for (int i=0;i&lt;n;i++) tax[rk[i]=a[i]]++; for (int i=0;i&lt;m;i++) tax[i] += tax[i-1]; for (int i=n-1;i&gt;=0;i--) SA[--tax[rk[i]]] = i;//基数排序排第一轮 for (int k=1;k&lt;=n;k*=2) { p = 0; for (int i=n-k;i&lt;n;i++) tp[p++] = i;//(n-k)~(n-1)无第二关键字，所以排序应该排在前面 for (int i=0;i&lt;n;i++) if (SA[i]&gt;=k) tp[p++] = SA[i] - k; //只有SA[i]&gt;=k的SA[i]才是第二关键字的位置 //从图中可以看出第一关键字和第二关键字的位置相差k，故SA[i] - k for (int i=0;i&lt;m;i++) tax[i] = 0; for (int i=0;i&lt;n;i++) tax[rk[tp[i]]]++;//x[tp[i]]相等于排名第i的第二关键字的第一关键字的排名 for (int i=1;i&lt;m;i++) tax[i] += tax[i-1]; for (int i=n-1;i&gt;=0;i--) SA[--tax[rk[tp[i]]]] = tp[i];//保证了第一关键字的顺序再排第二关键字 //基数排序第一关键字(rank[i]的数值)和第二关键字(tp[i]的下标) swap(rk, tp);//此时tp没用，暂存上一轮rank的值 p = 0, rk[SA[0]] = 0;//sa[0]一定是添加的字符0, 排名一定是0 for (int i=1;i&lt;n;i++) rk[SA[i]] = cmp(tp, i, k) ? p : ++p; //算排名第i的数的rank，按sa顺序能够保证rank的正确性，但是要cmp判断与上一个字符串相等的情况 if (++p&gt;=n) break;//剪枝，已经没有重复元素 m = p; } } void getH() {//算height int i, j, k = 0;//k是比i-1前一名的后缀 for (int i=0;i&lt;n;i++) {//H[0], H[1], H[2] ...的顺序计算 if (k) k--;//从k-1开始比较 ,运用结论H[i]&gt;=H[i-1]-1, 最长公共前缀的长度至少是k-1(k = H[i-1]) j = SA[rk[i]-1]; //前一名的后缀位置 while(ch[i+k] == ch[j+k]) k++; //往后比较 height[rk[i]] = k; //更新答案 } } void init() { int i; n = strlen(ch) + 1, m = 128; for (int i=0;i&lt;n-1;i++) a[i] = ch[i];//处理原字符串 a[n - 1] = 0;//补末尾的0 } void solve() { int i; build(); getH(); for (int i=1;i&lt;n;i++) printf(&quot;%d &quot;, SA[i]+1);//输出范围1~n-1 printf(&quot;\n&quot;); for (int i=2;i&lt;n;i++) printf(&quot;%d &quot;, height[i]); } int main() { scanf(&quot;%s&quot;, ch), init(), solve(); return 0; } 从1开始的SA (不用补0)： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i, j) memset(i, j, sizeof i) #define FN2 &quot;uoj35&quot; using namespace std; const int MAXN = 1000000 + 5; char ch[MAXN]; int a[MAXN], n, m; //ch为输入字符串，a为处理后的整数原串 int SA[MAXN], rk[MAXN], tp[MAXN], tax[MAXN], height[MAXN]; /* SA[i]: 排名第i的后缀的位置(下标是后缀排名) rk[i]: 第i个后缀的排名 tp[i]: 排名为i的第二关键字的第一关键字的位置 (下标是第二关键字排名) tax[i]:基数排序的桶 height[i]: 排名为i, i-1后缀的最长公共前缀 */ void build() {//构造后缀数组 for (int i = 1; i &lt;= m; ++i) tax[i] = 0; for (int i = 1; i &lt;= n; ++i) tax[rk[i] = a[i]]++; for (int i = 1; i &lt;= m; ++i) tax[i] += tax[i - 1]; for (int i = n; i &gt;= 1; --i) SA[tax[rk[i]]--] = i;//基数排序排第一轮 for (int k = 1; k &lt;= n; k *= 2) { int p = 0; for (int i = n - k + 1; i &lt;= n; i++) tp[++p] = i;//(n-k)~(n-1)无第二关键字，所以排序应该排在前面 for (int i = 1; i &lt;= n; i++) if (SA[i] &gt; k) tp[++p] = SA[i] - k; //只有SA[i]&gt;=k的SA[i]才是第二关键字的位置 //从图中可以看出第一关键字和第二关键字的位置相差k，故SA[i] - k for (int i = 1; i &lt;= m; ++i) tax[i] = 0; for (int i = 1; i &lt;= n; ++i) tax[rk[tp[i]]]++;//x[tp[i]]相等于排名第i的第二关键字的第一关键字的排名 for (int i = 1; i &lt;= m; ++i) tax[i] += tax[i - 1]; for (int i = n; i &gt;= 1; --i) SA[tax[rk[tp[i]]]--] = tp[i];//保证了第一关键字的顺序再排第二关键字 //基数排序第一关键字(rank[i]的数值)和第二关键字(tp[i]的下标) swap(rk, tp);//此时tp没用，暂存上一轮rank的值 p = 1, rk[SA[1]] = 1; for (int i = 2; i &lt;= n; ++i) rk[SA[i]] = (tp[SA[i]] == tp[SA[i - 1]] &amp;&amp; tp[SA[i] + k] == tp[SA[i - 1] + k]) ? p : ++p; //算排名第i的数的rank，按sa顺序能够保证rank的正确性，但是要cmp判断与上一个字符串相等的情况 if (p &gt;= n) break;//剪枝，已经没有重复元素 m = p; } } void getH() {//算height int k = 0;//k是比i-1前一名的后缀 for (int i = 1; i &lt;= n; ++i) {//H[0], H[1], H[2] ...的顺序计算 if (k) k--;//从k-1开始比较 ,运用结论H[i]&gt;=H[i-1]-1, 最长公共前缀的长度至少是k-1(k = H[i-1]) int j = SA[rk[i] - 1]; //前一名的后缀位置 while(ch[i + k] == ch[j + k]) k++; //往后比较 height[rk[i]] = k; //更新答案 } } void solve() { n = strlen(ch + 1), m = 256; for (int i = 1; i &lt;= n; ++i) a[i] = ch[i];//处理原字符串 build(); getH(); for (int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, SA[i]); printf(&quot;\n&quot;); for (int i = 2; i &lt;= n; ++i) printf(&quot;%d &quot;, height[i]); } int main() { scanf(&quot;%s&quot;, ch + 1), solve(); return 0; } 写时注意：1、不要将字符对应到02、不同字符串之间一定要用不同字符连接3、用不同字符串连接字符串后注意空间开大 常见题型LCP相关1、LCP入手：Bzoj 46502、子串=后缀LCP：Bzoj 4650, Bzoj 4199, Bzoj 4566, Spoj 6943、所有串的LCP(单调栈 / 并查集)：Bzoj 4199, Bzoj 3238, Bzoj 4566 其他1、二分后SA(Height分组)：Hdu 23282、ST表+二分查找 (仅用于求出询问的区间)：Bzoj 2754，Bzoj 31723、多次求后缀数组：Bzoj 4698, Hdu 2328 与Height无关1、SA的单调性：Bzoj 27542、后缀数组的后缀排序运用：Bzoj 1031]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>后缀数组</tag>
        <tag>算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hdu 1561(树形背包DP)]]></title>
    <url>%2Fhdu1561%2F</url>
    <content type="text"><![CDATA[Hdu 1561经典树形依赖背包问题。因为可能出现森林，所有要建立一个虚结点0，将森林中所有树的根节点作为结点0的儿子$f[i][j]$表示以i为根选j个课程$f[u][j] = max(f[u][j], f[u][j-k]+f[v][k])$ v是u的儿子 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #define ms(i,j) memset(i, j, sizeof(i)); using namespace std; int n,m; int c[205]; vector&lt;int&gt; G[205]; int f[205][205]; int t; void dfs(int u) { for (int i=1;i&lt;=m;i++) f[u][i] = c[u]; for (int i=0;i&lt;G[u].size();i++) { int v = G[u][i]; dfs(v); for (int j=t;j&gt;=2;j--) for (int k=1;k&lt;j;k++) f[u][j] = max(f[u][j], f[u][j-k]+f[v][k]); } } int main() { while (scanf(&quot;%d%d&quot;, &amp;n, &amp;m)==2&amp;&amp;(n||m)) { for (int i=0;i&lt;=n;i++) G[i].clear(); ms(f,0); for (int i=1;i&lt;=n;i++) { int ai; scanf(&quot;%d%d&quot;, &amp;ai, &amp;c[i]); G[ai].push_back(i); } t = m+1; dfs(0); printf(&quot;%d\n&quot;, f[0][m+1]); } return 0; }]]></content>
      <categories>
        <category>Hdu</category>
      </categories>
      <tags>
        <tag>树形DP</tag>
        <tag>背包DP</tag>
        <tag>Hdu</tag>
      </tags>
  </entry>
</search>
